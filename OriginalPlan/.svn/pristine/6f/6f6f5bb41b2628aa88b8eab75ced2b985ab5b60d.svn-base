#include "script_lua_inc.h"
#include "lua_tinker.h"
#include "tolua++.h"
#include "lua_base_conversions.h"
#include "lua_base_conversions_impl.h"
#include "tolua_fix.h"


#include "__header.h"

int lua_mapserver_CBasePacket_getFlag(lua_State* tolua_S)
{
    int argc = 0;
    CBasePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBasePacket_getFlag'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getFlag();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBasePacket:getFlag has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePacket_getFlag'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBasePacket_isCompress(lua_State* tolua_S)
{
    int argc = 0;
    CBasePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBasePacket_isCompress'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCompress();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBasePacket:isCompress has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePacket_isCompress'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBasePacket_setPacketID(lua_State* tolua_S)
{
    int argc = 0;
    CBasePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBasePacket_setPacketID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CBasePacket:setPacketID");
        if(!ok)
            return 0;
        cobj->setPacketID(arg0);
        return 0;
    }

    gxError("CBasePacket:setPacketID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePacket_setPacketID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBasePacket_setUnCompressed(lua_State* tolua_S)
{
    int argc = 0;
    CBasePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBasePacket_setUnCompressed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setUnCompressed();
        return 0;
    }

    gxError("CBasePacket:setUnCompressed has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePacket_setUnCompressed'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBasePacket_data(lua_State* tolua_S)
{
    int argc = 0;
    CBasePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBasePacket_data'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->data();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CBasePacket:data has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePacket_data'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBasePacket_setTotalLen(lua_State* tolua_S)
{
    int argc = 0;
    CBasePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBasePacket_setTotalLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CBasePacket:setTotalLen");
        if(!ok)
            return 0;
        cobj->setTotalLen(arg0);
        return 0;
    }

    gxError("CBasePacket:setTotalLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePacket_setTotalLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBasePacket_setFlag(lua_State* tolua_S)
{
    int argc = 0;
    CBasePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBasePacket_setFlag'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CBasePacket:setFlag");
        if(!ok)
            return 0;
        cobj->setFlag(arg0);
        return 0;
    }

    gxError("CBasePacket:setFlag has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePacket_setFlag'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBasePacket_setCompressed(lua_State* tolua_S)
{
    int argc = 0;
    CBasePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBasePacket_setCompressed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setCompressed();
        return 0;
    }

    gxError("CBasePacket:setCompressed has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePacket_setCompressed'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBasePacket_isCrypt(lua_State* tolua_S)
{
    int argc = 0;
    CBasePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBasePacket_isCrypt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCrypt();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBasePacket:isCrypt has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePacket_isCrypt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBasePacket_getPacketID(lua_State* tolua_S)
{
    int argc = 0;
    CBasePacket* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CBasePacket_getPacketID'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            unsigned short ret = cobj->getPacketID();
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            unsigned short ret = cobj->getPacketID();
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CBasePacket:getPacketID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePacket_getPacketID'.",&tolua_err);
    return 0;
}
int lua_mapserver_CBasePacket_getTotalLen(lua_State* tolua_S)
{
    int argc = 0;
    CBasePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBasePacket_getTotalLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getTotalLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBasePacket:getTotalLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePacket_getTotalLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBasePacket_check(lua_State* tolua_S)
{
    int argc = 0;
    CBasePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBasePacket_check'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->check();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBasePacket:check has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePacket_check'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBasePacket_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CBasePacket* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CBasePacket:CBasePacket");
        if(!ok)
            return 0;
        cobj = new CBasePacket(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CBasePacket");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CBasePacket:CBasePacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_mapserver_CBasePacket_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBasePacket)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBasePacket",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CBasePacket* self = (CBasePacket*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CBasePacket(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBasePacket");
    tolua_cclass(tolua_S,"CBasePacket","CBasePacket","",lua_mapserver_CBasePacket_finalize);

    tolua_beginmodule(tolua_S,"CBasePacket");
        tolua_function(tolua_S,"new",lua_mapserver_CBasePacket_constructor);
        tolua_function(tolua_S,"getFlag",lua_mapserver_CBasePacket_getFlag);
        tolua_function(tolua_S,"isCompress",lua_mapserver_CBasePacket_isCompress);
        tolua_function(tolua_S,"setPacketID",lua_mapserver_CBasePacket_setPacketID);
        tolua_function(tolua_S,"setUnCompressed",lua_mapserver_CBasePacket_setUnCompressed);
        tolua_function(tolua_S,"data",lua_mapserver_CBasePacket_data);
        tolua_function(tolua_S,"setTotalLen",lua_mapserver_CBasePacket_setTotalLen);
        tolua_function(tolua_S,"setFlag",lua_mapserver_CBasePacket_setFlag);
        tolua_function(tolua_S,"setCompressed",lua_mapserver_CBasePacket_setCompressed);
        tolua_function(tolua_S,"isCrypt",lua_mapserver_CBasePacket_isCrypt);
        tolua_function(tolua_S,"getPacketID",lua_mapserver_CBasePacket_getPacketID);
        tolua_function(tolua_S,"getTotalLen",lua_mapserver_CBasePacket_getTotalLen);
        tolua_function(tolua_S,"check",lua_mapserver_CBasePacket_check);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CBasePacket).name();
    g_luaType[typeName] = "CBasePacket";
    g_typeCast["CBasePacket"] = "CBasePacket";
    return 1;
}

int lua_mapserver_CRequestPacket_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CRequestPacket* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            cobj = new CRequestPacket();
            tolua_pushusertype(tolua_S,(void*)cobj,"CRequestPacket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CRequestPacket:CRequestPacket");

            if (!ok) { break; }
            cobj = new CRequestPacket(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CRequestPacket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CRequestPacket:CRequestPacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_mapserver_CRequestPacket_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CRequestPacket)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CRequestPacket",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CRequestPacket* self = (CRequestPacket*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CRequestPacket(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CRequestPacket");
    tolua_cclass(tolua_S,"CRequestPacket","CRequestPacket","CBasePacket",lua_mapserver_CRequestPacket_finalize);

    tolua_beginmodule(tolua_S,"CRequestPacket");
        tolua_function(tolua_S,"new",lua_mapserver_CRequestPacket_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CRequestPacket).name();
    g_luaType[typeName] = "CRequestPacket";
    g_typeCast["CRequestPacket"] = "CRequestPacket";
    return 1;
}

int lua_mapserver_CResponsePacket_isSuccess(lua_State* tolua_S)
{
    int argc = 0;
    CResponsePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CResponsePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CResponsePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CResponsePacket_isSuccess'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isSuccess();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CResponsePacket:isSuccess has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CResponsePacket_isSuccess'.",&tolua_err);
	return 0;
}
int lua_mapserver_CResponsePacket_setRetCode(lua_State* tolua_S)
{
    int argc = 0;
    CResponsePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CResponsePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CResponsePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CResponsePacket_setRetCode'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CResponsePacket:setRetCode");
        if(!ok)
            return 0;
        cobj->setRetCode(arg0);
        return 0;
    }

    gxError("CResponsePacket:setRetCode has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CResponsePacket_setRetCode'.",&tolua_err);
	return 0;
}
int lua_mapserver_CResponsePacket_getRetCode(lua_State* tolua_S)
{
    int argc = 0;
    CResponsePacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CResponsePacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (CResponsePacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CResponsePacket_getRetCode'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getRetCode();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CResponsePacket:getRetCode has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CResponsePacket_getRetCode'.",&tolua_err);
	return 0;
}
int lua_mapserver_CResponsePacket_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CResponsePacket* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            cobj = new CResponsePacket();
            tolua_pushusertype(tolua_S,(void*)cobj,"CResponsePacket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CResponsePacket:CResponsePacket");

            if (!ok) { break; }
            cobj = new CResponsePacket(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CResponsePacket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CResponsePacket:CResponsePacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_mapserver_CResponsePacket_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CResponsePacket)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CResponsePacket",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CResponsePacket* self = (CResponsePacket*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CResponsePacket(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CResponsePacket");
    tolua_cclass(tolua_S,"CResponsePacket","CResponsePacket","CBasePacket",lua_mapserver_CResponsePacket_finalize);

    tolua_beginmodule(tolua_S,"CResponsePacket");
        tolua_function(tolua_S,"new",lua_mapserver_CResponsePacket_constructor);
        tolua_function(tolua_S,"isSuccess",lua_mapserver_CResponsePacket_isSuccess);
        tolua_function(tolua_S,"setRetCode",lua_mapserver_CResponsePacket_setRetCode);
        tolua_function(tolua_S,"getRetCode",lua_mapserver_CResponsePacket_getRetCode);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CResponsePacket).name();
    g_luaType[typeName] = "CResponsePacket";
    g_typeCast["CResponsePacket"] = "CResponsePacket";
    return 1;
}

int lua_mapserver_CServerPacket_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CServerPacket* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CServerPacket:CServerPacket");

            if (!ok) { break; }
            cobj = new CServerPacket(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CServerPacket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new CServerPacket();
            tolua_pushusertype(tolua_S,(void*)cobj,"CServerPacket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CServerPacket:CServerPacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CServerPacket_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CServerPacket)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CServerPacket",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CServerPacket* self = (CServerPacket*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CServerPacket(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CServerPacket");
    tolua_cclass(tolua_S,"CServerPacket","CServerPacket","CResponsePacket",lua_mapserver_CServerPacket_finalize);

    tolua_beginmodule(tolua_S,"CServerPacket");
        tolua_function(tolua_S,"new",lua_mapserver_CServerPacket_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CServerPacket).name();
    g_luaType[typeName] = "CServerPacket";
    g_typeCast["CServerPacket"] = "CServerPacket";
    return 1;
}

int lua_mapserver_CAnnouncement_GetNumber(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CAnnouncement",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CAnnouncement:GetNumber");
        if(!ok)
            return 0;
        std::string ret = CAnnouncement::GetNumber(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }
    gxError("CAnnouncement:GetNumber has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncement_GetNumber'.", &tolua_err);
    return 0;
}
int lua_mapserver_CAnnouncement_GetItemName(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CAnnouncement",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned short arg0;
        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CAnnouncement:GetItemName");
        if(!ok)
            return 0;
        std::string ret = CAnnouncement::GetItemName(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }
    gxError("CAnnouncement:GetItemName has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncement_GetItemName'.", &tolua_err);
    return 0;
}
int lua_mapserver_CAnnouncement_BroadSystem(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CAnnouncement",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        unsigned short arg0;
        std::string arg1;
        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CAnnouncement:BroadSystem");
        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CAnnouncement:BroadSystem");
        if(!ok)
            return 0;
        CAnnouncement::BroadSystem(arg0, arg1);
        return 0;
    }
    gxError("CAnnouncement:BroadSystem has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncement_BroadSystem'.", &tolua_err);
    return 0;
}
int lua_mapserver_CAnnouncement_GetRoleName(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CAnnouncement",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        CRole* arg0;
        ok &= luaval_to_object<CRole>(tolua_S, 2, "CRole", &arg0, "CAnnouncement:GetRoleName");
        if(!ok)
            return 0;
        std::string ret = CAnnouncement::GetRoleName(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }
    gxError("CAnnouncement:GetRoleName has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncement_GetRoleName'.", &tolua_err);
    return 0;
}
int lua_mapserver_CAnnouncement_BroadToAll(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CAnnouncement",0,&tolua_err)) goto tolua_lerror;

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg1;
            ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            CAnnouncement::BroadToAll(arg0, arg1);
            return 0;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 1)
        {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            CAnnouncement::BroadToAll(arg0);
            return 0;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg1;
            ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg2;
            ok &= luaval_to_std_string(tolua_S, 4,&arg2, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            CAnnouncement::BroadToAll(arg0, arg1, arg2);
            return 0;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 4)
        {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg1;
            ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg2;
            ok &= luaval_to_std_string(tolua_S, 4,&arg2, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg3;
            ok &= luaval_to_std_string(tolua_S, 5,&arg3, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            CAnnouncement::BroadToAll(arg0, arg1, arg2, arg3);
            return 0;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 5)
        {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg1;
            ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg2;
            ok &= luaval_to_std_string(tolua_S, 4,&arg2, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg3;
            ok &= luaval_to_std_string(tolua_S, 5,&arg3, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg4;
            ok &= luaval_to_std_string(tolua_S, 6,&arg4, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            CAnnouncement::BroadToAll(arg0, arg1, arg2, arg3, arg4);
            return 0;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 6)
        {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg1;
            ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg2;
            ok &= luaval_to_std_string(tolua_S, 4,&arg2, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg3;
            ok &= luaval_to_std_string(tolua_S, 5,&arg3, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg4;
            ok &= luaval_to_std_string(tolua_S, 6,&arg4, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg5;
            ok &= luaval_to_std_string(tolua_S, 7,&arg5, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            CAnnouncement::BroadToAll(arg0, arg1, arg2, arg3, arg4, arg5);
            return 0;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 4)
        {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            char arg2;
            ok &= luaval_to_sint8(tolua_S, 4,(sint8*)&arg2, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg3;
            ok &= luaval_to_std_string(tolua_S, 5,&arg3, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            CAnnouncement::BroadToAll(arg0, arg1, arg2, arg3);
            return 0;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 5)
        {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            char arg2;
            ok &= luaval_to_sint8(tolua_S, 4,(sint8*)&arg2, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg3;
            ok &= luaval_to_std_string(tolua_S, 5,&arg3, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg4;
            ok &= luaval_to_std_string(tolua_S, 6,&arg4, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            CAnnouncement::BroadToAll(arg0, arg1, arg2, arg3, arg4);
            return 0;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 6)
        {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            char arg2;
            ok &= luaval_to_sint8(tolua_S, 4,(sint8*)&arg2, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg3;
            ok &= luaval_to_std_string(tolua_S, 5,&arg3, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg4;
            ok &= luaval_to_std_string(tolua_S, 6,&arg4, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg5;
            ok &= luaval_to_std_string(tolua_S, 7,&arg5, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            CAnnouncement::BroadToAll(arg0, arg1, arg2, arg3, arg4, arg5);
            return 0;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 7)
        {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            char arg2;
            ok &= luaval_to_sint8(tolua_S, 4,(sint8*)&arg2, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg3;
            ok &= luaval_to_std_string(tolua_S, 5,&arg3, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg4;
            ok &= luaval_to_std_string(tolua_S, 6,&arg4, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg5;
            ok &= luaval_to_std_string(tolua_S, 7,&arg5, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg6;
            ok &= luaval_to_std_string(tolua_S, 8,&arg6, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            CAnnouncement::BroadToAll(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            return 0;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 8)
        {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            char arg2;
            ok &= luaval_to_sint8(tolua_S, 4,(sint8*)&arg2, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg3;
            ok &= luaval_to_std_string(tolua_S, 5,&arg3, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg4;
            ok &= luaval_to_std_string(tolua_S, 6,&arg4, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg5;
            ok &= luaval_to_std_string(tolua_S, 7,&arg5, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg6;
            ok &= luaval_to_std_string(tolua_S, 8,&arg6, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            std::string arg7;
            ok &= luaval_to_std_string(tolua_S, 9,&arg7, "CAnnouncement:BroadToAll");
            if (!ok) { break; }
            CAnnouncement::BroadToAll(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            return 0;
        }
    } while (0);
    ok  = true;

    gxError("CAnnouncement:BroadToAll has wrong number of arguments: {0}, was expecting {1}",argc, 8);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncement_BroadToAll'.",&tolua_err);
    return 0;
}
static int lua_mapserver_CAnnouncement_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CAnnouncement)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CAnnouncement",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CAnnouncement* self = (CAnnouncement*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CAnnouncement(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CAnnouncement");
    tolua_cclass(tolua_S,"CAnnouncement","CAnnouncement","",nullptr);

    tolua_beginmodule(tolua_S,"CAnnouncement");
        tolua_function(tolua_S,"GetNumber", lua_mapserver_CAnnouncement_GetNumber);
        tolua_function(tolua_S,"GetItemName", lua_mapserver_CAnnouncement_GetItemName);
        tolua_function(tolua_S,"BroadSystem", lua_mapserver_CAnnouncement_BroadSystem);
        tolua_function(tolua_S,"GetRoleName", lua_mapserver_CAnnouncement_GetRoleName);
        tolua_function(tolua_S,"BroadToAll", lua_mapserver_CAnnouncement_BroadToAll);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CAnnouncement).name();
    g_luaType[typeName] = "CAnnouncement";
    g_typeCast["CAnnouncement"] = "CAnnouncement";
    return 1;
}

static int lua_mapserver__PackBuffer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_PackBuffer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_PackBuffer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _PackBuffer* self = (_PackBuffer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__PackBuffer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_PackBuffer");
    tolua_cclass(tolua_S,"_PackBuffer","_PackBuffer","",nullptr);

    tolua_beginmodule(tolua_S,"_PackBuffer");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_PackBuffer).name();
    g_luaType[typeName] = "_PackBuffer";
    g_typeCast["_PackBuffer"] = "_PackBuffer";
    return 1;
}

static int lua_mapserver__PackSimpleBuff_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_PackSimpleBuff)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_PackSimpleBuff",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _PackSimpleBuff* self = (_PackSimpleBuff*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__PackSimpleBuff(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_PackSimpleBuff");
    tolua_cclass(tolua_S,"_PackSimpleBuff","_PackSimpleBuff","",nullptr);

    tolua_beginmodule(tolua_S,"_PackSimpleBuff");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_PackSimpleBuff).name();
    g_luaType[typeName] = "_PackSimpleBuff";
    g_typeCast["_PackSimpleBuff"] = "_PackSimpleBuff";
    return 1;
}

int lua_mapserver_PackLoginRole_setParam(lua_State* tolua_S)
{
    int argc = 0;
    PackLoginRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"PackLoginRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (PackLoginRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_PackLoginRole_setParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 7) 
    {
        const char* arg0;
        unsigned long long arg1;
        unsigned char arg2;
        unsigned char arg3;
        unsigned char arg4;
        unsigned int arg5;
        unsigned int arg6;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "PackLoginRole:setParam"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "PackLoginRole:setParam");

        ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "PackLoginRole:setParam");

        ok &= luaval_to_uint8(tolua_S, 5,(uint8*)&arg3, "PackLoginRole:setParam");

        ok &= luaval_to_uint8(tolua_S, 6,(uint8*)&arg4, "PackLoginRole:setParam");

        ok &= luaval_to_uint32(tolua_S, 7,(uint32*)&arg5, "PackLoginRole:setParam");

        ok &= luaval_to_uint32(tolua_S, 8,(uint32*)&arg6, "PackLoginRole:setParam");
        if(!ok)
            return 0;
        cobj->setParam(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
        return 0;
    }

    gxError("PackLoginRole:setParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 7);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_PackLoginRole_setParam'.",&tolua_err);
	return 0;
}
int lua_mapserver_PackLoginRole_toString(lua_State* tolua_S)
{
    int argc = 0;
    PackLoginRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"PackLoginRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (PackLoginRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_PackLoginRole_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("PackLoginRole:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_PackLoginRole_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_PackLoginRole_constructor(lua_State* tolua_S)
{
    int argc = 0;
    PackLoginRole* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new PackLoginRole();
        tolua_pushusertype(tolua_S,(void*)cobj,"PackLoginRole");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("PackLoginRole:PackLoginRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_PackLoginRole_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PackLoginRole)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PackLoginRole",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PackLoginRole* self = (PackLoginRole*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PackLoginRole(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PackLoginRole");
    tolua_cclass(tolua_S,"PackLoginRole","PackLoginRole","",lua_mapserver_PackLoginRole_finalize);

    tolua_beginmodule(tolua_S,"PackLoginRole");
        tolua_function(tolua_S,"new",lua_mapserver_PackLoginRole_constructor);
        tolua_function(tolua_S,"setParam",lua_mapserver_PackLoginRole_setParam);
        tolua_function(tolua_S,"toString",lua_mapserver_PackLoginRole_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PackLoginRole).name();
    g_luaType[typeName] = "PackLoginRole";
    g_typeCast["PackLoginRole"] = "PackLoginRole";
    return 1;
}

static int lua_mapserver_PackRoleShape_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PackRoleShape)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PackRoleShape",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PackRoleShape* self = (PackRoleShape*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PackRoleShape(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PackRoleShape");
    tolua_cclass(tolua_S,"PackRoleShape","PackRoleShape","IStreamableAll",nullptr);

    tolua_beginmodule(tolua_S,"PackRoleShape");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PackRoleShape).name();
    g_luaType[typeName] = "PackRoleShape";
    g_typeCast["PackRoleShape"] = "PackRoleShape";
    return 1;
}

static int lua_mapserver_PackMonsterShape_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PackMonsterShape)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PackMonsterShape",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PackMonsterShape* self = (PackMonsterShape*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PackMonsterShape(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PackMonsterShape");
    tolua_cclass(tolua_S,"PackMonsterShape","PackMonsterShape","",nullptr);

    tolua_beginmodule(tolua_S,"PackMonsterShape");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PackMonsterShape).name();
    g_luaType[typeName] = "PackMonsterShape";
    g_typeCast["PackMonsterShape"] = "PackMonsterShape";
    return 1;
}

static int lua_mapserver_PacketSourceWay_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PacketSourceWay)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PacketSourceWay",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PacketSourceWay* self = (PacketSourceWay*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PacketSourceWay(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PacketSourceWay");
    tolua_cclass(tolua_S,"PacketSourceWay","PacketSourceWay","",nullptr);

    tolua_beginmodule(tolua_S,"PacketSourceWay");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PacketSourceWay).name();
    g_luaType[typeName] = "PacketSourceWay";
    g_typeCast["PacketSourceWay"] = "PacketSourceWay";
    return 1;
}

static int lua_mapserver_PacketNewRegister_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PacketNewRegister)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PacketNewRegister",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PacketNewRegister* self = (PacketNewRegister*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PacketNewRegister(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PacketNewRegister");
    tolua_cclass(tolua_S,"PacketNewRegister","PacketNewRegister","",nullptr);

    tolua_beginmodule(tolua_S,"PacketNewRegister");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PacketNewRegister).name();
    g_luaType[typeName] = "PacketNewRegister";
    g_typeCast["PacketNewRegister"] = "PacketNewRegister";
    return 1;
}

static int lua_mapserver_PacketLoginTime_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PacketLoginTime)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PacketLoginTime",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PacketLoginTime* self = (PacketLoginTime*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PacketLoginTime(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PacketLoginTime");
    tolua_cclass(tolua_S,"PacketLoginTime","PacketLoginTime","",nullptr);

    tolua_beginmodule(tolua_S,"PacketLoginTime");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PacketLoginTime).name();
    g_luaType[typeName] = "PacketLoginTime";
    g_typeCast["PacketLoginTime"] = "PacketLoginTime";
    return 1;
}

static int lua_mapserver_PacketSingletonInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PacketSingletonInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PacketSingletonInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PacketSingletonInfo* self = (PacketSingletonInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PacketSingletonInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PacketSingletonInfo");
    tolua_cclass(tolua_S,"PacketSingletonInfo","PacketSingletonInfo","",nullptr);

    tolua_beginmodule(tolua_S,"PacketSingletonInfo");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PacketSingletonInfo).name();
    g_luaType[typeName] = "PacketSingletonInfo";
    g_typeCast["PacketSingletonInfo"] = "PacketSingletonInfo";
    return 1;
}

static int lua_mapserver_PacketGameCollectInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PacketGameCollectInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PacketGameCollectInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PacketGameCollectInfo* self = (PacketGameCollectInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PacketGameCollectInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PacketGameCollectInfo");
    tolua_cclass(tolua_S,"PacketGameCollectInfo","PacketGameCollectInfo","",nullptr);

    tolua_beginmodule(tolua_S,"PacketGameCollectInfo");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PacketGameCollectInfo).name();
    g_luaType[typeName] = "PacketGameCollectInfo";
    g_typeCast["PacketGameCollectInfo"] = "PacketGameCollectInfo";
    return 1;
}

static int lua_mapserver_PacketCreateBrforeInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PacketCreateBrforeInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PacketCreateBrforeInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PacketCreateBrforeInfo* self = (PacketCreateBrforeInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PacketCreateBrforeInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PacketCreateBrforeInfo");
    tolua_cclass(tolua_S,"PacketCreateBrforeInfo","PacketCreateBrforeInfo","",nullptr);

    tolua_beginmodule(tolua_S,"PacketCreateBrforeInfo");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PacketCreateBrforeInfo).name();
    g_luaType[typeName] = "PacketCreateBrforeInfo";
    g_typeCast["PacketCreateBrforeInfo"] = "PacketCreateBrforeInfo";
    return 1;
}

static int lua_mapserver_TAdjust_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (TAdjust)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"TAdjust",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        TAdjust* self = (TAdjust*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_TAdjust(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"TAdjust");
    tolua_cclass(tolua_S,"TAdjust","TAdjust","",nullptr);

    tolua_beginmodule(tolua_S,"TAdjust");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(TAdjust).name();
    g_luaType[typeName] = "TAdjust";
    g_typeCast["TAdjust"] = "TAdjust";
    return 1;
}

int lua_mapserver_AxisPos_toSinglePos(lua_State* tolua_S)
{
    int argc = 0;
    AxisPos* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AxisPos",0,&tolua_err)) goto tolua_lerror;
    cobj = (AxisPos*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AxisPos_toSinglePos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        uint64 ret = cobj->toSinglePos();
        lua_tinker::push(tolua_S,ret);
        return 1;
    }

    gxError("AxisPos:toSinglePos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AxisPos_toSinglePos'.",&tolua_err);
	return 0;
}
int lua_mapserver_AxisPos_isValid(lua_State* tolua_S)
{
    int argc = 0;
    AxisPos* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AxisPos",0,&tolua_err)) goto tolua_lerror;
    cobj = (AxisPos*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AxisPos_isValid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isValid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("AxisPos:isValid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AxisPos_isValid'.",&tolua_err);
	return 0;
}
int lua_mapserver_AxisPos_getDirect(lua_State* tolua_S)
{
    int argc = 0;
    AxisPos* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AxisPos",0,&tolua_err)) goto tolua_lerror;
    cobj = (AxisPos*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AxisPos_getDirect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "AxisPos:getDirect");
        if(!ok)
            return 0;
        const int ret = cobj->getDirect(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("AxisPos:getDirect has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AxisPos_getDirect'.",&tolua_err);
	return 0;
}
int lua_mapserver_AxisPos_getX(lua_State* tolua_S)
{
    int argc = 0;
    AxisPos* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AxisPos",0,&tolua_err)) goto tolua_lerror;
    cobj = (AxisPos*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AxisPos_getX'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        short ret = cobj->getX();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("AxisPos:getX has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AxisPos_getX'.",&tolua_err);
	return 0;
}
int lua_mapserver_AxisPos_getY(lua_State* tolua_S)
{
    int argc = 0;
    AxisPos* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AxisPos",0,&tolua_err)) goto tolua_lerror;
    cobj = (AxisPos*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AxisPos_getY'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        short ret = cobj->getY();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("AxisPos:getY has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AxisPos_getY'.",&tolua_err);
	return 0;
}
int lua_mapserver_AxisPos_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    AxisPos* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AxisPos",0,&tolua_err)) goto tolua_lerror;
    cobj = (AxisPos*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AxisPos_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("AxisPos:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AxisPos_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_AxisPos_toString(lua_State* tolua_S)
{
    int argc = 0;
    AxisPos* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AxisPos",0,&tolua_err)) goto tolua_lerror;
    cobj = (AxisPos*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AxisPos_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("AxisPos:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AxisPos_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_AxisPos_setX(lua_State* tolua_S)
{
    int argc = 0;
    AxisPos* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AxisPos",0,&tolua_err)) goto tolua_lerror;
    cobj = (AxisPos*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AxisPos_setX'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        short arg0;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "AxisPos:setX");
        if(!ok)
            return 0;
        cobj->setX(arg0);
        return 0;
    }

    gxError("AxisPos:setX has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AxisPos_setX'.",&tolua_err);
	return 0;
}
int lua_mapserver_AxisPos_setY(lua_State* tolua_S)
{
    int argc = 0;
    AxisPos* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AxisPos",0,&tolua_err)) goto tolua_lerror;
    cobj = (AxisPos*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AxisPos_setY'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        short arg0;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "AxisPos:setY");
        if(!ok)
            return 0;
        cobj->setY(arg0);
        return 0;
    }

    gxError("AxisPos:setY has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AxisPos_setY'.",&tolua_err);
	return 0;
}
int lua_mapserver_AxisPos_constructor(lua_State* tolua_S)
{
    int argc = 0;
    AxisPos* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            short arg0;
            ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "AxisPos:AxisPos");

            if (!ok) { break; }
            short arg1;
            ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "AxisPos:AxisPos");

            if (!ok) { break; }
            cobj = new AxisPos(arg0, arg1);
            tolua_pushusertype(tolua_S,(void*)cobj,"AxisPos");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new AxisPos();
            tolua_pushusertype(tolua_S,(void*)cobj,"AxisPos");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("AxisPos:AxisPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_AxisPos_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (AxisPos)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"AxisPos",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        AxisPos* self = (AxisPos*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_AxisPos(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"AxisPos");
    tolua_cclass(tolua_S,"AxisPos","AxisPos","",lua_mapserver_AxisPos_finalize);

    tolua_beginmodule(tolua_S,"AxisPos");
        tolua_function(tolua_S,"new",lua_mapserver_AxisPos_constructor);
        tolua_function(tolua_S,"toSinglePos",lua_mapserver_AxisPos_toSinglePos);
        tolua_function(tolua_S,"isValid",lua_mapserver_AxisPos_isValid);
        tolua_function(tolua_S,"getDirect",lua_mapserver_AxisPos_getDirect);
        tolua_function(tolua_S,"getX",lua_mapserver_AxisPos_getX);
        tolua_function(tolua_S,"getY",lua_mapserver_AxisPos_getY);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_AxisPos_cleanUp);
        tolua_function(tolua_S,"toString",lua_mapserver_AxisPos_toString);
        tolua_function(tolua_S,"setX",lua_mapserver_AxisPos_setX);
        tolua_function(tolua_S,"setY",lua_mapserver_AxisPos_setY);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(AxisPos).name();
    g_luaType[typeName] = "AxisPos";
    g_typeCast["AxisPos"] = "AxisPos";
    return 1;
}

static int lua_mapserver_AreaRect_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (AreaRect)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"AreaRect",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        AreaRect* self = (AreaRect*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_AreaRect(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"AreaRect");
    tolua_cclass(tolua_S,"AreaRect","AreaRect","",nullptr);

    tolua_beginmodule(tolua_S,"AreaRect");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(AreaRect).name();
    g_luaType[typeName] = "AreaRect";
    g_typeCast["AreaRect"] = "AreaRect";
    return 1;
}

static int lua_mapserver_MapPos_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MapPos)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MapPos",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MapPos* self = (MapPos*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MapPos(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MapPos");
    tolua_cclass(tolua_S,"MapPos","MapPos","",nullptr);

    tolua_beginmodule(tolua_S,"MapPos");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MapPos).name();
    g_luaType[typeName] = "MapPos";
    g_typeCast["MapPos"] = "MapPos";
    return 1;
}

int lua_mapserver_CRandGen_reset(lua_State* tolua_S)
{
    int argc = 0;
    CRandGen* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandGen",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandGen*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandGen_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRandGen:reset");
        if(!ok)
            return 0;
        cobj->reset(arg0);
        return 0;
    }

    gxError("CRandGen:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandGen_reset'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandGen_randBool(lua_State* tolua_S)
{
    int argc = 0;
    CRandGen* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandGen",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandGen*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandGen_randBool'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->randBool();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRandGen:randBool has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandGen_randBool'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandGen_randOdds(lua_State* tolua_S)
{
    int argc = 0;
    CRandGen* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandGen",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandGen*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandGen_randOdds'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        unsigned int arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRandGen:randOdds");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CRandGen:randOdds");
        if(!ok)
            return 0;
        bool ret = cobj->randOdds(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRandGen:randOdds has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandGen_randOdds'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandGen_randUInt(lua_State* tolua_S)
{
    int argc = 0;
    CRandGen* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandGen",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandGen*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandGen_randUInt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->randUInt();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRandGen:randUInt has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandGen_randUInt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandGen_randNumList(lua_State* tolua_S)
{
    int argc = 0;
    CRandGen* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandGen",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandGen*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandGen_randNumList'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        std::vector<int, std::allocator<int> >* arg0;
        int arg1;
        int arg2;
        int arg3;
        int arg4;

        ok &= luaval_to_object<std::vector<int, std::allocator<int> >>(tolua_S, 2, "std::vector<int, std::allocator<int> >*", &arg0, "CRandGen:randNumList");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRandGen:randNumList");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CRandGen:randNumList");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CRandGen:randNumList");

        ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CRandGen:randNumList");
        if(!ok)
            return 0;
        bool ret = cobj->randNumList(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 6) 
    {
        std::vector<int, std::allocator<int> >* arg0;
        int arg1;
        int arg2;
        int arg3;
        int arg4;
        bool arg5;

        ok &= luaval_to_object<std::vector<int, std::allocator<int> >>(tolua_S, 2, "std::vector<int, std::allocator<int> >*", &arg0, "CRandGen:randNumList");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRandGen:randNumList");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CRandGen:randNumList");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CRandGen:randNumList");

        ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CRandGen:randNumList");

        ok &= luaval_to_boolean(tolua_S, 7,(bool*)&arg5, "CRandGen:randNumList");
        if(!ok)
            return 0;
        bool ret = cobj->randNumList(arg0, arg1, arg2, arg3, arg4, arg5);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRandGen:randNumList has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandGen_randNumList'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandGen_randDouble(lua_State* tolua_S)
{
    int argc = 0;
    CRandGen* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandGen",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandGen*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandGen_randDouble'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        double ret = cobj->randDouble();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRandGen:randDouble has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandGen_randDouble'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandGen_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CRandGen",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CRandGen* ret = CRandGen::GetPtr();
        object_to_luaval<CRandGen>(tolua_S, "CRandGen",(CRandGen*)ret);
        return 1;
    }
    gxError("CRandGen:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandGen_GetPtr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CRandGen_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CRandGen* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CRandGen();
        tolua_pushusertype(tolua_S,(void*)cobj,"CRandGen");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRandGen:CRandGen");
        if(!ok)
            return 0;
        cobj = new CRandGen(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CRandGen");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CRandGen:CRandGen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CRandGen_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CRandGen)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CRandGen",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CRandGen* self = (CRandGen*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CRandGen(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CRandGen");
    tolua_cclass(tolua_S,"CRandGen","CRandGen","CManualSingleton<CRandGen>",lua_mapserver_CRandGen_finalize);

    tolua_beginmodule(tolua_S,"CRandGen");
        tolua_function(tolua_S,"new",lua_mapserver_CRandGen_constructor);
        tolua_function(tolua_S,"reset",lua_mapserver_CRandGen_reset);
        tolua_function(tolua_S,"randBool",lua_mapserver_CRandGen_randBool);
        tolua_function(tolua_S,"randOdds",lua_mapserver_CRandGen_randOdds);
        tolua_function(tolua_S,"randUInt",lua_mapserver_CRandGen_randUInt);
        tolua_function(tolua_S,"randNumList",lua_mapserver_CRandGen_randNumList);
        tolua_function(tolua_S,"randDouble",lua_mapserver_CRandGen_randDouble);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CRandGen_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CRandGen).name();
    g_luaType[typeName] = "CRandGen";
    g_typeCast["CRandGen"] = "CRandGen";
    return 1;
}

int lua_mapserver_CGameMisc_GenSceneID(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        unsigned short arg0;
        unsigned char arg1;
        unsigned short arg2;
        unsigned int arg3;
        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CGameMisc:GenSceneID");
        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CGameMisc:GenSceneID");
        ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CGameMisc:GenSceneID");
        ok &= luaval_to_uint32(tolua_S, 5,(uint32*)&arg3, "CGameMisc:GenSceneID");
        if(!ok)
            return 0;
        unsigned long long ret = CGameMisc::GenSceneID(arg0, arg1, arg2, arg3);
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }
    gxError("CGameMisc:GenSceneID has wrong number of arguments: {0}, was expecting {1}\n ", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_GenSceneID'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_GenRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        unsigned long long arg0;
        unsigned short arg1;
        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CGameMisc:GenRoleUID");
        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CGameMisc:GenRoleUID");
        if(!ok)
            return 0;
        unsigned long long ret = CGameMisc::GenRoleUID(arg0, arg1);
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }
    gxError("CGameMisc:GenRoleUID has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_GenRoleUID'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_ToSeconds(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        char arg0;
        char arg1;
        char arg2;
        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CGameMisc:ToSeconds");
        ok &= luaval_to_sint8(tolua_S, 3,(sint8*)&arg1, "CGameMisc:ToSeconds");
        ok &= luaval_to_sint8(tolua_S, 4,(sint8*)&arg2, "CGameMisc:ToSeconds");
        if(!ok)
            return 0;
        int ret = CGameMisc::ToSeconds(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CGameMisc:ToSeconds has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_ToSeconds'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_IsInValidRadius(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 5)
    {
        short arg0;
        short arg1;
        short arg2;
        short arg3;
        unsigned char arg4;
        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CGameMisc:IsInValidRadius");
        ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CGameMisc:IsInValidRadius");
        ok &= luaval_to_sint16(tolua_S, 4,(sint16*)&arg2, "CGameMisc:IsInValidRadius");
        ok &= luaval_to_sint16(tolua_S, 5,(sint16*)&arg3, "CGameMisc:IsInValidRadius");
        ok &= luaval_to_uint8(tolua_S, 6,(uint8*)&arg4, "CGameMisc:IsInValidRadius");
        if(!ok)
            return 0;
        bool ret = CGameMisc::IsInValidRadius(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CGameMisc:IsInValidRadius has wrong number of arguments: {0}, was expecting {1}\n ", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_IsInValidRadius'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_IsSameDay(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        unsigned int arg0;
        unsigned int arg1;
        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameMisc:IsSameDay");
        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CGameMisc:IsSameDay");
        if(!ok)
            return 0;
        bool ret = CGameMisc::IsSameDay(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CGameMisc:IsSameDay has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_IsSameDay'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_GetDir(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        AxisPos arg0;
        AxisPos arg1;
        ok &= luaval_to_axispos(tolua_S, 2, "AxisPos", &arg0, "CGameMisc:GetDir");
        ok &= luaval_to_axispos(tolua_S, 3, "AxisPos", &arg1, "CGameMisc:GetDir");
        if(!ok)
            return 0;
        unsigned char ret = CGameMisc::GetDir(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CGameMisc:GetDir has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_GetDir'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_GetWorldIDByRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned long long arg0;
        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CGameMisc:GetWorldIDByRoleUID");
        if(!ok)
            return 0;
        unsigned short ret = CGameMisc::GetWorldIDByRoleUID(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CGameMisc:GetWorldIDByRoleUID has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_GetWorldIDByRoleUID'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_GetOpposeDir(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned char arg0;
        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CGameMisc:GetOpposeDir");
        if(!ok)
            return 0;
        unsigned char ret = CGameMisc::GetOpposeDir(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CGameMisc:GetOpposeDir has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_GetOpposeDir'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_GetMapType(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned long long arg0;
        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CGameMisc:GetMapType");
        if(!ok)
            return 0;
        unsigned char ret = CGameMisc::GetMapType(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CGameMisc:GetMapType has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_GetMapType'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_RandDir(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        unsigned char ret = CGameMisc::RandDir();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CGameMisc:RandDir has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_RandDir'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_GetMapServerID(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned long long arg0;
        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CGameMisc:GetMapServerID");
        if(!ok)
            return 0;
        unsigned short ret = CGameMisc::GetMapServerID(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CGameMisc:GetMapServerID has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_GetMapServerID'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_GetMapID(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned long long arg0;
        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CGameMisc:GetMapID");
        if(!ok)
            return 0;
        unsigned short ret = CGameMisc::GetMapID(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CGameMisc:GetMapID has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_GetMapID'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_GetDirForAngle(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        AxisPos arg0;
        AxisPos arg1;
        ok &= luaval_to_axispos(tolua_S, 2, "AxisPos", &arg0, "CGameMisc:GetDirForAngle");
        ok &= luaval_to_axispos(tolua_S, 3, "AxisPos", &arg1, "CGameMisc:GetDirForAngle");
        if(!ok)
            return 0;
        unsigned char ret = CGameMisc::GetDirForAngle(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CGameMisc:GetDirForAngle has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_GetDirForAngle'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_IsNormalMap(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ESceneType arg0;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGameMisc:IsNormalMap");
        if(!ok)
            return 0;
        bool ret = CGameMisc::IsNormalMap(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CGameMisc:IsNormalMap has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_IsNormalMap'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_ToNumber(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string arg0;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CGameMisc:ToNumber");
        if(!ok)
            return 0;
        int ret = CGameMisc::ToNumber(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CGameMisc:ToNumber has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_ToNumber'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_GetRoleUIDSeedByRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned long long arg0;
        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CGameMisc:GetRoleUIDSeedByRoleUID");
        if(!ok)
            return 0;
        unsigned long long ret = CGameMisc::GetRoleUIDSeedByRoleUID(arg0);
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }
    gxError("CGameMisc:GetRoleUIDSeedByRoleUID has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_GetRoleUIDSeedByRoleUID'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_MySqrt(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        AxisPos arg0;
        AxisPos arg1;
        ok &= luaval_to_axispos(tolua_S, 2, "AxisPos", &arg0, "CGameMisc:MySqrt");
        ok &= luaval_to_axispos(tolua_S, 3, "AxisPos", &arg1, "CGameMisc:MySqrt");
        if(!ok)
            return 0;
        double ret = CGameMisc::MySqrt(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CGameMisc:MySqrt has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_MySqrt'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_GetFourDir(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        AxisPos arg0;
        AxisPos arg1;
        ok &= luaval_to_axispos(tolua_S, 2, "AxisPos", &arg0, "CGameMisc:GetFourDir");
        ok &= luaval_to_axispos(tolua_S, 3, "AxisPos", &arg1, "CGameMisc:GetFourDir");
        if(!ok)
            return 0;
        unsigned char ret = CGameMisc::GetFourDir(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CGameMisc:GetFourDir has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_GetFourDir'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_ToLocalDay(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)) goto tolua_lerror;

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameMisc:ToLocalDay");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CGameMisc:ToLocalDay");
            if (!ok) { break; }
            int ret = CGameMisc::ToLocalDay(arg0, arg1);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameMisc:ToLocalDay");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CGameMisc:ToLocalDay");
            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CGameMisc:ToLocalDay");
            if (!ok) { break; }
            int ret = CGameMisc::ToLocalDay(arg0, arg1, arg2);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 4)
        {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameMisc:ToLocalDay");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CGameMisc:ToLocalDay");
            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CGameMisc:ToLocalDay");
            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CGameMisc:ToLocalDay");
            if (!ok) { break; }
            int ret = CGameMisc::ToLocalDay(arg0, arg1, arg2, arg3);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 1)
        {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameMisc:ToLocalDay");
            if (!ok) { break; }
            int ret = CGameMisc::ToLocalDay(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    } while (0);
    ok  = true;

    gxError("CGameMisc:ToLocalDay has wrong number of arguments: {0}, was expecting {1}",argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_ToLocalDay'.",&tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_MyAngle(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        AxisPos arg0;
        AxisPos arg1;
        ok &= luaval_to_axispos(tolua_S, 2, "AxisPos", &arg0, "CGameMisc:MyAngle");
        ok &= luaval_to_axispos(tolua_S, 3, "AxisPos", &arg1, "CGameMisc:MyAngle");
        if(!ok)
            return 0;
        double ret = CGameMisc::MyAngle(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CGameMisc:MyAngle has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_MyAngle'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameMisc_IsDynamicMap(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameMisc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ESceneType arg0;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGameMisc:IsDynamicMap");
        if(!ok)
            return 0;
        bool ret = CGameMisc::IsDynamicMap(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CGameMisc:IsDynamicMap has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMisc_IsDynamicMap'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CGameMisc_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGameMisc)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGameMisc",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CGameMisc* self = (CGameMisc*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CGameMisc(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGameMisc");
    tolua_cclass(tolua_S,"CGameMisc","CGameMisc","",nullptr);

    tolua_beginmodule(tolua_S,"CGameMisc");
        tolua_function(tolua_S,"GenSceneID", lua_mapserver_CGameMisc_GenSceneID);
        tolua_function(tolua_S,"GenRoleUID", lua_mapserver_CGameMisc_GenRoleUID);
        tolua_function(tolua_S,"ToSeconds", lua_mapserver_CGameMisc_ToSeconds);
        tolua_function(tolua_S,"IsInValidRadius", lua_mapserver_CGameMisc_IsInValidRadius);
        tolua_function(tolua_S,"IsSameDay", lua_mapserver_CGameMisc_IsSameDay);
        tolua_function(tolua_S,"GetDir", lua_mapserver_CGameMisc_GetDir);
        tolua_function(tolua_S,"GetWorldIDByRoleUID", lua_mapserver_CGameMisc_GetWorldIDByRoleUID);
        tolua_function(tolua_S,"GetOpposeDir", lua_mapserver_CGameMisc_GetOpposeDir);
        tolua_function(tolua_S,"GetMapType", lua_mapserver_CGameMisc_GetMapType);
        tolua_function(tolua_S,"RandDir", lua_mapserver_CGameMisc_RandDir);
        tolua_function(tolua_S,"GetMapServerID", lua_mapserver_CGameMisc_GetMapServerID);
        tolua_function(tolua_S,"GetMapID", lua_mapserver_CGameMisc_GetMapID);
        tolua_function(tolua_S,"GetDirForAngle", lua_mapserver_CGameMisc_GetDirForAngle);
        tolua_function(tolua_S,"IsNormalMap", lua_mapserver_CGameMisc_IsNormalMap);
        tolua_function(tolua_S,"ToNumber", lua_mapserver_CGameMisc_ToNumber);
        tolua_function(tolua_S,"GetRoleUIDSeedByRoleUID", lua_mapserver_CGameMisc_GetRoleUIDSeedByRoleUID);
        tolua_function(tolua_S,"MySqrt", lua_mapserver_CGameMisc_MySqrt);
        tolua_function(tolua_S,"GetFourDir", lua_mapserver_CGameMisc_GetFourDir);
        tolua_function(tolua_S,"ToLocalDay", lua_mapserver_CGameMisc_ToLocalDay);
        tolua_function(tolua_S,"MyAngle", lua_mapserver_CGameMisc_MyAngle);
        tolua_function(tolua_S,"IsDynamicMap", lua_mapserver_CGameMisc_IsDynamicMap);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CGameMisc).name();
    g_luaType[typeName] = "CGameMisc";
    g_typeCast["CGameMisc"] = "CGameMisc";
    return 1;
}

int lua_mapserver_IAttrBase_setStrength(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setStrength'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setStrength");
        if(!ok)
            return 0;
        cobj->setStrength(arg0);
        return 0;
    }

    gxError("IAttrBase:setStrength has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setStrength'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addMaxHp(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addMaxHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addMaxHp");
        if(!ok)
            return 0;
        int ret = cobj->addMaxHp(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addMaxHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addMaxHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setDamage(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setDamage'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setDamage");
        if(!ok)
            return 0;
        cobj->setDamage(arg0);
        return 0;
    }

    gxError("IAttrBase:setDamage has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setDamage'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addPhysicDefense(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addPhysicDefense'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addPhysicDefense");
        if(!ok)
            return 0;
        int ret = cobj->addPhysicDefense(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addPhysicDefense has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addPhysicDefense'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addPower(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addPower'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addPower");
        if(!ok)
            return 0;
        int ret = cobj->addPower(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addPower has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addPower'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getDamageReduce(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getDamageReduce'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getDamageReduce();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getDamageReduce has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getDamageReduce'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addDamageReduce(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addDamageReduce'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addDamageReduce");
        if(!ok)
            return 0;
        int ret = cobj->addDamageReduce(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addDamageReduce has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addDamageReduce'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getStrength(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getStrength'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getStrength();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getStrength has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getStrength'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setHp(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setHp");
        if(!ok)
            return 0;
        cobj->setHp(arg0);
        return 0;
    }

    gxError("IAttrBase:setHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getMoveSpeed(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getMoveSpeed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMoveSpeed();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getMoveSpeed has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getMoveSpeed'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addDodge(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addDodge'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addDodge");
        if(!ok)
            return 0;
        int ret = cobj->addDodge(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addDodge has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addDodge'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addWisdom(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addWisdom'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addWisdom");
        if(!ok)
            return 0;
        int ret = cobj->addWisdom(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addWisdom has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addWisdom'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getCrit(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getCrit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getCrit();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getCrit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getCrit'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setWisdom(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setWisdom'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setWisdom");
        if(!ok)
            return 0;
        cobj->setWisdom(arg0);
        return 0;
    }

    gxError("IAttrBase:setWisdom has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setWisdom'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getPhysicDefense(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getPhysicDefense'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPhysicDefense();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getPhysicDefense has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getPhysicDefense'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addSkillAttack(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addSkillAttack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addSkillAttack");
        if(!ok)
            return 0;
        int ret = cobj->addSkillAttack(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addSkillAttack has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addSkillAttack'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setPower(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setPower'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setPower");
        if(!ok)
            return 0;
        cobj->setPower(arg0);
        return 0;
    }

    gxError("IAttrBase:setPower has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setPower'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setDodge(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setDodge'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setDodge");
        if(!ok)
            return 0;
        cobj->setDodge(arg0);
        return 0;
    }

    gxError("IAttrBase:setDodge has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setDodge'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setAgility(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setAgility'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setAgility");
        if(!ok)
            return 0;
        cobj->setAgility(arg0);
        return 0;
    }

    gxError("IAttrBase:setAgility has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setAgility'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getPhysicAttck(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getPhysicAttck'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPhysicAttck();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getPhysicAttck has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getPhysicAttck'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getWisdom(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getWisdom'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getWisdom();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getWisdom has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getWisdom'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getMp(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getMp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMp();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getMp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getMp'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addAgility(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addAgility'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addAgility");
        if(!ok)
            return 0;
        int ret = cobj->addAgility(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addAgility has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addAgility'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setPhysicDefense(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setPhysicDefense'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setPhysicDefense");
        if(!ok)
            return 0;
        cobj->setPhysicDefense(arg0);
        return 0;
    }

    gxError("IAttrBase:setPhysicDefense has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setPhysicDefense'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addCrit(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addCrit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addCrit");
        if(!ok)
            return 0;
        int ret = cobj->addCrit(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addCrit has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addCrit'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getDodge(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getDodge'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getDodge();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getDodge has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getDodge'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setValue(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char arg0;
        int arg1;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "IAttrBase:setValue");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "IAttrBase:setValue");
        if(!ok)
            return 0;
        cobj->setValue(arg0, arg1);
        return 0;
    }

    gxError("IAttrBase:setValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addEnergy(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addEnergy'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addEnergy");
        if(!ok)
            return 0;
        int ret = cobj->addEnergy(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addEnergy has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addEnergy'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getMaxHp(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getMaxHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxHp();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getMaxHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getMaxHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setMp(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setMp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setMp");
        if(!ok)
            return 0;
        cobj->setMp(arg0);
        return 0;
    }

    gxError("IAttrBase:setMp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setMp'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setMaxEnergy(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setMaxEnergy'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setMaxEnergy");
        if(!ok)
            return 0;
        cobj->setMaxEnergy(arg0);
        return 0;
    }

    gxError("IAttrBase:setMaxEnergy has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setMaxEnergy'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getDamage(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getDamage'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getDamage();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getDamage has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getDamage'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addStrength(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addStrength'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addStrength");
        if(!ok)
            return 0;
        int ret = cobj->addStrength(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addStrength has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addStrength'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setSkillAttack(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setSkillAttack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setSkillAttack");
        if(!ok)
            return 0;
        cobj->setSkillAttack(arg0);
        return 0;
    }

    gxError("IAttrBase:setSkillAttack has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setSkillAttack'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setMaxHp(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setMaxHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setMaxHp");
        if(!ok)
            return 0;
        cobj->setMaxHp(arg0);
        return 0;
    }

    gxError("IAttrBase:setMaxHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setMaxHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setPhysicAttck(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setPhysicAttck'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setPhysicAttck");
        if(!ok)
            return 0;
        cobj->setPhysicAttck(arg0);
        return 0;
    }

    gxError("IAttrBase:setPhysicAttck has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setPhysicAttck'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getPower(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getPower'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPower();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getPower has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getPower'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getAgility(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getAgility'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getAgility();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getAgility has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getAgility'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addHp(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addHp");
        if(!ok)
            return 0;
        int ret = cobj->addHp(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getValue(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "IAttrBase:getValue");
        if(!ok)
            return 0;
        int ret = cobj->getValue(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getMaxEnergy(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getMaxEnergy'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxEnergy();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getMaxEnergy has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getMaxEnergy'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setDamageReduce(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setDamageReduce'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setDamageReduce");
        if(!ok)
            return 0;
        cobj->setDamageReduce(arg0);
        return 0;
    }

    gxError("IAttrBase:setDamageReduce has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setDamageReduce'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addDamage(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addDamage'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addDamage");
        if(!ok)
            return 0;
        int ret = cobj->addDamage(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addDamage has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addDamage'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addMaxEnergy(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addMaxEnergy'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addMaxEnergy");
        if(!ok)
            return 0;
        int ret = cobj->addMaxEnergy(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addMaxEnergy has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addMaxEnergy'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addPhysicAttck(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addPhysicAttck'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addPhysicAttck");
        if(!ok)
            return 0;
        int ret = cobj->addPhysicAttck(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addPhysicAttck has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addPhysicAttck'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addMoveSpeed(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addMoveSpeed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:addMoveSpeed");
        if(!ok)
            return 0;
        int ret = cobj->addMoveSpeed(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addMoveSpeed has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addMoveSpeed'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setMoveSpeed(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setMoveSpeed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setMoveSpeed");
        if(!ok)
            return 0;
        cobj->setMoveSpeed(arg0);
        return 0;
    }

    gxError("IAttrBase:setMoveSpeed has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setMoveSpeed'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_addValue(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_addValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char arg0;
        int arg1;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "IAttrBase:addValue");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "IAttrBase:addValue");
        if(!ok)
            return 0;
        int ret = cobj->addValue(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:addValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_addValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getHp(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getHp();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_setCrit(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_setCrit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IAttrBase:setCrit");
        if(!ok)
            return 0;
        cobj->setCrit(arg0);
        return 0;
    }

    gxError("IAttrBase:setCrit has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_setCrit'.",&tolua_err);
	return 0;
}
int lua_mapserver_IAttrBase_getSkillAttack(lua_State* tolua_S)
{
    int argc = 0;
    IAttrBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (IAttrBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IAttrBase_getSkillAttack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getSkillAttack();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IAttrBase:getSkillAttack has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IAttrBase_getSkillAttack'.",&tolua_err);
	return 0;
}
static int lua_mapserver_IAttrBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IAttrBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IAttrBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        IAttrBase* self = (IAttrBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_IAttrBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IAttrBase");
    tolua_cclass(tolua_S,"IAttrBase","IAttrBase","",nullptr);

    tolua_beginmodule(tolua_S,"IAttrBase");
        tolua_function(tolua_S,"setStrength",lua_mapserver_IAttrBase_setStrength);
        tolua_function(tolua_S,"addMaxHp",lua_mapserver_IAttrBase_addMaxHp);
        tolua_function(tolua_S,"setDamage",lua_mapserver_IAttrBase_setDamage);
        tolua_function(tolua_S,"addPhysicDefense",lua_mapserver_IAttrBase_addPhysicDefense);
        tolua_function(tolua_S,"addPower",lua_mapserver_IAttrBase_addPower);
        tolua_function(tolua_S,"getDamageReduce",lua_mapserver_IAttrBase_getDamageReduce);
        tolua_function(tolua_S,"addDamageReduce",lua_mapserver_IAttrBase_addDamageReduce);
        tolua_function(tolua_S,"getStrength",lua_mapserver_IAttrBase_getStrength);
        tolua_function(tolua_S,"setHp",lua_mapserver_IAttrBase_setHp);
        tolua_function(tolua_S,"getMoveSpeed",lua_mapserver_IAttrBase_getMoveSpeed);
        tolua_function(tolua_S,"addDodge",lua_mapserver_IAttrBase_addDodge);
        tolua_function(tolua_S,"addWisdom",lua_mapserver_IAttrBase_addWisdom);
        tolua_function(tolua_S,"getCrit",lua_mapserver_IAttrBase_getCrit);
        tolua_function(tolua_S,"setWisdom",lua_mapserver_IAttrBase_setWisdom);
        tolua_function(tolua_S,"getPhysicDefense",lua_mapserver_IAttrBase_getPhysicDefense);
        tolua_function(tolua_S,"addSkillAttack",lua_mapserver_IAttrBase_addSkillAttack);
        tolua_function(tolua_S,"setPower",lua_mapserver_IAttrBase_setPower);
        tolua_function(tolua_S,"setDodge",lua_mapserver_IAttrBase_setDodge);
        tolua_function(tolua_S,"setAgility",lua_mapserver_IAttrBase_setAgility);
        tolua_function(tolua_S,"getPhysicAttck",lua_mapserver_IAttrBase_getPhysicAttck);
        tolua_function(tolua_S,"getWisdom",lua_mapserver_IAttrBase_getWisdom);
        tolua_function(tolua_S,"getMp",lua_mapserver_IAttrBase_getMp);
        tolua_function(tolua_S,"addAgility",lua_mapserver_IAttrBase_addAgility);
        tolua_function(tolua_S,"setPhysicDefense",lua_mapserver_IAttrBase_setPhysicDefense);
        tolua_function(tolua_S,"addCrit",lua_mapserver_IAttrBase_addCrit);
        tolua_function(tolua_S,"getDodge",lua_mapserver_IAttrBase_getDodge);
        tolua_function(tolua_S,"setValue",lua_mapserver_IAttrBase_setValue);
        tolua_function(tolua_S,"addEnergy",lua_mapserver_IAttrBase_addEnergy);
        tolua_function(tolua_S,"getMaxHp",lua_mapserver_IAttrBase_getMaxHp);
        tolua_function(tolua_S,"setMp",lua_mapserver_IAttrBase_setMp);
        tolua_function(tolua_S,"setMaxEnergy",lua_mapserver_IAttrBase_setMaxEnergy);
        tolua_function(tolua_S,"getDamage",lua_mapserver_IAttrBase_getDamage);
        tolua_function(tolua_S,"addStrength",lua_mapserver_IAttrBase_addStrength);
        tolua_function(tolua_S,"setSkillAttack",lua_mapserver_IAttrBase_setSkillAttack);
        tolua_function(tolua_S,"setMaxHp",lua_mapserver_IAttrBase_setMaxHp);
        tolua_function(tolua_S,"setPhysicAttck",lua_mapserver_IAttrBase_setPhysicAttck);
        tolua_function(tolua_S,"getPower",lua_mapserver_IAttrBase_getPower);
        tolua_function(tolua_S,"getAgility",lua_mapserver_IAttrBase_getAgility);
        tolua_function(tolua_S,"addHp",lua_mapserver_IAttrBase_addHp);
        tolua_function(tolua_S,"getValue",lua_mapserver_IAttrBase_getValue);
        tolua_function(tolua_S,"getMaxEnergy",lua_mapserver_IAttrBase_getMaxEnergy);
        tolua_function(tolua_S,"setDamageReduce",lua_mapserver_IAttrBase_setDamageReduce);
        tolua_function(tolua_S,"addDamage",lua_mapserver_IAttrBase_addDamage);
        tolua_function(tolua_S,"addMaxEnergy",lua_mapserver_IAttrBase_addMaxEnergy);
        tolua_function(tolua_S,"addPhysicAttck",lua_mapserver_IAttrBase_addPhysicAttck);
        tolua_function(tolua_S,"addMoveSpeed",lua_mapserver_IAttrBase_addMoveSpeed);
        tolua_function(tolua_S,"setMoveSpeed",lua_mapserver_IAttrBase_setMoveSpeed);
        tolua_function(tolua_S,"addValue",lua_mapserver_IAttrBase_addValue);
        tolua_function(tolua_S,"getHp",lua_mapserver_IAttrBase_getHp);
        tolua_function(tolua_S,"setCrit",lua_mapserver_IAttrBase_setCrit);
        tolua_function(tolua_S,"getSkillAttack",lua_mapserver_IAttrBase_getSkillAttack);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(IAttrBase).name();
    g_luaType[typeName] = "IAttrBase";
    g_typeCast["IAttrBase"] = "IAttrBase";
    return 1;
}

int lua_mapserver_AddAttr_setAddType(lua_State* tolua_S)
{
    int argc = 0;
    AddAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AddAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (AddAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AddAttr_setAddType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "AddAttr:setAddType");
        if(!ok)
            return 0;
        cobj->setAddType(arg0);
        return 0;
    }

    gxError("AddAttr:setAddType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AddAttr_setAddType'.",&tolua_err);
	return 0;
}
int lua_mapserver_AddAttr_isValid(lua_State* tolua_S)
{
    int argc = 0;
    AddAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AddAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (AddAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AddAttr_isValid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isValid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("AddAttr:isValid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AddAttr_isValid'.",&tolua_err);
	return 0;
}
int lua_mapserver_AddAttr_setAttrValue(lua_State* tolua_S)
{
    int argc = 0;
    AddAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AddAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (AddAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AddAttr_setAttrValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "AddAttr:setAttrValue");
        if(!ok)
            return 0;
        cobj->setAttrValue(arg0);
        return 0;
    }

    gxError("AddAttr:setAttrValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AddAttr_setAttrValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_AddAttr_getAttrValue(lua_State* tolua_S)
{
    int argc = 0;
    AddAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AddAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (AddAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AddAttr_getAttrValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getAttrValue();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("AddAttr:getAttrValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AddAttr_getAttrValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_AddAttr_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    AddAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AddAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (AddAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AddAttr_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("AddAttr:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AddAttr_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_AddAttr_isRate(lua_State* tolua_S)
{
    int argc = 0;
    AddAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AddAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (AddAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AddAttr_isRate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isRate();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("AddAttr:isRate has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AddAttr_isRate'.",&tolua_err);
	return 0;
}
int lua_mapserver_AddAttr_getAddType(lua_State* tolua_S)
{
    int argc = 0;
    AddAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AddAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (AddAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AddAttr_getAddType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        char ret = cobj->getAddType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("AddAttr:getAddType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AddAttr_getAddType'.",&tolua_err);
	return 0;
}
int lua_mapserver_AddAttr_constructor(lua_State* tolua_S)
{
    int argc = 0;
    AddAttr* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            unsigned char arg0;
            ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "AddAttr:AddAttr");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "AddAttr:AddAttr");

            if (!ok) { break; }
            cobj = new AddAttr(arg0, arg1);
            tolua_pushusertype(tolua_S,(void*)cobj,"AddAttr");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new AddAttr();
            tolua_pushusertype(tolua_S,(void*)cobj,"AddAttr");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("AddAttr:AddAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_AddAttr_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (AddAttr)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"AddAttr",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        AddAttr* self = (AddAttr*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_AddAttr(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"AddAttr");
    tolua_cclass(tolua_S,"AddAttr","AddAttr","",lua_mapserver_AddAttr_finalize);

    tolua_beginmodule(tolua_S,"AddAttr");
        tolua_function(tolua_S,"new",lua_mapserver_AddAttr_constructor);
        tolua_function(tolua_S,"setAddType",lua_mapserver_AddAttr_setAddType);
        tolua_function(tolua_S,"isValid",lua_mapserver_AddAttr_isValid);
        tolua_function(tolua_S,"setAttrValue",lua_mapserver_AddAttr_setAttrValue);
        tolua_function(tolua_S,"getAttrValue",lua_mapserver_AddAttr_getAttrValue);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_AddAttr_cleanUp);
        tolua_function(tolua_S,"isRate",lua_mapserver_AddAttr_isRate);
        tolua_function(tolua_S,"getAddType",lua_mapserver_AddAttr_getAddType);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(AddAttr).name();
    g_luaType[typeName] = "AddAttr";
    g_typeCast["AddAttr"] = "AddAttr";
    return 1;
}

int lua_mapserver_Attr_setAttrType(lua_State* tolua_S)
{
    int argc = 0;
    Attr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"Attr",0,&tolua_err)) goto tolua_lerror;
    cobj = (Attr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_Attr_setAttrType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "Attr:setAttrType");
        if(!ok)
            return 0;
        cobj->setAttrType(arg0);
        return 0;
    }

    gxError("Attr:setAttrType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_Attr_setAttrType'.",&tolua_err);
	return 0;
}
int lua_mapserver_Attr_getAttrType(lua_State* tolua_S)
{
    int argc = 0;
    Attr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"Attr",0,&tolua_err)) goto tolua_lerror;
    cobj = (Attr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_Attr_getAttrType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        char ret = cobj->getAttrType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("Attr:getAttrType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_Attr_getAttrType'.",&tolua_err);
	return 0;
}
int lua_mapserver_Attr_isValid(lua_State* tolua_S)
{
    int argc = 0;
    Attr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"Attr",0,&tolua_err)) goto tolua_lerror;
    cobj = (Attr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_Attr_isValid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isValid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("Attr:isValid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_Attr_isValid'.",&tolua_err);
	return 0;
}
int lua_mapserver_Attr_setAttrValue(lua_State* tolua_S)
{
    int argc = 0;
    Attr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"Attr",0,&tolua_err)) goto tolua_lerror;
    cobj = (Attr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_Attr_setAttrValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "Attr:setAttrValue");
        if(!ok)
            return 0;
        cobj->setAttrValue(arg0);
        return 0;
    }

    gxError("Attr:setAttrValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_Attr_setAttrValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_Attr_getAttrValue(lua_State* tolua_S)
{
    int argc = 0;
    Attr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"Attr",0,&tolua_err)) goto tolua_lerror;
    cobj = (Attr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_Attr_getAttrValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getAttrValue();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("Attr:getAttrValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_Attr_getAttrValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_Attr_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    Attr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"Attr",0,&tolua_err)) goto tolua_lerror;
    cobj = (Attr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_Attr_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }
    if (argc == 1) 
    {
        EAttributes arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "Attr:cleanUp");
        if(!ok)
            return 0;
        cobj->cleanUp(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        EAttributes arg0;
        int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "Attr:cleanUp");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "Attr:cleanUp");
        if(!ok)
            return 0;
        cobj->cleanUp(arg0, arg1);
        return 0;
    }

    gxError("Attr:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_Attr_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_Attr_constructor(lua_State* tolua_S)
{
    int argc = 0;
    Attr* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            char arg0;
            ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "Attr:Attr");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "Attr:Attr");

            if (!ok) { break; }
            cobj = new Attr(arg0, arg1);
            tolua_pushusertype(tolua_S,(void*)cobj,"Attr");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new Attr();
            tolua_pushusertype(tolua_S,(void*)cobj,"Attr");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("Attr:Attr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_Attr_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (Attr)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"Attr",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        Attr* self = (Attr*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_Attr(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"Attr");
    tolua_cclass(tolua_S,"Attr","Attr","",lua_mapserver_Attr_finalize);

    tolua_beginmodule(tolua_S,"Attr");
        tolua_function(tolua_S,"new",lua_mapserver_Attr_constructor);
        tolua_function(tolua_S,"setAttrType",lua_mapserver_Attr_setAttrType);
        tolua_function(tolua_S,"getAttrType",lua_mapserver_Attr_getAttrType);
        tolua_function(tolua_S,"isValid",lua_mapserver_Attr_isValid);
        tolua_function(tolua_S,"setAttrValue",lua_mapserver_Attr_setAttrValue);
        tolua_function(tolua_S,"getAttrValue",lua_mapserver_Attr_getAttrValue);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_Attr_cleanUp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(Attr).name();
    g_luaType[typeName] = "Attr";
    g_typeCast["Attr"] = "Attr";
    return 1;
}

int lua_mapserver_ExtendAttr_getValueType(lua_State* tolua_S)
{
    int argc = 0;
    ExtendAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ExtendAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (ExtendAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_ExtendAttr_getValueType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getValueType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("ExtendAttr:getValueType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_ExtendAttr_getValueType'.",&tolua_err);
	return 0;
}
int lua_mapserver_ExtendAttr_setAttrType(lua_State* tolua_S)
{
    int argc = 0;
    ExtendAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ExtendAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (ExtendAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_ExtendAttr_setAttrType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "ExtendAttr:setAttrType");
        if(!ok)
            return 0;
        cobj->setAttrType(arg0);
        return 0;
    }

    gxError("ExtendAttr:setAttrType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_ExtendAttr_setAttrType'.",&tolua_err);
	return 0;
}
int lua_mapserver_ExtendAttr_getAttrType(lua_State* tolua_S)
{
    int argc = 0;
    ExtendAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ExtendAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (ExtendAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_ExtendAttr_getAttrType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        char ret = cobj->getAttrType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("ExtendAttr:getAttrType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_ExtendAttr_getAttrType'.",&tolua_err);
	return 0;
}
int lua_mapserver_ExtendAttr_setAttrValue(lua_State* tolua_S)
{
    int argc = 0;
    ExtendAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ExtendAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (ExtendAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_ExtendAttr_setAttrValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "ExtendAttr:setAttrValue");
        if(!ok)
            return 0;
        cobj->setAttrValue(arg0);
        return 0;
    }

    gxError("ExtendAttr:setAttrValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_ExtendAttr_setAttrValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_ExtendAttr_setValueType(lua_State* tolua_S)
{
    int argc = 0;
    ExtendAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ExtendAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (ExtendAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_ExtendAttr_setValueType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "ExtendAttr:setValueType");
        if(!ok)
            return 0;
        cobj->setValueType(arg0);
        return 0;
    }

    gxError("ExtendAttr:setValueType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_ExtendAttr_setValueType'.",&tolua_err);
	return 0;
}
int lua_mapserver_ExtendAttr_getAttrValue(lua_State* tolua_S)
{
    int argc = 0;
    ExtendAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ExtendAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (ExtendAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_ExtendAttr_getAttrValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getAttrValue();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("ExtendAttr:getAttrValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_ExtendAttr_getAttrValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_ExtendAttr_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    ExtendAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ExtendAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (ExtendAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_ExtendAttr_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("ExtendAttr:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_ExtendAttr_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_ExtendAttr_isRate(lua_State* tolua_S)
{
    int argc = 0;
    ExtendAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ExtendAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (ExtendAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_ExtendAttr_isRate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isRate();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("ExtendAttr:isRate has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_ExtendAttr_isRate'.",&tolua_err);
	return 0;
}
int lua_mapserver_ExtendAttr_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ExtendAttr* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            char arg0;
            ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "ExtendAttr:ExtendAttr");

            if (!ok) { break; }
            unsigned char arg1;
            ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "ExtendAttr:ExtendAttr");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "ExtendAttr:ExtendAttr");

            if (!ok) { break; }
            cobj = new ExtendAttr(arg0, arg1, arg2);
            tolua_pushusertype(tolua_S,(void*)cobj,"ExtendAttr");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new ExtendAttr();
            tolua_pushusertype(tolua_S,(void*)cobj,"ExtendAttr");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("ExtendAttr:ExtendAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_ExtendAttr_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ExtendAttr)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ExtendAttr",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ExtendAttr* self = (ExtendAttr*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ExtendAttr(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ExtendAttr");
    tolua_cclass(tolua_S,"ExtendAttr","ExtendAttr","",lua_mapserver_ExtendAttr_finalize);

    tolua_beginmodule(tolua_S,"ExtendAttr");
        tolua_function(tolua_S,"new",lua_mapserver_ExtendAttr_constructor);
        tolua_function(tolua_S,"getValueType",lua_mapserver_ExtendAttr_getValueType);
        tolua_function(tolua_S,"setAttrType",lua_mapserver_ExtendAttr_setAttrType);
        tolua_function(tolua_S,"getAttrType",lua_mapserver_ExtendAttr_getAttrType);
        tolua_function(tolua_S,"setAttrValue",lua_mapserver_ExtendAttr_setAttrValue);
        tolua_function(tolua_S,"setValueType",lua_mapserver_ExtendAttr_setValueType);
        tolua_function(tolua_S,"getAttrValue",lua_mapserver_ExtendAttr_getAttrValue);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_ExtendAttr_cleanUp);
        tolua_function(tolua_S,"isRate",lua_mapserver_ExtendAttr_isRate);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ExtendAttr).name();
    g_luaType[typeName] = "ExtendAttr";
    g_typeCast["ExtendAttr"] = "ExtendAttr";
    return 1;
}

int lua_mapserver_CActionBan_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CActionBan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CActionBan",0,&tolua_err)) goto tolua_lerror;
    cobj = (CActionBan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CActionBan_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CActionBan:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CActionBan_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CActionBan_reset(lua_State* tolua_S)
{
    int argc = 0;
    CActionBan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CActionBan",0,&tolua_err)) goto tolua_lerror;
    cobj = (CActionBan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CActionBan_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }

    gxError("CActionBan:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CActionBan_reset'.",&tolua_err);
	return 0;
}
int lua_mapserver_CActionBan_getState(lua_State* tolua_S)
{
    int argc = 0;
    CActionBan* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CActionBan",0,&tolua_err)) goto tolua_lerror;
    cobj = (CActionBan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CActionBan_getState'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            char arg0;
            ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CActionBan:getState");

            if (!ok) { break; }
            bool ret = cobj->getState(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            const GXMISC::CBit16* ret = cobj->getState();
            object_to_luaval<GXMISC::CBit16>(tolua_S, "CBit16",(GXMISC::CBit16*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CActionBan:getState has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CActionBan_getState'.",&tolua_err);
    return 0;
}
int lua_mapserver_CActionBan_setValue(lua_State* tolua_S)
{
    int argc = 0;
    CActionBan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CActionBan",0,&tolua_err)) goto tolua_lerror;
    cobj = (CActionBan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CActionBan_setValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char arg0;
        bool arg1;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CActionBan:setValue");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CActionBan:setValue");
        if(!ok)
            return 0;
        cobj->setValue(arg0, arg1);
        return 0;
    }

    gxError("CActionBan:setValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CActionBan_setValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_CActionBan_getValue(lua_State* tolua_S)
{
    int argc = 0;
    CActionBan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CActionBan",0,&tolua_err)) goto tolua_lerror;
    cobj = (CActionBan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CActionBan_getValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CActionBan:getValue");
        if(!ok)
            return 0;
        bool ret = cobj->getValue(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CActionBan:getValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CActionBan_getValue'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CActionBan_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CActionBan)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CActionBan",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CActionBan* self = (CActionBan*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CActionBan(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CActionBan");
    tolua_cclass(tolua_S,"CActionBan","CActionBan","",nullptr);

    tolua_beginmodule(tolua_S,"CActionBan");
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CActionBan_cleanUp);
        tolua_function(tolua_S,"reset",lua_mapserver_CActionBan_reset);
        tolua_function(tolua_S,"getState",lua_mapserver_CActionBan_getState);
        tolua_function(tolua_S,"setValue",lua_mapserver_CActionBan_setValue);
        tolua_function(tolua_S,"getValue",lua_mapserver_CActionBan_getValue);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CActionBan).name();
    g_luaType[typeName] = "CActionBan";
    g_typeCast["CActionBan"] = "CActionBan";
    return 1;
}

int lua_mapserver_SkillAttr_setValue(lua_State* tolua_S)
{
    int argc = 0;
    SkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"SkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (SkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_SkillAttr_setValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "SkillAttr:setValue");
        if(!ok)
            return 0;
        cobj->setValue(arg0);
        return 0;
    }

    gxError("SkillAttr:setValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_SkillAttr_setValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_SkillAttr_getRate(lua_State* tolua_S)
{
    int argc = 0;
    SkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"SkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (SkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_SkillAttr_getRate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("SkillAttr:getRate has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_SkillAttr_getRate'.",&tolua_err);
	return 0;
}
int lua_mapserver_SkillAttr_getValue(lua_State* tolua_S)
{
    int argc = 0;
    SkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"SkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (SkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_SkillAttr_getValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getValue();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("SkillAttr:getValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_SkillAttr_getValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_SkillAttr_setRate(lua_State* tolua_S)
{
    int argc = 0;
    SkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"SkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (SkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_SkillAttr_setRate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "SkillAttr:setRate");
        if(!ok)
            return 0;
        cobj->setRate(arg0);
        return 0;
    }

    gxError("SkillAttr:setRate has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_SkillAttr_setRate'.",&tolua_err);
	return 0;
}
int lua_mapserver_SkillAttr_add(lua_State* tolua_S)
{
    int argc = 0;
    SkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"SkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (SkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_SkillAttr_add'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const SkillAttr* arg0;

        ok &= luaval_to_object<const SkillAttr>(tolua_S, 2, "SkillAttr", &arg0, "SkillAttr:add");
        if(!ok)
            return 0;
        cobj->add(arg0);
        return 0;
    }

    gxError("SkillAttr:add has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_SkillAttr_add'.",&tolua_err);
	return 0;
}
int lua_mapserver_SkillAttr_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    SkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"SkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (SkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_SkillAttr_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("SkillAttr:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_SkillAttr_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_SkillAttr_addRate(lua_State* tolua_S)
{
    int argc = 0;
    SkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"SkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (SkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_SkillAttr_addRate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "SkillAttr:addRate");
        if(!ok)
            return 0;
        int ret = cobj->addRate(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("SkillAttr:addRate has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_SkillAttr_addRate'.",&tolua_err);
	return 0;
}
int lua_mapserver_SkillAttr_addValue(lua_State* tolua_S)
{
    int argc = 0;
    SkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"SkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (SkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_SkillAttr_addValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "SkillAttr:addValue");
        if(!ok)
            return 0;
        int ret = cobj->addValue(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("SkillAttr:addValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_SkillAttr_addValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_SkillAttr_isEmpty(lua_State* tolua_S)
{
    int argc = 0;
    SkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"SkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (SkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_SkillAttr_isEmpty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isEmpty();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("SkillAttr:isEmpty has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_SkillAttr_isEmpty'.",&tolua_err);
	return 0;
}
int lua_mapserver_SkillAttr_constructor(lua_State* tolua_S)
{
    int argc = 0;
    SkillAttr* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new SkillAttr();
        tolua_pushusertype(tolua_S,(void*)cobj,"SkillAttr");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("SkillAttr:SkillAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_SkillAttr_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (SkillAttr)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"SkillAttr",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        SkillAttr* self = (SkillAttr*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_SkillAttr(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"SkillAttr");
    tolua_cclass(tolua_S,"SkillAttr","SkillAttr","",lua_mapserver_SkillAttr_finalize);

    tolua_beginmodule(tolua_S,"SkillAttr");
        tolua_function(tolua_S,"new",lua_mapserver_SkillAttr_constructor);
        tolua_function(tolua_S,"setValue",lua_mapserver_SkillAttr_setValue);
        tolua_function(tolua_S,"getRate",lua_mapserver_SkillAttr_getRate);
        tolua_function(tolua_S,"getValue",lua_mapserver_SkillAttr_getValue);
        tolua_function(tolua_S,"setRate",lua_mapserver_SkillAttr_setRate);
        tolua_function(tolua_S,"add",lua_mapserver_SkillAttr_add);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_SkillAttr_cleanUp);
        tolua_function(tolua_S,"addRate",lua_mapserver_SkillAttr_addRate);
        tolua_function(tolua_S,"addValue",lua_mapserver_SkillAttr_addValue);
        tolua_function(tolua_S,"isEmpty",lua_mapserver_SkillAttr_isEmpty);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(SkillAttr).name();
    g_luaType[typeName] = "SkillAttr";
    g_typeCast["SkillAttr"] = "SkillAttr";
    return 1;
}

int lua_mapserver_CSkillAttr_addFixCritHurt(lua_State* tolua_S)
{
    int argc = 0;
    CSkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillAttr_addFixCritHurt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned char arg0;
        int arg1;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CSkillAttr:addFixCritHurt");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSkillAttr:addFixCritHurt");
        if(!ok)
            return 0;
        int ret = cobj->addFixCritHurt(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillAttr:addFixCritHurt has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillAttr_addFixCritHurt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillAttr_getFixCritHurt(lua_State* tolua_S)
{
    int argc = 0;
    CSkillAttr* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CSkillAttr_getFixCritHurt'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            const SkillAttr* ret = cobj->getFixCritHurt();
            object_to_luaval<SkillAttr>(tolua_S, "SkillAttr",(SkillAttr*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            unsigned char arg0;
            ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CSkillAttr:getFixCritHurt");

            if (!ok) { break; }
            int ret = cobj->getFixCritHurt(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CSkillAttr:getFixCritHurt has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillAttr_getFixCritHurt'.",&tolua_err);
    return 0;
}
int lua_mapserver_CSkillAttr_getAppendCritRate(lua_State* tolua_S)
{
    int argc = 0;
    CSkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillAttr_getAppendCritRate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getAppendCritRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillAttr:getAppendCritRate has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillAttr_getAppendCritRate'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillAttr_setFixCritHurt(lua_State* tolua_S)
{
    int argc = 0;
    CSkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillAttr_setFixCritHurt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned char arg0;
        int arg1;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CSkillAttr:setFixCritHurt");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSkillAttr:setFixCritHurt");
        if(!ok)
            return 0;
        cobj->setFixCritHurt(arg0, arg1);
        return 0;
    }

    gxError("CSkillAttr:setFixCritHurt has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillAttr_setFixCritHurt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillAttr_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CSkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillAttr_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CSkillAttr:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillAttr_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillAttr_isFixCritHurt(lua_State* tolua_S)
{
    int argc = 0;
    CSkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillAttr_isFixCritHurt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isFixCritHurt();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSkillAttr:isFixCritHurt has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillAttr_isFixCritHurt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillAttr_setAppendCritRate(lua_State* tolua_S)
{
    int argc = 0;
    CSkillAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillAttr_setAppendCritRate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSkillAttr:setAppendCritRate");
        if(!ok)
            return 0;
        cobj->setAppendCritRate(arg0);
        return 0;
    }

    gxError("CSkillAttr:setAppendCritRate has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillAttr_setAppendCritRate'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillAttr_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CSkillAttr* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CSkillAttr();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSkillAttr");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSkillAttr:CSkillAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CSkillAttr_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSkillAttr)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSkillAttr",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CSkillAttr* self = (CSkillAttr*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CSkillAttr(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSkillAttr");
    tolua_cclass(tolua_S,"CSkillAttr","CSkillAttr","CDetailAttrBase<int, 49>",lua_mapserver_CSkillAttr_finalize);

    tolua_beginmodule(tolua_S,"CSkillAttr");
        tolua_function(tolua_S,"new",lua_mapserver_CSkillAttr_constructor);
        tolua_function(tolua_S,"addFixCritHurt",lua_mapserver_CSkillAttr_addFixCritHurt);
        tolua_function(tolua_S,"getFixCritHurt",lua_mapserver_CSkillAttr_getFixCritHurt);
        tolua_function(tolua_S,"getAppendCritRate",lua_mapserver_CSkillAttr_getAppendCritRate);
        tolua_function(tolua_S,"setFixCritHurt",lua_mapserver_CSkillAttr_setFixCritHurt);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CSkillAttr_cleanUp);
        tolua_function(tolua_S,"isFixCritHurt",lua_mapserver_CSkillAttr_isFixCritHurt);
        tolua_function(tolua_S,"setAppendCritRate",lua_mapserver_CSkillAttr_setAppendCritRate);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CSkillAttr).name();
    g_luaType[typeName] = "CSkillAttr";
    g_typeCast["CSkillAttr"] = "CSkillAttr";
    return 1;
}

int lua_mapserver_CBufferAttr_reset(lua_State* tolua_S)
{
    int argc = 0;
    CBufferAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferAttr_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }

    gxError("CBufferAttr:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferAttr_reset'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferAttr_toString(lua_State* tolua_S)
{
    int argc = 0;
    CBufferAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferAttr_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CBufferAttr:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferAttr_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferAttr_resetBase(lua_State* tolua_S)
{
    int argc = 0;
    CBufferAttr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferAttr",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferAttr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferAttr_resetBase'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->resetBase();
        return 0;
    }

    gxError("CBufferAttr:resetBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferAttr_resetBase'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CBufferAttr_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBufferAttr)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBufferAttr",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CBufferAttr* self = (CBufferAttr*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CBufferAttr(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBufferAttr");
    tolua_cclass(tolua_S,"CBufferAttr","CBufferAttr","CDetailAttrBase<int, 49>",nullptr);

    tolua_beginmodule(tolua_S,"CBufferAttr");
        tolua_function(tolua_S,"reset",lua_mapserver_CBufferAttr_reset);
        tolua_function(tolua_S,"toString",lua_mapserver_CBufferAttr_toString);
        tolua_function(tolua_S,"resetBase",lua_mapserver_CBufferAttr_resetBase);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CBufferAttr).name();
    g_luaType[typeName] = "CBufferAttr";
    g_typeCast["CBufferAttr"] = "CBufferAttr";
    return 1;
}

static int lua_mapserver_ServerPwdInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ServerPwdInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ServerPwdInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ServerPwdInfo* self = (ServerPwdInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ServerPwdInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ServerPwdInfo");
    tolua_cclass(tolua_S,"ServerPwdInfo","ServerPwdInfo","",nullptr);

    tolua_beginmodule(tolua_S,"ServerPwdInfo");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ServerPwdInfo).name();
    g_luaType[typeName] = "ServerPwdInfo";
    g_typeCast["ServerPwdInfo"] = "ServerPwdInfo";
    return 1;
}

static int lua_mapserver_SceneData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (SceneData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"SceneData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        SceneData* self = (SceneData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_SceneData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"SceneData");
    tolua_cclass(tolua_S,"SceneData","SceneData","",nullptr);

    tolua_beginmodule(tolua_S,"SceneData");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(SceneData).name();
    g_luaType[typeName] = "SceneData";
    g_typeCast["SceneData"] = "SceneData";
    return 1;
}

static int lua_mapserver_ChangeLineWait_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ChangeLineWait)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ChangeLineWait",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ChangeLineWait* self = (ChangeLineWait*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ChangeLineWait(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ChangeLineWait");
    tolua_cclass(tolua_S,"ChangeLineWait","ChangeLineWait","",nullptr);

    tolua_beginmodule(tolua_S,"ChangeLineWait");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ChangeLineWait).name();
    g_luaType[typeName] = "ChangeLineWait";
    g_typeCast["ChangeLineWait"] = "ChangeLineWait";
    return 1;
}

static int lua_mapserver_LoadWaitEnter_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (LoadWaitEnter)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"LoadWaitEnter",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        LoadWaitEnter* self = (LoadWaitEnter*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_LoadWaitEnter(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"LoadWaitEnter");
    tolua_cclass(tolua_S,"LoadWaitEnter","LoadWaitEnter","",nullptr);

    tolua_beginmodule(tolua_S,"LoadWaitEnter");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(LoadWaitEnter).name();
    g_luaType[typeName] = "LoadWaitEnter";
    g_typeCast["LoadWaitEnter"] = "LoadWaitEnter";
    return 1;
}

static int lua_mapserver_RoleSceneRecord_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (RoleSceneRecord)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"RoleSceneRecord",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        RoleSceneRecord* self = (RoleSceneRecord*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_RoleSceneRecord(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"RoleSceneRecord");
    tolua_cclass(tolua_S,"RoleSceneRecord","RoleSceneRecord","",nullptr);

    tolua_beginmodule(tolua_S,"RoleSceneRecord");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(RoleSceneRecord).name();
    g_luaType[typeName] = "RoleSceneRecord";
    g_typeCast["RoleSceneRecord"] = "RoleSceneRecord";
    return 1;
}

static int lua_mapserver_LoadRoleData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (LoadRoleData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"LoadRoleData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        LoadRoleData* self = (LoadRoleData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_LoadRoleData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"LoadRoleData");
    tolua_cclass(tolua_S,"LoadRoleData","LoadRoleData","",nullptr);

    tolua_beginmodule(tolua_S,"LoadRoleData");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(LoadRoleData).name();
    g_luaType[typeName] = "LoadRoleData";
    g_typeCast["LoadRoleData"] = "LoadRoleData";
    return 1;
}

static int lua_mapserver_MapServerUpdate_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MapServerUpdate)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MapServerUpdate",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MapServerUpdate* self = (MapServerUpdate*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MapServerUpdate(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MapServerUpdate");
    tolua_cclass(tolua_S,"MapServerUpdate","MapServerUpdate","",nullptr);

    tolua_beginmodule(tolua_S,"MapServerUpdate");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MapServerUpdate).name();
    g_luaType[typeName] = "MapServerUpdate";
    g_typeCast["MapServerUpdate"] = "MapServerUpdate";
    return 1;
}

static int lua_mapserver_BuffImpact_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (BuffImpact)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"BuffImpact",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        BuffImpact* self = (BuffImpact*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_BuffImpact(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"BuffImpact");
    tolua_cclass(tolua_S,"BuffImpact","BuffImpact","",nullptr);

    tolua_beginmodule(tolua_S,"BuffImpact");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(BuffImpact).name();
    g_luaType[typeName] = "BuffImpact";
    g_typeCast["BuffImpact"] = "BuffImpact";
    return 1;
}

int lua_mapserver_AttackorImpact_isInvalid(lua_State* tolua_S)
{
    int argc = 0;
    AttackorImpact* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AttackorImpact",0,&tolua_err)) goto tolua_lerror;
    cobj = (AttackorImpact*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AttackorImpact_isInvalid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isInvalid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("AttackorImpact:isInvalid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AttackorImpact_isInvalid'.",&tolua_err);
	return 0;
}
int lua_mapserver_AttackorImpact_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    AttackorImpact* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AttackorImpact",0,&tolua_err)) goto tolua_lerror;
    cobj = (AttackorImpact*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AttackorImpact_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("AttackorImpact:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AttackorImpact_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_AttackorImpact_toString(lua_State* tolua_S)
{
    int argc = 0;
    AttackorImpact* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AttackorImpact",0,&tolua_err)) goto tolua_lerror;
    cobj = (AttackorImpact*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AttackorImpact_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("AttackorImpact:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AttackorImpact_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_AttackorImpact_constructor(lua_State* tolua_S)
{
    int argc = 0;
    AttackorImpact* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            const BuffImpact* arg0;
            ok &= luaval_to_object<const BuffImpact>(tolua_S, 2, "BuffImpact", &arg0, "AttackorImpact:AttackorImpact");

            if (!ok) { break; }
            cobj = new AttackorImpact(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"AttackorImpact");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new AttackorImpact();
            tolua_pushusertype(tolua_S,(void*)cobj,"AttackorImpact");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("AttackorImpact:AttackorImpact has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_AttackorImpact_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (AttackorImpact)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"AttackorImpact",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        AttackorImpact* self = (AttackorImpact*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_AttackorImpact(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"AttackorImpact");
    tolua_cclass(tolua_S,"AttackorImpact","AttackorImpact","",lua_mapserver_AttackorImpact_finalize);

    tolua_beginmodule(tolua_S,"AttackorImpact");
        tolua_function(tolua_S,"new",lua_mapserver_AttackorImpact_constructor);
        tolua_function(tolua_S,"isInvalid",lua_mapserver_AttackorImpact_isInvalid);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_AttackorImpact_cleanUp);
        tolua_function(tolua_S,"toString",lua_mapserver_AttackorImpact_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(AttackorImpact).name();
    g_luaType[typeName] = "AttackorImpact";
    g_typeCast["AttackorImpact"] = "AttackorImpact";
    return 1;
}

static int lua_mapserver_OwnSkill_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (OwnSkill)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"OwnSkill",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        OwnSkill* self = (OwnSkill*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_OwnSkill(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"OwnSkill");
    tolua_cclass(tolua_S,"OwnSkill","OwnSkill","",nullptr);

    tolua_beginmodule(tolua_S,"OwnSkill");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(OwnSkill).name();
    g_luaType[typeName] = "OwnSkill";
    g_typeCast["OwnSkill"] = "OwnSkill";
    return 1;
}

static int lua_mapserver_ExtUseSkill_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ExtUseSkill)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ExtUseSkill",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ExtUseSkill* self = (ExtUseSkill*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ExtUseSkill(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ExtUseSkill");
    tolua_cclass(tolua_S,"ExtUseSkill","ExtUseSkill","",nullptr);

    tolua_beginmodule(tolua_S,"ExtUseSkill");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ExtUseSkill).name();
    g_luaType[typeName] = "ExtUseSkill";
    g_typeCast["ExtUseSkill"] = "ExtUseSkill";
    return 1;
}

static int lua_mapserver_ItemIDNum_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ItemIDNum)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ItemIDNum",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ItemIDNum* self = (ItemIDNum*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ItemIDNum(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ItemIDNum");
    tolua_cclass(tolua_S,"ItemIDNum","ItemIDNum","",nullptr);

    tolua_beginmodule(tolua_S,"ItemIDNum");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ItemIDNum).name();
    g_luaType[typeName] = "ItemIDNum";
    g_typeCast["ItemIDNum"] = "ItemIDNum";
    return 1;
}

static int lua_mapserver_MapIDRangePos_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MapIDRangePos)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MapIDRangePos",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MapIDRangePos* self = (MapIDRangePos*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MapIDRangePos(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MapIDRangePos");
    tolua_cclass(tolua_S,"MapIDRangePos","MapIDRangePos","",nullptr);

    tolua_beginmodule(tolua_S,"MapIDRangePos");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MapIDRangePos).name();
    g_luaType[typeName] = "MapIDRangePos";
    g_typeCast["MapIDRangePos"] = "MapIDRangePos";
    return 1;
}

static int lua_mapserver_MapRangePos_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MapRangePos)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MapRangePos",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MapRangePos* self = (MapRangePos*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MapRangePos(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MapRangePos");
    tolua_cclass(tolua_S,"MapRangePos","MapRangePos","",nullptr);

    tolua_beginmodule(tolua_S,"MapRangePos");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MapRangePos).name();
    g_luaType[typeName] = "MapRangePos";
    g_typeCast["MapRangePos"] = "MapRangePos";
    return 1;
}

static int lua_mapserver_MapIDPos_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MapIDPos)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MapIDPos",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MapIDPos* self = (MapIDPos*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MapIDPos(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MapIDPos");
    tolua_cclass(tolua_S,"MapIDPos","MapIDPos","",nullptr);

    tolua_beginmodule(tolua_S,"MapIDPos");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MapIDPos).name();
    g_luaType[typeName] = "MapIDPos";
    g_typeCast["MapIDPos"] = "MapIDPos";
    return 1;
}

static int lua_mapserver_ZoneServer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ZoneServer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ZoneServer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ZoneServer* self = (ZoneServer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ZoneServer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ZoneServer");
    tolua_cclass(tolua_S,"ZoneServer","ZoneServer","IStreamableAll",nullptr);

    tolua_beginmodule(tolua_S,"ZoneServer");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ZoneServer).name();
    g_luaType[typeName] = "ZoneServer";
    g_typeCast["ZoneServer"] = "ZoneServer";
    return 1;
}

static int lua_mapserver_OwnerBuffer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (OwnerBuffer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"OwnerBuffer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        OwnerBuffer* self = (OwnerBuffer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_OwnerBuffer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"OwnerBuffer");
    tolua_cclass(tolua_S,"OwnerBuffer","OwnerBuffer","",nullptr);

    tolua_beginmodule(tolua_S,"OwnerBuffer");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(OwnerBuffer).name();
    g_luaType[typeName] = "OwnerBuffer";
    g_typeCast["OwnerBuffer"] = "OwnerBuffer";
    return 1;
}

int lua_mapserver_LimitServerIDInfo_clean(lua_State* tolua_S)
{
    int argc = 0;
    LimitServerIDInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"LimitServerIDInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (LimitServerIDInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_LimitServerIDInfo_clean'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->clean();
        return 0;
    }

    gxError("LimitServerIDInfo:clean has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_LimitServerIDInfo_clean'.",&tolua_err);
	return 0;
}
int lua_mapserver_LimitServerIDInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    LimitServerIDInfo* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new LimitServerIDInfo();
        tolua_pushusertype(tolua_S,(void*)cobj,"LimitServerIDInfo");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("LimitServerIDInfo:LimitServerIDInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_LimitServerIDInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (LimitServerIDInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"LimitServerIDInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        LimitServerIDInfo* self = (LimitServerIDInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_LimitServerIDInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"LimitServerIDInfo");
    tolua_cclass(tolua_S,"LimitServerIDInfo","LimitServerIDInfo","",lua_mapserver_LimitServerIDInfo_finalize);

    tolua_beginmodule(tolua_S,"LimitServerIDInfo");
        tolua_function(tolua_S,"new",lua_mapserver_LimitServerIDInfo_constructor);
        tolua_function(tolua_S,"clean",lua_mapserver_LimitServerIDInfo_clean);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(LimitServerIDInfo).name();
    g_luaType[typeName] = "LimitServerIDInfo";
    g_typeCast["LimitServerIDInfo"] = "LimitServerIDInfo";
    return 1;
}

int lua_mapserver_LimitAccountInfo_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    LimitAccountInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"LimitAccountInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (LimitAccountInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_LimitAccountInfo_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("LimitAccountInfo:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_LimitAccountInfo_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_LimitAccountInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    LimitAccountInfo* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new LimitAccountInfo();
        tolua_pushusertype(tolua_S,(void*)cobj,"LimitAccountInfo");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("LimitAccountInfo:LimitAccountInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_LimitAccountInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (LimitAccountInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"LimitAccountInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        LimitAccountInfo* self = (LimitAccountInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_LimitAccountInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"LimitAccountInfo");
    tolua_cclass(tolua_S,"LimitAccountInfo","LimitAccountInfo","",lua_mapserver_LimitAccountInfo_finalize);

    tolua_beginmodule(tolua_S,"LimitAccountInfo");
        tolua_function(tolua_S,"new",lua_mapserver_LimitAccountInfo_constructor);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_LimitAccountInfo_cleanUp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(LimitAccountInfo).name();
    g_luaType[typeName] = "LimitAccountInfo";
    g_typeCast["LimitAccountInfo"] = "LimitAccountInfo";
    return 1;
}

int lua_mapserver_LimitChatInfo_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    LimitChatInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"LimitChatInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (LimitChatInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_LimitChatInfo_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("LimitChatInfo:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_LimitChatInfo_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_LimitChatInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    LimitChatInfo* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new LimitChatInfo();
        tolua_pushusertype(tolua_S,(void*)cobj,"LimitChatInfo");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("LimitChatInfo:LimitChatInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_LimitChatInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (LimitChatInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"LimitChatInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        LimitChatInfo* self = (LimitChatInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_LimitChatInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"LimitChatInfo");
    tolua_cclass(tolua_S,"LimitChatInfo","LimitChatInfo","",lua_mapserver_LimitChatInfo_finalize);

    tolua_beginmodule(tolua_S,"LimitChatInfo");
        tolua_function(tolua_S,"new",lua_mapserver_LimitChatInfo_constructor);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_LimitChatInfo_cleanUp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(LimitChatInfo).name();
    g_luaType[typeName] = "LimitChatInfo";
    g_typeCast["LimitChatInfo"] = "LimitChatInfo";
    return 1;
}

int lua_mapserver_LimitAccount_clean(lua_State* tolua_S)
{
    int argc = 0;
    LimitAccount* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"LimitAccount",0,&tolua_err)) goto tolua_lerror;
    cobj = (LimitAccount*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_LimitAccount_clean'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->clean();
        return 0;
    }

    gxError("LimitAccount:clean has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_LimitAccount_clean'.",&tolua_err);
	return 0;
}
int lua_mapserver_LimitAccount_constructor(lua_State* tolua_S)
{
    int argc = 0;
    LimitAccount* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new LimitAccount();
        tolua_pushusertype(tolua_S,(void*)cobj,"LimitAccount");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("LimitAccount:LimitAccount has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_LimitAccount_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (LimitAccount)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"LimitAccount",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        LimitAccount* self = (LimitAccount*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_LimitAccount(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"LimitAccount");
    tolua_cclass(tolua_S,"LimitAccount","LimitAccount","",lua_mapserver_LimitAccount_finalize);

    tolua_beginmodule(tolua_S,"LimitAccount");
        tolua_function(tolua_S,"new",lua_mapserver_LimitAccount_constructor);
        tolua_function(tolua_S,"clean",lua_mapserver_LimitAccount_clean);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(LimitAccount).name();
    g_luaType[typeName] = "LimitAccount";
    g_typeCast["LimitAccount"] = "LimitAccount";
    return 1;
}

int lua_mapserver_LimitChat_clean(lua_State* tolua_S)
{
    int argc = 0;
    LimitChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"LimitChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (LimitChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_LimitChat_clean'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->clean();
        return 0;
    }

    gxError("LimitChat:clean has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_LimitChat_clean'.",&tolua_err);
	return 0;
}
int lua_mapserver_LimitChat_constructor(lua_State* tolua_S)
{
    int argc = 0;
    LimitChat* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new LimitChat();
        tolua_pushusertype(tolua_S,(void*)cobj,"LimitChat");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("LimitChat:LimitChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_LimitChat_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (LimitChat)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"LimitChat",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        LimitChat* self = (LimitChat*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_LimitChat(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"LimitChat");
    tolua_cclass(tolua_S,"LimitChat","LimitChat","",lua_mapserver_LimitChat_finalize);

    tolua_beginmodule(tolua_S,"LimitChat");
        tolua_function(tolua_S,"new",lua_mapserver_LimitChat_constructor);
        tolua_function(tolua_S,"clean",lua_mapserver_LimitChat_clean);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(LimitChat).name();
    g_luaType[typeName] = "LimitChat";
    g_typeCast["LimitChat"] = "LimitChat";
    return 1;
}

int lua_mapserver_LimitAccountDB_clean(lua_State* tolua_S)
{
    int argc = 0;
    LimitAccountDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"LimitAccountDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (LimitAccountDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_LimitAccountDB_clean'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->clean();
        return 0;
    }

    gxError("LimitAccountDB:clean has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_LimitAccountDB_clean'.",&tolua_err);
	return 0;
}
int lua_mapserver_LimitAccountDB_constructor(lua_State* tolua_S)
{
    int argc = 0;
    LimitAccountDB* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new LimitAccountDB();
        tolua_pushusertype(tolua_S,(void*)cobj,"LimitAccountDB");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("LimitAccountDB:LimitAccountDB has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_LimitAccountDB_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (LimitAccountDB)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"LimitAccountDB",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        LimitAccountDB* self = (LimitAccountDB*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_LimitAccountDB(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"LimitAccountDB");
    tolua_cclass(tolua_S,"LimitAccountDB","LimitAccountDB","",lua_mapserver_LimitAccountDB_finalize);

    tolua_beginmodule(tolua_S,"LimitAccountDB");
        tolua_function(tolua_S,"new",lua_mapserver_LimitAccountDB_constructor);
        tolua_function(tolua_S,"clean",lua_mapserver_LimitAccountDB_clean);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(LimitAccountDB).name();
    g_luaType[typeName] = "LimitAccountDB";
    g_typeCast["LimitAccountDB"] = "LimitAccountDB";
    return 1;
}

int lua_mapserver_LimitChatDB_clean(lua_State* tolua_S)
{
    int argc = 0;
    LimitChatDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"LimitChatDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (LimitChatDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_LimitChatDB_clean'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->clean();
        return 0;
    }

    gxError("LimitChatDB:clean has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_LimitChatDB_clean'.",&tolua_err);
	return 0;
}
int lua_mapserver_LimitChatDB_constructor(lua_State* tolua_S)
{
    int argc = 0;
    LimitChatDB* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new LimitChatDB();
        tolua_pushusertype(tolua_S,(void*)cobj,"LimitChatDB");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("LimitChatDB:LimitChatDB has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_LimitChatDB_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (LimitChatDB)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"LimitChatDB",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        LimitChatDB* self = (LimitChatDB*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_LimitChatDB(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"LimitChatDB");
    tolua_cclass(tolua_S,"LimitChatDB","LimitChatDB","",lua_mapserver_LimitChatDB_finalize);

    tolua_beginmodule(tolua_S,"LimitChatDB");
        tolua_function(tolua_S,"new",lua_mapserver_LimitChatDB_constructor);
        tolua_function(tolua_S,"clean",lua_mapserver_LimitChatDB_clean);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(LimitChatDB).name();
    g_luaType[typeName] = "LimitChatDB";
    g_typeCast["LimitChatDB"] = "LimitChatDB";
    return 1;
}

static int lua_mapserver_CConfigTbl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CConfigTbl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CConfigTbl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CConfigTbl* self = (CConfigTbl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CConfigTbl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CConfigTbl");
    tolua_cclass(tolua_S,"CConfigTbl","CConfigTbl","",nullptr);

    tolua_beginmodule(tolua_S,"CConfigTbl");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CConfigTbl).name();
    g_luaType[typeName] = "CConfigTbl";
    g_typeCast["CConfigTbl"] = "CConfigTbl";
    return 1;
}

int lua_mapserver_UrlDownFile_constructor(lua_State* tolua_S)
{
    int argc = 0;
    UrlDownFile* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new UrlDownFile();
        tolua_pushusertype(tolua_S,(void*)cobj,"UrlDownFile");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("UrlDownFile:UrlDownFile has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_UrlDownFile_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (UrlDownFile)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"UrlDownFile",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        UrlDownFile* self = (UrlDownFile*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_UrlDownFile(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"UrlDownFile");
    tolua_cclass(tolua_S,"UrlDownFile","UrlDownFile","",lua_mapserver_UrlDownFile_finalize);

    tolua_beginmodule(tolua_S,"UrlDownFile");
        tolua_function(tolua_S,"new",lua_mapserver_UrlDownFile_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(UrlDownFile).name();
    g_luaType[typeName] = "UrlDownFile";
    g_typeCast["UrlDownFile"] = "UrlDownFile";
    return 1;
}

int lua_mapserver_CCconfigLoaderParam_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CCconfigLoaderParam* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CCconfigLoaderParam();
        tolua_pushusertype(tolua_S,(void*)cobj,"CCconfigLoaderParam");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CCconfigLoaderParam:CCconfigLoaderParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CCconfigLoaderParam_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCconfigLoaderParam)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCconfigLoaderParam",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CCconfigLoaderParam* self = (CCconfigLoaderParam*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CCconfigLoaderParam(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCconfigLoaderParam");
    tolua_cclass(tolua_S,"CCconfigLoaderParam","CCconfigLoaderParam","",lua_mapserver_CCconfigLoaderParam_finalize);

    tolua_beginmodule(tolua_S,"CCconfigLoaderParam");
        tolua_function(tolua_S,"new",lua_mapserver_CCconfigLoaderParam_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CCconfigLoaderParam).name();
    g_luaType[typeName] = "CCconfigLoaderParam";
    g_typeCast["CCconfigLoaderParam"] = "CCconfigLoaderParam";
    return 1;
}

int lua_mapserver_CConfigLoaderBase_checkConfig(lua_State* tolua_S)
{
    int argc = 0;
    CConfigLoaderBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConfigLoaderBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CConfigLoaderBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CConfigLoaderBase_checkConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->checkConfig();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CConfigLoaderBase:checkConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CConfigLoaderBase_checkConfig'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CConfigLoaderBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CConfigLoaderBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CConfigLoaderBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CConfigLoaderBase* self = (CConfigLoaderBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CConfigLoaderBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CConfigLoaderBase");
    tolua_cclass(tolua_S,"CConfigLoaderBase","CConfigLoaderBase","",nullptr);

    tolua_beginmodule(tolua_S,"CConfigLoaderBase");
        tolua_function(tolua_S,"checkConfig",lua_mapserver_CConfigLoaderBase_checkConfig);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CConfigLoaderBase).name();
    g_luaType[typeName] = "CConfigLoaderBase";
    g_typeCast["CConfigLoaderBase"] = "CConfigLoaderBase";
    return 1;
}

int lua_mapserver_CAnnouncementTbl_isPassCond(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAnnouncementTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAnnouncementTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAnnouncementTbl_isPassCond'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CAnnouncementTbl:isPassCond");
        if(!ok)
            return 0;
        bool ret = cobj->isPassCond(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CAnnouncementTbl:isPassCond has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementTbl_isPassCond'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAnnouncementTbl_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAnnouncementTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAnnouncementTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAnnouncementTbl_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CAnnouncementTbl:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementTbl_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAnnouncementTbl_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAnnouncementTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAnnouncementTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAnnouncementTbl_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CAnnouncementTbl:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementTbl_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAnnouncementTbl_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAnnouncementTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAnnouncementTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAnnouncementTbl_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CAnnouncementTbl:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementTbl_getKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAnnouncementTbl_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAnnouncementTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAnnouncementTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAnnouncementTbl_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CAnnouncementTbl:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CAnnouncementTbl:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementTbl_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAnnouncementTbl_toString(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAnnouncementTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAnnouncementTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAnnouncementTbl_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CAnnouncementTbl:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementTbl_toString'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CAnnouncementTbl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CAnnouncementTbl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CAnnouncementTbl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CAnnouncementTbl* self = (CAnnouncementTbl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CAnnouncementTbl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CAnnouncementTbl");
    tolua_cclass(tolua_S,"CAnnouncementTbl","CAnnouncementTbl","CConfigTbl",nullptr);

    tolua_beginmodule(tolua_S,"CAnnouncementTbl");
        tolua_function(tolua_S,"isPassCond",lua_mapserver_CAnnouncementTbl_isPassCond);
        tolua_function(tolua_S,"isKey",lua_mapserver_CAnnouncementTbl_isKey);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CAnnouncementTbl_keyToString);
        tolua_function(tolua_S,"getKey",lua_mapserver_CAnnouncementTbl_getKey);
        tolua_function(tolua_S,"setKey",lua_mapserver_CAnnouncementTbl_setKey);
        tolua_function(tolua_S,"toString",lua_mapserver_CAnnouncementTbl_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CAnnouncementTbl).name();
    g_luaType[typeName] = "CAnnouncementTbl";
    g_typeCast["CAnnouncementTbl"] = "CAnnouncementTbl";
    return 1;
}

int lua_mapserver_CAnnouncementTblLoader_getPassCondID(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAnnouncementTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAnnouncementTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAnnouncementTblLoader_getPassCondID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        int arg0;
        int arg1;
        char arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CAnnouncementTblLoader:getPassCondID");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CAnnouncementTblLoader:getPassCondID");

        ok &= luaval_to_sint8(tolua_S, 4,(sint8*)&arg2, "CAnnouncementTblLoader:getPassCondID");
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPassCondID(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CAnnouncementTblLoader:getPassCondID has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementTblLoader_getPassCondID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAnnouncementTblLoader_findByKey(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAnnouncementTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAnnouncementTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAnnouncementTblLoader_findByKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CAnnouncementTblLoader:findByKey");
        if(!ok)
            return 0;
        CAnnouncementTbl* ret = cobj->findByKey(arg0);
        object_to_luaval<CAnnouncementTbl>(tolua_S, "CAnnouncementTbl",(CAnnouncementTbl*)ret);
        return 1;
    }

    gxError("CAnnouncementTblLoader:findByKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementTblLoader_findByKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAnnouncementTblLoader_readRow(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAnnouncementTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAnnouncementTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAnnouncementTblLoader_readRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        TiXmlElement* arg0;
        int arg1;
        CAnnouncementTbl* arg2;

        ok &= luaval_to_object<TiXmlElement>(tolua_S, 2, "TiXmlElement", &arg0, "CAnnouncementTblLoader:readRow");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CAnnouncementTblLoader:readRow");

        ok &= luaval_to_object<CAnnouncementTbl>(tolua_S, 4, "CAnnouncementTbl", &arg2, "CAnnouncementTblLoader:readRow");
        if(!ok)
            return 0;
        bool ret = cobj->readRow(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CAnnouncementTblLoader:readRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementTblLoader_readRow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAnnouncementTblLoader_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CAnnouncementTblLoader",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CAnnouncementTblLoader* ret = CAnnouncementTblLoader::GetPtr();
        object_to_luaval<CAnnouncementTblLoader>(tolua_S, "CAnnouncementTblLoader",(CAnnouncementTblLoader*)ret);
        return 1;
    }
    gxError("CAnnouncementTblLoader:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementTblLoader_GetPtr'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CAnnouncementTblLoader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CAnnouncementTblLoader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CAnnouncementTblLoader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CAnnouncementTblLoader* self = (CAnnouncementTblLoader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CAnnouncementTblLoader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CAnnouncementTblLoader");
    tolua_cclass(tolua_S,"CAnnouncementTblLoader","CAnnouncementTblLoader","CConfigLoader<CAnnouncementTblLoader, CAnnouncementTbl>",nullptr);

    tolua_beginmodule(tolua_S,"CAnnouncementTblLoader");
        tolua_function(tolua_S,"getPassCondID",lua_mapserver_CAnnouncementTblLoader_getPassCondID);
        tolua_function(tolua_S,"findByKey",lua_mapserver_CAnnouncementTblLoader_findByKey);
        tolua_function(tolua_S,"readRow",lua_mapserver_CAnnouncementTblLoader_readRow);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CAnnouncementTblLoader_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CAnnouncementTblLoader).name();
    g_luaType[typeName] = "CAnnouncementTblLoader";
    g_typeCast["CAnnouncementTblLoader"] = "CAnnouncementTblLoader";
    return 1;
}

int lua_mapserver_CItemConfigTbl_canSell(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_canSell'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canSell();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemConfigTbl:canSell has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_canSell'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_isSexUnlimit(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_isSexUnlimit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isSexUnlimit();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemConfigTbl:isSexUnlimit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_isSexUnlimit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_getSellPrice(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_getSellPrice'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CItemConfigTbl:getSellPrice");
        if(!ok)
            return 0;
        int ret = cobj->getSellPrice(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemConfigTbl:getSellPrice has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_getSellPrice'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemConfigTbl:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_isTimeUnlimit(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_isTimeUnlimit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isTimeUnlimit();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemConfigTbl:isTimeUnlimit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_isTimeUnlimit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CItemConfigTbl:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemConfigTbl:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_getKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_isTask(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_isTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isTask();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemConfigTbl:isTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_isTask'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_isBind(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_isBind'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isBind();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemConfigTbl:isBind has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_isBind'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_toString(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CItemConfigTbl:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_getIsNeedRecorde(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_getIsNeedRecorde'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getIsNeedRecorde();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemConfigTbl:getIsNeedRecorde has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_getIsNeedRecorde'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_isJobUnlimit(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_isJobUnlimit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isJobUnlimit();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemConfigTbl:isJobUnlimit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_isJobUnlimit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_canDrop(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_canDrop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canDrop();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemConfigTbl:canDrop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_canDrop'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CItemConfigTbl:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CItemConfigTbl:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_getBuyBackPrice(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemConfigTbl_getBuyBackPrice'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CItemConfigTbl:getBuyBackPrice");
        if(!ok)
            return 0;
        int ret = cobj->getBuyBackPrice(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemConfigTbl:getBuyBackPrice has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemConfigTbl_getBuyBackPrice'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemConfigTbl_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CItemConfigTbl* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CItemConfigTbl();
        tolua_pushusertype(tolua_S,(void*)cobj,"CItemConfigTbl");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CItemConfigTbl:CItemConfigTbl has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CItemConfigTbl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CItemConfigTbl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CItemConfigTbl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CItemConfigTbl* self = (CItemConfigTbl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CItemConfigTbl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CItemConfigTbl");
    tolua_cclass(tolua_S,"CItemConfigTbl","CItemConfigTbl","CConfigTbl",lua_mapserver_CItemConfigTbl_finalize);

    tolua_beginmodule(tolua_S,"CItemConfigTbl");
        tolua_function(tolua_S,"new",lua_mapserver_CItemConfigTbl_constructor);
        tolua_function(tolua_S,"canSell",lua_mapserver_CItemConfigTbl_canSell);
        tolua_function(tolua_S,"isSexUnlimit",lua_mapserver_CItemConfigTbl_isSexUnlimit);
        tolua_function(tolua_S,"getSellPrice",lua_mapserver_CItemConfigTbl_getSellPrice);
        tolua_function(tolua_S,"isKey",lua_mapserver_CItemConfigTbl_isKey);
        tolua_function(tolua_S,"isTimeUnlimit",lua_mapserver_CItemConfigTbl_isTimeUnlimit);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CItemConfigTbl_keyToString);
        tolua_function(tolua_S,"getKey",lua_mapserver_CItemConfigTbl_getKey);
        tolua_function(tolua_S,"isTask",lua_mapserver_CItemConfigTbl_isTask);
        tolua_function(tolua_S,"isBind",lua_mapserver_CItemConfigTbl_isBind);
        tolua_function(tolua_S,"toString",lua_mapserver_CItemConfigTbl_toString);
        tolua_function(tolua_S,"getIsNeedRecorde",lua_mapserver_CItemConfigTbl_getIsNeedRecorde);
        tolua_function(tolua_S,"isJobUnlimit",lua_mapserver_CItemConfigTbl_isJobUnlimit);
        tolua_function(tolua_S,"canDrop",lua_mapserver_CItemConfigTbl_canDrop);
        tolua_function(tolua_S,"setKey",lua_mapserver_CItemConfigTbl_setKey);
        tolua_function(tolua_S,"getBuyBackPrice",lua_mapserver_CItemConfigTbl_getBuyBackPrice);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CItemConfigTbl).name();
    g_luaType[typeName] = "CItemConfigTbl";
    g_typeCast["CItemConfigTbl"] = "CItemConfigTbl";
    return 1;
}

int lua_mapserver_CItemTblLoader_getConfigByQuality(lua_State* tolua_S)
{
    int argc = 0;
    CItemTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemTblLoader_getConfigByQuality'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        EItemType arg0;
        unsigned char arg1;
        unsigned char arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemTblLoader:getConfigByQuality");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemTblLoader:getConfigByQuality");

        ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CItemTblLoader:getConfigByQuality");
        if(!ok)
            return 0;
        CItemConfigTbl* ret = cobj->getConfigByQuality(arg0, arg1, arg2);
        object_to_luaval<CItemConfigTbl>(tolua_S, "CItemConfigTbl",(CItemConfigTbl*)ret);
        return 1;
    }

    gxError("CItemTblLoader:getConfigByQuality has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemTblLoader_getConfigByQuality'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemTblLoader_getConfig(lua_State* tolua_S)
{
    int argc = 0;
    CItemTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemTblLoader_getConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EItemType arg0;
        unsigned char arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemTblLoader:getConfig");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemTblLoader:getConfig");
        if(!ok)
            return 0;
        CItemConfigTbl* ret = cobj->getConfig(arg0, arg1);
        object_to_luaval<CItemConfigTbl>(tolua_S, "CItemConfigTbl",(CItemConfigTbl*)ret);
        return 1;
    }

    gxError("CItemTblLoader:getConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemTblLoader_getConfig'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemTblLoader_findByKey(lua_State* tolua_S)
{
    int argc = 0;
    CItemTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemTblLoader_findByKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CItemTblLoader:findByKey");
        if(!ok)
            return 0;
        CItemConfigTbl* ret = cobj->findByKey(arg0);
        object_to_luaval<CItemConfigTbl>(tolua_S, "CItemConfigTbl",(CItemConfigTbl*)ret);
        return 1;
    }

    gxError("CItemTblLoader:findByKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemTblLoader_findByKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemTblLoader_readRow(lua_State* tolua_S)
{
    int argc = 0;
    CItemTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemTblLoader_readRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        TiXmlElement* arg0;
        int arg1;
        CItemConfigTbl* arg2;

        ok &= luaval_to_object<TiXmlElement>(tolua_S, 2, "TiXmlElement", &arg0, "CItemTblLoader:readRow");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CItemTblLoader:readRow");

        ok &= luaval_to_object<CItemConfigTbl>(tolua_S, 4, "CItemConfigTbl", &arg2, "CItemTblLoader:readRow");
        if(!ok)
            return 0;
        bool ret = cobj->readRow(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemTblLoader:readRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemTblLoader_readRow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemTblLoader_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItemTblLoader",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CItemTblLoader* ret = CItemTblLoader::GetPtr();
        object_to_luaval<CItemTblLoader>(tolua_S, "CItemTblLoader",(CItemTblLoader*)ret);
        return 1;
    }
    gxError("CItemTblLoader:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemTblLoader_GetPtr'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CItemTblLoader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CItemTblLoader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CItemTblLoader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CItemTblLoader* self = (CItemTblLoader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CItemTblLoader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CItemTblLoader");
    tolua_cclass(tolua_S,"CItemTblLoader","CItemTblLoader","CConfigLoader<CItemTblLoader, CItemConfigTbl>",nullptr);

    tolua_beginmodule(tolua_S,"CItemTblLoader");
        tolua_function(tolua_S,"getConfigByQuality",lua_mapserver_CItemTblLoader_getConfigByQuality);
        tolua_function(tolua_S,"getConfig",lua_mapserver_CItemTblLoader_getConfig);
        tolua_function(tolua_S,"findByKey",lua_mapserver_CItemTblLoader_findByKey);
        tolua_function(tolua_S,"readRow",lua_mapserver_CItemTblLoader_readRow);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CItemTblLoader_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CItemTblLoader).name();
    g_luaType[typeName] = "CItemTblLoader";
    g_typeCast["CItemTblLoader"] = "CItemTblLoader";
    return 1;
}

int lua_mapserver_CMsgBase_setRole(lua_State* tolua_S)
{
    int argc = 0;
    CMsgBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMsgBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMsgBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMsgBase_setRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CRole* arg0;

        ok &= luaval_to_object<CRole>(tolua_S, 2, "CRole", &arg0, "CMsgBase:setRole");
        if(!ok)
            return 0;
        cobj->setRole(arg0);
        return 0;
    }

    gxError("CMsgBase:setRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMsgBase_setRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMsgBase_getRole(lua_State* tolua_S)
{
    int argc = 0;
    CMsgBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMsgBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMsgBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMsgBase_getRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CRole* ret = cobj->getRole();
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CMsgBase:getRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMsgBase_getRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMsgBase_handleCallBack(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMsgBase",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        EGameRetCode arg0;
        CRole* arg1;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMsgBase:handleCallBack");
        ok &= luaval_to_object<CRole>(tolua_S, 3, "CRole", &arg1, "CMsgBase:handleCallBack");
        if(!ok)
            return 0;
        CMsgBase::handleCallBack(arg0, arg1);
        return 0;
    }
    gxError("CMsgBase:handleCallBack has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMsgBase_handleCallBack'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMsgBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMsgBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMsgBase();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMsgBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMsgBase:CMsgBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMsgBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMsgBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMsgBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMsgBase* self = (CMsgBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMsgBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMsgBase");
    tolua_cclass(tolua_S,"CMsgBase","CMsgBase","",lua_mapserver_CMsgBase_finalize);

    tolua_beginmodule(tolua_S,"CMsgBase");
        tolua_function(tolua_S,"new",lua_mapserver_CMsgBase_constructor);
        tolua_function(tolua_S,"setRole",lua_mapserver_CMsgBase_setRole);
        tolua_function(tolua_S,"getRole",lua_mapserver_CMsgBase_getRole);
        tolua_function(tolua_S,"handleCallBack", lua_mapserver_CMsgBase_handleCallBack);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMsgBase).name();
    g_luaType[typeName] = "CMsgBase";
    g_typeCast["CMsgBase"] = "CMsgBase";
    return 1;
}

int lua_mapserver_CGameMoudle_onLoad(lua_State* tolua_S)
{
    int argc = 0;
    CGameMoudle* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameMoudle",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameMoudle*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameMoudle_onLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onLoad();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameMoudle:onLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMoudle_onLoad'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameMoudle_onSave(lua_State* tolua_S)
{
    int argc = 0;
    CGameMoudle* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameMoudle",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameMoudle*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameMoudle_onSave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CGameMoudle:onSave");
        if(!ok)
            return 0;
        cobj->onSave(arg0);
        return 0;
    }

    gxError("CGameMoudle:onSave has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMoudle_onSave'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameMoudle_update(lua_State* tolua_S)
{
    int argc = 0;
    CGameMoudle* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameMoudle",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameMoudle*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameMoudle_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGameMoudle:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CGameMoudle:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMoudle_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameMoudle_init(lua_State* tolua_S)
{
    int argc = 0;
    CGameMoudle* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameMoudle",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameMoudle*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameMoudle_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CGameMoudle:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameMoudle:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMoudle_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameMoudle_getRole(lua_State* tolua_S)
{
    int argc = 0;
    CGameMoudle* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameMoudle",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameMoudle*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameMoudle_getRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CRole* ret = cobj->getRole();
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CGameMoudle:getRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameMoudle_getRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameMoudle_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CGameMoudle* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CGameMoudle();
        tolua_pushusertype(tolua_S,(void*)cobj,"CGameMoudle");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CGameMoudle:CGameMoudle has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CGameMoudle_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGameMoudle)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGameMoudle",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CGameMoudle* self = (CGameMoudle*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CGameMoudle(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGameMoudle");
    tolua_cclass(tolua_S,"CGameMoudle","CGameMoudle","",lua_mapserver_CGameMoudle_finalize);

    tolua_beginmodule(tolua_S,"CGameMoudle");
        tolua_function(tolua_S,"new",lua_mapserver_CGameMoudle_constructor);
        tolua_function(tolua_S,"onLoad",lua_mapserver_CGameMoudle_onLoad);
        tolua_function(tolua_S,"onSave",lua_mapserver_CGameMoudle_onSave);
        tolua_function(tolua_S,"update",lua_mapserver_CGameMoudle_update);
        tolua_function(tolua_S,"init",lua_mapserver_CGameMoudle_init);
        tolua_function(tolua_S,"getRole",lua_mapserver_CGameMoudle_getRole);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CGameMoudle).name();
    g_luaType[typeName] = "CGameMoudle";
    g_typeCast["CGameMoudle"] = "CGameMoudle";
    return 1;
}

int lua_mapserver_CGameRoleModule_onLoad(lua_State* tolua_S)
{
    int argc = 0;
    CGameRoleModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameRoleModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameRoleModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameRoleModule_onLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onLoad();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameRoleModule:onLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameRoleModule_onLoad'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameRoleModule_onSendData(lua_State* tolua_S)
{
    int argc = 0;
    CGameRoleModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameRoleModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameRoleModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameRoleModule_onSendData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onSendData();
        return 0;
    }

    gxError("CGameRoleModule:onSendData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameRoleModule_onSendData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameRoleModule_onSave(lua_State* tolua_S)
{
    int argc = 0;
    CGameRoleModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameRoleModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameRoleModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameRoleModule_onSave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CGameRoleModule:onSave");
        if(!ok)
            return 0;
        cobj->onSave(arg0);
        return 0;
    }

    gxError("CGameRoleModule:onSave has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameRoleModule_onSave'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameRoleModule_update(lua_State* tolua_S)
{
    int argc = 0;
    CGameRoleModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameRoleModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameRoleModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameRoleModule_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGameRoleModule:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CGameRoleModule:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameRoleModule_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameRoleModule_init(lua_State* tolua_S)
{
    int argc = 0;
    CGameRoleModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameRoleModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameRoleModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameRoleModule_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CRole* arg0;

        ok &= luaval_to_object<CRole>(tolua_S, 2, "CRole", &arg0, "CGameRoleModule:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameRoleModule:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameRoleModule_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameRoleModule_getRole(lua_State* tolua_S)
{
    int argc = 0;
    CGameRoleModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameRoleModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameRoleModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameRoleModule_getRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CRole* ret = cobj->getRole();
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CGameRoleModule:getRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameRoleModule_getRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameRoleModule_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CGameRoleModule* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CGameRoleModule();
        tolua_pushusertype(tolua_S,(void*)cobj,"CGameRoleModule");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CGameRoleModule:CGameRoleModule has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CGameRoleModule_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGameRoleModule)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGameRoleModule",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CGameRoleModule* self = (CGameRoleModule*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CGameRoleModule(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGameRoleModule");
    tolua_cclass(tolua_S,"CGameRoleModule","CGameRoleModule","",lua_mapserver_CGameRoleModule_finalize);

    tolua_beginmodule(tolua_S,"CGameRoleModule");
        tolua_function(tolua_S,"new",lua_mapserver_CGameRoleModule_constructor);
        tolua_function(tolua_S,"onLoad",lua_mapserver_CGameRoleModule_onLoad);
        tolua_function(tolua_S,"onSendData",lua_mapserver_CGameRoleModule_onSendData);
        tolua_function(tolua_S,"onSave",lua_mapserver_CGameRoleModule_onSave);
        tolua_function(tolua_S,"update",lua_mapserver_CGameRoleModule_update);
        tolua_function(tolua_S,"init",lua_mapserver_CGameRoleModule_init);
        tolua_function(tolua_S,"getRole",lua_mapserver_CGameRoleModule_getRole);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CGameRoleModule).name();
    g_luaType[typeName] = "CGameRoleModule";
    g_typeCast["CGameRoleModule"] = "CGameRoleModule";
    return 1;
}

static int lua_mapserver_PackHandleAttr_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PackHandleAttr)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PackHandleAttr",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PackHandleAttr* self = (PackHandleAttr*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PackHandleAttr(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PackHandleAttr");
    tolua_cclass(tolua_S,"PackHandleAttr","PackHandleAttr","",nullptr);

    tolua_beginmodule(tolua_S,"PackHandleAttr");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PackHandleAttr).name();
    g_luaType[typeName] = "PackHandleAttr";
    g_typeCast["PackHandleAttr"] = "PackHandleAttr";
    return 1;
}

static int lua_mapserver_SockAttr_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (SockAttr)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"SockAttr",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        SockAttr* self = (SockAttr*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_SockAttr(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"SockAttr");
    tolua_cclass(tolua_S,"SockAttr","SockAttr","",nullptr);

    tolua_beginmodule(tolua_S,"SockAttr");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(SockAttr).name();
    g_luaType[typeName] = "SockAttr";
    g_typeCast["SockAttr"] = "SockAttr";
    return 1;
}

int lua_mapserver_MCCompress_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCCompress* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCCompress",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCCompress*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCCompress_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCCompress:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCCompress_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCCompress_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCCompress* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCCompress();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCCompress");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCCompress:MCCompress has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCCompress_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCCompress)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCCompress",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCCompress* self = (MCCompress*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCCompress(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCCompress");
    tolua_cclass(tolua_S,"MCCompress","MCCompress","CServerPacket",lua_mapserver_MCCompress_finalize);

    tolua_beginmodule(tolua_S,"MCCompress");
        tolua_function(tolua_S,"new",lua_mapserver_MCCompress_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCCompress_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCCompress).name();
    g_luaType[typeName] = "MCCompress";
    g_typeCast["MCCompress"] = "MCCompress";
    return 1;
}

static int lua_mapserver_PackCompress_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PackCompress)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PackCompress",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PackCompress* self = (PackCompress*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PackCompress(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PackCompress");
    tolua_cclass(tolua_S,"PackCompress","PackCompress","",nullptr);

    tolua_beginmodule(tolua_S,"PackCompress");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PackCompress).name();
    g_luaType[typeName] = "PackCompress";
    g_typeCast["PackCompress"] = "PackCompress";
    return 1;
}

static int lua_mapserver_PackEncrypt_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PackEncrypt)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PackEncrypt",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PackEncrypt* self = (PackEncrypt*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PackEncrypt(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PackEncrypt");
    tolua_cclass(tolua_S,"PackEncrypt","PackEncrypt","",nullptr);

    tolua_beginmodule(tolua_S,"PackEncrypt");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PackEncrypt).name();
    g_luaType[typeName] = "PackEncrypt";
    g_typeCast["PackEncrypt"] = "PackEncrypt";
    return 1;
}

int lua_mapserver_CBasePackHandleAry_parse(lua_State* tolua_S)
{
    int argc = 0;
    CBasePackHandleAry* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePackHandleAry",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePackHandleAry*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBasePackHandleAry_parse'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CBasePackHandleAry:parse"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CBasePackHandleAry:parse");
        if(!ok)
            return 0;
        bool ret = cobj->parse(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBasePackHandleAry:parse has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePackHandleAry_parse'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBasePackHandleAry_getBasePack(lua_State* tolua_S)
{
    int argc = 0;
    CBasePackHandleAry* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBasePackHandleAry",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBasePackHandleAry*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBasePackHandleAry_getBasePack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CBasePackHandleAry:getBasePack");
        if(!ok)
            return 0;
        CBasePacket* ret = cobj->getBasePack(arg0);
        object_to_luaval<CBasePacket>(tolua_S, "CBasePacket",(CBasePacket*)ret);
        return 1;
    }

    gxError("CBasePackHandleAry:getBasePack has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBasePackHandleAry_getBasePack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBasePackHandleAry_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CBasePackHandleAry* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CBasePackHandleAry();
        tolua_pushusertype(tolua_S,(void*)cobj,"CBasePackHandleAry");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CBasePackHandleAry:CBasePackHandleAry has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CBasePackHandleAry_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBasePackHandleAry)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBasePackHandleAry",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CBasePackHandleAry* self = (CBasePackHandleAry*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CBasePackHandleAry(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBasePackHandleAry");
    tolua_cclass(tolua_S,"CBasePackHandleAry","CBasePackHandleAry","CPackHandleAry",lua_mapserver_CBasePackHandleAry_finalize);

    tolua_beginmodule(tolua_S,"CBasePackHandleAry");
        tolua_function(tolua_S,"new",lua_mapserver_CBasePackHandleAry_constructor);
        tolua_function(tolua_S,"parse",lua_mapserver_CBasePackHandleAry_parse);
        tolua_function(tolua_S,"getBasePack",lua_mapserver_CBasePackHandleAry_getBasePack);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CBasePackHandleAry).name();
    g_luaType[typeName] = "CBasePackHandleAry";
    g_typeCast["CBasePackHandleAry"] = "CBasePackHandleAry";
    return 1;
}

static int lua_mapserver_TUnpacketIDHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (TUnpacketIDHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"TUnpacketIDHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        TUnpacketIDHandler* self = (TUnpacketIDHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_TUnpacketIDHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"TUnpacketIDHandler");
    tolua_cclass(tolua_S,"TUnpacketIDHandler","TUnpacketIDHandler","",nullptr);

    tolua_beginmodule(tolua_S,"TUnpacketIDHandler");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(TUnpacketIDHandler).name();
    g_luaType[typeName] = "TUnpacketIDHandler";
    g_typeCast["TUnpacketIDHandler"] = "TUnpacketIDHandler";
    return 1;
}

int lua_mapserver_CGameSocketPacketHandler_onPackAfterFromSocket(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_onPackAfterFromSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        const char* arg0;
        int arg1;
        char* arg2;
        int arg3;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CGameSocketPacketHandler:onPackAfterFromSocket"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CGameSocketPacketHandler:onPackAfterFromSocket");

        CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "CGameSocketPacketHandler:onPackAfterFromSocket"); arg2 = (char*)arg2_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CGameSocketPacketHandler:onPackAfterFromSocket");
        if(!ok)
            return 0;
        int ret = cobj->onPackAfterFromSocket(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameSocketPacketHandler:onPackAfterFromSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_onPackAfterFromSocket'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_onPackBeforeFlushToSocket(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_onPackBeforeFlushToSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        const char* arg0;
        int arg1;
        char* arg2;
        int arg3;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CGameSocketPacketHandler:onPackBeforeFlushToSocket"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CGameSocketPacketHandler:onPackBeforeFlushToSocket");

        CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "CGameSocketPacketHandler:onPackBeforeFlushToSocket"); arg2 = (char*)arg2_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CGameSocketPacketHandler:onPackBeforeFlushToSocket");
        if(!ok)
            return 0;
        int ret = cobj->onPackBeforeFlushToSocket(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameSocketPacketHandler:onPackBeforeFlushToSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_onPackBeforeFlushToSocket'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_onBeforeFlushToSocket(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_onBeforeFlushToSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        const char* arg0;
        int arg1;
        char* arg2;
        int arg3;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CGameSocketPacketHandler:onBeforeFlushToSocket"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CGameSocketPacketHandler:onBeforeFlushToSocket");

        CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "CGameSocketPacketHandler:onBeforeFlushToSocket"); arg2 = (char*)arg2_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CGameSocketPacketHandler:onBeforeFlushToSocket");
        if(!ok)
            return 0;
        int ret = cobj->onBeforeFlushToSocket(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameSocketPacketHandler:onBeforeFlushToSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_onBeforeFlushToSocket'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_setAttr(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_setAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        SockAttr* arg0;

        ok &= luaval_to_object<SockAttr>(tolua_S, 2, "SockAttr", &arg0, "CGameSocketPacketHandler:setAttr");
        if(!ok)
            return 0;
        cobj->setAttr(arg0);
        return 0;
    }

    gxError("CGameSocketPacketHandler:setAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_setAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_onSendPack(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_onSendPack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const char* arg0;
        int arg1;
        bool arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CGameSocketPacketHandler:onSendPack"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CGameSocketPacketHandler:onSendPack");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CGameSocketPacketHandler:onSendPack");
        if(!ok)
            return 0;
        cobj->onSendPack(arg0, arg1, arg2);
        return 0;
    }

    gxError("CGameSocketPacketHandler:onSendPack has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_onSendPack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_doCompress(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_doCompress'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        const char* arg0;
        int arg1;
        char* arg2;
        int arg3;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CGameSocketPacketHandler:doCompress"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CGameSocketPacketHandler:doCompress");

        CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "CGameSocketPacketHandler:doCompress"); arg2 = (char*)arg2_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CGameSocketPacketHandler:doCompress");
        if(!ok)
            return 0;
        int ret = cobj->doCompress(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameSocketPacketHandler:doCompress has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_doCompress'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_onAfterReadFromSocket(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_onAfterReadFromSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        const char* arg0;
        int arg1;
        char* arg2;
        int arg3;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CGameSocketPacketHandler:onAfterReadFromSocket"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CGameSocketPacketHandler:onAfterReadFromSocket");

        CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "CGameSocketPacketHandler:onAfterReadFromSocket"); arg2 = (char*)arg2_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CGameSocketPacketHandler:onAfterReadFromSocket");
        if(!ok)
            return 0;
        int ret = cobj->onAfterReadFromSocket(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameSocketPacketHandler:onAfterReadFromSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_onAfterReadFromSocket'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_doEncrypt(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_doEncrypt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        const char* arg0;
        int arg1;
        char* arg2;
        int arg3;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CGameSocketPacketHandler:doEncrypt"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CGameSocketPacketHandler:doEncrypt");

        CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "CGameSocketPacketHandler:doEncrypt"); arg2 = (char*)arg2_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CGameSocketPacketHandler:doEncrypt");
        if(!ok)
            return 0;
        int ret = cobj->doEncrypt(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameSocketPacketHandler:doEncrypt has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_doEncrypt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_canCompress(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_canCompress'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CBasePacket* arg0;

        ok &= luaval_to_object<CBasePacket>(tolua_S, 2, "CBasePacket", &arg0, "CGameSocketPacketHandler:canCompress");
        if(!ok)
            return 0;
        bool ret = cobj->canCompress(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameSocketPacketHandler:canCompress has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_canCompress'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_getMaxVarPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_getMaxVarPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CGameSocketPacketHandler:getMaxVarPackLen"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        int ret = cobj->getMaxVarPackLen(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameSocketPacketHandler:getMaxVarPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_getMaxVarPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_needHandle(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_needHandle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::ISocketPacketHandler::EPackOpt arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGameSocketPacketHandler:needHandle");
        if(!ok)
            return 0;
        bool ret = cobj->needHandle(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameSocketPacketHandler:needHandle has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_needHandle'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_getPackHeaderLen(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_getPackHeaderLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPackHeaderLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameSocketPacketHandler:getPackHeaderLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_getPackHeaderLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_canUnpacket(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_canUnpacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->canUnpacket();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameSocketPacketHandler:canUnpacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_canUnpacket'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_canReadPack(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_canReadPack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CGameSocketPacketHandler:canReadPack"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CGameSocketPacketHandler:canReadPack");
        if(!ok)
            return 0;
        int ret = cobj->canReadPack(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameSocketPacketHandler:canReadPack has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_canReadPack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_isVarPacket(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_isVarPacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CGameSocketPacketHandler:isVarPacket"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CGameSocketPacketHandler:isVarPacket");
        if(!ok)
            return 0;
        bool ret = cobj->isVarPacket(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameSocketPacketHandler:isVarPacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_isVarPacket'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_onHandleVarUnpacket(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_onHandleVarUnpacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        char* arg0;
        const char* arg1;
        int arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CGameSocketPacketHandler:onHandleVarUnpacket"); arg0 = (char*)arg0_tmp.buffer;

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CGameSocketPacketHandler:onHandleVarUnpacket"); arg1 = (char*)arg1_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CGameSocketPacketHandler:onHandleVarUnpacket");
        if(!ok)
            return 0;
        cobj->onHandleVarUnpacket(arg0, arg1, arg2);
        return 0;
    }

    gxError("CGameSocketPacketHandler:onHandleVarUnpacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_onHandleVarUnpacket'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_onRecvPack(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameSocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameSocketPacketHandler_onRecvPack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const char* arg0;
        int arg1;
        bool arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CGameSocketPacketHandler:onRecvPack"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CGameSocketPacketHandler:onRecvPack");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CGameSocketPacketHandler:onRecvPack");
        if(!ok)
            return 0;
        cobj->onRecvPack(arg0, arg1, arg2);
        return 0;
    }

    gxError("CGameSocketPacketHandler:onRecvPack has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_onRecvPack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameSocketPacketHandler_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CGameSocketPacketHandler::Setup();
        return 0;
    }
    gxError("CGameSocketPacketHandler:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameSocketPacketHandler_OnFlushDataToNetLoop(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        GXMISC::CNetLoopWrap* arg0;
        const char* arg1;
        int arg2;
        unsigned long long arg3;
        ok &= luaval_to_object<GXMISC::CNetLoopWrap>(tolua_S, 2, "CNetLoopWrap", &arg0, "CGameSocketPacketHandler:OnFlushDataToNetLoop");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CGameSocketPacketHandler:OnFlushDataToNetLoop"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CGameSocketPacketHandler:OnFlushDataToNetLoop");
        ok &= luaval_to_uint64(tolua_S, 5, (uint64*)&arg3, "CGameSocketPacketHandler:OnFlushDataToNetLoop");
        if(!ok)
            return 0;
        bool ret = CGameSocketPacketHandler::OnFlushDataToNetLoop(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CGameSocketPacketHandler:OnFlushDataToNetLoop has wrong number of arguments: {0}, was expecting {1}\n ", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameSocketPacketHandler_OnFlushDataToNetLoop'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameSocketPacketHandler_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CGameSocketPacketHandler* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CGameSocketPacketHandler();
        tolua_pushusertype(tolua_S,(void*)cobj,"CGameSocketPacketHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CGameSocketPacketHandler:CGameSocketPacketHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CGameSocketPacketHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGameSocketPacketHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGameSocketPacketHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CGameSocketPacketHandler* self = (CGameSocketPacketHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CGameSocketPacketHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGameSocketPacketHandler");
    tolua_cclass(tolua_S,"CGameSocketPacketHandler","CGameSocketPacketHandler","ISocketPacketHandler",lua_mapserver_CGameSocketPacketHandler_finalize);

    tolua_beginmodule(tolua_S,"CGameSocketPacketHandler");
        tolua_function(tolua_S,"new",lua_mapserver_CGameSocketPacketHandler_constructor);
        tolua_function(tolua_S,"onPackAfterFromSocket",lua_mapserver_CGameSocketPacketHandler_onPackAfterFromSocket);
        tolua_function(tolua_S,"onPackBeforeFlushToSocket",lua_mapserver_CGameSocketPacketHandler_onPackBeforeFlushToSocket);
        tolua_function(tolua_S,"onBeforeFlushToSocket",lua_mapserver_CGameSocketPacketHandler_onBeforeFlushToSocket);
        tolua_function(tolua_S,"setAttr",lua_mapserver_CGameSocketPacketHandler_setAttr);
        tolua_function(tolua_S,"onSendPack",lua_mapserver_CGameSocketPacketHandler_onSendPack);
        tolua_function(tolua_S,"doCompress",lua_mapserver_CGameSocketPacketHandler_doCompress);
        tolua_function(tolua_S,"onAfterReadFromSocket",lua_mapserver_CGameSocketPacketHandler_onAfterReadFromSocket);
        tolua_function(tolua_S,"doEncrypt",lua_mapserver_CGameSocketPacketHandler_doEncrypt);
        tolua_function(tolua_S,"canCompress",lua_mapserver_CGameSocketPacketHandler_canCompress);
        tolua_function(tolua_S,"getMaxVarPackLen",lua_mapserver_CGameSocketPacketHandler_getMaxVarPackLen);
        tolua_function(tolua_S,"needHandle",lua_mapserver_CGameSocketPacketHandler_needHandle);
        tolua_function(tolua_S,"getPackHeaderLen",lua_mapserver_CGameSocketPacketHandler_getPackHeaderLen);
        tolua_function(tolua_S,"canUnpacket",lua_mapserver_CGameSocketPacketHandler_canUnpacket);
        tolua_function(tolua_S,"canReadPack",lua_mapserver_CGameSocketPacketHandler_canReadPack);
        tolua_function(tolua_S,"isVarPacket",lua_mapserver_CGameSocketPacketHandler_isVarPacket);
        tolua_function(tolua_S,"onHandleVarUnpacket",lua_mapserver_CGameSocketPacketHandler_onHandleVarUnpacket);
        tolua_function(tolua_S,"onRecvPack",lua_mapserver_CGameSocketPacketHandler_onRecvPack);
        tolua_function(tolua_S,"Setup", lua_mapserver_CGameSocketPacketHandler_Setup);
        tolua_function(tolua_S,"OnFlushDataToNetLoop", lua_mapserver_CGameSocketPacketHandler_OnFlushDataToNetLoop);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CGameSocketPacketHandler).name();
    g_luaType[typeName] = "CGameSocketPacketHandler";
    g_typeCast["CGameSocketPacketHandler"] = "CGameSocketPacketHandler";
    return 1;
}

static int lua_mapserver_RoleDetail_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (RoleDetail)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"RoleDetail",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        RoleDetail* self = (RoleDetail*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_RoleDetail(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"RoleDetail");
    tolua_cclass(tolua_S,"RoleDetail","RoleDetail","IStreamableAll",nullptr);

    tolua_beginmodule(tolua_S,"RoleDetail");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(RoleDetail).name();
    g_luaType[typeName] = "RoleDetail";
    g_typeCast["RoleDetail"] = "RoleDetail";
    return 1;
}

int lua_mapserver_MCEnterView_size(lua_State* tolua_S)
{
    int argc = 0;
    MCEnterView* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCEnterView",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCEnterView*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCEnterView_size'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->size();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCEnterView:size has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterView_size'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCEnterView_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCEnterView* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCEnterView",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCEnterView*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCEnterView_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCEnterView:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterView_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCEnterView_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCEnterView",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCEnterView::Setup();
        return 0;
    }
    gxError("MCEnterView:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterView_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCEnterView_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCEnterView",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCEnterView::Unsetup();
        return 0;
    }
    gxError("MCEnterView:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterView_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCEnterView_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCEnterView",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCEnterView* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCEnterView>(tolua_S, 2, "MCEnterView", &arg0, "MCEnterView:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCEnterView:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCEnterView:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCEnterView::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCEnterView:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterView_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCEnterView_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCEnterView* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCEnterView();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCEnterView");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCEnterView:MCEnterView has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCEnterView_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCEnterView)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCEnterView",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCEnterView* self = (MCEnterView*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCEnterView(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCEnterView");
    tolua_cclass(tolua_S,"MCEnterView","MCEnterView","CServerPacket",lua_mapserver_MCEnterView_finalize);

    tolua_beginmodule(tolua_S,"MCEnterView");
        tolua_function(tolua_S,"new",lua_mapserver_MCEnterView_constructor);
        tolua_function(tolua_S,"size",lua_mapserver_MCEnterView_size);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCEnterView_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCEnterView_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCEnterView_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCEnterView_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCEnterView).name();
    g_luaType[typeName] = "MCEnterView";
    g_typeCast["MCEnterView"] = "MCEnterView";
    return 1;
}

int lua_mapserver_MCLeaveView_push(lua_State* tolua_S)
{
    int argc = 0;
    MCLeaveView* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCLeaveView",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCLeaveView*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCLeaveView_push'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        unsigned char arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "MCLeaveView:push");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "MCLeaveView:push");
        if(!ok)
            return 0;
        cobj->push(arg0, arg1);
        return 0;
    }

    gxError("MCLeaveView:push has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCLeaveView_push'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCLeaveView_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCLeaveView* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCLeaveView",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCLeaveView*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCLeaveView_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCLeaveView:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCLeaveView_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCLeaveView_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCLeaveView",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCLeaveView::Setup();
        return 0;
    }
    gxError("MCLeaveView:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCLeaveView_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCLeaveView_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCLeaveView",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCLeaveView::Unsetup();
        return 0;
    }
    gxError("MCLeaveView:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCLeaveView_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCLeaveView_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCLeaveView",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCLeaveView* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCLeaveView>(tolua_S, 2, "MCLeaveView", &arg0, "MCLeaveView:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCLeaveView:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCLeaveView:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCLeaveView::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCLeaveView:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCLeaveView_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCLeaveView_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCLeaveView* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCLeaveView();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCLeaveView");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCLeaveView:MCLeaveView has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCLeaveView_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCLeaveView)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCLeaveView",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCLeaveView* self = (MCLeaveView*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCLeaveView(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCLeaveView");
    tolua_cclass(tolua_S,"MCLeaveView","MCLeaveView","CServerPacket",lua_mapserver_MCLeaveView_finalize);

    tolua_beginmodule(tolua_S,"MCLeaveView");
        tolua_function(tolua_S,"new",lua_mapserver_MCLeaveView_constructor);
        tolua_function(tolua_S,"push",lua_mapserver_MCLeaveView_push);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCLeaveView_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCLeaveView_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCLeaveView_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCLeaveView_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCLeaveView).name();
    g_luaType[typeName] = "MCLeaveView";
    g_typeCast["MCLeaveView"] = "MCLeaveView";
    return 1;
}

int lua_mapserver_MCSceneData_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCSceneData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCSceneData",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCSceneData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCSceneData_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCSceneData:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCSceneData_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCSceneData_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCSceneData",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCSceneData::Setup();
        return 0;
    }
    gxError("MCSceneData:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCSceneData_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCSceneData_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCSceneData",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCSceneData::Unsetup();
        return 0;
    }
    gxError("MCSceneData:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCSceneData_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCSceneData_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCSceneData",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCSceneData* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCSceneData>(tolua_S, 2, "MCSceneData", &arg0, "MCSceneData:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCSceneData:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCSceneData:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCSceneData::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCSceneData:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCSceneData_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCSceneData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCSceneData* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCSceneData();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCSceneData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCSceneData:MCSceneData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCSceneData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCSceneData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCSceneData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCSceneData* self = (MCSceneData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCSceneData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCSceneData");
    tolua_cclass(tolua_S,"MCSceneData","MCSceneData","CServerPacket",lua_mapserver_MCSceneData_finalize);

    tolua_beginmodule(tolua_S,"MCSceneData");
        tolua_function(tolua_S,"new",lua_mapserver_MCSceneData_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCSceneData_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCSceneData_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCSceneData_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCSceneData_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCSceneData).name();
    g_luaType[typeName] = "MCSceneData";
    g_typeCast["MCSceneData"] = "MCSceneData";
    return 1;
}

int lua_mapserver_CMMove_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMMove* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMMove",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMMove*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMMove_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMMove:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMMove_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMMove_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMMove",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMMove::Setup();
        return 0;
    }
    gxError("CMMove:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMMove_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMMove_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMMove",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMMove::Unsetup();
        return 0;
    }
    gxError("CMMove:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMMove_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMMove_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMMove",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        CMMove* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<CMMove>(tolua_S, 2, "CMMove", &arg0, "CMMove:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CMMove:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CMMove:Unpacket");
        if(!ok)
            return 0;
        bool ret = CMMove::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CMMove:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMMove_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMMove_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMMove* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMMove();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMMove");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMMove:CMMove has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMMove_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMMove)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMMove",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMMove* self = (CMMove*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMMove(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMMove");
    tolua_cclass(tolua_S,"CMMove","CMMove","CRequestPacket",lua_mapserver_CMMove_finalize);

    tolua_beginmodule(tolua_S,"CMMove");
        tolua_function(tolua_S,"new",lua_mapserver_CMMove_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMMove_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_CMMove_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_CMMove_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_CMMove_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMMove).name();
    g_luaType[typeName] = "CMMove";
    g_typeCast["CMMove"] = "CMMove";
    return 1;
}

int lua_mapserver_MCMoveRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCMoveRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCMoveRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCMoveRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCMoveRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCMoveRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCMoveRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCMoveRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCMoveRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCMoveRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCMoveRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCMoveRet:MCMoveRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCMoveRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCMoveRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCMoveRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCMoveRet* self = (MCMoveRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCMoveRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCMoveRet");
    tolua_cclass(tolua_S,"MCMoveRet","MCMoveRet","CResponsePacket",lua_mapserver_MCMoveRet_finalize);

    tolua_beginmodule(tolua_S,"MCMoveRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCMoveRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCMoveRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCMoveRet).name();
    g_luaType[typeName] = "MCMoveRet";
    g_typeCast["MCMoveRet"] = "MCMoveRet";
    return 1;
}

int lua_mapserver_MCMoveBroad_toString(lua_State* tolua_S)
{
    int argc = 0;
    MCMoveBroad* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCMoveBroad",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCMoveBroad*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCMoveBroad_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("MCMoveBroad:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCMoveBroad_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCMoveBroad_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCMoveBroad* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCMoveBroad",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCMoveBroad*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCMoveBroad_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCMoveBroad:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCMoveBroad_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCMoveBroad_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCMoveBroad",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCMoveBroad::Setup();
        return 0;
    }
    gxError("MCMoveBroad:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCMoveBroad_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCMoveBroad_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCMoveBroad",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCMoveBroad::Unsetup();
        return 0;
    }
    gxError("MCMoveBroad:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCMoveBroad_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCMoveBroad_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCMoveBroad",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        CMMove* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<CMMove>(tolua_S, 2, "CMMove", &arg0, "MCMoveBroad:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCMoveBroad:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCMoveBroad:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCMoveBroad::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCMoveBroad:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCMoveBroad_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCMoveBroad_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCMoveBroad* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCMoveBroad();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCMoveBroad");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCMoveBroad:MCMoveBroad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCMoveBroad_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCMoveBroad)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCMoveBroad",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCMoveBroad* self = (MCMoveBroad*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCMoveBroad(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCMoveBroad");
    tolua_cclass(tolua_S,"MCMoveBroad","MCMoveBroad","CServerPacket",lua_mapserver_MCMoveBroad_finalize);

    tolua_beginmodule(tolua_S,"MCMoveBroad");
        tolua_function(tolua_S,"new",lua_mapserver_MCMoveBroad_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_MCMoveBroad_toString);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCMoveBroad_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCMoveBroad_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCMoveBroad_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCMoveBroad_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCMoveBroad).name();
    g_luaType[typeName] = "MCMoveBroad";
    g_typeCast["MCMoveBroad"] = "MCMoveBroad";
    return 1;
}

int lua_mapserver_CMJump_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMJump* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMJump",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMJump*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMJump_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMJump:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMJump_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMJump_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMJump* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMJump();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMJump");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMJump:CMJump has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMJump_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMJump)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMJump",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMJump* self = (CMJump*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMJump(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMJump");
    tolua_cclass(tolua_S,"CMJump","CMJump","CRequestPacket",lua_mapserver_CMJump_finalize);

    tolua_beginmodule(tolua_S,"CMJump");
        tolua_function(tolua_S,"new",lua_mapserver_CMJump_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMJump_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMJump).name();
    g_luaType[typeName] = "CMJump";
    g_typeCast["CMJump"] = "CMJump";
    return 1;
}

int lua_mapserver_MCJumpRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCJumpRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCJumpRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCJumpRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCJumpRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCJumpRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCJumpRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCJumpRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCJumpRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCJumpRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCJumpRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCJumpRet:MCJumpRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCJumpRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCJumpRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCJumpRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCJumpRet* self = (MCJumpRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCJumpRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCJumpRet");
    tolua_cclass(tolua_S,"MCJumpRet","MCJumpRet","CResponsePacket",lua_mapserver_MCJumpRet_finalize);

    tolua_beginmodule(tolua_S,"MCJumpRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCJumpRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCJumpRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCJumpRet).name();
    g_luaType[typeName] = "MCJumpRet";
    g_typeCast["MCJumpRet"] = "MCJumpRet";
    return 1;
}

int lua_mapserver_CMDrop_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMDrop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMDrop",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMDrop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMDrop_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMDrop:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMDrop_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMDrop_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMDrop* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMDrop();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMDrop");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMDrop:CMDrop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMDrop_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMDrop)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMDrop",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMDrop* self = (CMDrop*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMDrop(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMDrop");
    tolua_cclass(tolua_S,"CMDrop","CMDrop","CRequestPacket",lua_mapserver_CMDrop_finalize);

    tolua_beginmodule(tolua_S,"CMDrop");
        tolua_function(tolua_S,"new",lua_mapserver_CMDrop_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMDrop_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMDrop).name();
    g_luaType[typeName] = "CMDrop";
    g_typeCast["CMDrop"] = "CMDrop";
    return 1;
}

int lua_mapserver_MCDropRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCDropRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCDropRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCDropRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCDropRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCDropRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCDropRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCDropRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCDropRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCDropRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCDropRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCDropRet:MCDropRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCDropRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCDropRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCDropRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCDropRet* self = (MCDropRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCDropRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCDropRet");
    tolua_cclass(tolua_S,"MCDropRet","MCDropRet","CResponsePacket",lua_mapserver_MCDropRet_finalize);

    tolua_beginmodule(tolua_S,"MCDropRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCDropRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCDropRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCDropRet).name();
    g_luaType[typeName] = "MCDropRet";
    g_typeCast["MCDropRet"] = "MCDropRet";
    return 1;
}

int lua_mapserver_CMLand_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMLand* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMLand",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMLand*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMLand_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMLand:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMLand_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMLand_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMLand* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMLand();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMLand");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMLand:CMLand has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMLand_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMLand)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMLand",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMLand* self = (CMLand*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMLand(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMLand");
    tolua_cclass(tolua_S,"CMLand","CMLand","CRequestPacket",lua_mapserver_CMLand_finalize);

    tolua_beginmodule(tolua_S,"CMLand");
        tolua_function(tolua_S,"new",lua_mapserver_CMLand_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMLand_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMLand).name();
    g_luaType[typeName] = "CMLand";
    g_typeCast["CMLand"] = "CMLand";
    return 1;
}

int lua_mapserver_MCLandRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCLandRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCLandRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCLandRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCLandRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCLandRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCLandRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCLandRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCLandRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCLandRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCLandRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCLandRet:MCLandRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCLandRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCLandRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCLandRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCLandRet* self = (MCLandRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCLandRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCLandRet");
    tolua_cclass(tolua_S,"MCLandRet","MCLandRet","CResponsePacket",lua_mapserver_MCLandRet_finalize);

    tolua_beginmodule(tolua_S,"MCLandRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCLandRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCLandRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCLandRet).name();
    g_luaType[typeName] = "MCLandRet";
    g_typeCast["MCLandRet"] = "MCLandRet";
    return 1;
}

int lua_mapserver_MCResetPos_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCResetPos* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCResetPos",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCResetPos*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCResetPos_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCResetPos:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCResetPos_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCResetPos_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCResetPos* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCResetPos();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCResetPos");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCResetPos:MCResetPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCResetPos_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCResetPos)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCResetPos",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCResetPos* self = (MCResetPos*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCResetPos(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCResetPos");
    tolua_cclass(tolua_S,"MCResetPos","MCResetPos","CServerPacket",lua_mapserver_MCResetPos_finalize);

    tolua_beginmodule(tolua_S,"MCResetPos");
        tolua_function(tolua_S,"new",lua_mapserver_MCResetPos_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCResetPos_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCResetPos).name();
    g_luaType[typeName] = "MCResetPos";
    g_typeCast["MCResetPos"] = "MCResetPos";
    return 1;
}

int lua_mapserver_MCEnterScene_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCEnterScene* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCEnterScene",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCEnterScene*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCEnterScene_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCEnterScene:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterScene_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCEnterScene_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCEnterScene* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCEnterScene();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCEnterScene");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCEnterScene:MCEnterScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCEnterScene_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCEnterScene)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCEnterScene",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCEnterScene* self = (MCEnterScene*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCEnterScene(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCEnterScene");
    tolua_cclass(tolua_S,"MCEnterScene","MCEnterScene","CServerPacket",lua_mapserver_MCEnterScene_finalize);

    tolua_beginmodule(tolua_S,"MCEnterScene");
        tolua_function(tolua_S,"new",lua_mapserver_MCEnterScene_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCEnterScene_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCEnterScene).name();
    g_luaType[typeName] = "MCEnterScene";
    g_typeCast["MCEnterScene"] = "MCEnterScene";
    return 1;
}

int lua_mapserver_CMEnterScene_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMEnterScene* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMEnterScene",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMEnterScene*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMEnterScene_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMEnterScene:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMEnterScene_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMEnterScene_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMEnterScene* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMEnterScene();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMEnterScene");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMEnterScene:CMEnterScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMEnterScene_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMEnterScene)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMEnterScene",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMEnterScene* self = (CMEnterScene*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMEnterScene(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMEnterScene");
    tolua_cclass(tolua_S,"CMEnterScene","CMEnterScene","CRequestPacket",lua_mapserver_CMEnterScene_finalize);

    tolua_beginmodule(tolua_S,"CMEnterScene");
        tolua_function(tolua_S,"new",lua_mapserver_CMEnterScene_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMEnterScene_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMEnterScene).name();
    g_luaType[typeName] = "CMEnterScene";
    g_typeCast["CMEnterScene"] = "CMEnterScene";
    return 1;
}

int lua_mapserver_MCEnterSceneRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCEnterSceneRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCEnterSceneRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCEnterSceneRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCEnterSceneRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCEnterSceneRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterSceneRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCEnterSceneRet_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCEnterSceneRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCEnterSceneRet::Setup();
        return 0;
    }
    gxError("MCEnterSceneRet:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterSceneRet_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCEnterSceneRet_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCEnterSceneRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCEnterSceneRet::Unsetup();
        return 0;
    }
    gxError("MCEnterSceneRet:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterSceneRet_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCEnterSceneRet_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCEnterSceneRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCEnterSceneRet* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCEnterSceneRet>(tolua_S, 2, "MCEnterSceneRet", &arg0, "MCEnterSceneRet:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCEnterSceneRet:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCEnterSceneRet:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCEnterSceneRet::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCEnterSceneRet:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterSceneRet_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCEnterSceneRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCEnterSceneRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCEnterSceneRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCEnterSceneRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCEnterSceneRet:MCEnterSceneRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCEnterSceneRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCEnterSceneRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCEnterSceneRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCEnterSceneRet* self = (MCEnterSceneRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCEnterSceneRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCEnterSceneRet");
    tolua_cclass(tolua_S,"MCEnterSceneRet","MCEnterSceneRet","CResponsePacket",lua_mapserver_MCEnterSceneRet_finalize);

    tolua_beginmodule(tolua_S,"MCEnterSceneRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCEnterSceneRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCEnterSceneRet_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCEnterSceneRet_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCEnterSceneRet_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCEnterSceneRet_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCEnterSceneRet).name();
    g_luaType[typeName] = "MCEnterSceneRet";
    g_typeCast["MCEnterSceneRet"] = "MCEnterSceneRet";
    return 1;
}

int lua_mapserver_CMChangeMap_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMChangeMap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMChangeMap",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMChangeMap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMChangeMap_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMChangeMap:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMChangeMap_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMChangeMap_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMChangeMap* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMChangeMap();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMChangeMap");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMChangeMap:CMChangeMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMChangeMap_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMChangeMap)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMChangeMap",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMChangeMap* self = (CMChangeMap*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMChangeMap(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMChangeMap");
    tolua_cclass(tolua_S,"CMChangeMap","CMChangeMap","CRequestPacket",lua_mapserver_CMChangeMap_finalize);

    tolua_beginmodule(tolua_S,"CMChangeMap");
        tolua_function(tolua_S,"new",lua_mapserver_CMChangeMap_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMChangeMap_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMChangeMap).name();
    g_luaType[typeName] = "CMChangeMap";
    g_typeCast["CMChangeMap"] = "CMChangeMap";
    return 1;
}

int lua_mapserver_MCChangeMapRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCChangeMapRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCChangeMapRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCChangeMapRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCChangeMapRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCChangeMapRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCChangeMapRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCChangeMapRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCChangeMapRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCChangeMapRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCChangeMapRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCChangeMapRet:MCChangeMapRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCChangeMapRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCChangeMapRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCChangeMapRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCChangeMapRet* self = (MCChangeMapRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCChangeMapRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCChangeMapRet");
    tolua_cclass(tolua_S,"MCChangeMapRet","MCChangeMapRet","CResponsePacket",lua_mapserver_MCChangeMapRet_finalize);

    tolua_beginmodule(tolua_S,"MCChangeMapRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCChangeMapRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCChangeMapRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCChangeMapRet).name();
    g_luaType[typeName] = "MCChangeMapRet";
    g_typeCast["MCChangeMapRet"] = "MCChangeMapRet";
    return 1;
}

int lua_mapserver_CMDynamicMapList_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMDynamicMapList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMDynamicMapList",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMDynamicMapList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMDynamicMapList_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMDynamicMapList:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMDynamicMapList_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMDynamicMapList_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMDynamicMapList* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMDynamicMapList();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMDynamicMapList");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMDynamicMapList:CMDynamicMapList has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMDynamicMapList_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMDynamicMapList)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMDynamicMapList",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMDynamicMapList* self = (CMDynamicMapList*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMDynamicMapList(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMDynamicMapList");
    tolua_cclass(tolua_S,"CMDynamicMapList","CMDynamicMapList","CRequestPacket",lua_mapserver_CMDynamicMapList_finalize);

    tolua_beginmodule(tolua_S,"CMDynamicMapList");
        tolua_function(tolua_S,"new",lua_mapserver_CMDynamicMapList_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMDynamicMapList_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMDynamicMapList).name();
    g_luaType[typeName] = "CMDynamicMapList";
    g_typeCast["CMDynamicMapList"] = "CMDynamicMapList";
    return 1;
}

int lua_mapserver_MCDynamicMapListRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCDynamicMapListRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCDynamicMapListRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCDynamicMapListRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCDynamicMapListRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCDynamicMapListRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCDynamicMapListRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCDynamicMapListRet_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCDynamicMapListRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCDynamicMapListRet::Setup();
        return 0;
    }
    gxError("MCDynamicMapListRet:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCDynamicMapListRet_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCDynamicMapListRet_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCDynamicMapListRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCDynamicMapListRet::Unsetup();
        return 0;
    }
    gxError("MCDynamicMapListRet:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCDynamicMapListRet_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCDynamicMapListRet_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCDynamicMapListRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCDynamicMapListRet* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCDynamicMapListRet>(tolua_S, 2, "MCDynamicMapListRet", &arg0, "MCDynamicMapListRet:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCDynamicMapListRet:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCDynamicMapListRet:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCDynamicMapListRet::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCDynamicMapListRet:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCDynamicMapListRet_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCDynamicMapListRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCDynamicMapListRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCDynamicMapListRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCDynamicMapListRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCDynamicMapListRet:MCDynamicMapListRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCDynamicMapListRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCDynamicMapListRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCDynamicMapListRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCDynamicMapListRet* self = (MCDynamicMapListRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCDynamicMapListRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCDynamicMapListRet");
    tolua_cclass(tolua_S,"MCDynamicMapListRet","MCDynamicMapListRet","CResponsePacket",lua_mapserver_MCDynamicMapListRet_finalize);

    tolua_beginmodule(tolua_S,"MCDynamicMapListRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCDynamicMapListRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCDynamicMapListRet_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCDynamicMapListRet_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCDynamicMapListRet_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCDynamicMapListRet_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCDynamicMapListRet).name();
    g_luaType[typeName] = "MCDynamicMapListRet";
    g_typeCast["MCDynamicMapListRet"] = "MCDynamicMapListRet";
    return 1;
}

int lua_mapserver_CMChat_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMChat_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMChat:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMChat_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMChat_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMChat",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMChat::Setup();
        return 0;
    }
    gxError("CMChat:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMChat_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMChat_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMChat",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMChat::Unsetup();
        return 0;
    }
    gxError("CMChat:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMChat_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMChat_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMChat",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        CMChat* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<CMChat>(tolua_S, 2, "CMChat", &arg0, "CMChat:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CMChat:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CMChat:Unpacket");
        if(!ok)
            return 0;
        bool ret = CMChat::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CMChat:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMChat_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMChat_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMChat* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMChat();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMChat");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMChat:CMChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMChat_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMChat)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMChat",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMChat* self = (CMChat*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMChat(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMChat");
    tolua_cclass(tolua_S,"CMChat","CMChat","CRequestPacket",lua_mapserver_CMChat_finalize);

    tolua_beginmodule(tolua_S,"CMChat");
        tolua_function(tolua_S,"new",lua_mapserver_CMChat_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMChat_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_CMChat_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_CMChat_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_CMChat_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMChat).name();
    g_luaType[typeName] = "CMChat";
    g_typeCast["CMChat"] = "CMChat";
    return 1;
}

int lua_mapserver_MCChatBroad_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCChatBroad* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCChatBroad",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCChatBroad*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCChatBroad_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCChatBroad:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCChatBroad_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCChatBroad_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCChatBroad",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCChatBroad::Setup();
        return 0;
    }
    gxError("MCChatBroad:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCChatBroad_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCChatBroad_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCChatBroad",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCChatBroad::Unsetup();
        return 0;
    }
    gxError("MCChatBroad:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCChatBroad_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCChatBroad_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCChatBroad",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCChatBroad* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCChatBroad>(tolua_S, 2, "MCChatBroad", &arg0, "MCChatBroad:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCChatBroad:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCChatBroad:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCChatBroad::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCChatBroad:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCChatBroad_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCChatBroad_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCChatBroad* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCChatBroad();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCChatBroad");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCChatBroad:MCChatBroad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCChatBroad_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCChatBroad)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCChatBroad",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCChatBroad* self = (MCChatBroad*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCChatBroad(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCChatBroad");
    tolua_cclass(tolua_S,"MCChatBroad","MCChatBroad","CResponsePacket",lua_mapserver_MCChatBroad_finalize);

    tolua_beginmodule(tolua_S,"MCChatBroad");
        tolua_function(tolua_S,"new",lua_mapserver_MCChatBroad_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCChatBroad_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCChatBroad_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCChatBroad_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCChatBroad_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCChatBroad).name();
    g_luaType[typeName] = "MCChatBroad";
    g_typeCast["MCChatBroad"] = "MCChatBroad";
    return 1;
}

int lua_mapserver_MCAnnouncement_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCAnnouncement* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCAnnouncement",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCAnnouncement*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCAnnouncement_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCAnnouncement:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCAnnouncement_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCAnnouncement_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCAnnouncement",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCAnnouncement::Setup();
        return 0;
    }
    gxError("MCAnnouncement:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCAnnouncement_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCAnnouncement_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCAnnouncement",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCAnnouncement::Unsetup();
        return 0;
    }
    gxError("MCAnnouncement:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCAnnouncement_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCAnnouncement_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCAnnouncement",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCAnnouncement* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCAnnouncement>(tolua_S, 2, "MCAnnouncement", &arg0, "MCAnnouncement:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCAnnouncement:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCAnnouncement:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCAnnouncement::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCAnnouncement:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCAnnouncement_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCAnnouncement_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCAnnouncement* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCAnnouncement();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCAnnouncement");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCAnnouncement:MCAnnouncement has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCAnnouncement_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCAnnouncement)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCAnnouncement",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCAnnouncement* self = (MCAnnouncement*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCAnnouncement(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCAnnouncement");
    tolua_cclass(tolua_S,"MCAnnouncement","MCAnnouncement","CServerPacket",lua_mapserver_MCAnnouncement_finalize);

    tolua_beginmodule(tolua_S,"MCAnnouncement");
        tolua_function(tolua_S,"new",lua_mapserver_MCAnnouncement_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCAnnouncement_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCAnnouncement_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCAnnouncement_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCAnnouncement_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCAnnouncement).name();
    g_luaType[typeName] = "MCAnnouncement";
    g_typeCast["MCAnnouncement"] = "MCAnnouncement";
    return 1;
}

int lua_mapserver_CMTransmite_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMTransmite* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMTransmite",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMTransmite*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMTransmite_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMTransmite:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMTransmite_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMTransmite_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMTransmite* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMTransmite();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMTransmite");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMTransmite:CMTransmite has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMTransmite_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMTransmite)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMTransmite",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMTransmite* self = (CMTransmite*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMTransmite(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMTransmite");
    tolua_cclass(tolua_S,"CMTransmite","CMTransmite","CRequestPacket",lua_mapserver_CMTransmite_finalize);

    tolua_beginmodule(tolua_S,"CMTransmite");
        tolua_function(tolua_S,"new",lua_mapserver_CMTransmite_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMTransmite_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMTransmite).name();
    g_luaType[typeName] = "CMTransmite";
    g_typeCast["CMTransmite"] = "CMTransmite";
    return 1;
}

int lua_mapserver_MCTransmiteRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCTransmiteRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCTransmiteRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCTransmiteRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCTransmiteRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCTransmiteRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCTransmiteRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCTransmiteRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCTransmiteRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCTransmiteRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCTransmiteRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCTransmiteRet:MCTransmiteRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCTransmiteRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCTransmiteRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCTransmiteRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCTransmiteRet* self = (MCTransmiteRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCTransmiteRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCTransmiteRet");
    tolua_cclass(tolua_S,"MCTransmiteRet","MCTransmiteRet","CResponsePacket",lua_mapserver_MCTransmiteRet_finalize);

    tolua_beginmodule(tolua_S,"MCTransmiteRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCTransmiteRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCTransmiteRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCTransmiteRet).name();
    g_luaType[typeName] = "MCTransmiteRet";
    g_typeCast["MCTransmiteRet"] = "MCTransmiteRet";
    return 1;
}

int lua_mapserver_MCSyncRoleData_reset(lua_State* tolua_S)
{
    int argc = 0;
    MCSyncRoleData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCSyncRoleData",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCSyncRoleData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCSyncRoleData_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }

    gxError("MCSyncRoleData:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCSyncRoleData_reset'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCSyncRoleData_isDirty(lua_State* tolua_S)
{
    int argc = 0;
    MCSyncRoleData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCSyncRoleData",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCSyncRoleData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCSyncRoleData_isDirty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDirty();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("MCSyncRoleData:isDirty has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCSyncRoleData_isDirty'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCSyncRoleData_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCSyncRoleData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCSyncRoleData",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCSyncRoleData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCSyncRoleData_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCSyncRoleData:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCSyncRoleData_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCSyncRoleData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCSyncRoleData* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCSyncRoleData();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCSyncRoleData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCSyncRoleData:MCSyncRoleData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCSyncRoleData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCSyncRoleData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCSyncRoleData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCSyncRoleData* self = (MCSyncRoleData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCSyncRoleData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCSyncRoleData");
    tolua_cclass(tolua_S,"MCSyncRoleData","MCSyncRoleData","CServerPacket",lua_mapserver_MCSyncRoleData_finalize);

    tolua_beginmodule(tolua_S,"MCSyncRoleData");
        tolua_function(tolua_S,"new",lua_mapserver_MCSyncRoleData_constructor);
        tolua_function(tolua_S,"reset",lua_mapserver_MCSyncRoleData_reset);
        tolua_function(tolua_S,"isDirty",lua_mapserver_MCSyncRoleData_isDirty);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCSyncRoleData_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCSyncRoleData).name();
    g_luaType[typeName] = "MCSyncRoleData";
    g_typeCast["MCSyncRoleData"] = "MCSyncRoleData";
    return 1;
}

int lua_mapserver_MCCallBackRetCode_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCCallBackRetCode* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCCallBackRetCode",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCCallBackRetCode*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCCallBackRetCode_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCCallBackRetCode:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCCallBackRetCode_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCCallBackRetCode_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCCallBackRetCode* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCCallBackRetCode();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCCallBackRetCode");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCCallBackRetCode:MCCallBackRetCode has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCCallBackRetCode_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCCallBackRetCode)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCCallBackRetCode",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCCallBackRetCode* self = (MCCallBackRetCode*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCCallBackRetCode(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCCallBackRetCode");
    tolua_cclass(tolua_S,"MCCallBackRetCode","MCCallBackRetCode","CServerPacket",lua_mapserver_MCCallBackRetCode_finalize);

    tolua_beginmodule(tolua_S,"MCCallBackRetCode");
        tolua_function(tolua_S,"new",lua_mapserver_MCCallBackRetCode_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCCallBackRetCode_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCCallBackRetCode).name();
    g_luaType[typeName] = "MCCallBackRetCode";
    g_typeCast["MCCallBackRetCode"] = "MCCallBackRetCode";
    return 1;
}

int lua_mapserver_CMRenameRoleName_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMRenameRoleName* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMRenameRoleName",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMRenameRoleName*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMRenameRoleName_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMRenameRoleName:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMRenameRoleName_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMRenameRoleName_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMRenameRoleName",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMRenameRoleName::Setup();
        return 0;
    }
    gxError("CMRenameRoleName:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMRenameRoleName_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMRenameRoleName_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMRenameRoleName",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMRenameRoleName::Unsetup();
        return 0;
    }
    gxError("CMRenameRoleName:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMRenameRoleName_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMRenameRoleName_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMRenameRoleName",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        CMRenameRoleName* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<CMRenameRoleName>(tolua_S, 2, "CMRenameRoleName", &arg0, "CMRenameRoleName:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CMRenameRoleName:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CMRenameRoleName:Unpacket");
        if(!ok)
            return 0;
        bool ret = CMRenameRoleName::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CMRenameRoleName:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMRenameRoleName_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMRenameRoleName_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMRenameRoleName* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMRenameRoleName();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMRenameRoleName");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMRenameRoleName:CMRenameRoleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMRenameRoleName_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMRenameRoleName)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMRenameRoleName",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMRenameRoleName* self = (CMRenameRoleName*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMRenameRoleName(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMRenameRoleName");
    tolua_cclass(tolua_S,"CMRenameRoleName","CMRenameRoleName","CRequestPacket",lua_mapserver_CMRenameRoleName_finalize);

    tolua_beginmodule(tolua_S,"CMRenameRoleName");
        tolua_function(tolua_S,"new",lua_mapserver_CMRenameRoleName_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMRenameRoleName_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_CMRenameRoleName_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_CMRenameRoleName_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_CMRenameRoleName_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMRenameRoleName).name();
    g_luaType[typeName] = "CMRenameRoleName";
    g_typeCast["CMRenameRoleName"] = "CMRenameRoleName";
    return 1;
}

int lua_mapserver_MCRenameRoleNameRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCRenameRoleNameRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCRenameRoleNameRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCRenameRoleNameRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCRenameRoleNameRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCRenameRoleNameRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCRenameRoleNameRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCRenameRoleNameRet_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCRenameRoleNameRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCRenameRoleNameRet::Setup();
        return 0;
    }
    gxError("MCRenameRoleNameRet:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCRenameRoleNameRet_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCRenameRoleNameRet_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCRenameRoleNameRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCRenameRoleNameRet::Unsetup();
        return 0;
    }
    gxError("MCRenameRoleNameRet:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCRenameRoleNameRet_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCRenameRoleNameRet_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCRenameRoleNameRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCRenameRoleNameRet* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCRenameRoleNameRet>(tolua_S, 2, "MCRenameRoleNameRet", &arg0, "MCRenameRoleNameRet:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCRenameRoleNameRet:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCRenameRoleNameRet:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCRenameRoleNameRet::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCRenameRoleNameRet:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCRenameRoleNameRet_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCRenameRoleNameRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCRenameRoleNameRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCRenameRoleNameRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCRenameRoleNameRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCRenameRoleNameRet:MCRenameRoleNameRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCRenameRoleNameRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCRenameRoleNameRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCRenameRoleNameRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCRenameRoleNameRet* self = (MCRenameRoleNameRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCRenameRoleNameRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCRenameRoleNameRet");
    tolua_cclass(tolua_S,"MCRenameRoleNameRet","MCRenameRoleNameRet","CResponsePacket",lua_mapserver_MCRenameRoleNameRet_finalize);

    tolua_beginmodule(tolua_S,"MCRenameRoleNameRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCRenameRoleNameRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCRenameRoleNameRet_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCRenameRoleNameRet_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCRenameRoleNameRet_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCRenameRoleNameRet_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCRenameRoleNameRet).name();
    g_luaType[typeName] = "MCRenameRoleNameRet";
    g_typeCast["MCRenameRoleNameRet"] = "MCRenameRoleNameRet";
    return 1;
}

int lua_mapserver_CMRandRoleName_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMRandRoleName* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMRandRoleName",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMRandRoleName*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMRandRoleName_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMRandRoleName:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMRandRoleName_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMRandRoleName_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMRandRoleName* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMRandRoleName();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMRandRoleName");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMRandRoleName:CMRandRoleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMRandRoleName_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMRandRoleName)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMRandRoleName",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMRandRoleName* self = (CMRandRoleName*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMRandRoleName(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMRandRoleName");
    tolua_cclass(tolua_S,"CMRandRoleName","CMRandRoleName","CRequestPacket",lua_mapserver_CMRandRoleName_finalize);

    tolua_beginmodule(tolua_S,"CMRandRoleName");
        tolua_function(tolua_S,"new",lua_mapserver_CMRandRoleName_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMRandRoleName_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMRandRoleName).name();
    g_luaType[typeName] = "CMRandRoleName";
    g_typeCast["CMRandRoleName"] = "CMRandRoleName";
    return 1;
}

int lua_mapserver_MCRandRoleNameRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCRandRoleNameRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCRandRoleNameRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCRandRoleNameRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCRandRoleNameRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCRandRoleNameRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCRandRoleNameRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCRandRoleNameRet_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCRandRoleNameRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCRandRoleNameRet::Setup();
        return 0;
    }
    gxError("MCRandRoleNameRet:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCRandRoleNameRet_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCRandRoleNameRet_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCRandRoleNameRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCRandRoleNameRet::Unsetup();
        return 0;
    }
    gxError("MCRandRoleNameRet:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCRandRoleNameRet_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCRandRoleNameRet_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCRandRoleNameRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCRandRoleNameRet* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCRandRoleNameRet>(tolua_S, 2, "MCRandRoleNameRet", &arg0, "MCRandRoleNameRet:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCRandRoleNameRet:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCRandRoleNameRet:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCRandRoleNameRet::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCRandRoleNameRet:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCRandRoleNameRet_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCRandRoleNameRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCRandRoleNameRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCRandRoleNameRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCRandRoleNameRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCRandRoleNameRet:MCRandRoleNameRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCRandRoleNameRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCRandRoleNameRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCRandRoleNameRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCRandRoleNameRet* self = (MCRandRoleNameRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCRandRoleNameRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCRandRoleNameRet");
    tolua_cclass(tolua_S,"MCRandRoleNameRet","MCRandRoleNameRet","CResponsePacket",lua_mapserver_MCRandRoleNameRet_finalize);

    tolua_beginmodule(tolua_S,"MCRandRoleNameRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCRandRoleNameRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCRandRoleNameRet_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCRandRoleNameRet_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCRandRoleNameRet_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCRandRoleNameRet_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCRandRoleNameRet).name();
    g_luaType[typeName] = "MCRandRoleNameRet";
    g_typeCast["MCRandRoleNameRet"] = "MCRandRoleNameRet";
    return 1;
}

int lua_mapserver_MCKickRole_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCKickRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCKickRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCKickRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCKickRole_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCKickRole:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCKickRole_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCKickRole_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCKickRole* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCKickRole();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCKickRole");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCKickRole:MCKickRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCKickRole_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCKickRole)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCKickRole",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCKickRole* self = (MCKickRole*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCKickRole(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCKickRole");
    tolua_cclass(tolua_S,"MCKickRole","MCKickRole","CServerPacket",lua_mapserver_MCKickRole_finalize);

    tolua_beginmodule(tolua_S,"MCKickRole");
        tolua_function(tolua_S,"new",lua_mapserver_MCKickRole_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCKickRole_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCKickRole).name();
    g_luaType[typeName] = "MCKickRole";
    g_typeCast["MCKickRole"] = "MCKickRole";
    return 1;
}

int lua_mapserver_CMOpenDynamicMap_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMOpenDynamicMap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMOpenDynamicMap",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMOpenDynamicMap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMOpenDynamicMap_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMOpenDynamicMap:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMOpenDynamicMap_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMOpenDynamicMap_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMOpenDynamicMap* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMOpenDynamicMap();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMOpenDynamicMap");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMOpenDynamicMap:CMOpenDynamicMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMOpenDynamicMap_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMOpenDynamicMap)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMOpenDynamicMap",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMOpenDynamicMap* self = (CMOpenDynamicMap*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMOpenDynamicMap(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMOpenDynamicMap");
    tolua_cclass(tolua_S,"CMOpenDynamicMap","CMOpenDynamicMap","CRequestPacket",lua_mapserver_CMOpenDynamicMap_finalize);

    tolua_beginmodule(tolua_S,"CMOpenDynamicMap");
        tolua_function(tolua_S,"new",lua_mapserver_CMOpenDynamicMap_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMOpenDynamicMap_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMOpenDynamicMap).name();
    g_luaType[typeName] = "CMOpenDynamicMap";
    g_typeCast["CMOpenDynamicMap"] = "CMOpenDynamicMap";
    return 1;
}

int lua_mapserver_MCOpenDynamicMapRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCOpenDynamicMapRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCOpenDynamicMapRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCOpenDynamicMapRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCOpenDynamicMapRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCOpenDynamicMapRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCOpenDynamicMapRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCOpenDynamicMapRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCOpenDynamicMapRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCOpenDynamicMapRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCOpenDynamicMapRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCOpenDynamicMapRet:MCOpenDynamicMapRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCOpenDynamicMapRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCOpenDynamicMapRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCOpenDynamicMapRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCOpenDynamicMapRet* self = (MCOpenDynamicMapRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCOpenDynamicMapRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCOpenDynamicMapRet");
    tolua_cclass(tolua_S,"MCOpenDynamicMapRet","MCOpenDynamicMapRet","CResponsePacket",lua_mapserver_MCOpenDynamicMapRet_finalize);

    tolua_beginmodule(tolua_S,"MCOpenDynamicMapRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCOpenDynamicMapRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCOpenDynamicMapRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCOpenDynamicMapRet).name();
    g_luaType[typeName] = "MCOpenDynamicMapRet";
    g_typeCast["MCOpenDynamicMapRet"] = "MCOpenDynamicMapRet";
    return 1;
}

int lua_mapserver_CMWorldChatMsg_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMWorldChatMsg* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMWorldChatMsg",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMWorldChatMsg*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMWorldChatMsg_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMWorldChatMsg:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMWorldChatMsg_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMWorldChatMsg_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMWorldChatMsg* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMWorldChatMsg();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMWorldChatMsg");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMWorldChatMsg:CMWorldChatMsg has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMWorldChatMsg_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMWorldChatMsg)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMWorldChatMsg",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMWorldChatMsg* self = (CMWorldChatMsg*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMWorldChatMsg(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMWorldChatMsg");
    tolua_cclass(tolua_S,"CMWorldChatMsg","CMWorldChatMsg","CRequestPacket",lua_mapserver_CMWorldChatMsg_finalize);

    tolua_beginmodule(tolua_S,"CMWorldChatMsg");
        tolua_function(tolua_S,"new",lua_mapserver_CMWorldChatMsg_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMWorldChatMsg_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMWorldChatMsg).name();
    g_luaType[typeName] = "CMWorldChatMsg";
    g_typeCast["CMWorldChatMsg"] = "CMWorldChatMsg";
    return 1;
}

int lua_mapserver_MCWorldChatMsg_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCWorldChatMsg* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCWorldChatMsg",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCWorldChatMsg*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCWorldChatMsg_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCWorldChatMsg:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCWorldChatMsg_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCWorldChatMsg_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCWorldChatMsg",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCWorldChatMsg::Setup();
        return 0;
    }
    gxError("MCWorldChatMsg:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCWorldChatMsg_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCWorldChatMsg_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCWorldChatMsg",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCWorldChatMsg::Unsetup();
        return 0;
    }
    gxError("MCWorldChatMsg:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCWorldChatMsg_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCWorldChatMsg_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCWorldChatMsg",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCWorldChatMsg* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCWorldChatMsg>(tolua_S, 2, "MCWorldChatMsg", &arg0, "MCWorldChatMsg:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCWorldChatMsg:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCWorldChatMsg:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCWorldChatMsg::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCWorldChatMsg:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCWorldChatMsg_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCWorldChatMsg_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCWorldChatMsg* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCWorldChatMsg();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCWorldChatMsg");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCWorldChatMsg:MCWorldChatMsg has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCWorldChatMsg_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCWorldChatMsg)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCWorldChatMsg",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCWorldChatMsg* self = (MCWorldChatMsg*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCWorldChatMsg(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCWorldChatMsg");
    tolua_cclass(tolua_S,"MCWorldChatMsg","MCWorldChatMsg","CServerPacket",lua_mapserver_MCWorldChatMsg_finalize);

    tolua_beginmodule(tolua_S,"MCWorldChatMsg");
        tolua_function(tolua_S,"new",lua_mapserver_MCWorldChatMsg_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCWorldChatMsg_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCWorldChatMsg_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCWorldChatMsg_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCWorldChatMsg_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCWorldChatMsg).name();
    g_luaType[typeName] = "MCWorldChatMsg";
    g_typeCast["MCWorldChatMsg"] = "MCWorldChatMsg";
    return 1;
}

int lua_mapserver_CMRoomChatMsg_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMRoomChatMsg* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMRoomChatMsg",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMRoomChatMsg*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMRoomChatMsg_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMRoomChatMsg:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMRoomChatMsg_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMRoomChatMsg_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMRoomChatMsg* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMRoomChatMsg();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMRoomChatMsg");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMRoomChatMsg:CMRoomChatMsg has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMRoomChatMsg_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMRoomChatMsg)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMRoomChatMsg",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMRoomChatMsg* self = (CMRoomChatMsg*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMRoomChatMsg(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMRoomChatMsg");
    tolua_cclass(tolua_S,"CMRoomChatMsg","CMRoomChatMsg","CRequestPacket",lua_mapserver_CMRoomChatMsg_finalize);

    tolua_beginmodule(tolua_S,"CMRoomChatMsg");
        tolua_function(tolua_S,"new",lua_mapserver_CMRoomChatMsg_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMRoomChatMsg_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMRoomChatMsg).name();
    g_luaType[typeName] = "CMRoomChatMsg";
    g_typeCast["CMRoomChatMsg"] = "CMRoomChatMsg";
    return 1;
}

int lua_mapserver_MCRoomChatMsg_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCRoomChatMsg* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCRoomChatMsg",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCRoomChatMsg*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCRoomChatMsg_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCRoomChatMsg:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCRoomChatMsg_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCRoomChatMsg_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCRoomChatMsg",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCRoomChatMsg::Setup();
        return 0;
    }
    gxError("MCRoomChatMsg:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCRoomChatMsg_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCRoomChatMsg_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCRoomChatMsg",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCRoomChatMsg::Unsetup();
        return 0;
    }
    gxError("MCRoomChatMsg:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCRoomChatMsg_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCRoomChatMsg_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCRoomChatMsg",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCRoomChatMsg* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCRoomChatMsg>(tolua_S, 2, "MCRoomChatMsg", &arg0, "MCRoomChatMsg:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCRoomChatMsg:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCRoomChatMsg:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCRoomChatMsg::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCRoomChatMsg:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCRoomChatMsg_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCRoomChatMsg_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCRoomChatMsg* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCRoomChatMsg();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCRoomChatMsg");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCRoomChatMsg:MCRoomChatMsg has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCRoomChatMsg_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCRoomChatMsg)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCRoomChatMsg",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCRoomChatMsg* self = (MCRoomChatMsg*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCRoomChatMsg(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCRoomChatMsg");
    tolua_cclass(tolua_S,"MCRoomChatMsg","MCRoomChatMsg","CServerPacket",lua_mapserver_MCRoomChatMsg_finalize);

    tolua_beginmodule(tolua_S,"MCRoomChatMsg");
        tolua_function(tolua_S,"new",lua_mapserver_MCRoomChatMsg_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCRoomChatMsg_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCRoomChatMsg_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCRoomChatMsg_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCRoomChatMsg_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCRoomChatMsg).name();
    g_luaType[typeName] = "MCRoomChatMsg";
    g_typeCast["MCRoomChatMsg"] = "MCRoomChatMsg";
    return 1;
}

int lua_mapserver_MCScreenAnnounce_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCScreenAnnounce* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCScreenAnnounce",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCScreenAnnounce*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCScreenAnnounce_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCScreenAnnounce:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCScreenAnnounce_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCScreenAnnounce_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCScreenAnnounce",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCScreenAnnounce::Setup();
        return 0;
    }
    gxError("MCScreenAnnounce:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCScreenAnnounce_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCScreenAnnounce_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCScreenAnnounce",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCScreenAnnounce::Unsetup();
        return 0;
    }
    gxError("MCScreenAnnounce:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCScreenAnnounce_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCScreenAnnounce_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCScreenAnnounce",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCScreenAnnounce* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCScreenAnnounce>(tolua_S, 2, "MCScreenAnnounce", &arg0, "MCScreenAnnounce:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCScreenAnnounce:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCScreenAnnounce:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCScreenAnnounce::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCScreenAnnounce:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCScreenAnnounce_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCScreenAnnounce_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCScreenAnnounce* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCScreenAnnounce();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCScreenAnnounce");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCScreenAnnounce:MCScreenAnnounce has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCScreenAnnounce_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCScreenAnnounce)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCScreenAnnounce",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCScreenAnnounce* self = (MCScreenAnnounce*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCScreenAnnounce(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCScreenAnnounce");
    tolua_cclass(tolua_S,"MCScreenAnnounce","MCScreenAnnounce","CServerPacket",lua_mapserver_MCScreenAnnounce_finalize);

    tolua_beginmodule(tolua_S,"MCScreenAnnounce");
        tolua_function(tolua_S,"new",lua_mapserver_MCScreenAnnounce_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCScreenAnnounce_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCScreenAnnounce_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCScreenAnnounce_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCScreenAnnounce_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCScreenAnnounce).name();
    g_luaType[typeName] = "MCScreenAnnounce";
    g_typeCast["MCScreenAnnounce"] = "MCScreenAnnounce";
    return 1;
}

int lua_mapserver_CModChat_toChatBroadMsg(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_toChatBroadMsg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        MCChatBroad* arg0;
        CMChat* arg1;

        ok &= luaval_to_object<MCChatBroad>(tolua_S, 2, "MCChatBroad", &arg0, "CModChat:toChatBroadMsg");

        ok &= luaval_to_object<CMChat>(tolua_S, 3, "CMChat", &arg1, "CModChat:toChatBroadMsg");
        if(!ok)
            return 0;
        cobj->toChatBroadMsg(arg0, arg1);
        return 0;
    }

    gxError("CModChat:toChatBroadMsg has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_toChatBroadMsg'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_onLoad(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_onLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onLoad();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModChat:onLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_onLoad'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_reSetTime(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_reSetTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CModChat:reSetTime");
        if(!ok)
            return 0;
        cobj->reSetTime(arg0);
        return 0;
    }

    gxError("CModChat:reSetTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_reSetTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_chatFaction(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_chatFaction'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMChat* arg0;

        ok &= luaval_to_object<CMChat>(tolua_S, 2, "CMChat", &arg0, "CModChat:chatFaction");
        if(!ok)
            return 0;
        cobj->chatFaction(arg0);
        return 0;
    }

    gxError("CModChat:chatFaction has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_chatFaction'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_chatWorld(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_chatWorld'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMChat* arg0;

        ok &= luaval_to_object<CMChat>(tolua_S, 2, "CMChat", &arg0, "CModChat:chatWorld");
        if(!ok)
            return 0;
        cobj->chatWorld(arg0);
        return 0;
    }

    gxError("CModChat:chatWorld has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_chatWorld'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_isHaveOtherForbid(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_isHaveOtherForbid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharArray2<250> arg0;

        ok &= luaval_to_array_string2(tolua_S, 2,&arg0, "CModChat:isHaveOtherForbid");
        if(!ok)
            return 0;
        bool ret = cobj->isHaveOtherForbid(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModChat:isHaveOtherForbid has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_isHaveOtherForbid'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_isTimePassed(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_isTimePassed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CModChat:isTimePassed");
        if(!ok)
            return 0;
        bool ret = cobj->isTimePassed(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModChat:isTimePassed has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_isTimePassed'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_chatFriend(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_chatFriend'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMChat* arg0;

        ok &= luaval_to_object<CMChat>(tolua_S, 2, "CMChat", &arg0, "CModChat:chatFriend");
        if(!ok)
            return 0;
        cobj->chatFriend(arg0);
        return 0;
    }

    gxError("CModChat:chatFriend has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_chatFriend'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_update(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CModChat:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CModChat:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_isCanChatSystem(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_isCanChatSystem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMChat* arg0;

        ok &= luaval_to_object<CMChat>(tolua_S, 2, "CMChat", &arg0, "CModChat:isCanChatSystem");
        if(!ok)
            return 0;
        int ret = (int)cobj->isCanChatSystem(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModChat:isCanChatSystem has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_isCanChatSystem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_init(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CRole* arg0;

        ok &= luaval_to_object<CRole>(tolua_S, 2, "CRole", &arg0, "CModChat:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 2) 
    {
        CRole* arg0;
        unsigned int arg1;

        ok &= luaval_to_object<CRole>(tolua_S, 2, "CRole", &arg0, "CModChat:init");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CModChat:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModChat:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_isCanChatFaction(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_isCanChatFaction'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMChat* arg0;

        ok &= luaval_to_object<CMChat>(tolua_S, 2, "CMChat", &arg0, "CModChat:isCanChatFaction");
        if(!ok)
            return 0;
        int ret = (int)cobj->isCanChatFaction(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModChat:isCanChatFaction has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_isCanChatFaction'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_isCanChatWorld(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_isCanChatWorld'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMChat* arg0;

        ok &= luaval_to_object<CMChat>(tolua_S, 2, "CMChat", &arg0, "CModChat:isCanChatWorld");
        if(!ok)
            return 0;
        int ret = (int)cobj->isCanChatWorld(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModChat:isCanChatWorld has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_isCanChatWorld'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_chatGm(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_chatGm'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMChat* arg0;

        ok &= luaval_to_object<CMChat>(tolua_S, 2, "CMChat", &arg0, "CModChat:chatGm");
        if(!ok)
            return 0;
        cobj->chatGm(arg0);
        return 0;
    }

    gxError("CModChat:chatGm has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_chatGm'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_isCanChatFriend(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_isCanChatFriend'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMChat* arg0;

        ok &= luaval_to_object<CMChat>(tolua_S, 2, "CMChat", &arg0, "CModChat:isCanChatFriend");
        if(!ok)
            return 0;
        int ret = (int)cobj->isCanChatFriend(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModChat:isCanChatFriend has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_isCanChatFriend'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_isMsgContentAllSpace(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_isMsgContentAllSpace'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharArray2<250> arg0;

        ok &= luaval_to_array_string2(tolua_S, 2,&arg0, "CModChat:isMsgContentAllSpace");
        if(!ok)
            return 0;
        bool ret = cobj->isMsgContentAllSpace(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModChat:isMsgContentAllSpace has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_isMsgContentAllSpace'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_chatSystem(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_chatSystem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMChat* arg0;

        ok &= luaval_to_object<CMChat>(tolua_S, 2, "CMChat", &arg0, "CModChat:chatSystem");
        if(!ok)
            return 0;
        cobj->chatSystem(arg0);
        return 0;
    }

    gxError("CModChat:chatSystem has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_chatSystem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_updateMax(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModChat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModChat_updateMax'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->updateMax();
        return 0;
    }

    gxError("CModChat:updateMax has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_updateMax'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModChat_doFilterContent(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CModChat",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        CCharArray2<250> arg0;
        std::vector<std::string> arg1;
        ok &= luaval_to_array_string2(tolua_S, 2,&arg0, "CModChat:doFilterContent");
        ok &= luaval_to_vector(tolua_S, 3, "std::vector<std::basic_string<char>, std::allocator<std::basic_string<char> > >", &arg1, "CModChat:doFilterContent");
        if(!ok)
            return 0;
        CModChat::doFilterContent(arg0, arg1);
        return 0;
    }
    gxError("CModChat:doFilterContent has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModChat_doFilterContent'.", &tolua_err);
    return 0;
}
int lua_mapserver_CModChat_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CModChat* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CModChat();
        tolua_pushusertype(tolua_S,(void*)cobj,"CModChat");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CModChat:CModChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CModChat_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CModChat)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CModChat",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CModChat* self = (CModChat*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CModChat(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CModChat");
    tolua_cclass(tolua_S,"CModChat","CModChat","CGameRoleModule",lua_mapserver_CModChat_finalize);

    tolua_beginmodule(tolua_S,"CModChat");
        tolua_function(tolua_S,"new",lua_mapserver_CModChat_constructor);
        tolua_function(tolua_S,"toChatBroadMsg",lua_mapserver_CModChat_toChatBroadMsg);
        tolua_function(tolua_S,"onLoad",lua_mapserver_CModChat_onLoad);
        tolua_function(tolua_S,"reSetTime",lua_mapserver_CModChat_reSetTime);
        tolua_function(tolua_S,"chatFaction",lua_mapserver_CModChat_chatFaction);
        tolua_function(tolua_S,"chatWorld",lua_mapserver_CModChat_chatWorld);
        tolua_function(tolua_S,"isHaveOtherForbid",lua_mapserver_CModChat_isHaveOtherForbid);
        tolua_function(tolua_S,"isTimePassed",lua_mapserver_CModChat_isTimePassed);
        tolua_function(tolua_S,"chatFriend",lua_mapserver_CModChat_chatFriend);
        tolua_function(tolua_S,"update",lua_mapserver_CModChat_update);
        tolua_function(tolua_S,"isCanChatSystem",lua_mapserver_CModChat_isCanChatSystem);
        tolua_function(tolua_S,"init",lua_mapserver_CModChat_init);
        tolua_function(tolua_S,"isCanChatFaction",lua_mapserver_CModChat_isCanChatFaction);
        tolua_function(tolua_S,"isCanChatWorld",lua_mapserver_CModChat_isCanChatWorld);
        tolua_function(tolua_S,"chatGm",lua_mapserver_CModChat_chatGm);
        tolua_function(tolua_S,"isCanChatFriend",lua_mapserver_CModChat_isCanChatFriend);
        tolua_function(tolua_S,"isMsgContentAllSpace",lua_mapserver_CModChat_isMsgContentAllSpace);
        tolua_function(tolua_S,"chatSystem",lua_mapserver_CModChat_chatSystem);
        tolua_function(tolua_S,"updateMax",lua_mapserver_CModChat_updateMax);
        tolua_function(tolua_S,"doFilterContent", lua_mapserver_CModChat_doFilterContent);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CModChat).name();
    g_luaType[typeName] = "CModChat";
    g_typeCast["CModChat"] = "CModChat";
    return 1;
}

int lua_mapserver_CDhmTbl_checkTblConfig(lua_State* tolua_S)
{
    int argc = 0;
    CDhmTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDhmTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDhmTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDhmTbl_checkTblConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->checkTblConfig();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDhmTbl:checkTblConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDhmTbl_checkTblConfig'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDhmTbl_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CDhmTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDhmTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDhmTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDhmTbl_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDhmTbl:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDhmTbl_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDhmTbl_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CDhmTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDhmTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDhmTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDhmTbl_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CDhmTbl:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDhmTbl_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDhmTbl_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CDhmTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDhmTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDhmTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDhmTbl_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        short ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDhmTbl:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDhmTbl_getKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDhmTbl_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CDhmTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDhmTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDhmTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDhmTbl_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        short arg0;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CDhmTbl:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CDhmTbl:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDhmTbl_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDhmTbl_toString(lua_State* tolua_S)
{
    int argc = 0;
    CDhmTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDhmTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDhmTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDhmTbl_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CDhmTbl:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDhmTbl_toString'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CDhmTbl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDhmTbl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDhmTbl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CDhmTbl* self = (CDhmTbl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CDhmTbl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDhmTbl");
    tolua_cclass(tolua_S,"CDhmTbl","CDhmTbl","CConfigTbl",nullptr);

    tolua_beginmodule(tolua_S,"CDhmTbl");
        tolua_function(tolua_S,"checkTblConfig",lua_mapserver_CDhmTbl_checkTblConfig);
        tolua_function(tolua_S,"isKey",lua_mapserver_CDhmTbl_isKey);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CDhmTbl_keyToString);
        tolua_function(tolua_S,"getKey",lua_mapserver_CDhmTbl_getKey);
        tolua_function(tolua_S,"setKey",lua_mapserver_CDhmTbl_setKey);
        tolua_function(tolua_S,"toString",lua_mapserver_CDhmTbl_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CDhmTbl).name();
    g_luaType[typeName] = "CDhmTbl";
    g_typeCast["CDhmTbl"] = "CDhmTbl";
    return 1;
}

int lua_mapserver_CDhmTblLoader_findByKey(lua_State* tolua_S)
{
    int argc = 0;
    CDhmTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDhmTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDhmTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDhmTblLoader_findByKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        short arg0;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CDhmTblLoader:findByKey");
        if(!ok)
            return 0;
        CDhmTbl* ret = cobj->findByKey(arg0);
        object_to_luaval<CDhmTbl>(tolua_S, "CDhmTbl",(CDhmTbl*)ret);
        return 1;
    }

    gxError("CDhmTblLoader:findByKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDhmTblLoader_findByKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDhmTblLoader_readRow(lua_State* tolua_S)
{
    int argc = 0;
    CDhmTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDhmTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDhmTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDhmTblLoader_readRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        TiXmlElement* arg0;
        int arg1;
        CDhmTbl* arg2;

        ok &= luaval_to_object<TiXmlElement>(tolua_S, 2, "TiXmlElement", &arg0, "CDhmTblLoader:readRow");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CDhmTblLoader:readRow");

        ok &= luaval_to_object<CDhmTbl>(tolua_S, 4, "CDhmTbl", &arg2, "CDhmTblLoader:readRow");
        if(!ok)
            return 0;
        bool ret = cobj->readRow(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDhmTblLoader:readRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDhmTblLoader_readRow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDhmTblLoader_setId(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CDhmTblLoader",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        CDhmTbl* arg0;
        ok &= luaval_to_object<CDhmTbl>(tolua_S, 2, "CDhmTbl", &arg0, "CDhmTblLoader:setId");
        if(!ok)
            return 0;
        CDhmTblLoader::setId(arg0);
        return 0;
    }
    gxError("CDhmTblLoader:setId has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDhmTblLoader_setId'.", &tolua_err);
    return 0;
}
int lua_mapserver_CDhmTblLoader_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CDhmTblLoader",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CDhmTblLoader* ret = CDhmTblLoader::GetPtr();
        object_to_luaval<CDhmTblLoader>(tolua_S, "CDhmTblLoader",(CDhmTblLoader*)ret);
        return 1;
    }
    gxError("CDhmTblLoader:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDhmTblLoader_GetPtr'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CDhmTblLoader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDhmTblLoader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDhmTblLoader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CDhmTblLoader* self = (CDhmTblLoader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CDhmTblLoader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDhmTblLoader");
    tolua_cclass(tolua_S,"CDhmTblLoader","CDhmTblLoader","CConfigLoader<CDhmTblLoader, CDhmTbl>",nullptr);

    tolua_beginmodule(tolua_S,"CDhmTblLoader");
        tolua_function(tolua_S,"findByKey",lua_mapserver_CDhmTblLoader_findByKey);
        tolua_function(tolua_S,"readRow",lua_mapserver_CDhmTblLoader_readRow);
        tolua_function(tolua_S,"setId", lua_mapserver_CDhmTblLoader_setId);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CDhmTblLoader_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CDhmTblLoader).name();
    g_luaType[typeName] = "CDhmTblLoader";
    g_typeCast["CDhmTblLoader"] = "CDhmTblLoader";
    return 1;
}

int lua_mapserver_ItemPosition_isValid(lua_State* tolua_S)
{
    int argc = 0;
    ItemPosition* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ItemPosition",0,&tolua_err)) goto tolua_lerror;
    cobj = (ItemPosition*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_ItemPosition_isValid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isValid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("ItemPosition:isValid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_ItemPosition_isValid'.",&tolua_err);
	return 0;
}
int lua_mapserver_ItemPosition_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    ItemPosition* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ItemPosition",0,&tolua_err)) goto tolua_lerror;
    cobj = (ItemPosition*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_ItemPosition_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("ItemPosition:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_ItemPosition_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_ItemPosition_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ItemPosition* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            unsigned char arg0;
            ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "ItemPosition:ItemPosition");

            if (!ok) { break; }
            unsigned char arg1;
            ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "ItemPosition:ItemPosition");

            if (!ok) { break; }
            cobj = new ItemPosition(arg0, arg1);
            tolua_pushusertype(tolua_S,(void*)cobj,"ItemPosition");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new ItemPosition();
            tolua_pushusertype(tolua_S,(void*)cobj,"ItemPosition");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("ItemPosition:ItemPosition has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_ItemPosition_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ItemPosition)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ItemPosition",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ItemPosition* self = (ItemPosition*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ItemPosition(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ItemPosition");
    tolua_cclass(tolua_S,"ItemPosition","ItemPosition","",lua_mapserver_ItemPosition_finalize);

    tolua_beginmodule(tolua_S,"ItemPosition");
        tolua_function(tolua_S,"new",lua_mapserver_ItemPosition_constructor);
        tolua_function(tolua_S,"isValid",lua_mapserver_ItemPosition_isValid);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_ItemPosition_cleanUp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ItemPosition).name();
    g_luaType[typeName] = "ItemPosition";
    g_typeCast["ItemPosition"] = "ItemPosition";
    return 1;
}

int lua_mapserver_HoleGemInfo_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    HoleGemInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"HoleGemInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (HoleGemInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_HoleGemInfo_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned char arg0;
        unsigned short arg1;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "HoleGemInfo:cleanUp");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "HoleGemInfo:cleanUp");
        if(!ok)
            return 0;
        cobj->cleanUp(arg0, arg1);
        return 0;
    }

    gxError("HoleGemInfo:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_HoleGemInfo_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_HoleGemInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    HoleGemInfo* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            unsigned char arg0;
            ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "HoleGemInfo:HoleGemInfo");

            if (!ok) { break; }
            unsigned short arg1;
            ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "HoleGemInfo:HoleGemInfo");

            if (!ok) { break; }
            cobj = new HoleGemInfo(arg0, arg1);
            tolua_pushusertype(tolua_S,(void*)cobj,"HoleGemInfo");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new HoleGemInfo();
            tolua_pushusertype(tolua_S,(void*)cobj,"HoleGemInfo");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("HoleGemInfo:HoleGemInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_HoleGemInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (HoleGemInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"HoleGemInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        HoleGemInfo* self = (HoleGemInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_HoleGemInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"HoleGemInfo");
    tolua_cclass(tolua_S,"HoleGemInfo","HoleGemInfo","",lua_mapserver_HoleGemInfo_finalize);

    tolua_beginmodule(tolua_S,"HoleGemInfo");
        tolua_function(tolua_S,"new",lua_mapserver_HoleGemInfo_constructor);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_HoleGemInfo_cleanUp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(HoleGemInfo).name();
    g_luaType[typeName] = "HoleGemInfo";
    g_typeCast["HoleGemInfo"] = "HoleGemInfo";
    return 1;
}

static int lua_mapserver__ItemType_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_ItemType)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_ItemType",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _ItemType* self = (_ItemType*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__ItemType(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_ItemType");
    tolua_cclass(tolua_S,"_ItemType","_ItemType","",nullptr);

    tolua_beginmodule(tolua_S,"_ItemType");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_ItemType).name();
    g_luaType[typeName] = "_ItemType";
    g_typeCast["_ItemType"] = "_ItemType";
    return 1;
}

int lua_mapserver_MoveItem_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MoveItem* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MoveItem();
        tolua_pushusertype(tolua_S,(void*)cobj,"MoveItem");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MoveItem:MoveItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MoveItem_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MoveItem)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MoveItem",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MoveItem* self = (MoveItem*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MoveItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MoveItem");
    tolua_cclass(tolua_S,"MoveItem","MoveItem","",lua_mapserver_MoveItem_finalize);

    tolua_beginmodule(tolua_S,"MoveItem");
        tolua_function(tolua_S,"new",lua_mapserver_MoveItem_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MoveItem).name();
    g_luaType[typeName] = "MoveItem";
    g_typeCast["MoveItem"] = "MoveItem";
    return 1;
}

int lua_mapserver_UpdateItem_constructor(lua_State* tolua_S)
{
    int argc = 0;
    UpdateItem* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new UpdateItem();
        tolua_pushusertype(tolua_S,(void*)cobj,"UpdateItem");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("UpdateItem:UpdateItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_UpdateItem_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (UpdateItem)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"UpdateItem",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        UpdateItem* self = (UpdateItem*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_UpdateItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"UpdateItem");
    tolua_cclass(tolua_S,"UpdateItem","UpdateItem","",lua_mapserver_UpdateItem_finalize);

    tolua_beginmodule(tolua_S,"UpdateItem");
        tolua_function(tolua_S,"new",lua_mapserver_UpdateItem_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(UpdateItem).name();
    g_luaType[typeName] = "UpdateItem";
    g_typeCast["UpdateItem"] = "UpdateItem";
    return 1;
}

int lua_mapserver_SimpleItem_constructor(lua_State* tolua_S)
{
    int argc = 0;
    SimpleItem* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "SimpleItem:SimpleItem");

            if (!ok) { break; }
            short arg1;
            ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "SimpleItem:SimpleItem");

            if (!ok) { break; }
            cobj = new SimpleItem(arg0, arg1);
            tolua_pushusertype(tolua_S,(void*)cobj,"SimpleItem");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new SimpleItem();
            tolua_pushusertype(tolua_S,(void*)cobj,"SimpleItem");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("SimpleItem:SimpleItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_SimpleItem_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (SimpleItem)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"SimpleItem",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        SimpleItem* self = (SimpleItem*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_SimpleItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"SimpleItem");
    tolua_cclass(tolua_S,"SimpleItem","SimpleItem","",lua_mapserver_SimpleItem_finalize);

    tolua_beginmodule(tolua_S,"SimpleItem");
        tolua_function(tolua_S,"new",lua_mapserver_SimpleItem_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(SimpleItem).name();
    g_luaType[typeName] = "SimpleItem";
    g_typeCast["SimpleItem"] = "SimpleItem";
    return 1;
}

int lua_mapserver_ExtItem_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ExtItem* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new ExtItem();
        tolua_pushusertype(tolua_S,(void*)cobj,"ExtItem");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("ExtItem:ExtItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_ExtItem_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ExtItem)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ExtItem",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ExtItem* self = (ExtItem*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ExtItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ExtItem");
    tolua_cclass(tolua_S,"ExtItem","ExtItem","",lua_mapserver_ExtItem_finalize);

    tolua_beginmodule(tolua_S,"ExtItem");
        tolua_function(tolua_S,"new",lua_mapserver_ExtItem_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ExtItem).name();
    g_luaType[typeName] = "ExtItem";
    g_typeCast["ExtItem"] = "ExtItem";
    return 1;
}

int lua_mapserver_ItemReward_clean(lua_State* tolua_S)
{
    int argc = 0;
    ItemReward* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ItemReward",0,&tolua_err)) goto tolua_lerror;
    cobj = (ItemReward*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_ItemReward_clean'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->clean();
        return 0;
    }

    gxError("ItemReward:clean has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_ItemReward_clean'.",&tolua_err);
	return 0;
}
int lua_mapserver_ItemReward_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ItemReward* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "ItemReward:ItemReward");

            if (!ok) { break; }
            unsigned int arg1;
            ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "ItemReward:ItemReward");

            if (!ok) { break; }
            cobj = new ItemReward(arg0, arg1);
            tolua_pushusertype(tolua_S,(void*)cobj,"ItemReward");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new ItemReward();
            tolua_pushusertype(tolua_S,(void*)cobj,"ItemReward");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("ItemReward:ItemReward has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_ItemReward_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ItemReward)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ItemReward",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ItemReward* self = (ItemReward*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ItemReward(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ItemReward");
    tolua_cclass(tolua_S,"ItemReward","ItemReward","",lua_mapserver_ItemReward_finalize);

    tolua_beginmodule(tolua_S,"ItemReward");
        tolua_function(tolua_S,"new",lua_mapserver_ItemReward_constructor);
        tolua_function(tolua_S,"clean",lua_mapserver_ItemReward_clean);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ItemReward).name();
    g_luaType[typeName] = "ItemReward";
    g_typeCast["ItemReward"] = "ItemReward";
    return 1;
}

int lua_mapserver_PackItem_toString(lua_State* tolua_S)
{
    int argc = 0;
    PackItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"PackItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (PackItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_PackItem_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("PackItem:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_PackItem_toString'.",&tolua_err);
	return 0;
}
static int lua_mapserver_PackItem_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PackItem)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PackItem",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PackItem* self = (PackItem*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PackItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PackItem");
    tolua_cclass(tolua_S,"PackItem","PackItem","IStreamableAll",nullptr);

    tolua_beginmodule(tolua_S,"PackItem");
        tolua_function(tolua_S,"toString",lua_mapserver_PackItem_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PackItem).name();
    g_luaType[typeName] = "PackItem";
    g_typeCast["PackItem"] = "PackItem";
    return 1;
}

static int lua_mapserver__DBAppendAttr_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_DBAppendAttr)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_DBAppendAttr",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _DBAppendAttr* self = (_DBAppendAttr*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__DBAppendAttr(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_DBAppendAttr");
    tolua_cclass(tolua_S,"_DBAppendAttr","_DBAppendAttr","TDBStructBase",nullptr);

    tolua_beginmodule(tolua_S,"_DBAppendAttr");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_DBAppendAttr).name();
    g_luaType[typeName] = "_DBAppendAttr";
    g_typeCast["_DBAppendAttr"] = "_DBAppendAttr";
    return 1;
}

static int lua_mapserver__DBGemFix_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_DBGemFix)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_DBGemFix",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _DBGemFix* self = (_DBGemFix*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__DBGemFix(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_DBGemFix");
    tolua_cclass(tolua_S,"_DBGemFix","_DBGemFix","TDBStructBase",nullptr);

    tolua_beginmodule(tolua_S,"_DBGemFix");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_DBGemFix).name();
    g_luaType[typeName] = "_DBGemFix";
    g_typeCast["_DBGemFix"] = "_DBGemFix";
    return 1;
}

int lua_mapserver__DbBaseItem_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    _DbBaseItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_DbBaseItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (_DbBaseItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__DbBaseItem_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("_DbBaseItem:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__DbBaseItem_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver__DbBaseItem_toString(lua_State* tolua_S)
{
    int argc = 0;
    _DbBaseItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_DbBaseItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (_DbBaseItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__DbBaseItem_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("_DbBaseItem:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__DbBaseItem_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver__DbBaseItem_getRemainTime(lua_State* tolua_S)
{
    int argc = 0;
    _DbBaseItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_DbBaseItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (_DbBaseItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__DbBaseItem_getRemainTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getRemainTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("_DbBaseItem:getRemainTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__DbBaseItem_getRemainTime'.",&tolua_err);
	return 0;
}
int lua_mapserver__DbBaseItem_constructor(lua_State* tolua_S)
{
    int argc = 0;
    _DbBaseItem* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new _DbBaseItem();
        tolua_pushusertype(tolua_S,(void*)cobj,"_DbBaseItem");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("_DbBaseItem:_DbBaseItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver__DbBaseItem_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_DbBaseItem)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_DbBaseItem",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _DbBaseItem* self = (_DbBaseItem*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__DbBaseItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_DbBaseItem");
    tolua_cclass(tolua_S,"_DbBaseItem","_DbBaseItem","TDBStructBase",lua_mapserver__DbBaseItem_finalize);

    tolua_beginmodule(tolua_S,"_DbBaseItem");
        tolua_function(tolua_S,"new",lua_mapserver__DbBaseItem_constructor);
        tolua_function(tolua_S,"cleanUp",lua_mapserver__DbBaseItem_cleanUp);
        tolua_function(tolua_S,"toString",lua_mapserver__DbBaseItem_toString);
        tolua_function(tolua_S,"getRemainTime",lua_mapserver__DbBaseItem_getRemainTime);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_DbBaseItem).name();
    g_luaType[typeName] = "_DbBaseItem";
    g_typeCast["_DbBaseItem"] = "_DbBaseItem";
    return 1;
}

int lua_mapserver__DbItem_isNull(lua_State* tolua_S)
{
    int argc = 0;
    _DbItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_DbItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (_DbItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__DbItem_isNull'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNull();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("_DbItem:isNull has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__DbItem_isNull'.",&tolua_err);
	return 0;
}
int lua_mapserver__DbItem_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    _DbItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_DbItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (_DbItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__DbItem_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("_DbItem:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__DbItem_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver__DbItem_constructor(lua_State* tolua_S)
{
    int argc = 0;
    _DbItem* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            const _DbBaseItem* arg0;
            ok &= luaval_to_object<const _DbBaseItem>(tolua_S, 2, "_DbBaseItem", &arg0, "_DbItem:_DbItem");

            if (!ok) { break; }
            cobj = new _DbItem(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"_DbItem");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new _DbItem();
            tolua_pushusertype(tolua_S,(void*)cobj,"_DbItem");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("_DbItem:_DbItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver__DbItem_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_DbItem)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_DbItem",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _DbItem* self = (_DbItem*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__DbItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_DbItem");
    tolua_cclass(tolua_S,"_DbItem","_DbItem","TDbBaseItem",lua_mapserver__DbItem_finalize);

    tolua_beginmodule(tolua_S,"_DbItem");
        tolua_function(tolua_S,"new",lua_mapserver__DbItem_constructor);
        tolua_function(tolua_S,"isNull",lua_mapserver__DbItem_isNull);
        tolua_function(tolua_S,"cleanUp",lua_mapserver__DbItem_cleanUp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_DbItem).name();
    g_luaType[typeName] = "_DbItem";
    g_typeCast["_DbItem"] = "_DbItem";
    return 1;
}

static int lua_mapserver_TGMFunc_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (TGMFunc)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"TGMFunc",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        TGMFunc* self = (TGMFunc*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_TGMFunc(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"TGMFunc");
    tolua_cclass(tolua_S,"TGMFunc","TGMFunc","",nullptr);

    tolua_beginmodule(tolua_S,"TGMFunc");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(TGMFunc).name();
    g_luaType[typeName] = "TGMFunc";
    g_typeCast["TGMFunc"] = "TGMFunc";
    return 1;
}

int lua_mapserver_CGmCmdFunc_parse(lua_State* tolua_S)
{
    int argc = 0;
    CGmCmdFunc* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGmCmdFunc",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGmCmdFunc*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGmCmdFunc_parse'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CRole* arg0;
        GXMISC::CFixString<500> arg1;

        ok &= luaval_to_object<CRole>(tolua_S, 2, "CRole", &arg0, "CGmCmdFunc:parse");

        ok &= luaval_to_fixstring(tolua_S, 3,&arg1, "CGmCmdFunc:parse");
        if(!ok)
            return 0;
        int ret = (int)cobj->parse(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGmCmdFunc:parse has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGmCmdFunc_parse'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGmCmdFunc_init(lua_State* tolua_S)
{
    int argc = 0;
    CGmCmdFunc* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGmCmdFunc",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGmCmdFunc*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGmCmdFunc_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CGmCmdFunc:init");
        if(!ok)
            return 0;
        cobj->init(arg0);
        return 0;
    }

    gxError("CGmCmdFunc:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGmCmdFunc_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGmCmdFunc_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGmCmdFunc",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CGmCmdFunc* ret = CGmCmdFunc::GetPtr();
        object_to_luaval<CGmCmdFunc>(tolua_S, "CGmCmdFunc",(CGmCmdFunc*)ret);
        return 1;
    }
    gxError("CGmCmdFunc:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGmCmdFunc_GetPtr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGmCmdFunc_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CGmCmdFunc* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CGmCmdFunc();
        tolua_pushusertype(tolua_S,(void*)cobj,"CGmCmdFunc");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CGmCmdFunc:CGmCmdFunc has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CGmCmdFunc_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGmCmdFunc)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGmCmdFunc",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CGmCmdFunc* self = (CGmCmdFunc*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CGmCmdFunc(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGmCmdFunc");
    tolua_cclass(tolua_S,"CGmCmdFunc","CGmCmdFunc","CManualSingleton<CGmCmdFunc>",lua_mapserver_CGmCmdFunc_finalize);

    tolua_beginmodule(tolua_S,"CGmCmdFunc");
        tolua_function(tolua_S,"new",lua_mapserver_CGmCmdFunc_constructor);
        tolua_function(tolua_S,"parse",lua_mapserver_CGmCmdFunc_parse);
        tolua_function(tolua_S,"init",lua_mapserver_CGmCmdFunc_init);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CGmCmdFunc_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CGmCmdFunc).name();
    g_luaType[typeName] = "CGmCmdFunc";
    g_typeCast["CGmCmdFunc"] = "CGmCmdFunc";
    return 1;
}

int lua_mapserver_CItemHelper_BagMoveItem(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItemHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        CRole* arg0;
        unsigned char arg1;
        unsigned char arg2;
        ok &= luaval_to_object<CRole>(tolua_S, 2, "CRole", &arg0, "CItemHelper:BagMoveItem");
        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemHelper:BagMoveItem");
        ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CItemHelper:BagMoveItem");
        if(!ok)
            return 0;
        int ret = (int)CItemHelper::BagMoveItem(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CItemHelper:BagMoveItem has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemHelper_BagMoveItem'.", &tolua_err);
    return 0;
}
int lua_mapserver_CItemHelper_AddItemToBag(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItemHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 5)
    {
        EItemRecordType arg0;
        CRole* arg1;
        unsigned short arg2;
        short arg3;
        bool arg4;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemHelper:AddItemToBag");
        ok &= luaval_to_object<CRole>(tolua_S, 3, "CRole", &arg1, "CItemHelper:AddItemToBag");
        ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CItemHelper:AddItemToBag");
        ok &= luaval_to_sint16(tolua_S, 5,(sint16*)&arg3, "CItemHelper:AddItemToBag");
        ok &= luaval_to_boolean(tolua_S, 6,(bool*)&arg4, "CItemHelper:AddItemToBag");
        if(!ok)
            return 0;
        int ret = (int)CItemHelper::AddItemToBag(arg0, arg1, arg2, arg3, arg4);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CItemHelper:AddItemToBag has wrong number of arguments: {0}, was expecting {1}\n ", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemHelper_AddItemToBag'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CItemHelper_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CItemHelper)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CItemHelper",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CItemHelper* self = (CItemHelper*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CItemHelper(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CItemHelper");
    tolua_cclass(tolua_S,"CItemHelper","CItemHelper","",nullptr);

    tolua_beginmodule(tolua_S,"CItemHelper");
        tolua_function(tolua_S,"BagMoveItem", lua_mapserver_CItemHelper_BagMoveItem);
        tolua_function(tolua_S,"AddItemToBag", lua_mapserver_CItemHelper_AddItemToBag);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CItemHelper).name();
    g_luaType[typeName] = "CItemHelper";
    g_typeCast["CItemHelper"] = "CItemHelper";
    return 1;
}

int lua_mapserver_CItemInit_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CItemInit* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const _DbItem* arg0;
        EPackType arg1;
        unsigned char arg2;

        ok &= luaval_to_object<const _DbItem>(tolua_S, 2, "_DbItem", &arg0, "CItemInit:CItemInit");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CItemInit:CItemInit");

        ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CItemInit:CItemInit");
        if(!ok)
            return 0;
        cobj = new CItemInit(arg0, arg1, arg2);
        tolua_pushusertype(tolua_S,(void*)cobj,"CItemInit");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CItemInit:CItemInit has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

}

static int lua_mapserver_CItemInit_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CItemInit)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CItemInit",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CItemInit* self = (CItemInit*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CItemInit(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CItemInit");
    tolua_cclass(tolua_S,"CItemInit","CItemInit","",lua_mapserver_CItemInit_finalize);

    tolua_beginmodule(tolua_S,"CItemInit");
        tolua_function(tolua_S,"new",lua_mapserver_CItemInit_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CItemInit).name();
    g_luaType[typeName] = "CItemInit";
    g_typeCast["CItemInit"] = "CItemInit";
    return 1;
}

int lua_mapserver_CItemTbls_getType(lua_State* tolua_S)
{
    int argc = 0;
    CItemTbls* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemTbls",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemTbls*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemTbls_getType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemTbls:getType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemTbls_getType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemTbls_getSubType(lua_State* tolua_S)
{
    int argc = 0;
    CItemTbls* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemTbls",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemTbls*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemTbls_getSubType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getSubType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemTbls:getSubType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemTbls_getSubType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemTbls_isNull(lua_State* tolua_S)
{
    int argc = 0;
    CItemTbls* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemTbls",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemTbls*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemTbls_isNull'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNull();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemTbls:isNull has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemTbls_isNull'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemTbls_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CItemTbls* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemTbls",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemTbls*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemTbls_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CItemTbls:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemTbls_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemTbls_isFashion(lua_State* tolua_S)
{
    int argc = 0;
    CItemTbls* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemTbls",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemTbls*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemTbls_isFashion'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isFashion();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemTbls:isFashion has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemTbls_isFashion'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemTbls_setLoaded(lua_State* tolua_S)
{
    int argc = 0;
    CItemTbls* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemTbls",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemTbls*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemTbls_setLoaded'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setLoaded();
        return 0;
    }

    gxError("CItemTbls:setLoaded has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemTbls_setLoaded'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemTbls_isMission(lua_State* tolua_S)
{
    int argc = 0;
    CItemTbls* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemTbls",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemTbls*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemTbls_isMission'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isMission();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemTbls:isMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemTbls_isMission'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemTbls_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CItemTbls* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CItemTbls();
        tolua_pushusertype(tolua_S,(void*)cobj,"CItemTbls");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CItemTbls:CItemTbls has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CItemTbls_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CItemTbls)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CItemTbls",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CItemTbls* self = (CItemTbls*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CItemTbls(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CItemTbls");
    tolua_cclass(tolua_S,"CItemTbls","CItemTbls","",lua_mapserver_CItemTbls_finalize);

    tolua_beginmodule(tolua_S,"CItemTbls");
        tolua_function(tolua_S,"new",lua_mapserver_CItemTbls_constructor);
        tolua_function(tolua_S,"getType",lua_mapserver_CItemTbls_getType);
        tolua_function(tolua_S,"getSubType",lua_mapserver_CItemTbls_getSubType);
        tolua_function(tolua_S,"isNull",lua_mapserver_CItemTbls_isNull);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CItemTbls_cleanUp);
        tolua_function(tolua_S,"isFashion",lua_mapserver_CItemTbls_isFashion);
        tolua_function(tolua_S,"setLoaded",lua_mapserver_CItemTbls_setLoaded);
        tolua_function(tolua_S,"isMission",lua_mapserver_CItemTbls_isMission);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CItemTbls).name();
    g_luaType[typeName] = "CItemTbls";
    g_typeCast["CItemTbls"] = "CItemTbls";
    return 1;
}

int lua_mapserver_CItem_getEmptyGemIndex(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getEmptyGemIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getEmptyGemIndex();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getEmptyGemIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getEmptyGemIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_canSell(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_canSell'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canSell();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:canSell has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_canSell'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_isSkillBook(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_isSkillBook'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isSkillBook();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:isSkillBook has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_isSkillBook'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_lock(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_lock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->lock();
        return 0;
    }

    gxError("CItem:lock has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_lock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_setGemItem(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_setGemItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned short arg0;
        unsigned char arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CItem:setGemItem");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItem:setGemItem");
        if(!ok)
            return 0;
        cobj->setGemItem(arg0, arg1);
        return 0;
    }

    gxError("CItem:setGemItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_setGemItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_updatePos(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_updatePos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->updatePos();
        return 0;
    }

    gxError("CItem:updatePos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_updatePos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getItemTbls(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getItemTbls'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const CItemTbls* ret = cobj->getItemTbls();
        object_to_luaval<CItemTbls>(tolua_S, "CItemTbls",(CItemTbls*)ret);
        return 1;
    }

    gxError("CItem:getItemTbls has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getItemTbls'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getRemainLayNum(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getRemainLayNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        short ret = cobj->getRemainLayNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getRemainLayNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getRemainLayNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CItem:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getBind(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getBind'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getBind();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getBind has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getBind'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_newItem(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_newItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 7) 
    {
        unsigned short arg0;
        short arg1;
        unsigned char arg2;
        unsigned char arg3;
        unsigned int arg4;
        unsigned int arg5;
        char arg6;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CItem:newItem");

        ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CItem:newItem");

        ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CItem:newItem");

        ok &= luaval_to_uint8(tolua_S, 5,(uint8*)&arg3, "CItem:newItem");

        ok &= luaval_to_uint32(tolua_S, 6,(uint32*)&arg4, "CItem:newItem");

        ok &= luaval_to_uint32(tolua_S, 7,(uint32*)&arg5, "CItem:newItem");

        ok &= luaval_to_sint8(tolua_S, 8,(sint8*)&arg6, "CItem:newItem");
        if(!ok)
            return 0;
        bool ret = cobj->newItem(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:newItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 7);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_newItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_toString(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CItem:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_check(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_check'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->check();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CItem:check");
        if(!ok)
            return 0;
        int ret = (int)cobj->check(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        bool arg0;
        bool arg1;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CItem:check");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CItem:check");
        if(!ok)
            return 0;
        int ret = (int)cobj->check(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 3) 
    {
        bool arg0;
        bool arg1;
        bool arg2;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CItem:check");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CItem:check");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CItem:check");
        if(!ok)
            return 0;
        int ret = (int)cobj->check(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 4) 
    {
        bool arg0;
        bool arg1;
        bool arg2;
        bool arg3;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CItem:check");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CItem:check");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CItem:check");

        ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CItem:check");
        if(!ok)
            return 0;
        int ret = (int)cobj->check(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 5) 
    {
        bool arg0;
        bool arg1;
        bool arg2;
        bool arg3;
        bool arg4;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CItem:check");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CItem:check");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CItem:check");

        ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CItem:check");

        ok &= luaval_to_boolean(tolua_S, 6,(bool*)&arg4, "CItem:check");
        if(!ok)
            return 0;
        int ret = (int)cobj->check(arg0, arg1, arg2, arg3, arg4);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:check has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_check'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_isBuffer(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_isBuffer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isBuffer();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:isBuffer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_isBuffer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getIndex(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getIndex();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getGemTypeID(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getGemTypeID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItem:getGemTypeID");
        if(!ok)
            return 0;
        unsigned short ret = cobj->getGemTypeID(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getGemTypeID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getGemTypeID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_isLock(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_isLock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isLock();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:isLock has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_isLock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_canLay(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CItem_canLay'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CItem:canLay");

            if (!ok) { break; }
            short arg1;
            ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CItem:canLay");

            if (!ok) { break; }
            unsigned char arg2;
            ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CItem:canLay");

            if (!ok) { break; }
            bool ret = cobj->canLay(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            bool ret = cobj->canLay();
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CItem:canLay has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_canLay'.",&tolua_err);
    return 0;
}
int lua_mapserver_CItem_isHoleEnchased(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_isHoleEnchased'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItem:isHoleEnchased");
        if(!ok)
            return 0;
        bool ret = cobj->isHoleEnchased(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:isHoleEnchased has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_isHoleEnchased'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getEquipQuality(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getEquipQuality'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getEquipQuality();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getEquipQuality has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getEquipQuality'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_init(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const CItemInit* arg0;

        ok &= luaval_to_object<const CItemInit>(tolua_S, 2, "CItemInit", &arg0, "CItem:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_updateItemValue(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CItem_updateItemValue'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            const _DbItem* arg0;
            ok &= luaval_to_object<const _DbItem>(tolua_S, 2, "_DbItem", &arg0, "CItem:updateItemValue");

            if (!ok) { break; }
            cobj->updateItemValue(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            const CItem* arg0;
            ok &= luaval_to_object<const CItem>(tolua_S, 2, "CItem", &arg0, "CItem:updateItemValue");

            if (!ok) { break; }
            cobj->updateItemValue(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CItem:updateItemValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_updateItemValue'.",&tolua_err);
    return 0;
}
int lua_mapserver_CItem_getAppendAttrNum(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getAppendAttrNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getAppendAttrNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getAppendAttrNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getAppendAttrNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_canLevel(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_canLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItem:canLevel");
        if(!ok)
            return 0;
        bool ret = cobj->canLevel(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:canLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_canLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_setRemainTime(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_setRemainTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CItem:setRemainTime");
        if(!ok)
            return 0;
        cobj->setRemainTime(arg0);
        return 0;
    }

    gxError("CItem:setRemainTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_setRemainTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_addStre(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_addStre'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->addStre();
        return 0;
    }
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CItem:addStre");
        if(!ok)
            return 0;
        cobj->addStre(arg0);
        return 0;
    }

    gxError("CItem:addStre has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_addStre'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_isConsume(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_isConsume'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isConsume();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:isConsume has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_isConsume'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_canEquipBind(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_canEquipBind'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canEquipBind();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:canEquipBind has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_canEquipBind'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getStre(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getStre'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        char ret = cobj->getStre();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getStre has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getStre'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_isOutDay(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_isOutDay'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isOutDay();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:isOutDay has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_isOutDay'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getItemTbl(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getItemTbl'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CItemConfigTbl* ret = cobj->getItemTbl();
        object_to_luaval<CItemConfigTbl>(tolua_S, "CItemConfigTbl",(CItemConfigTbl*)ret);
        return 1;
    }

    gxError("CItem:getItemTbl has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getItemTbl'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_canBind(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_canBind'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canBind();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:canBind has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_canBind'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getTypeID(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getTypeID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getTypeID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getTypeID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getTypeID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_decNum(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_decNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        short arg0;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CItem:decNum");
        if(!ok)
            return 0;
        bool ret = cobj->decNum(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:decNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_decNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getGemQuality(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getGemQuality'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getGemQuality();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getGemQuality has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getGemQuality'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_isGem(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_isGem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isGem();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:isGem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_isGem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_addGem(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_addGem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned short arg0;
        unsigned char arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CItem:addGem");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItem:addGem");
        if(!ok)
            return 0;
        cobj->addGem(arg0, arg1);
        return 0;
    }

    gxError("CItem:addGem has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_addGem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_isMaxNum(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_isMaxNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isMaxNum();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:isMaxNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_isMaxNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_isEquip(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_isEquip'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isEquip();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:isEquip has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_isEquip'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_hasGem(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_hasGem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->hasGem();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:hasGem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_hasGem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getEquipPoint(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getEquipPoint'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getEquipPoint();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getEquipPoint has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getEquipPoint'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_addAppendAttr(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_addAppendAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        char arg0;
        unsigned char arg1;
        int arg2;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CItem:addAppendAttr");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItem:addAppendAttr");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CItem:addAppendAttr");
        if(!ok)
            return 0;
        cobj->addAppendAttr(arg0, arg1, arg2);
        return 0;
    }

    gxError("CItem:addAppendAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_addAppendAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_setBind(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_setBind'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setBind();
        return 0;
    }
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItem:setBind");
        if(!ok)
            return 0;
        cobj->setBind(arg0);
        return 0;
    }

    gxError("CItem:setBind has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_setBind'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getType(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getMaxLayNum(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getMaxLayNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        short ret = cobj->getMaxLayNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getMaxLayNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getMaxLayNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_addNum(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_addNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        short arg0;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CItem:addNum");
        if(!ok)
            return 0;
        bool ret = cobj->addNum(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:addNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_addNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_canDestroy(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_canDestroy'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canDestroy();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:canDestroy has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_canDestroy'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getSubType(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getSubType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getSubType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getSubType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getSubType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getAppendAttr(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getAppendAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItem:getAppendAttr");
        if(!ok)
            return 0;
        const ExtendAttr* ret = cobj->getAppendAttr(arg0);
        object_to_luaval<ExtendAttr>(tolua_S, "ExtendAttr",(ExtendAttr*)ret);
        return 1;
    }

    gxError("CItem:getAppendAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getAppendAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getObjUID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_isDrug(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_isDrug'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDrug();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:isDrug has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_isDrug'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getCreateTime(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getCreateTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getCreateTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getCreateTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getCreateTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getBufferID(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getBufferID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getBufferID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getBufferID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getBufferID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getEquipType(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getEquipType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getEquipType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getEquipType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getEquipType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_isTask(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_isTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isTask();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:isTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_isTask'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getItemValue(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getItemValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const _DbItem* ret = cobj->getItemValue();
        object_to_luaval<_DbItem>(tolua_S, "_DbItem",(_DbItem*)ret);
        return 1;
    }

    gxError("CItem:getItemValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getItemValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_setStre(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_setStre'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CItem:setStre");
        if(!ok)
            return 0;
        cobj->setStre(arg0);
        return 0;
    }

    gxError("CItem:setStre has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_setStre'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_setItemPos(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_setItemPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EPackType arg0;
        unsigned char arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItem:setItemPos");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItem:setItemPos");
        if(!ok)
            return 0;
        cobj->setItemPos(arg0, arg1);
        return 0;
    }

    gxError("CItem:setItemPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_setItemPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_unLock(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_unLock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->unLock();
        return 0;
    }

    gxError("CItem:unLock has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_unLock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_delGem(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_delGem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItem:delGem");
        if(!ok)
            return 0;
        cobj->delGem(arg0);
        return 0;
    }

    gxError("CItem:delGem has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_delGem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_setItemTypeID(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_setItemTypeID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CItem:setItemTypeID");
        if(!ok)
            return 0;
        cobj->setItemTypeID(arg0);
        return 0;
    }

    gxError("CItem:setItemTypeID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_setItemTypeID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getQuality(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getQuality'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getQuality();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getQuality has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getQuality'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getGemNum(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getGemNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getGemNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getGemNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getGemNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_canStre(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_canStre'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canStre();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:canStre has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_canStre'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getCanLayNum(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getCanLayNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        short ret = cobj->getCanLayNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getCanLayNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getCanLayNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_setQuality(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_setQuality'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItem:setQuality");
        if(!ok)
            return 0;
        cobj->setQuality(arg0);
        return 0;
    }

    gxError("CItem:setQuality has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_setQuality'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getNum(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        short ret = cobj->getNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_isBind(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_isBind'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isBind();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:isBind has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_isBind'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_canWash(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_canWash'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canWash();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:canWash has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_canWash'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_empty(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_empty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->empty();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:empty has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_empty'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_setNum(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_setNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        short arg0;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CItem:setNum");
        if(!ok)
            return 0;
        cobj->setNum(arg0);
        return 0;
    }

    gxError("CItem:setNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_setNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_copyItemValue(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_copyItemValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const CItem* arg0;

        ok &= luaval_to_object<const CItem>(tolua_S, 2, "CItem", &arg0, "CItem:copyItemValue");
        if(!ok)
            return 0;
        cobj->copyItemValue(arg0);
        return 0;
    }

    gxError("CItem:copyItemValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_copyItemValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_setCreateTime(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_setCreateTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CItem:setCreateTime");
        if(!ok)
            return 0;
        cobj->setCreateTime(arg0);
        return 0;
    }

    gxError("CItem:setCreateTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_setCreateTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_isScroll(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_isScroll'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isScroll();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItem:isScroll has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_isScroll'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_getRemainTime(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItem_getRemainTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getRemainTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItem:getRemainTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_getRemainTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItem_GetEquipPoint(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItem",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        EEquipType arg0;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItem:GetEquipPoint");
        if(!ok)
            return 0;
        unsigned char ret = CItem::GetEquipPoint(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CItem:GetEquipPoint has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItem_GetEquipPoint'.", &tolua_err);
    return 0;
}
int lua_mapserver_CItem_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CItem* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CItem();
        tolua_pushusertype(tolua_S,(void*)cobj,"CItem");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CItem:CItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CItem_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CItem)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CItem",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CItem* self = (CItem*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CItem");
    tolua_cclass(tolua_S,"CItem","CItem","",lua_mapserver_CItem_finalize);

    tolua_beginmodule(tolua_S,"CItem");
        tolua_function(tolua_S,"new",lua_mapserver_CItem_constructor);
        tolua_function(tolua_S,"getEmptyGemIndex",lua_mapserver_CItem_getEmptyGemIndex);
        tolua_function(tolua_S,"canSell",lua_mapserver_CItem_canSell);
        tolua_function(tolua_S,"isSkillBook",lua_mapserver_CItem_isSkillBook);
        tolua_function(tolua_S,"lock",lua_mapserver_CItem_lock);
        tolua_function(tolua_S,"setGemItem",lua_mapserver_CItem_setGemItem);
        tolua_function(tolua_S,"updatePos",lua_mapserver_CItem_updatePos);
        tolua_function(tolua_S,"getItemTbls",lua_mapserver_CItem_getItemTbls);
        tolua_function(tolua_S,"getRemainLayNum",lua_mapserver_CItem_getRemainLayNum);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CItem_cleanUp);
        tolua_function(tolua_S,"getBind",lua_mapserver_CItem_getBind);
        tolua_function(tolua_S,"newItem",lua_mapserver_CItem_newItem);
        tolua_function(tolua_S,"toString",lua_mapserver_CItem_toString);
        tolua_function(tolua_S,"check",lua_mapserver_CItem_check);
        tolua_function(tolua_S,"isBuffer",lua_mapserver_CItem_isBuffer);
        tolua_function(tolua_S,"getIndex",lua_mapserver_CItem_getIndex);
        tolua_function(tolua_S,"getGemTypeID",lua_mapserver_CItem_getGemTypeID);
        tolua_function(tolua_S,"isLock",lua_mapserver_CItem_isLock);
        tolua_function(tolua_S,"canLay",lua_mapserver_CItem_canLay);
        tolua_function(tolua_S,"isHoleEnchased",lua_mapserver_CItem_isHoleEnchased);
        tolua_function(tolua_S,"getEquipQuality",lua_mapserver_CItem_getEquipQuality);
        tolua_function(tolua_S,"init",lua_mapserver_CItem_init);
        tolua_function(tolua_S,"updateItemValue",lua_mapserver_CItem_updateItemValue);
        tolua_function(tolua_S,"getAppendAttrNum",lua_mapserver_CItem_getAppendAttrNum);
        tolua_function(tolua_S,"canLevel",lua_mapserver_CItem_canLevel);
        tolua_function(tolua_S,"setRemainTime",lua_mapserver_CItem_setRemainTime);
        tolua_function(tolua_S,"addStre",lua_mapserver_CItem_addStre);
        tolua_function(tolua_S,"isConsume",lua_mapserver_CItem_isConsume);
        tolua_function(tolua_S,"canEquipBind",lua_mapserver_CItem_canEquipBind);
        tolua_function(tolua_S,"getStre",lua_mapserver_CItem_getStre);
        tolua_function(tolua_S,"isOutDay",lua_mapserver_CItem_isOutDay);
        tolua_function(tolua_S,"getItemTbl",lua_mapserver_CItem_getItemTbl);
        tolua_function(tolua_S,"canBind",lua_mapserver_CItem_canBind);
        tolua_function(tolua_S,"getTypeID",lua_mapserver_CItem_getTypeID);
        tolua_function(tolua_S,"decNum",lua_mapserver_CItem_decNum);
        tolua_function(tolua_S,"getGemQuality",lua_mapserver_CItem_getGemQuality);
        tolua_function(tolua_S,"isGem",lua_mapserver_CItem_isGem);
        tolua_function(tolua_S,"addGem",lua_mapserver_CItem_addGem);
        tolua_function(tolua_S,"isMaxNum",lua_mapserver_CItem_isMaxNum);
        tolua_function(tolua_S,"isEquip",lua_mapserver_CItem_isEquip);
        tolua_function(tolua_S,"hasGem",lua_mapserver_CItem_hasGem);
        tolua_function(tolua_S,"getEquipPoint",lua_mapserver_CItem_getEquipPoint);
        tolua_function(tolua_S,"addAppendAttr",lua_mapserver_CItem_addAppendAttr);
        tolua_function(tolua_S,"setBind",lua_mapserver_CItem_setBind);
        tolua_function(tolua_S,"getType",lua_mapserver_CItem_getType);
        tolua_function(tolua_S,"getMaxLayNum",lua_mapserver_CItem_getMaxLayNum);
        tolua_function(tolua_S,"addNum",lua_mapserver_CItem_addNum);
        tolua_function(tolua_S,"canDestroy",lua_mapserver_CItem_canDestroy);
        tolua_function(tolua_S,"getSubType",lua_mapserver_CItem_getSubType);
        tolua_function(tolua_S,"getAppendAttr",lua_mapserver_CItem_getAppendAttr);
        tolua_function(tolua_S,"getObjUID",lua_mapserver_CItem_getObjUID);
        tolua_function(tolua_S,"isDrug",lua_mapserver_CItem_isDrug);
        tolua_function(tolua_S,"getCreateTime",lua_mapserver_CItem_getCreateTime);
        tolua_function(tolua_S,"getBufferID",lua_mapserver_CItem_getBufferID);
        tolua_function(tolua_S,"getEquipType",lua_mapserver_CItem_getEquipType);
        tolua_function(tolua_S,"isTask",lua_mapserver_CItem_isTask);
        tolua_function(tolua_S,"getItemValue",lua_mapserver_CItem_getItemValue);
        tolua_function(tolua_S,"setStre",lua_mapserver_CItem_setStre);
        tolua_function(tolua_S,"setItemPos",lua_mapserver_CItem_setItemPos);
        tolua_function(tolua_S,"unLock",lua_mapserver_CItem_unLock);
        tolua_function(tolua_S,"delGem",lua_mapserver_CItem_delGem);
        tolua_function(tolua_S,"setItemTypeID",lua_mapserver_CItem_setItemTypeID);
        tolua_function(tolua_S,"getQuality",lua_mapserver_CItem_getQuality);
        tolua_function(tolua_S,"getGemNum",lua_mapserver_CItem_getGemNum);
        tolua_function(tolua_S,"canStre",lua_mapserver_CItem_canStre);
        tolua_function(tolua_S,"getCanLayNum",lua_mapserver_CItem_getCanLayNum);
        tolua_function(tolua_S,"setQuality",lua_mapserver_CItem_setQuality);
        tolua_function(tolua_S,"getNum",lua_mapserver_CItem_getNum);
        tolua_function(tolua_S,"isBind",lua_mapserver_CItem_isBind);
        tolua_function(tolua_S,"canWash",lua_mapserver_CItem_canWash);
        tolua_function(tolua_S,"empty",lua_mapserver_CItem_empty);
        tolua_function(tolua_S,"setNum",lua_mapserver_CItem_setNum);
        tolua_function(tolua_S,"copyItemValue",lua_mapserver_CItem_copyItemValue);
        tolua_function(tolua_S,"setCreateTime",lua_mapserver_CItem_setCreateTime);
        tolua_function(tolua_S,"isScroll",lua_mapserver_CItem_isScroll);
        tolua_function(tolua_S,"getRemainTime",lua_mapserver_CItem_getRemainTime);
        tolua_function(tolua_S,"GetEquipPoint", lua_mapserver_CItem_GetEquipPoint);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CItem).name();
    g_luaType[typeName] = "CItem";
    g_typeCast["CItem"] = "CItem";
    return 1;
}

int lua_mapserver_CTempItem_setPos(lua_State* tolua_S)
{
    int argc = 0;
    CTempItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTempItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTempItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTempItem_setPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned char arg0;
        unsigned char arg1;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CTempItem:setPos");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CTempItem:setPos");
        if(!ok)
            return 0;
        cobj->setPos(arg0, arg1);
        return 0;
    }

    gxError("CTempItem:setPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTempItem_setPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTempItem_setItem(lua_State* tolua_S)
{
    int argc = 0;
    CTempItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTempItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTempItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTempItem_setItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const CItem* arg0;

        ok &= luaval_to_object<const CItem>(tolua_S, 2, "CItem", &arg0, "CTempItem:setItem");
        if(!ok)
            return 0;
        cobj->setItem(arg0);
        return 0;
    }

    gxError("CTempItem:setItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTempItem_setItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTempItem_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CTempItem* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CTempItem();
        tolua_pushusertype(tolua_S,(void*)cobj,"CTempItem");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CTempItem:CTempItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CTempItem_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTempItem)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTempItem",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CTempItem* self = (CTempItem*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CTempItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTempItem");
    tolua_cclass(tolua_S,"CTempItem","CTempItem","CItem",lua_mapserver_CTempItem_finalize);

    tolua_beginmodule(tolua_S,"CTempItem");
        tolua_function(tolua_S,"new",lua_mapserver_CTempItem_constructor);
        tolua_function(tolua_S,"setPos",lua_mapserver_CTempItem_setPos);
        tolua_function(tolua_S,"setItem",lua_mapserver_CTempItem_setItem);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CTempItem).name();
    g_luaType[typeName] = "CTempItem";
    g_typeCast["CTempItem"] = "CTempItem";
    return 1;
}

int lua_mapserver_CItemContainer_checkContainerSize(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_checkContainerSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->checkContainerSize();
        return 0;
    }

    gxError("CItemContainer:checkContainerSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_checkContainerSize'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_countCanLay(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_countCanLay'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CItemContainer:countCanLay");
        if(!ok)
            return 0;
        int ret = cobj->countCanLay(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned short arg0;
        EItemAttrBindType arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CItemContainer:countCanLay");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CItemContainer:countCanLay");
        if(!ok)
            return 0;
        int ret = cobj->countCanLay(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemContainer:countCanLay has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_countCanLay'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getContainerSize(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getContainerSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getContainerSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemContainer:getContainerSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getContainerSize'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getLastAddItemIndex(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getLastAddItemIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getLastAddItemIndex();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemContainer:getLastAddItemIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getLastAddItemIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_delItemByIndex(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_delItemByIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        EItemRecordType arg0;
        unsigned char arg1;
        bool arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:delItemByIndex");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemContainer:delItemByIndex");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CItemContainer:delItemByIndex");
        if(!ok)
            return 0;
        int ret = (int)cobj->delItemByIndex(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemContainer:delItemByIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_delItemByIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getRoleContainerSize(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getRoleContainerSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getRoleContainerSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemContainer:getRoleContainerSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getRoleContainerSize'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getItemByTypeID(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getItemByTypeID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CItemContainer:getItemByTypeID");
        if(!ok)
            return 0;
        CItem* ret = cobj->getItemByTypeID(arg0);
        object_to_luaval<CItem>(tolua_S, "CItem",(CItem*)ret);
        return 1;
    }

    gxError("CItemContainer:getItemByTypeID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getItemByTypeID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_isBind(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_isBind'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItemContainer:isBind");
        if(!ok)
            return 0;
        bool ret = cobj->isBind(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:isBind has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_isBind'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_checkMemError(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_checkMemError'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->checkMemError();
        return 0;
    }

    gxError("CItemContainer:checkMemError has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_checkMemError'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getObjUIDByIndex(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getObjUIDByIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItemContainer:getObjUIDByIndex");
        if(!ok)
            return 0;
        unsigned int ret = cobj->getObjUIDByIndex(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemContainer:getObjUIDByIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getObjUIDByIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_canLaying(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_canLaying'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned short arg0;
        short arg1;
        unsigned char arg2;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CItemContainer:canLaying");

        ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CItemContainer:canLaying");

        ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CItemContainer:canLaying");
        if(!ok)
            return 0;
        bool ret = cobj->canLaying(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:canLaying has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_canLaying'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getEmptyCount(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getEmptyCount'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getEmptyCount();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemContainer:getEmptyCount has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getEmptyCount'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getEmptyIndex(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getEmptyIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getEmptyIndex();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemContainer:getEmptyIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getEmptyIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_unLock(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_unLock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItemContainer:unLock");
        if(!ok)
            return 0;
        bool ret = cobj->unLock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:unLock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_unLock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getItemByIndex(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getItemByIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItemContainer:getItemByIndex");
        if(!ok)
            return 0;
        CItem* ret = cobj->getItemByIndex(arg0);
        object_to_luaval<CItem>(tolua_S, "CItem",(CItem*)ret);
        return 1;
    }

    gxError("CItemContainer:getItemByIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getItemByIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_init(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        unsigned char arg0;
        unsigned char arg1;
        EPackType arg2;
        CRole* arg3;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItemContainer:init");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemContainer:init");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CItemContainer:init");

        ok &= luaval_to_object<CRole>(tolua_S, 5, "CRole", &arg3, "CItemContainer:init");
        if(!ok)
            return 0;
        cobj->init(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CItemContainer:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_initItems(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_initItems'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->initItems();
        return 0;
    }

    gxError("CItemContainer:initItems has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_initItems'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_isEmpty(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_isEmpty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItemContainer:isEmpty");
        if(!ok)
            return 0;
        bool ret = cobj->isEmpty(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:isEmpty has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_isEmpty'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getDbItem(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getDbItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItemContainer:getDbItem");
        if(!ok)
            return 0;
        _DbItem* ret = cobj->getDbItem(arg0);
        object_to_luaval<_DbItem>(tolua_S, "_DbItem",(_DbItem*)ret);
        return 1;
    }

    gxError("CItemContainer:getDbItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getDbItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_sendDelItem(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_sendDelItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItemContainer:sendDelItem");
        if(!ok)
            return 0;
        cobj->sendDelItem(arg0);
        return 0;
    }

    gxError("CItemContainer:sendDelItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_sendDelItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_extendContainer(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_extendContainer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned char arg0;
        unsigned char arg1;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItemContainer:extendContainer");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemContainer:extendContainer");
        if(!ok)
            return 0;
        bool ret = cobj->extendContainer(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:extendContainer has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_extendContainer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_canPackUp(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_canPackUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canPackUp();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:canPackUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_canPackUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getItemNum(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getItemNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getItemNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemContainer:getItemNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getItemNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_checkOutDayItem(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_checkOutDayItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::vector<unsigned char, std::allocator<unsigned char> > arg0;

        ok &= luaval_to_vector(tolua_S, 2, "std::vector<unsigned char, std::allocator<unsigned char> >", &arg0, "CItemContainer:checkOutDayItem");
        if(!ok)
            return 0;
        cobj->checkOutDayItem(arg0);
        return 0;
    }

    gxError("CItemContainer:checkOutDayItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_checkOutDayItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_setBind(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_setBind'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned char arg0;
        unsigned char arg1;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItemContainer:setBind");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemContainer:setBind");
        if(!ok)
            return 0;
        bool ret = cobj->setBind(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:setBind has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_setBind'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_addItem(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CItemContainer_addItem'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 4) {
            EItemRecordType arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:addItem");

            if (!ok) { break; }
            unsigned char arg1;
            ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemContainer:addItem");

            if (!ok) { break; }
            _DbBaseItem* arg2;
            ok &= luaval_to_object<_DbBaseItem>(tolua_S, 4, "_DbBaseItem", &arg2, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CItemContainer:addItem");

            if (!ok) { break; }
            int ret = (int)cobj->addItem(arg0, arg1, arg2, arg3);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            EItemRecordType arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:addItem");

            if (!ok) { break; }
            unsigned char arg1;
            ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemContainer:addItem");

            if (!ok) { break; }
            _DbBaseItem* arg2;
            ok &= luaval_to_object<_DbBaseItem>(tolua_S, 4, "_DbBaseItem", &arg2, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg4;
            ok &= luaval_to_boolean(tolua_S, 6,(bool*)&arg4, "CItemContainer:addItem");

            if (!ok) { break; }
            int ret = (int)cobj->addItem(arg0, arg1, arg2, arg3, arg4);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 6) {
            EItemRecordType arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:addItem");

            if (!ok) { break; }
            unsigned char arg1;
            ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemContainer:addItem");

            if (!ok) { break; }
            _DbBaseItem* arg2;
            ok &= luaval_to_object<_DbBaseItem>(tolua_S, 4, "_DbBaseItem", &arg2, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg4;
            ok &= luaval_to_boolean(tolua_S, 6,(bool*)&arg4, "CItemContainer:addItem");

            if (!ok) { break; }
            unsigned char arg5;
            ok &= luaval_to_uint8(tolua_S, 7,(uint8*)&arg5, "CItemContainer:addItem");

            if (!ok) { break; }
            int ret = (int)cobj->addItem(arg0, arg1, arg2, arg3, arg4, arg5);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            EItemRecordType arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:addItem");

            if (!ok) { break; }
            CItem* arg1;
            ok &= luaval_to_object<CItem>(tolua_S, 3, "CItem", &arg1, "CItemContainer:addItem");

            if (!ok) { break; }
            _DbBaseItem* arg2;
            ok &= luaval_to_object<_DbBaseItem>(tolua_S, 4, "_DbBaseItem", &arg2, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CItemContainer:addItem");

            if (!ok) { break; }
            int ret = (int)cobj->addItem(arg0, arg1, arg2, arg3);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            EItemRecordType arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:addItem");

            if (!ok) { break; }
            CItem* arg1;
            ok &= luaval_to_object<CItem>(tolua_S, 3, "CItem", &arg1, "CItemContainer:addItem");

            if (!ok) { break; }
            _DbBaseItem* arg2;
            ok &= luaval_to_object<_DbBaseItem>(tolua_S, 4, "_DbBaseItem", &arg2, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg4;
            ok &= luaval_to_boolean(tolua_S, 6,(bool*)&arg4, "CItemContainer:addItem");

            if (!ok) { break; }
            int ret = (int)cobj->addItem(arg0, arg1, arg2, arg3, arg4);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 6) {
            EItemRecordType arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:addItem");

            if (!ok) { break; }
            CItem* arg1;
            ok &= luaval_to_object<CItem>(tolua_S, 3, "CItem", &arg1, "CItemContainer:addItem");

            if (!ok) { break; }
            _DbBaseItem* arg2;
            ok &= luaval_to_object<_DbBaseItem>(tolua_S, 4, "_DbBaseItem", &arg2, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg4;
            ok &= luaval_to_boolean(tolua_S, 6,(bool*)&arg4, "CItemContainer:addItem");

            if (!ok) { break; }
            unsigned char arg5;
            ok &= luaval_to_uint8(tolua_S, 7,(uint8*)&arg5, "CItemContainer:addItem");

            if (!ok) { break; }
            int ret = (int)cobj->addItem(arg0, arg1, arg2, arg3, arg4, arg5);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            EItemRecordType arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:addItem");

            if (!ok) { break; }
            _DbBaseItem* arg1;
            ok &= luaval_to_object<_DbBaseItem>(tolua_S, 3, "_DbBaseItem", &arg1, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CItemContainer:addItem");

            if (!ok) { break; }
            int ret = (int)cobj->addItem(arg0, arg1, arg2);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            EItemRecordType arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:addItem");

            if (!ok) { break; }
            _DbBaseItem* arg1;
            ok &= luaval_to_object<_DbBaseItem>(tolua_S, 3, "_DbBaseItem", &arg1, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CItemContainer:addItem");

            if (!ok) { break; }
            int ret = (int)cobj->addItem(arg0, arg1, arg2, arg3);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            EItemRecordType arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:addItem");

            if (!ok) { break; }
            _DbBaseItem* arg1;
            ok &= luaval_to_object<_DbBaseItem>(tolua_S, 3, "_DbBaseItem", &arg1, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CItemContainer:addItem");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CItemContainer:addItem");

            if (!ok) { break; }
            unsigned char arg4;
            ok &= luaval_to_uint8(tolua_S, 6,(uint8*)&arg4, "CItemContainer:addItem");

            if (!ok) { break; }
            int ret = (int)cobj->addItem(arg0, arg1, arg2, arg3, arg4);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CItemContainer:addItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_addItem'.",&tolua_err);
    return 0;
}
int lua_mapserver_CItemContainer_update(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        std::vector<unsigned char, std::allocator<unsigned char> > arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:update");

        ok &= luaval_to_vector(tolua_S, 3, "std::vector<unsigned char, std::allocator<unsigned char> >", &arg1, "CItemContainer:update");
        if(!ok)
            return 0;
        cobj->update(arg0, arg1);
        return 0;
    }

    gxError("CItemContainer:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_delAllItems(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_delAllItems'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EItemRecordType arg0;
        std::vector<unsigned short, std::allocator<unsigned short> > arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:delAllItems");

        ok &= luaval_to_vector(tolua_S, 3, "std::vector<unsigned short, std::allocator<unsigned short> >", &arg1, "CItemContainer:delAllItems");
        if(!ok)
            return 0;
        bool ret = cobj->delAllItems(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 3) 
    {
        EItemRecordType arg0;
        std::vector<unsigned short, std::allocator<unsigned short> > arg1;
        EItemAttrBindType arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:delAllItems");

        ok &= luaval_to_vector(tolua_S, 3, "std::vector<unsigned short, std::allocator<unsigned short> >", &arg1, "CItemContainer:delAllItems");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CItemContainer:delAllItems");
        if(!ok)
            return 0;
        bool ret = cobj->delAllItems(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:delAllItems has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_delAllItems'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_isFull(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_isFull'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isFull();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:isFull has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_isFull'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getContainerType(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getContainerType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getContainerType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemContainer:getContainerType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getContainerType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_packUp(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_packUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->packUp();
        return 0;
    }

    gxError("CItemContainer:packUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_packUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getLastAddItem(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getLastAddItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CItem* ret = cobj->getLastAddItem();
        object_to_luaval<CItem>(tolua_S, "CItem",(CItem*)ret);
        return 1;
    }

    gxError("CItemContainer:getLastAddItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getLastAddItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_lock(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_lock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItemContainer:lock");
        if(!ok)
            return 0;
        bool ret = cobj->lock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:lock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_lock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_checkContainerItems(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_checkContainerItems'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->checkContainerItems();
        return 0;
    }

    gxError("CItemContainer:checkContainerItems has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_checkContainerItems'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getItemTypeByIndex(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getItemTypeByIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItemContainer:getItemTypeByIndex");
        if(!ok)
            return 0;
        unsigned short ret = cobj->getItemTypeByIndex(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemContainer:getItemTypeByIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getItemTypeByIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getItemByObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getItemByObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CItemContainer:getItemByObjUID");
        if(!ok)
            return 0;
        CItem* ret = cobj->getItemByObjUID(arg0);
        object_to_luaval<CItem>(tolua_S, "CItem",(CItem*)ret);
        return 1;
    }

    gxError("CItemContainer:getItemByObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getItemByObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_autoCanLaying(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_autoCanLaying'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        unsigned short arg0;
        short arg1;
        unsigned char arg2;
        unsigned char arg3;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CItemContainer:autoCanLaying");

        ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CItemContainer:autoCanLaying");

        ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CItemContainer:autoCanLaying");

        ok &= luaval_to_uint8(tolua_S, 5,(uint8*)&arg3, "CItemContainer:autoCanLaying");
        if(!ok)
            return 0;
        bool ret = cobj->autoCanLaying(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:autoCanLaying has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_autoCanLaying'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getOwner(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getOwner'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CRole* ret = cobj->getOwner();
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CItemContainer:getOwner has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getOwner'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_delAllItem(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_delAllItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EItemRecordType arg0;
        unsigned short arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:delAllItem");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CItemContainer:delAllItem");
        if(!ok)
            return 0;
        bool ret = cobj->delAllItem(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 3) 
    {
        EItemRecordType arg0;
        unsigned short arg1;
        EItemAttrBindType arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CItemContainer:delAllItem");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CItemContainer:delAllItem");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CItemContainer:delAllItem");
        if(!ok)
            return 0;
        bool ret = cobj->delAllItem(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:delAllItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_delAllItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_layItemInDiffCont(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_layItemInDiffCont'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CItem* arg0;
        bool arg1;

        ok &= luaval_to_object<CItem>(tolua_S, 2, "CItem", &arg0, "CItemContainer:layItemInDiffCont");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CItemContainer:layItemInDiffCont");
        if(!ok)
            return 0;
        bool ret = cobj->layItemInDiffCont(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:layItemInDiffCont has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_layItemInDiffCont'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_sendUpdateItem(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_sendUpdateItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CItemContainer:sendUpdateItem");
        if(!ok)
            return 0;
        bool ret = cobj->sendUpdateItem(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CItemContainer:sendUpdateItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_sendUpdateItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_getAllItemObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemContainer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemContainer_getAllItemObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::list<unsigned int, std::allocator<unsigned int> > arg0;

        ok &= luaval_to_list(tolua_S, 2, "std::list<unsigned int, std::allocator<unsigned int> >", &arg0, "CItemContainer:getAllItemObjUID");
        if(!ok)
            return 0;
        cobj->getAllItemObjUID(arg0);
        return 0;
    }

    gxError("CItemContainer:getAllItemObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_getAllItemObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemContainer_PushPackItem(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItemContainer",0,&tolua_err)) goto tolua_lerror;

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            MCUpdateItems* arg0;
            ok &= luaval_to_object<MCUpdateItems>(tolua_S, 2, "MCUpdateItems", &arg0, "CItemContainer:PushPackItem");
            if (!ok) { break; }
            CItem* arg1;
            ok &= luaval_to_object<CItem>(tolua_S, 3, "CItem", &arg1, "CItemContainer:PushPackItem");
            if (!ok) { break; }
            CItemContainer::PushPackItem(arg0, arg1);
            return 0;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            MCAddItems* arg0;
            ok &= luaval_to_object<MCAddItems>(tolua_S, 2, "MCAddItems", &arg0, "CItemContainer:PushPackItem");
            if (!ok) { break; }
            CItem* arg1;
            ok &= luaval_to_object<CItem>(tolua_S, 3, "CItem", &arg1, "CItemContainer:PushPackItem");
            if (!ok) { break; }
            CItemContainer::PushPackItem(arg0, arg1);
            return 0;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            MCDelItems* arg0;
            ok &= luaval_to_object<MCDelItems>(tolua_S, 2, "MCDelItems", &arg0, "CItemContainer:PushPackItem");
            if (!ok) { break; }
            CItem* arg1;
            ok &= luaval_to_object<CItem>(tolua_S, 3, "CItem", &arg1, "CItemContainer:PushPackItem");
            if (!ok) { break; }
            CItemContainer::PushPackItem(arg0, arg1);
            return 0;
        }
    } while (0);
    ok  = true;

    gxError("CItemContainer:PushPackItem has wrong number of arguments: {0}, was expecting {1}",argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemContainer_PushPackItem'.",&tolua_err);
    return 0;
}
int lua_mapserver_CItemContainer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CItemContainer* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CItemContainer();
        tolua_pushusertype(tolua_S,(void*)cobj,"CItemContainer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CItemContainer:CItemContainer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CItemContainer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CItemContainer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CItemContainer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CItemContainer* self = (CItemContainer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CItemContainer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CItemContainer");
    tolua_cclass(tolua_S,"CItemContainer","CItemContainer","",lua_mapserver_CItemContainer_finalize);

    tolua_beginmodule(tolua_S,"CItemContainer");
        tolua_function(tolua_S,"new",lua_mapserver_CItemContainer_constructor);
        tolua_function(tolua_S,"checkContainerSize",lua_mapserver_CItemContainer_checkContainerSize);
        tolua_function(tolua_S,"countCanLay",lua_mapserver_CItemContainer_countCanLay);
        tolua_function(tolua_S,"getContainerSize",lua_mapserver_CItemContainer_getContainerSize);
        tolua_function(tolua_S,"getLastAddItemIndex",lua_mapserver_CItemContainer_getLastAddItemIndex);
        tolua_function(tolua_S,"delItemByIndex",lua_mapserver_CItemContainer_delItemByIndex);
        tolua_function(tolua_S,"getRoleContainerSize",lua_mapserver_CItemContainer_getRoleContainerSize);
        tolua_function(tolua_S,"getItemByTypeID",lua_mapserver_CItemContainer_getItemByTypeID);
        tolua_function(tolua_S,"isBind",lua_mapserver_CItemContainer_isBind);
        tolua_function(tolua_S,"checkMemError",lua_mapserver_CItemContainer_checkMemError);
        tolua_function(tolua_S,"getObjUIDByIndex",lua_mapserver_CItemContainer_getObjUIDByIndex);
        tolua_function(tolua_S,"canLaying",lua_mapserver_CItemContainer_canLaying);
        tolua_function(tolua_S,"getEmptyCount",lua_mapserver_CItemContainer_getEmptyCount);
        tolua_function(tolua_S,"getEmptyIndex",lua_mapserver_CItemContainer_getEmptyIndex);
        tolua_function(tolua_S,"unLock",lua_mapserver_CItemContainer_unLock);
        tolua_function(tolua_S,"getItemByIndex",lua_mapserver_CItemContainer_getItemByIndex);
        tolua_function(tolua_S,"init",lua_mapserver_CItemContainer_init);
        tolua_function(tolua_S,"initItems",lua_mapserver_CItemContainer_initItems);
        tolua_function(tolua_S,"isEmpty",lua_mapserver_CItemContainer_isEmpty);
        tolua_function(tolua_S,"getDbItem",lua_mapserver_CItemContainer_getDbItem);
        tolua_function(tolua_S,"sendDelItem",lua_mapserver_CItemContainer_sendDelItem);
        tolua_function(tolua_S,"extendContainer",lua_mapserver_CItemContainer_extendContainer);
        tolua_function(tolua_S,"canPackUp",lua_mapserver_CItemContainer_canPackUp);
        tolua_function(tolua_S,"getItemNum",lua_mapserver_CItemContainer_getItemNum);
        tolua_function(tolua_S,"checkOutDayItem",lua_mapserver_CItemContainer_checkOutDayItem);
        tolua_function(tolua_S,"setBind",lua_mapserver_CItemContainer_setBind);
        tolua_function(tolua_S,"addItem",lua_mapserver_CItemContainer_addItem);
        tolua_function(tolua_S,"update",lua_mapserver_CItemContainer_update);
        tolua_function(tolua_S,"delAllItems",lua_mapserver_CItemContainer_delAllItems);
        tolua_function(tolua_S,"isFull",lua_mapserver_CItemContainer_isFull);
        tolua_function(tolua_S,"getContainerType",lua_mapserver_CItemContainer_getContainerType);
        tolua_function(tolua_S,"packUp",lua_mapserver_CItemContainer_packUp);
        tolua_function(tolua_S,"getLastAddItem",lua_mapserver_CItemContainer_getLastAddItem);
        tolua_function(tolua_S,"lock",lua_mapserver_CItemContainer_lock);
        tolua_function(tolua_S,"checkContainerItems",lua_mapserver_CItemContainer_checkContainerItems);
        tolua_function(tolua_S,"getItemTypeByIndex",lua_mapserver_CItemContainer_getItemTypeByIndex);
        tolua_function(tolua_S,"getItemByObjUID",lua_mapserver_CItemContainer_getItemByObjUID);
        tolua_function(tolua_S,"autoCanLaying",lua_mapserver_CItemContainer_autoCanLaying);
        tolua_function(tolua_S,"getOwner",lua_mapserver_CItemContainer_getOwner);
        tolua_function(tolua_S,"delAllItem",lua_mapserver_CItemContainer_delAllItem);
        tolua_function(tolua_S,"layItemInDiffCont",lua_mapserver_CItemContainer_layItemInDiffCont);
        tolua_function(tolua_S,"sendUpdateItem",lua_mapserver_CItemContainer_sendUpdateItem);
        tolua_function(tolua_S,"getAllItemObjUID",lua_mapserver_CItemContainer_getAllItemObjUID);
        tolua_function(tolua_S,"PushPackItem", lua_mapserver_CItemContainer_PushPackItem);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CItemContainer).name();
    g_luaType[typeName] = "CItemContainer";
    g_typeCast["CItemContainer"] = "CItemContainer";
    return 1;
}

int lua_mapserver_CItemManager_genObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CItemManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemManager_genObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->genObjUID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemManager:genObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemManager_genObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemManager_init(lua_State* tolua_S)
{
    int argc = 0;
    CItemManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemManager_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->init();
        return 0;
    }

    gxError("CItemManager:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemManager_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemManager_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItemManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CItemManager* ret = CItemManager::GetPtr();
        object_to_luaval<CItemManager>(tolua_S, "CItemManager",(CItemManager*)ret);
        return 1;
    }
    gxError("CItemManager:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemManager_GetPtr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CItemManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CItemManager* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CItemManager();
        tolua_pushusertype(tolua_S,(void*)cobj,"CItemManager");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CItemManager:CItemManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CItemManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CItemManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CItemManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CItemManager* self = (CItemManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CItemManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CItemManager");
    tolua_cclass(tolua_S,"CItemManager","CItemManager","CManualSingleton<CItemManager>",lua_mapserver_CItemManager_finalize);

    tolua_beginmodule(tolua_S,"CItemManager");
        tolua_function(tolua_S,"new",lua_mapserver_CItemManager_constructor);
        tolua_function(tolua_S,"genObjUID",lua_mapserver_CItemManager_genObjUID);
        tolua_function(tolua_S,"init",lua_mapserver_CItemManager_init);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CItemManager_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CItemManager).name();
    g_luaType[typeName] = "CItemManager";
    g_typeCast["CItemManager"] = "CItemManager";
    return 1;
}

int lua_mapserver_CItemOperator_MoveItem(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItemOperator",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        CItemContainer* arg0;
        unsigned char arg1;
        CItemContainer* arg2;
        unsigned char arg3;
        ok &= luaval_to_object<CItemContainer>(tolua_S, 2, "CItemContainer", &arg0, "CItemOperator:MoveItem");
        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemOperator:MoveItem");
        ok &= luaval_to_object<CItemContainer>(tolua_S, 4, "CItemContainer", &arg2, "CItemOperator:MoveItem");
        ok &= luaval_to_uint8(tolua_S, 5,(uint8*)&arg3, "CItemOperator:MoveItem");
        if(!ok)
            return 0;
        int ret = (int)CItemOperator::MoveItem(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CItemOperator:MoveItem has wrong number of arguments: {0}, was expecting {1}\n ", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemOperator_MoveItem'.", &tolua_err);
    return 0;
}
int lua_mapserver_CItemOperator_ExchangeItem(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItemOperator",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        CItemContainer* arg0;
        unsigned char arg1;
        CItemContainer* arg2;
        unsigned char arg3;
        ok &= luaval_to_object<CItemContainer>(tolua_S, 2, "CItemContainer", &arg0, "CItemOperator:ExchangeItem");
        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemOperator:ExchangeItem");
        ok &= luaval_to_object<CItemContainer>(tolua_S, 4, "CItemContainer", &arg2, "CItemOperator:ExchangeItem");
        ok &= luaval_to_uint8(tolua_S, 5,(uint8*)&arg3, "CItemOperator:ExchangeItem");
        if(!ok)
            return 0;
        int ret = (int)CItemOperator::ExchangeItem(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CItemOperator:ExchangeItem has wrong number of arguments: {0}, was expecting {1}\n ", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemOperator_ExchangeItem'.", &tolua_err);
    return 0;
}
int lua_mapserver_CItemOperator_EraseItem(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItemOperator",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        CItemContainer* arg0;
        unsigned char arg1;
        ok &= luaval_to_object<CItemContainer>(tolua_S, 2, "CItemContainer", &arg0, "CItemOperator:EraseItem");
        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemOperator:EraseItem");
        if(!ok)
            return 0;
        int ret = (int)CItemOperator::EraseItem(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CItemOperator:EraseItem has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemOperator_EraseItem'.", &tolua_err);
    return 0;
}
int lua_mapserver_CItemOperator_SplitItem(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItemOperator",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 5)
    {
        CItemContainer* arg0;
        unsigned char arg1;
        short arg2;
        CItemContainer* arg3;
        unsigned char arg4;
        ok &= luaval_to_object<CItemContainer>(tolua_S, 2, "CItemContainer", &arg0, "CItemOperator:SplitItem");
        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemOperator:SplitItem");
        ok &= luaval_to_sint16(tolua_S, 4,(sint16*)&arg2, "CItemOperator:SplitItem");
        ok &= luaval_to_object<CItemContainer>(tolua_S, 5, "CItemContainer", &arg3, "CItemOperator:SplitItem");
        ok &= luaval_to_uint8(tolua_S, 6,(uint8*)&arg4, "CItemOperator:SplitItem");
        if(!ok)
            return 0;
        int ret = (int)CItemOperator::SplitItem(arg0, arg1, arg2, arg3, arg4);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CItemOperator:SplitItem has wrong number of arguments: {0}, was expecting {1}\n ", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemOperator_SplitItem'.", &tolua_err);
    return 0;
}
int lua_mapserver_CItemOperator_MoveSpliceItem(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItemOperator",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        CItemContainer* arg0;
        unsigned char arg1;
        CItemContainer* arg2;
        unsigned char arg3;
        ok &= luaval_to_object<CItemContainer>(tolua_S, 2, "CItemContainer", &arg0, "CItemOperator:MoveSpliceItem");
        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemOperator:MoveSpliceItem");
        ok &= luaval_to_object<CItemContainer>(tolua_S, 4, "CItemContainer", &arg2, "CItemOperator:MoveSpliceItem");
        ok &= luaval_to_uint8(tolua_S, 5,(uint8*)&arg3, "CItemOperator:MoveSpliceItem");
        if(!ok)
            return 0;
        int ret = (int)CItemOperator::MoveSpliceItem(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CItemOperator:MoveSpliceItem has wrong number of arguments: {0}, was expecting {1}\n ", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemOperator_MoveSpliceItem'.", &tolua_err);
    return 0;
}
int lua_mapserver_CItemOperator_PackUp(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItemOperator",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        CItemContainer* arg0;
        ok &= luaval_to_object<CItemContainer>(tolua_S, 2, "CItemContainer", &arg0, "CItemOperator:PackUp");
        if(!ok)
            return 0;
        int ret = (int)CItemOperator::PackUp(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CItemOperator:PackUp has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemOperator_PackUp'.", &tolua_err);
    return 0;
}
int lua_mapserver_CItemOperator_UseItem(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItemOperator",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        CItemContainer* arg0;
        unsigned char arg1;
        ok &= luaval_to_object<CItemContainer>(tolua_S, 2, "CItemContainer", &arg0, "CItemOperator:UseItem");
        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CItemOperator:UseItem");
        if(!ok)
            return 0;
        int ret = (int)CItemOperator::UseItem(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CItemOperator:UseItem has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemOperator_UseItem'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CItemOperator_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CItemOperator)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CItemOperator",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CItemOperator* self = (CItemOperator*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CItemOperator(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CItemOperator");
    tolua_cclass(tolua_S,"CItemOperator","CItemOperator","",nullptr);

    tolua_beginmodule(tolua_S,"CItemOperator");
        tolua_function(tolua_S,"MoveItem", lua_mapserver_CItemOperator_MoveItem);
        tolua_function(tolua_S,"ExchangeItem", lua_mapserver_CItemOperator_ExchangeItem);
        tolua_function(tolua_S,"EraseItem", lua_mapserver_CItemOperator_EraseItem);
        tolua_function(tolua_S,"SplitItem", lua_mapserver_CItemOperator_SplitItem);
        tolua_function(tolua_S,"MoveSpliceItem", lua_mapserver_CItemOperator_MoveSpliceItem);
        tolua_function(tolua_S,"PackUp", lua_mapserver_CItemOperator_PackUp);
        tolua_function(tolua_S,"UseItem", lua_mapserver_CItemOperator_UseItem);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CItemOperator).name();
    g_luaType[typeName] = "CItemOperator";
    g_typeCast["CItemOperator"] = "CItemOperator";
    return 1;
}

int lua_mapserver_CItemProperty_init(lua_State* tolua_S)
{
    int argc = 0;
    CItemProperty* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemProperty",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemProperty*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemProperty_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->init();
        return 0;
    }

    gxError("CItemProperty:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemProperty_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemProperty_onUseItem(lua_State* tolua_S)
{
    int argc = 0;
    CItemProperty* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CItemProperty",0,&tolua_err)) goto tolua_lerror;
    cobj = (CItemProperty*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CItemProperty_onUseItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CRole* arg0;
        CItem* arg1;
        unsigned int arg2;

        ok &= luaval_to_object<CRole>(tolua_S, 2, "CRole", &arg0, "CItemProperty:onUseItem");

        ok &= luaval_to_object<CItem>(tolua_S, 3, "CItem", &arg1, "CItemProperty:onUseItem");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CItemProperty:onUseItem");
        if(!ok)
            return 0;
        int ret = (int)cobj->onUseItem(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CItemProperty:onUseItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemProperty_onUseItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CItemProperty_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CItemProperty",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CItemProperty* ret = CItemProperty::GetPtr();
        object_to_luaval<CItemProperty>(tolua_S, "CItemProperty",(CItemProperty*)ret);
        return 1;
    }
    gxError("CItemProperty:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CItemProperty_GetPtr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CItemProperty_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CItemProperty* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CItemProperty();
        tolua_pushusertype(tolua_S,(void*)cobj,"CItemProperty");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CItemProperty:CItemProperty has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CItemProperty_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CItemProperty)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CItemProperty",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CItemProperty* self = (CItemProperty*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CItemProperty(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CItemProperty");
    tolua_cclass(tolua_S,"CItemProperty","CItemProperty","CManualSingleton<CItemProperty>",lua_mapserver_CItemProperty_finalize);

    tolua_beginmodule(tolua_S,"CItemProperty");
        tolua_function(tolua_S,"new",lua_mapserver_CItemProperty_constructor);
        tolua_function(tolua_S,"init",lua_mapserver_CItemProperty_init);
        tolua_function(tolua_S,"onUseItem",lua_mapserver_CItemProperty_onUseItem);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CItemProperty_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CItemProperty).name();
    g_luaType[typeName] = "CItemProperty";
    g_typeCast["CItemProperty"] = "CItemProperty";
    return 1;
}

static int lua_mapserver__xinxiang_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_xinxiang)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_xinxiang",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _xinxiang* self = (_xinxiang*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__xinxiang(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_xinxiang");
    tolua_cclass(tolua_S,"_xinxiang","_xinxiang","",nullptr);

    tolua_beginmodule(tolua_S,"_xinxiang");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_xinxiang).name();
    g_luaType[typeName] = "_xinxiang";
    g_typeCast["_xinxiang"] = "_xinxiang";
    return 1;
}

int lua_mapserver_CLevelUpTbl_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CLevelUpTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLevelUpTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLevelUpTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLevelUpTbl_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CLevelUpTbl:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLevelUpTbl_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLevelUpTbl_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CLevelUpTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLevelUpTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLevelUpTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLevelUpTbl_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CLevelUpTbl:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLevelUpTbl_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLevelUpTbl_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CLevelUpTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLevelUpTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLevelUpTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLevelUpTbl_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CLevelUpTbl:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CLevelUpTbl:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLevelUpTbl_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLevelUpTbl_toString(lua_State* tolua_S)
{
    int argc = 0;
    CLevelUpTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLevelUpTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLevelUpTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLevelUpTbl_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CLevelUpTbl:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLevelUpTbl_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLevelUpTbl_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CLevelUpTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLevelUpTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLevelUpTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLevelUpTbl_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLevelUpTbl:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLevelUpTbl_getKey'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CLevelUpTbl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLevelUpTbl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLevelUpTbl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLevelUpTbl* self = (CLevelUpTbl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLevelUpTbl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLevelUpTbl");
    tolua_cclass(tolua_S,"CLevelUpTbl","CLevelUpTbl","CConfigTbl",nullptr);

    tolua_beginmodule(tolua_S,"CLevelUpTbl");
        tolua_function(tolua_S,"isKey",lua_mapserver_CLevelUpTbl_isKey);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CLevelUpTbl_keyToString);
        tolua_function(tolua_S,"setKey",lua_mapserver_CLevelUpTbl_setKey);
        tolua_function(tolua_S,"toString",lua_mapserver_CLevelUpTbl_toString);
        tolua_function(tolua_S,"getKey",lua_mapserver_CLevelUpTbl_getKey);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLevelUpTbl).name();
    g_luaType[typeName] = "CLevelUpTbl";
    g_typeCast["CLevelUpTbl"] = "CLevelUpTbl";
    return 1;
}

int lua_mapserver_CLevelUpTblLoader_findByKey(lua_State* tolua_S)
{
    int argc = 0;
    CLevelUpTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLevelUpTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLevelUpTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLevelUpTblLoader_findByKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CLevelUpTblLoader:findByKey");
        if(!ok)
            return 0;
        CLevelUpTbl* ret = cobj->findByKey(arg0);
        object_to_luaval<CLevelUpTbl>(tolua_S, "CLevelUpTbl",(CLevelUpTbl*)ret);
        return 1;
    }

    gxError("CLevelUpTblLoader:findByKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLevelUpTblLoader_findByKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLevelUpTblLoader_readRow(lua_State* tolua_S)
{
    int argc = 0;
    CLevelUpTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLevelUpTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLevelUpTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLevelUpTblLoader_readRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        TiXmlElement* arg0;
        int arg1;
        CLevelUpTbl* arg2;

        ok &= luaval_to_object<TiXmlElement>(tolua_S, 2, "TiXmlElement", &arg0, "CLevelUpTblLoader:readRow");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CLevelUpTblLoader:readRow");

        ok &= luaval_to_object<CLevelUpTbl>(tolua_S, 4, "CLevelUpTbl", &arg2, "CLevelUpTblLoader:readRow");
        if(!ok)
            return 0;
        bool ret = cobj->readRow(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CLevelUpTblLoader:readRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLevelUpTblLoader_readRow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLevelUpTblLoader_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CLevelUpTblLoader",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CLevelUpTblLoader* ret = CLevelUpTblLoader::GetPtr();
        object_to_luaval<CLevelUpTblLoader>(tolua_S, "CLevelUpTblLoader",(CLevelUpTblLoader*)ret);
        return 1;
    }
    gxError("CLevelUpTblLoader:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLevelUpTblLoader_GetPtr'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CLevelUpTblLoader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLevelUpTblLoader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLevelUpTblLoader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLevelUpTblLoader* self = (CLevelUpTblLoader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLevelUpTblLoader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLevelUpTblLoader");
    tolua_cclass(tolua_S,"CLevelUpTblLoader","CLevelUpTblLoader","CConfigLoader<CLevelUpTblLoader, CLevelUpTbl>",nullptr);

    tolua_beginmodule(tolua_S,"CLevelUpTblLoader");
        tolua_function(tolua_S,"findByKey",lua_mapserver_CLevelUpTblLoader_findByKey);
        tolua_function(tolua_S,"readRow",lua_mapserver_CLevelUpTblLoader_readRow);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CLevelUpTblLoader_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLevelUpTblLoader).name();
    g_luaType[typeName] = "CLevelUpTblLoader";
    g_typeCast["CLevelUpTblLoader"] = "CLevelUpTblLoader";
    return 1;
}

int lua_mapserver_CLimitHandle_deleteLimitChat(lua_State* tolua_S)
{
    int argc = 0;
    CLimitHandle* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitHandle",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitHandle*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitHandle_deleteLimitChat'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned long long arg0;
        unsigned long long arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CLimitHandle:deleteLimitChat");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CLimitHandle:deleteLimitChat");
        if(!ok)
            return 0;
        int ret = (int)cobj->deleteLimitChat(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLimitHandle:deleteLimitChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitHandle_deleteLimitChat'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitHandle_addLimitChat(lua_State* tolua_S)
{
    int argc = 0;
    CLimitHandle* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitHandle",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitHandle*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitHandle_addLimitChat'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const LimitChat* arg0;

        ok &= luaval_to_object<const LimitChat>(tolua_S, 2, "LimitChat", &arg0, "CLimitHandle:addLimitChat");
        if(!ok)
            return 0;
        int ret = (int)cobj->addLimitChat(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLimitHandle:addLimitChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitHandle_addLimitChat'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitHandle_intitLimitChatList(lua_State* tolua_S)
{
    int argc = 0;
    CLimitHandle* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitHandle",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitHandle*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitHandle_intitLimitChatList'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const GXMISC::CArray<LimitChatDB, 50, unsigned char>* arg0;

        ok &= luaval_to_object<const GXMISC::CArray<LimitChatDB, 50, unsigned char>>(tolua_S, 2, "CArray<LimitChatDB, 50, unsigned char>", &arg0, "CLimitHandle:intitLimitChatList");
        if(!ok)
            return 0;
        cobj->intitLimitChatList(arg0);
        return 0;
    }

    gxError("CLimitHandle:intitLimitChatList has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitHandle_intitLimitChatList'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitHandle_updateLimitChat(lua_State* tolua_S)
{
    int argc = 0;
    CLimitHandle* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitHandle",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitHandle*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitHandle_updateLimitChat'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const LimitChat* arg0;

        ok &= luaval_to_object<const LimitChat>(tolua_S, 2, "LimitChat", &arg0, "CLimitHandle:updateLimitChat");
        if(!ok)
            return 0;
        int ret = (int)cobj->updateLimitChat(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLimitHandle:updateLimitChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitHandle_updateLimitChat'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitHandle_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CLimitHandle* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CLimitHandle();
        tolua_pushusertype(tolua_S,(void*)cobj,"CLimitHandle");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CLimitHandle:CLimitHandle has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CLimitHandle_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLimitHandle)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLimitHandle",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLimitHandle* self = (CLimitHandle*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLimitHandle(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLimitHandle");
    tolua_cclass(tolua_S,"CLimitHandle","CLimitHandle","CSingleton<CLimitHandle>",lua_mapserver_CLimitHandle_finalize);

    tolua_beginmodule(tolua_S,"CLimitHandle");
        tolua_function(tolua_S,"new",lua_mapserver_CLimitHandle_constructor);
        tolua_function(tolua_S,"deleteLimitChat",lua_mapserver_CLimitHandle_deleteLimitChat);
        tolua_function(tolua_S,"addLimitChat",lua_mapserver_CLimitHandle_addLimitChat);
        tolua_function(tolua_S,"intitLimitChatList",lua_mapserver_CLimitHandle_intitLimitChatList);
        tolua_function(tolua_S,"updateLimitChat",lua_mapserver_CLimitHandle_updateLimitChat);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLimitHandle).name();
    g_luaType[typeName] = "CLimitHandle";
    g_typeCast["CLimitHandle"] = "CLimitHandle";
    return 1;
}

int lua_mapserver_CScriptEngineCommon_bindToScript(lua_State* tolua_S)
{
    int argc = 0;
    CScriptEngineCommon* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScriptEngineCommon",0,&tolua_err)) goto tolua_lerror;
    cobj = (CScriptEngineCommon*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CScriptEngineCommon_bindToScript'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->bindToScript();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CScriptEngineCommon:bindToScript has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CScriptEngineCommon_bindToScript'.",&tolua_err);
	return 0;
}
int lua_mapserver_CScriptEngineCommon_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CScriptEngineCommon* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CScriptEngineCommon();
        tolua_pushusertype(tolua_S,(void*)cobj,"CScriptEngineCommon");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CScriptEngineCommon:CScriptEngineCommon");
        if(!ok)
            return 0;
        cobj = new CScriptEngineCommon(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CScriptEngineCommon");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CScriptEngineCommon:CScriptEngineCommon has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CScriptEngineCommon_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CScriptEngineCommon)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CScriptEngineCommon",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CScriptEngineCommon* self = (CScriptEngineCommon*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CScriptEngineCommon(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CScriptEngineCommon");
    tolua_cclass(tolua_S,"CScriptEngineCommon","CScriptEngineCommon","CLuaVM",lua_mapserver_CScriptEngineCommon_finalize);

    tolua_beginmodule(tolua_S,"CScriptEngineCommon");
        tolua_function(tolua_S,"new",lua_mapserver_CScriptEngineCommon_constructor);
        tolua_function(tolua_S,"bindToScript",lua_mapserver_CScriptEngineCommon_bindToScript);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CScriptEngineCommon).name();
    g_luaType[typeName] = "CScriptEngineCommon";
    g_typeCast["CScriptEngineCommon"] = "CScriptEngineCommon";
    return 1;
}

int lua_mapserver_CScriptEngine_bindToScript(lua_State* tolua_S)
{
    int argc = 0;
    CScriptEngine* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScriptEngine",0,&tolua_err)) goto tolua_lerror;
    cobj = (CScriptEngine*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CScriptEngine_bindToScript'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->bindToScript();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CScriptEngine:bindToScript has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CScriptEngine_bindToScript'.",&tolua_err);
	return 0;
}
int lua_mapserver_CScriptEngine_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CScriptEngine* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CScriptEngine();
        tolua_pushusertype(tolua_S,(void*)cobj,"CScriptEngine");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CScriptEngine:CScriptEngine");
        if(!ok)
            return 0;
        cobj = new CScriptEngine(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CScriptEngine");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CScriptEngine:CScriptEngine has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CScriptEngine_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CScriptEngine)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CScriptEngine",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CScriptEngine* self = (CScriptEngine*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CScriptEngine(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CScriptEngine");
    tolua_cclass(tolua_S,"CScriptEngine","CScriptEngine","CScriptEngineCommon",lua_mapserver_CScriptEngine_finalize);

    tolua_beginmodule(tolua_S,"CScriptEngine");
        tolua_function(tolua_S,"new",lua_mapserver_CScriptEngine_constructor);
        tolua_function(tolua_S,"bindToScript",lua_mapserver_CScriptEngine_bindToScript);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CScriptEngine).name();
    g_luaType[typeName] = "CScriptEngine";
    g_typeCast["CScriptEngine"] = "CScriptEngine";
    return 1;
}

int lua_mapserver_IPlayer_onAddToLogout(lua_State* tolua_S)
{
    int argc = 0;
    IPlayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IPlayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (IPlayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IPlayer_onAddToLogout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onAddToLogout();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IPlayer:onAddToLogout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IPlayer_onAddToLogout'.",&tolua_err);
	return 0;
}
int lua_mapserver_IPlayer_onRemoveFromReady(lua_State* tolua_S)
{
    int argc = 0;
    IPlayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IPlayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (IPlayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IPlayer_onRemoveFromReady'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onRemoveFromReady();
        return 0;
    }

    gxError("IPlayer:onRemoveFromReady has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IPlayer_onRemoveFromReady'.",&tolua_err);
	return 0;
}
int lua_mapserver_IPlayer_onRemoveFromEnter(lua_State* tolua_S)
{
    int argc = 0;
    IPlayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IPlayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (IPlayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IPlayer_onRemoveFromEnter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onRemoveFromEnter();
        return 0;
    }

    gxError("IPlayer:onRemoveFromEnter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IPlayer_onRemoveFromEnter'.",&tolua_err);
	return 0;
}
int lua_mapserver_IPlayer_onAddToReady(lua_State* tolua_S)
{
    int argc = 0;
    IPlayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IPlayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (IPlayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IPlayer_onAddToReady'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onAddToReady();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IPlayer:onAddToReady has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IPlayer_onAddToReady'.",&tolua_err);
	return 0;
}
int lua_mapserver_IPlayer_onAddToEnter(lua_State* tolua_S)
{
    int argc = 0;
    IPlayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IPlayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (IPlayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IPlayer_onAddToEnter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onAddToEnter();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IPlayer:onAddToEnter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IPlayer_onAddToEnter'.",&tolua_err);
	return 0;
}
int lua_mapserver_IPlayer_onUpdateReadyQue(lua_State* tolua_S)
{
    int argc = 0;
    IPlayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IPlayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (IPlayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IPlayer_onUpdateReadyQue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IPlayer:onUpdateReadyQue");
        if(!ok)
            return 0;
        cobj->onUpdateReadyQue(arg0);
        return 0;
    }

    gxError("IPlayer:onUpdateReadyQue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IPlayer_onUpdateReadyQue'.",&tolua_err);
	return 0;
}
int lua_mapserver_IPlayer_onUpdateEnterQue(lua_State* tolua_S)
{
    int argc = 0;
    IPlayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IPlayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (IPlayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IPlayer_onUpdateEnterQue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IPlayer:onUpdateEnterQue");
        if(!ok)
            return 0;
        cobj->onUpdateEnterQue(arg0);
        return 0;
    }

    gxError("IPlayer:onUpdateEnterQue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IPlayer_onUpdateEnterQue'.",&tolua_err);
	return 0;
}
int lua_mapserver_IPlayer_onUpdateLogoutQue(lua_State* tolua_S)
{
    int argc = 0;
    IPlayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IPlayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (IPlayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IPlayer_onUpdateLogoutQue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IPlayer:onUpdateLogoutQue");
        if(!ok)
            return 0;
        cobj->onUpdateLogoutQue(arg0);
        return 0;
    }

    gxError("IPlayer:onUpdateLogoutQue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IPlayer_onUpdateLogoutQue'.",&tolua_err);
	return 0;
}
int lua_mapserver_IPlayer_onRemoveFromLogout(lua_State* tolua_S)
{
    int argc = 0;
    IPlayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IPlayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (IPlayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_IPlayer_onRemoveFromLogout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onRemoveFromLogout();
        return 0;
    }

    gxError("IPlayer:onRemoveFromLogout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_IPlayer_onRemoveFromLogout'.",&tolua_err);
	return 0;
}
static int lua_mapserver_IPlayer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IPlayer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IPlayer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        IPlayer* self = (IPlayer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_IPlayer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IPlayer");
    tolua_cclass(tolua_S,"IPlayer","IPlayer","",nullptr);

    tolua_beginmodule(tolua_S,"IPlayer");
        tolua_function(tolua_S,"onAddToLogout",lua_mapserver_IPlayer_onAddToLogout);
        tolua_function(tolua_S,"onRemoveFromReady",lua_mapserver_IPlayer_onRemoveFromReady);
        tolua_function(tolua_S,"onRemoveFromEnter",lua_mapserver_IPlayer_onRemoveFromEnter);
        tolua_function(tolua_S,"onAddToReady",lua_mapserver_IPlayer_onAddToReady);
        tolua_function(tolua_S,"onAddToEnter",lua_mapserver_IPlayer_onAddToEnter);
        tolua_function(tolua_S,"onUpdateReadyQue",lua_mapserver_IPlayer_onUpdateReadyQue);
        tolua_function(tolua_S,"onUpdateEnterQue",lua_mapserver_IPlayer_onUpdateEnterQue);
        tolua_function(tolua_S,"onUpdateLogoutQue",lua_mapserver_IPlayer_onUpdateLogoutQue);
        tolua_function(tolua_S,"onRemoveFromLogout",lua_mapserver_IPlayer_onRemoveFromLogout);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(IPlayer).name();
    g_luaType[typeName] = "IPlayer";
    g_typeCast["IPlayer"] = "IPlayer";
    return 1;
}

int lua_mapserver_CArea_isContain(lua_State* tolua_S)
{
    int argc = 0;
    CArea* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CArea",0,&tolua_err)) goto tolua_lerror;
    cobj = (CArea*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CArea_isContain'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        short arg0;
        short arg1;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CArea:isContain");

        ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CArea:isContain");
        if(!ok)
            return 0;
        bool ret = cobj->isContain(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CArea:isContain has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CArea_isContain'.",&tolua_err);
	return 0;
}
int lua_mapserver_CArea_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CArea* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CArea",0,&tolua_err)) goto tolua_lerror;
    cobj = (CArea*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CArea_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CArea:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CArea_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CArea_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CArea* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CArea();
        tolua_pushusertype(tolua_S,(void*)cobj,"CArea");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CArea:CArea has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CArea_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CArea)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CArea",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CArea* self = (CArea*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CArea(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CArea");
    tolua_cclass(tolua_S,"CArea","CArea","",lua_mapserver_CArea_finalize);

    tolua_beginmodule(tolua_S,"CArea");
        tolua_function(tolua_S,"new",lua_mapserver_CArea_constructor);
        tolua_function(tolua_S,"isContain",lua_mapserver_CArea_isContain);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CArea_cleanUp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CArea).name();
    g_luaType[typeName] = "CArea";
    g_typeCast["CArea"] = "CArea";
    return 1;
}

static int lua_mapserver__BlockRect_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_BlockRect)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_BlockRect",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _BlockRect* self = (_BlockRect*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__BlockRect(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_BlockRect");
    tolua_cclass(tolua_S,"_BlockRect","_BlockRect","",nullptr);

    tolua_beginmodule(tolua_S,"_BlockRect");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_BlockRect).name();
    g_luaType[typeName] = "_BlockRect";
    g_typeCast["_BlockRect"] = "_BlockRect";
    return 1;
}

static int lua_mapserver__AxisRect_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_AxisRect)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_AxisRect",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _AxisRect* self = (_AxisRect*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__AxisRect(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_AxisRect");
    tolua_cclass(tolua_S,"_AxisRect","_AxisRect","",nullptr);

    tolua_beginmodule(tolua_S,"_AxisRect");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_AxisRect).name();
    g_luaType[typeName] = "_AxisRect";
    g_typeCast["_AxisRect"] = "_AxisRect";
    return 1;
}

int lua_mapserver__BlockInfo_isValidBlockID(lua_State* tolua_S)
{
    int argc = 0;
    _BlockInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_BlockInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (_BlockInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__BlockInfo_isValidBlockID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "_BlockInfo:isValidBlockID");
        if(!ok)
            return 0;
        bool ret = cobj->isValidBlockID(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("_BlockInfo:isValidBlockID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__BlockInfo_isValidBlockID'.",&tolua_err);
	return 0;
}
int lua_mapserver__BlockInfo_toString(lua_State* tolua_S)
{
    int argc = 0;
    _BlockInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_BlockInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (_BlockInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__BlockInfo_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("_BlockInfo:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__BlockInfo_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver__BlockInfo_getBlockID(lua_State* tolua_S)
{
    int argc = 0;
    _BlockInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_BlockInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (_BlockInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__BlockInfo_getBlockID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        short arg0;
        short arg1;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "_BlockInfo:getBlockID");

        ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "_BlockInfo:getBlockID");
        if(!ok)
            return 0;
        int ret = cobj->getBlockID(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("_BlockInfo:getBlockID has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__BlockInfo_getBlockID'.",&tolua_err);
	return 0;
}
int lua_mapserver__BlockInfo_getBlockIDByAxis(lua_State* tolua_S)
{
    int argc = 0;
    _BlockInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_BlockInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (_BlockInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__BlockInfo_getBlockIDByAxis'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        short arg0;
        short arg1;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "_BlockInfo:getBlockIDByAxis");

        ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "_BlockInfo:getBlockIDByAxis");
        if(!ok)
            return 0;
        int ret = cobj->getBlockIDByAxis(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("_BlockInfo:getBlockIDByAxis has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__BlockInfo_getBlockIDByAxis'.",&tolua_err);
	return 0;
}
static int lua_mapserver__BlockInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_BlockInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_BlockInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _BlockInfo* self = (_BlockInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__BlockInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_BlockInfo");
    tolua_cclass(tolua_S,"_BlockInfo","_BlockInfo","",nullptr);

    tolua_beginmodule(tolua_S,"_BlockInfo");
        tolua_function(tolua_S,"isValidBlockID",lua_mapserver__BlockInfo_isValidBlockID);
        tolua_function(tolua_S,"toString",lua_mapserver__BlockInfo_toString);
        tolua_function(tolua_S,"getBlockID",lua_mapserver__BlockInfo_getBlockID);
        tolua_function(tolua_S,"getBlockIDByAxis",lua_mapserver__BlockInfo_getBlockIDByAxis);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_BlockInfo).name();
    g_luaType[typeName] = "_BlockInfo";
    g_typeCast["_BlockInfo"] = "_BlockInfo";
    return 1;
}

static int lua_mapserver__ObjListNode_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_ObjListNode)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_ObjListNode",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _ObjListNode* self = (_ObjListNode*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__ObjListNode(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_ObjListNode");
    tolua_cclass(tolua_S,"_ObjListNode","_ObjListNode","",nullptr);

    tolua_beginmodule(tolua_S,"_ObjListNode");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_ObjListNode).name();
    g_luaType[typeName] = "_ObjListNode";
    g_typeCast["_ObjListNode"] = "_ObjListNode";
    return 1;
}

int lua_mapserver_CObjList_deleteNode(lua_State* tolua_S)
{
    int argc = 0;
    CObjList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjList",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjList_deleteNode'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _ObjListNode* arg0;

        ok &= luaval_to_object<_ObjListNode>(tolua_S, 2, "_ObjListNode", &arg0, "CObjList:deleteNode");
        if(!ok)
            return 0;
        bool ret = cobj->deleteNode(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CObjList:deleteNode has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjList_deleteNode'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjList_addNode(lua_State* tolua_S)
{
    int argc = 0;
    CObjList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjList",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjList_addNode'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _ObjListNode* arg0;

        ok &= luaval_to_object<_ObjListNode>(tolua_S, 2, "_ObjListNode", &arg0, "CObjList:addNode");
        if(!ok)
            return 0;
        bool ret = cobj->addNode(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CObjList:addNode has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjList_addNode'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjList_getHead(lua_State* tolua_S)
{
    int argc = 0;
    CObjList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjList",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjList_getHead'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        _ObjListNode* ret = cobj->getHead();
        object_to_luaval<_ObjListNode>(tolua_S, "_ObjListNode",(_ObjListNode*)ret);
        return 1;
    }

    gxError("CObjList:getHead has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjList_getHead'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjList_getSize(lua_State* tolua_S)
{
    int argc = 0;
    CObjList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjList",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjList_getSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CObjList:getSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjList_getSize'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjList_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CObjList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjList",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjList_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CObjList:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjList_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjList_getTail(lua_State* tolua_S)
{
    int argc = 0;
    CObjList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjList",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjList_getTail'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        _ObjListNode* ret = cobj->getTail();
        object_to_luaval<_ObjListNode>(tolua_S, "_ObjListNode",(_ObjListNode*)ret);
        return 1;
    }

    gxError("CObjList:getTail has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjList_getTail'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjList_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CObjList* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EObjType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CObjList:CObjList");
        if(!ok)
            return 0;
        cobj = new CObjList(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CObjList");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CObjList:CObjList has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_mapserver_CObjList_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CObjList)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CObjList",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CObjList* self = (CObjList*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CObjList(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CObjList");
    tolua_cclass(tolua_S,"CObjList","CObjList","",lua_mapserver_CObjList_finalize);

    tolua_beginmodule(tolua_S,"CObjList");
        tolua_function(tolua_S,"new",lua_mapserver_CObjList_constructor);
        tolua_function(tolua_S,"deleteNode",lua_mapserver_CObjList_deleteNode);
        tolua_function(tolua_S,"addNode",lua_mapserver_CObjList_addNode);
        tolua_function(tolua_S,"getHead",lua_mapserver_CObjList_getHead);
        tolua_function(tolua_S,"getSize",lua_mapserver_CObjList_getSize);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CObjList_cleanUp);
        tolua_function(tolua_S,"getTail",lua_mapserver_CObjList_getTail);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CObjList).name();
    g_luaType[typeName] = "CObjList";
    g_typeCast["CObjList"] = "CObjList";
    return 1;
}

int lua_mapserver_CBlock_getTop(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_getTop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const AxisPos& ret = cobj->getTop();
        axispos_to_luaval(tolua_S, "AxisPos", ret);
        return 1;
    }

    gxError("CBlock:getTop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_getTop'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_addArea(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_addArea'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CArea* arg0;

        ok &= luaval_to_object<CArea>(tolua_S, 2, "CArea", &arg0, "CBlock:addArea");
        if(!ok)
            return 0;
        cobj->addArea(arg0);
        return 0;
    }

    gxError("CBlock:addArea has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_addArea'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_setBlockID(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_setBlockID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CBlock:setBlockID");
        if(!ok)
            return 0;
        cobj->setBlockID(arg0);
        return 0;
    }

    gxError("CBlock:setBlockID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_setBlockID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_getBlockID(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_getBlockID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getBlockID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBlock:getBlockID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_getBlockID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_getRoleList(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_getRoleList'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CObjList* ret = cobj->getRoleList();
        object_to_luaval<CObjList>(tolua_S, "CObjList",(CObjList*)ret);
        return 1;
    }

    gxError("CBlock:getRoleList has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_getRoleList'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_onObjectLeave(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_onObjectLeave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CGameObject* arg0;

        ok &= luaval_to_object<CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CBlock:onObjectLeave");
        if(!ok)
            return 0;
        cobj->onObjectLeave(arg0);
        return 0;
    }

    gxError("CBlock:onObjectLeave has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_onObjectLeave'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_getAreaCount(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_getAreaCount'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getAreaCount();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBlock:getAreaCount has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_getAreaCount'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CBlock:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_getObjList(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_getObjList'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CObjList* ret = cobj->getObjList();
        object_to_luaval<CObjList>(tolua_S, "CObjList",(CObjList*)ret);
        return 1;
    }

    gxError("CBlock:getObjList has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_getObjList'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_getBottom(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_getBottom'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        AxisPos ret = cobj->getBottom();
        axispos_to_luaval(tolua_S, "AxisPos", ret);
        return 1;
    }

    gxError("CBlock:getBottom has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_getBottom'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_calcAxisPos(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_calcAxisPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const _BlockInfo* arg0;

        ok &= luaval_to_object<const _BlockInfo>(tolua_S, 2, "_BlockInfo", &arg0, "CBlock:calcAxisPos");
        if(!ok)
            return 0;
        cobj->calcAxisPos(arg0);
        return 0;
    }

    gxError("CBlock:calcAxisPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_calcAxisPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_hasRole(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_hasRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->hasRole();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBlock:hasRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_hasRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_onObjectEnter(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_onObjectEnter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CGameObject* arg0;

        ok &= luaval_to_object<CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CBlock:onObjectEnter");
        if(!ok)
            return 0;
        cobj->onObjectEnter(arg0);
        return 0;
    }

    gxError("CBlock:onObjectEnter has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_onObjectEnter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_getCurrentArea(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBlock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBlock_getCurrentArea'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        AxisPos arg0;

        ok &= luaval_to_axispos(tolua_S, 2, "AxisPos", &arg0, "CBlock:getCurrentArea");
        if(!ok)
            return 0;
        const CArea* ret = cobj->getCurrentArea(arg0);
        object_to_luaval<CArea>(tolua_S, "CArea",(CArea*)ret);
        return 1;
    }

    gxError("CBlock:getCurrentArea has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBlock_getCurrentArea'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBlock_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CBlock* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CBlock();
        tolua_pushusertype(tolua_S,(void*)cobj,"CBlock");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CBlock:CBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CBlock_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBlock)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBlock",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CBlock* self = (CBlock*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CBlock(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBlock");
    tolua_cclass(tolua_S,"CBlock","CBlock","",lua_mapserver_CBlock_finalize);

    tolua_beginmodule(tolua_S,"CBlock");
        tolua_function(tolua_S,"new",lua_mapserver_CBlock_constructor);
        tolua_function(tolua_S,"getTop",lua_mapserver_CBlock_getTop);
        tolua_function(tolua_S,"addArea",lua_mapserver_CBlock_addArea);
        tolua_function(tolua_S,"setBlockID",lua_mapserver_CBlock_setBlockID);
        tolua_function(tolua_S,"getBlockID",lua_mapserver_CBlock_getBlockID);
        tolua_function(tolua_S,"getRoleList",lua_mapserver_CBlock_getRoleList);
        tolua_function(tolua_S,"onObjectLeave",lua_mapserver_CBlock_onObjectLeave);
        tolua_function(tolua_S,"getAreaCount",lua_mapserver_CBlock_getAreaCount);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CBlock_cleanUp);
        tolua_function(tolua_S,"getObjList",lua_mapserver_CBlock_getObjList);
        tolua_function(tolua_S,"getBottom",lua_mapserver_CBlock_getBottom);
        tolua_function(tolua_S,"calcAxisPos",lua_mapserver_CBlock_calcAxisPos);
        tolua_function(tolua_S,"hasRole",lua_mapserver_CBlock_hasRole);
        tolua_function(tolua_S,"onObjectEnter",lua_mapserver_CBlock_onObjectEnter);
        tolua_function(tolua_S,"getCurrentArea",lua_mapserver_CBlock_getCurrentArea);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CBlock).name();
    g_luaType[typeName] = "CBlock";
    g_typeCast["CBlock"] = "CBlock";
    return 1;
}

static int lua_mapserver__ObjInit_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_ObjInit)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_ObjInit",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _ObjInit* self = (_ObjInit*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__ObjInit(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_ObjInit");
    tolua_cclass(tolua_S,"_ObjInit","_ObjInit","",nullptr);

    tolua_beginmodule(tolua_S,"_ObjInit");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_ObjInit).name();
    g_luaType[typeName] = "_ObjInit";
    g_typeCast["_ObjInit"] = "_ObjInit";
    return 1;
}

static int lua_mapserver__CharacterInit_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_CharacterInit)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_CharacterInit",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _CharacterInit* self = (_CharacterInit*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__CharacterInit(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_CharacterInit");
    tolua_cclass(tolua_S,"_CharacterInit","_CharacterInit","TObjInit",nullptr);

    tolua_beginmodule(tolua_S,"_CharacterInit");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_CharacterInit).name();
    g_luaType[typeName] = "_CharacterInit";
    g_typeCast["_CharacterInit"] = "_CharacterInit";
    return 1;
}

int lua_mapserver_CGameObject_setMapID(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setMapID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CGameObject:setMapID");
        if(!ok)
            return 0;
        cobj->setMapID(arg0);
        return 0;
    }

    gxError("CGameObject:setMapID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setMapID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_toRoleBase(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CGameObject_toRoleBase'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            const CRoleBase* ret = cobj->toRoleBase();
            object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            CRoleBase* ret = cobj->toRoleBase();
            object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CGameObject:toRoleBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_toRoleBase'.",&tolua_err);
    return 0;
}
int lua_mapserver_CGameObject_isInValidRadius(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CGameObject_isInValidRadius'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 6) {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CGameObject:isInValidRadius");

            if (!ok) { break; }
            short arg1;
            ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CGameObject:isInValidRadius");

            if (!ok) { break; }
            short arg2;
            ok &= luaval_to_sint16(tolua_S, 4,(sint16*)&arg2, "CGameObject:isInValidRadius");

            if (!ok) { break; }
            short arg3;
            ok &= luaval_to_sint16(tolua_S, 5,(sint16*)&arg3, "CGameObject:isInValidRadius");

            if (!ok) { break; }
            short arg4;
            ok &= luaval_to_sint16(tolua_S, 6,(sint16*)&arg4, "CGameObject:isInValidRadius");

            if (!ok) { break; }
            unsigned char arg5;
            ok &= luaval_to_uint8(tolua_S, 7,(uint8*)&arg5, "CGameObject:isInValidRadius");

            if (!ok) { break; }
            bool ret = cobj->isInValidRadius(arg0, arg1, arg2, arg3, arg4, arg5);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CGameObject:isInValidRadius");

            if (!ok) { break; }
            const AxisPos* arg1;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CGameObject:isInValidRadius");

            if (!ok) { break; }
            unsigned char arg2;
            ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CGameObject:isInValidRadius");

            if (!ok) { break; }
            bool ret = cobj->isInValidRadius(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            const CGameObject* arg0;
            ok &= luaval_to_object<const CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CGameObject:isInValidRadius");

            if (!ok) { break; }
            unsigned char arg1;
            ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CGameObject:isInValidRadius");

            if (!ok) { break; }
            bool ret = cobj->isInValidRadius(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CGameObject:isInValidRadius has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_isInValidRadius'.",&tolua_err);
    return 0;
}
int lua_mapserver_CGameObject_setBlockID(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setBlockID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGameObject:setBlockID");
        if(!ok)
            return 0;
        cobj->setBlockID(arg0);
        return 0;
    }

    gxError("CGameObject:setBlockID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setBlockID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_leaveBlock(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_leaveBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->leaveBlock();
        return 0;
    }

    gxError("CGameObject:leaveBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_leaveBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_getAxisPos(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_getAxisPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        AxisPos* ret = cobj->getAxisPos();
        object_to_luaval<AxisPos>(tolua_S, "AxisPos",(AxisPos*)ret);
        return 1;
    }

    gxError("CGameObject:getAxisPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_getAxisPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CGameObject:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_isCanViewMe(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_isCanViewMe'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const CGameObject* arg0;

        ok &= luaval_to_object<const CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CGameObject:isCanViewMe");
        if(!ok)
            return 0;
        bool ret = cobj->isCanViewMe(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:isCanViewMe has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_isCanViewMe'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_setObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameObject:setObjUID");
        if(!ok)
            return 0;
        cobj->setObjUID(arg0);
        return 0;
    }

    gxError("CGameObject:setObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_toCharacter(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_toCharacter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CCharacterObject* ret = cobj->toCharacter();
        object_to_luaval<CCharacterObject>(tolua_S, "CCharacterObject",(CCharacterObject*)ret);
        return 1;
    }

    gxError("CGameObject:toCharacter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_toCharacter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_isObj(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_isObj'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isObj();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:isObj has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_isObj'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_isRole(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_isRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isRole();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:isRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_isRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_setPetAttr(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setPetAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EObjType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGameObject:setPetAttr");
        if(!ok)
            return 0;
        cobj->setPetAttr(arg0);
        return 0;
    }

    gxError("CGameObject:setPetAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setPetAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_updateOutBlock(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_updateOutBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameObject:updateOutBlock");
        if(!ok)
            return 0;
        bool ret = cobj->updateOutBlock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:updateOutBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_updateOutBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_isMonster(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_isMonster'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isMonster();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:isMonster has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_isMonster'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_isPet(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_isPet'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isPet();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:isPet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_isPet'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_updateBlock(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_updateBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->updateBlock();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:updateBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_updateBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_getShapeData(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_getShapeData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char* arg0;
        unsigned int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CGameObject:getShapeData"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CGameObject:getShapeData");
        if(!ok)
            return 0;
        unsigned short ret = cobj->getShapeData(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameObject:getShapeData has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_getShapeData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_getMapID(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_getMapID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getMapID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameObject:getMapID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_getMapID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_setSceneID(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setSceneID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CGameObject:setSceneID");
        if(!ok)
            return 0;
        cobj->setSceneID(arg0);
        return 0;
    }

    gxError("CGameObject:setSceneID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setSceneID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_onLeaveScene(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_onLeaveScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapSceneBase* arg0;

        ok &= luaval_to_object<CMapSceneBase>(tolua_S, 2, "CMapSceneBase", &arg0, "CGameObject:onLeaveScene");
        if(!ok)
            return 0;
        cobj->onLeaveScene(arg0);
        return 0;
    }

    gxError("CGameObject:onLeaveScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_onLeaveScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_init(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const _ObjInit* arg0;

        ok &= luaval_to_object<const _ObjInit>(tolua_S, 2, "_ObjInit", &arg0, "CGameObject:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameObject:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CGameObject:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_toString(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CGameObject:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_setObjType(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setObjType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EObjType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGameObject:setObjType");
        if(!ok)
            return 0;
        cobj->setObjType(arg0);
        return 0;
    }

    gxError("CGameObject:setObjType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setObjType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_setActive(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setActive'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CGameObject:setActive");
        if(!ok)
            return 0;
        cobj->setActive(arg0);
        return 0;
    }

    gxError("CGameObject:setActive has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setActive'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_getSceneID(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_getSceneID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getSceneID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CGameObject:getSceneID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_getSceneID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_setRoleAttr(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setRoleAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EObjType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGameObject:setRoleAttr");
        if(!ok)
            return 0;
        cobj->setRoleAttr(arg0);
        return 0;
    }

    gxError("CGameObject:setRoleAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setRoleAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CGameObject:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_onRegisterToBlock(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_onRegisterToBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onRegisterToBlock();
        return 0;
    }

    gxError("CGameObject:onRegisterToBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_onRegisterToBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_genStrName(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_genStrName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->genStrName();
        return 0;
    }

    gxError("CGameObject:genStrName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_genStrName'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_isCharacter(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_isCharacter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCharacter();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:isCharacter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_isCharacter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_isCanUpdateLeaveScene(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_isCanUpdateLeaveScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCanUpdateLeaveScene();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:isCanUpdateLeaveScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_isCanUpdateLeaveScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_getObjType(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_getObjType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getObjType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameObject:getObjType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_getObjType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_update(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameObject:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_getObjNode(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_getObjNode'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        _ObjListNode* ret = cobj->getObjNode();
        object_to_luaval<_ObjListNode>(tolua_S, "_ObjListNode",(_ObjListNode*)ret);
        return 1;
    }

    gxError("CGameObject:getObjNode has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_getObjNode'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_getObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_getObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getObjUID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameObject:getObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_getObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_setMonsterAttr(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setMonsterAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EObjType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGameObject:setMonsterAttr");
        if(!ok)
            return 0;
        cobj->setMonsterAttr(arg0);
        return 0;
    }

    gxError("CGameObject:setMonsterAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setMonsterAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_getObjGUID(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_getObjGUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getObjGUID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CGameObject:getObjGUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_getObjGUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_setDir(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setDir'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CGameObject:setDir");
        if(!ok)
            return 0;
        cobj->setDir(arg0);
        return 0;
    }

    gxError("CGameObject:setDir has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setDir'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_setAxisPos(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setAxisPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CGameObject:setAxisPos");
        if(!ok)
            return 0;
        cobj->setAxisPos(arg0);
        return 0;
    }

    gxError("CGameObject:setAxisPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setAxisPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_isActive(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_isActive'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isActive();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:isActive has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_isActive'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_setScene(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapSceneBase* arg0;

        ok &= luaval_to_object<CMapSceneBase>(tolua_S, 2, "CMapSceneBase", &arg0, "CGameObject:setScene");
        if(!ok)
            return 0;
        cobj->setScene(arg0);
        return 0;
    }

    gxError("CGameObject:setScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_getDir(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_getDir'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getDir();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameObject:getDir has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_getDir'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_onUnregisterFromBlock(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_onUnregisterFromBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onUnregisterFromBlock();
        return 0;
    }

    gxError("CGameObject:onUnregisterFromBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_onUnregisterFromBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_getBlockID(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_getBlockID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getBlockID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameObject:getBlockID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_getBlockID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_setObjGUID(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_setObjGUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CGameObject:setObjGUID");
        if(!ok)
            return 0;
        cobj->setObjGUID(arg0);
        return 0;
    }

    gxError("CGameObject:setObjGUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_setObjGUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameObject:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_getKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_onEnterScene(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_onEnterScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapSceneBase* arg0;

        ok &= luaval_to_object<CMapSceneBase>(tolua_S, 2, "CMapSceneBase", &arg0, "CGameObject:onEnterScene");
        if(!ok)
            return 0;
        cobj->onEnterScene(arg0);
        return 0;
    }

    gxError("CGameObject:onEnterScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_onEnterScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_getScene(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_getScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapSceneBase* ret = cobj->getScene();
        object_to_luaval<CMapSceneBase>(tolua_S, "CMapSceneBase",(CMapSceneBase*)ret);
        return 1;
    }

    gxError("CGameObject:getScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_getScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_getObjString(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_getObjString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getObjString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CGameObject:getObjString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_getObjString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_isCanLeaveScene(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_isCanLeaveScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCanLeaveScene();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:isCanLeaveScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_isCanLeaveScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_isNeedUpdateBlock(lua_State* tolua_S)
{
    int argc = 0;
    CGameObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameObject_isNeedUpdateBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNeedUpdateBlock();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameObject:isNeedUpdateBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_isNeedUpdateBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameObject_IsDynamic(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameObject",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        const CGameObject* arg0;
        ok &= luaval_to_object<const CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CGameObject:IsDynamic");
        if(!ok)
            return 0;
        bool ret = CGameObject::IsDynamic(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CGameObject:IsDynamic has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_IsDynamic'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameObject_IsInValidRadius(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameObject",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 5)
    {
        short arg0;
        short arg1;
        short arg2;
        short arg3;
        unsigned char arg4;
        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CGameObject:IsInValidRadius");
        ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CGameObject:IsInValidRadius");
        ok &= luaval_to_sint16(tolua_S, 4,(sint16*)&arg2, "CGameObject:IsInValidRadius");
        ok &= luaval_to_sint16(tolua_S, 5,(sint16*)&arg3, "CGameObject:IsInValidRadius");
        ok &= luaval_to_uint8(tolua_S, 6,(uint8*)&arg4, "CGameObject:IsInValidRadius");
        if(!ok)
            return 0;
        bool ret = CGameObject::IsInValidRadius(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CGameObject:IsInValidRadius has wrong number of arguments: {0}, was expecting {1}\n ", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_IsInValidRadius'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameObject_ObjTypeToStr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameObject",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        EObjType arg0;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGameObject:ObjTypeToStr");
        if(!ok)
            return 0;
        const char* ret = CGameObject::ObjTypeToStr(arg0);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }
    gxError("CGameObject:ObjTypeToStr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_ObjTypeToStr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CGameObject_IsCharacter(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGameObject",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        const CGameObject* arg0;
        ok &= luaval_to_object<const CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CGameObject:IsCharacter");
        if(!ok)
            return 0;
        bool ret = CGameObject::IsCharacter(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CGameObject:IsCharacter has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameObject_IsCharacter'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CGameObject_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGameObject)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGameObject",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CGameObject* self = (CGameObject*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CGameObject(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGameObject");
    tolua_cclass(tolua_S,"CGameObject","CGameObject","",nullptr);

    tolua_beginmodule(tolua_S,"CGameObject");
        tolua_function(tolua_S,"setMapID",lua_mapserver_CGameObject_setMapID);
        tolua_function(tolua_S,"toRoleBase",lua_mapserver_CGameObject_toRoleBase);
        tolua_function(tolua_S,"isInValidRadius",lua_mapserver_CGameObject_isInValidRadius);
        tolua_function(tolua_S,"setBlockID",lua_mapserver_CGameObject_setBlockID);
        tolua_function(tolua_S,"leaveBlock",lua_mapserver_CGameObject_leaveBlock);
        tolua_function(tolua_S,"getAxisPos",lua_mapserver_CGameObject_getAxisPos);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CGameObject_cleanUp);
        tolua_function(tolua_S,"isCanViewMe",lua_mapserver_CGameObject_isCanViewMe);
        tolua_function(tolua_S,"setObjUID",lua_mapserver_CGameObject_setObjUID);
        tolua_function(tolua_S,"toCharacter",lua_mapserver_CGameObject_toCharacter);
        tolua_function(tolua_S,"isObj",lua_mapserver_CGameObject_isObj);
        tolua_function(tolua_S,"isRole",lua_mapserver_CGameObject_isRole);
        tolua_function(tolua_S,"setPetAttr",lua_mapserver_CGameObject_setPetAttr);
        tolua_function(tolua_S,"updateOutBlock",lua_mapserver_CGameObject_updateOutBlock);
        tolua_function(tolua_S,"isMonster",lua_mapserver_CGameObject_isMonster);
        tolua_function(tolua_S,"isPet",lua_mapserver_CGameObject_isPet);
        tolua_function(tolua_S,"updateBlock",lua_mapserver_CGameObject_updateBlock);
        tolua_function(tolua_S,"getShapeData",lua_mapserver_CGameObject_getShapeData);
        tolua_function(tolua_S,"getMapID",lua_mapserver_CGameObject_getMapID);
        tolua_function(tolua_S,"setSceneID",lua_mapserver_CGameObject_setSceneID);
        tolua_function(tolua_S,"onLeaveScene",lua_mapserver_CGameObject_onLeaveScene);
        tolua_function(tolua_S,"init",lua_mapserver_CGameObject_init);
        tolua_function(tolua_S,"setKey",lua_mapserver_CGameObject_setKey);
        tolua_function(tolua_S,"toString",lua_mapserver_CGameObject_toString);
        tolua_function(tolua_S,"setObjType",lua_mapserver_CGameObject_setObjType);
        tolua_function(tolua_S,"setActive",lua_mapserver_CGameObject_setActive);
        tolua_function(tolua_S,"getSceneID",lua_mapserver_CGameObject_getSceneID);
        tolua_function(tolua_S,"setRoleAttr",lua_mapserver_CGameObject_setRoleAttr);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CGameObject_keyToString);
        tolua_function(tolua_S,"onRegisterToBlock",lua_mapserver_CGameObject_onRegisterToBlock);
        tolua_function(tolua_S,"genStrName",lua_mapserver_CGameObject_genStrName);
        tolua_function(tolua_S,"isCharacter",lua_mapserver_CGameObject_isCharacter);
        tolua_function(tolua_S,"isCanUpdateLeaveScene",lua_mapserver_CGameObject_isCanUpdateLeaveScene);
        tolua_function(tolua_S,"getObjType",lua_mapserver_CGameObject_getObjType);
        tolua_function(tolua_S,"update",lua_mapserver_CGameObject_update);
        tolua_function(tolua_S,"getObjNode",lua_mapserver_CGameObject_getObjNode);
        tolua_function(tolua_S,"getObjUID",lua_mapserver_CGameObject_getObjUID);
        tolua_function(tolua_S,"setMonsterAttr",lua_mapserver_CGameObject_setMonsterAttr);
        tolua_function(tolua_S,"getObjGUID",lua_mapserver_CGameObject_getObjGUID);
        tolua_function(tolua_S,"setDir",lua_mapserver_CGameObject_setDir);
        tolua_function(tolua_S,"setAxisPos",lua_mapserver_CGameObject_setAxisPos);
        tolua_function(tolua_S,"isActive",lua_mapserver_CGameObject_isActive);
        tolua_function(tolua_S,"setScene",lua_mapserver_CGameObject_setScene);
        tolua_function(tolua_S,"getDir",lua_mapserver_CGameObject_getDir);
        tolua_function(tolua_S,"isKey",lua_mapserver_CGameObject_isKey);
        tolua_function(tolua_S,"onUnregisterFromBlock",lua_mapserver_CGameObject_onUnregisterFromBlock);
        tolua_function(tolua_S,"getBlockID",lua_mapserver_CGameObject_getBlockID);
        tolua_function(tolua_S,"setObjGUID",lua_mapserver_CGameObject_setObjGUID);
        tolua_function(tolua_S,"getKey",lua_mapserver_CGameObject_getKey);
        tolua_function(tolua_S,"onEnterScene",lua_mapserver_CGameObject_onEnterScene);
        tolua_function(tolua_S,"getScene",lua_mapserver_CGameObject_getScene);
        tolua_function(tolua_S,"getObjString",lua_mapserver_CGameObject_getObjString);
        tolua_function(tolua_S,"isCanLeaveScene",lua_mapserver_CGameObject_isCanLeaveScene);
        tolua_function(tolua_S,"isNeedUpdateBlock",lua_mapserver_CGameObject_isNeedUpdateBlock);
        tolua_function(tolua_S,"IsDynamic", lua_mapserver_CGameObject_IsDynamic);
        tolua_function(tolua_S,"IsInValidRadius", lua_mapserver_CGameObject_IsInValidRadius);
        tolua_function(tolua_S,"ObjTypeToStr", lua_mapserver_CGameObject_ObjTypeToStr);
        tolua_function(tolua_S,"IsCharacter", lua_mapserver_CGameObject_IsCharacter);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CGameObject).name();
    g_luaType[typeName] = "CGameObject";
    g_typeCast["CGameObject"] = "CGameObject";
    return 1;
}

int lua_mapserver_CDynamicObject_init(lua_State* tolua_S)
{
    int argc = 0;
    CDynamicObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDynamicObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDynamicObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDynamicObject_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const _ObjInit* arg0;

        ok &= luaval_to_object<const _ObjInit>(tolua_S, 2, "_ObjInit", &arg0, "CDynamicObject:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDynamicObject:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDynamicObject_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDynamicObject_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CDynamicObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDynamicObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDynamicObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDynamicObject_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CDynamicObject:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDynamicObject_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDynamicObject_update(lua_State* tolua_S)
{
    int argc = 0;
    CDynamicObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDynamicObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDynamicObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDynamicObject_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CDynamicObject:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDynamicObject:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDynamicObject_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDynamicObject_updateOutBlock(lua_State* tolua_S)
{
    int argc = 0;
    CDynamicObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDynamicObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDynamicObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDynamicObject_updateOutBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CDynamicObject:updateOutBlock");
        if(!ok)
            return 0;
        bool ret = cobj->updateOutBlock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDynamicObject:updateOutBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDynamicObject_updateOutBlock'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CDynamicObject_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDynamicObject)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDynamicObject",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CDynamicObject* self = (CDynamicObject*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CDynamicObject(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDynamicObject");
    tolua_cclass(tolua_S,"CDynamicObject","CDynamicObject","CGameObject",nullptr);

    tolua_beginmodule(tolua_S,"CDynamicObject");
        tolua_function(tolua_S,"init",lua_mapserver_CDynamicObject_init);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CDynamicObject_cleanUp);
        tolua_function(tolua_S,"update",lua_mapserver_CDynamicObject_update);
        tolua_function(tolua_S,"updateOutBlock",lua_mapserver_CDynamicObject_updateOutBlock);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CDynamicObject).name();
    g_luaType[typeName] = "CDynamicObject";
    g_typeCast["CDynamicObject"] = "CDynamicObject";
    return 1;
}

static int lua_mapserver_CSkillBuff_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSkillBuff)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSkillBuff",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CSkillBuff* self = (CSkillBuff*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CSkillBuff(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSkillBuff");
    tolua_cclass(tolua_S,"CSkillBuff","CSkillBuff","",nullptr);

    tolua_beginmodule(tolua_S,"CSkillBuff");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CSkillBuff).name();
    g_luaType[typeName] = "CSkillBuff";
    g_typeCast["CSkillBuff"] = "CSkillBuff";
    return 1;
}

static int lua_mapserver_CItemBuff_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CItemBuff)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CItemBuff",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CItemBuff* self = (CItemBuff*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CItemBuff(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CItemBuff");
    tolua_cclass(tolua_S,"CItemBuff","CItemBuff","",nullptr);

    tolua_beginmodule(tolua_S,"CItemBuff");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CItemBuff).name();
    g_luaType[typeName] = "CItemBuff";
    g_typeCast["CItemBuff"] = "CItemBuff";
    return 1;
}

int lua_mapserver_CBufferEffect_log(lua_State* tolua_S)
{
    int argc = 0;
    CBufferEffect* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferEffect",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferEffect*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferEffect_log'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->log();
        return 0;
    }

    gxError("CBufferEffect:log has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferEffect_log'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferEffect_getPackBuff(lua_State* tolua_S)
{
    int argc = 0;
    CBufferEffect* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferEffect",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferEffect*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferEffect_getPackBuff'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _PackBuffer* arg0;

        ok &= luaval_to_object<_PackBuffer>(tolua_S, 2, "_PackBuffer", &arg0, "CBufferEffect:getPackBuff");
        if(!ok)
            return 0;
        cobj->getPackBuff(arg0);
        return 0;
    }

    gxError("CBufferEffect:getPackBuff has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferEffect_getPackBuff'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferEffect_getOwnerBuff(lua_State* tolua_S)
{
    int argc = 0;
    CBufferEffect* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferEffect",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferEffect*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferEffect_getOwnerBuff'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        OwnerBuffer* arg0;

        ok &= luaval_to_object<OwnerBuffer>(tolua_S, 2, "OwnerBuffer", &arg0, "CBufferEffect:getOwnerBuff");
        if(!ok)
            return 0;
        cobj->getOwnerBuff(arg0);
        return 0;
    }

    gxError("CBufferEffect:getOwnerBuff has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferEffect_getOwnerBuff'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferEffect_reload(lua_State* tolua_S)
{
    int argc = 0;
    CBufferEffect* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferEffect",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferEffect*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferEffect_reload'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reload();
        return 0;
    }

    gxError("CBufferEffect:reload has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferEffect_reload'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferEffect_toString(lua_State* tolua_S)
{
    int argc = 0;
    CBufferEffect* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferEffect",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferEffect*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferEffect_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CBufferEffect:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferEffect_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferEffect_isActive(lua_State* tolua_S)
{
    int argc = 0;
    CBufferEffect* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferEffect",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferEffect*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferEffect_isActive'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isActive();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferEffect:isActive has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferEffect_isActive'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferEffect_isNeedSave(lua_State* tolua_S)
{
    int argc = 0;
    CBufferEffect* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferEffect",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferEffect*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferEffect_isNeedSave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNeedSave();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferEffect:isNeedSave has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferEffect_isNeedSave'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferEffect_getRemainTime(lua_State* tolua_S)
{
    int argc = 0;
    CBufferEffect* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferEffect",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferEffect*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferEffect_getRemainTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getRemainTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBufferEffect:getRemainTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferEffect_getRemainTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferEffect_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CBufferEffect* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CBufferEffect();
        tolua_pushusertype(tolua_S,(void*)cobj,"CBufferEffect");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CBufferEffect:CBufferEffect has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CBufferEffect_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBufferEffect)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBufferEffect",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CBufferEffect* self = (CBufferEffect*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CBufferEffect(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBufferEffect");
    tolua_cclass(tolua_S,"CBufferEffect","CBufferEffect","",lua_mapserver_CBufferEffect_finalize);

    tolua_beginmodule(tolua_S,"CBufferEffect");
        tolua_function(tolua_S,"new",lua_mapserver_CBufferEffect_constructor);
        tolua_function(tolua_S,"log",lua_mapserver_CBufferEffect_log);
        tolua_function(tolua_S,"getPackBuff",lua_mapserver_CBufferEffect_getPackBuff);
        tolua_function(tolua_S,"getOwnerBuff",lua_mapserver_CBufferEffect_getOwnerBuff);
        tolua_function(tolua_S,"reload",lua_mapserver_CBufferEffect_reload);
        tolua_function(tolua_S,"toString",lua_mapserver_CBufferEffect_toString);
        tolua_function(tolua_S,"isActive",lua_mapserver_CBufferEffect_isActive);
        tolua_function(tolua_S,"isNeedSave",lua_mapserver_CBufferEffect_isNeedSave);
        tolua_function(tolua_S,"getRemainTime",lua_mapserver_CBufferEffect_getRemainTime);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CBufferEffect).name();
    g_luaType[typeName] = "CBufferEffect";
    g_typeCast["CBufferEffect"] = "CBufferEffect";
    return 1;
}

int lua_mapserver_CBufferImpactBase_getRange(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_getRange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CBufferImpactBase:getRange");
        if(!ok)
            return 0;
        char ret = cobj->getRange(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBufferImpactBase:getRange has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_getRange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_getAttrs(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_getAttrs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;
        CBufferAttr* arg2;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:getAttrs");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:getAttrs");

        ok &= luaval_to_object<CBufferAttr>(tolua_S, 4, "CBufferAttr", &arg2, "CBufferImpactBase:getAttrs");
        if(!ok)
            return 0;
        cobj->getAttrs(arg0, arg1, arg2);
        return 0;
    }

    gxError("CBufferImpactBase:getAttrs has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_getAttrs'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_onDamage(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_onDamage'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:onDamage");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:onDamage");
        if(!ok)
            return 0;
        cobj->onDamage(arg0, arg1);
        return 0;
    }

    gxError("CBufferImpactBase:onDamage has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_onDamage'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_isRangeBuff(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_isRangeBuff'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isRangeBuff();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferImpactBase:isRangeBuff has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_isRangeBuff'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_onReload(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_onReload'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:onReload");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:onReload");
        if(!ok)
            return 0;
        cobj->onReload(arg0, arg1);
        return 0;
    }

    gxError("CBufferImpactBase:onReload has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_onReload'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_getActionBan(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_getActionBan'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;
        CActionBan* arg2;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:getActionBan");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:getActionBan");

        ok &= luaval_to_object<CActionBan>(tolua_S, 4, "CActionBan", &arg2, "CBufferImpactBase:getActionBan");
        if(!ok)
            return 0;
        cobj->getActionBan(arg0, arg1, arg2);
        return 0;
    }

    gxError("CBufferImpactBase:getActionBan has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_getActionBan'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_getBufferConfig(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_getBufferConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CBufferConfigTbl* ret = cobj->getBufferConfig();
        object_to_luaval<CBufferConfigTbl>(tolua_S, "CBufferConfigTbl",(CBufferConfigTbl*)ret);
        return 1;
    }

    gxError("CBufferImpactBase:getBufferConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_getBufferConfig'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_getEffectType(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_getEffectType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getEffectType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBufferImpactBase:getEffectType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_getEffectType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_enterView(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_enterView'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;
        CCharacterObject* arg2;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:enterView");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:enterView");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 4, "CCharacterObject", &arg2, "CBufferImpactBase:enterView");
        if(!ok)
            return 0;
        cobj->enterView(arg0, arg1, arg2);
        return 0;
    }

    gxError("CBufferImpactBase:enterView has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_enterView'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_onHit(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_onHit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:onHit");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:onHit");
        if(!ok)
            return 0;
        cobj->onHit(arg0, arg1);
        return 0;
    }

    gxError("CBufferImpactBase:onHit has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_onHit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_onAdd(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_onAdd'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:onAdd");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:onAdd");
        if(!ok)
            return 0;
        cobj->onAdd(arg0, arg1);
        return 0;
    }

    gxError("CBufferImpactBase:onAdd has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_onAdd'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_initFromData(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_initFromData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;
        bool arg2;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:initFromData");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:initFromData");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CBufferImpactBase:initFromData");
        if(!ok)
            return 0;
        bool ret = cobj->initFromData(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferImpactBase:initFromData has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_initFromData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_onActive(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_onActive'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:onActive");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:onActive");
        if(!ok)
            return 0;
        int ret = cobj->onActive(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBufferImpactBase:onActive has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_onActive'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_onFadeout(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_onFadeout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:onFadeout");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:onFadeout");
        if(!ok)
            return 0;
        cobj->onFadeout(arg0, arg1);
        return 0;
    }

    gxError("CBufferImpactBase:onFadeout has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_onFadeout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_isEvent(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CBufferImpactBase_isEvent'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            EBuffEventFlag arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CBufferImpactBase:isEvent");

            if (!ok) { break; }
            bool ret = cobj->isEvent(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            bool ret = cobj->isEvent();
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CBufferImpactBase:isEvent has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_isEvent'.",&tolua_err);
    return 0;
}
int lua_mapserver_CBufferImpactBase_getBuffEvent(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_getBuffEvent'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;
        GXMISC::CFixBitSet<9>* arg2;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:getBuffEvent");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:getBuffEvent");

        ok &= luaval_to_object<GXMISC::CFixBitSet<9>>(tolua_S, 4, "CFixBitSet<9>", &arg2, "CBufferImpactBase:getBuffEvent");
        if(!ok)
            return 0;
        cobj->getBuffEvent(arg0, arg1, arg2);
        return 0;
    }

    gxError("CBufferImpactBase:getBuffEvent has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_getBuffEvent'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_update(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBufferEffect* arg0;
        int arg1;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:update");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CBufferImpactBase:update");
        if(!ok)
            return 0;
        cobj->update(arg0, arg1);
        return 0;
    }

    gxError("CBufferImpactBase:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_logBuffer(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_logBuffer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CBufferEffect* arg0;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:logBuffer");
        if(!ok)
            return 0;
        cobj->logBuffer(arg0);
        return 0;
    }

    gxError("CBufferImpactBase:logBuffer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_logBuffer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_updateBuff(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_updateBuff'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CBufferEffect* arg0;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:updateBuff");
        if(!ok)
            return 0;
        cobj->updateBuff(arg0);
        return 0;
    }

    gxError("CBufferImpactBase:updateBuff has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_updateBuff'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_isActionBan(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_isActionBan'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isActionBan();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferImpactBase:isActionBan has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_isActionBan'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_isRefreshAttr(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_isRefreshAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isRefreshAttr();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferImpactBase:isRefreshAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_isRefreshAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_loadFromDb(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_loadFromDb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:loadFromDb");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:loadFromDb");
        if(!ok)
            return 0;
        bool ret = cobj->loadFromDb(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferImpactBase:loadFromDb has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_loadFromDb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_isCountTime(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_isCountTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCountTime();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferImpactBase:isCountTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_isCountTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_onDie(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_onDie'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:onDie");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:onDie");
        if(!ok)
            return 0;
        cobj->onDie(arg0, arg1);
        return 0;
    }

    gxError("CBufferImpactBase:onDie has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_onDie'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_isTimeout(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_isTimeout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CBufferEffect* arg0;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:isTimeout");
        if(!ok)
            return 0;
        bool ret = cobj->isTimeout(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferImpactBase:isTimeout has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_isTimeout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_reload(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_reload'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:reload");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:reload");
        if(!ok)
            return 0;
        cobj->reload(arg0, arg1);
        return 0;
    }

    gxError("CBufferImpactBase:reload has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_reload'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_isIntervaled(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_isIntervaled'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CBufferEffect* arg0;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:isIntervaled");
        if(!ok)
            return 0;
        bool ret = cobj->isIntervaled(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferImpactBase:isIntervaled has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_isIntervaled'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_isDurationTime(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_isDurationTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDurationTime();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferImpactBase:isDurationTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_isDurationTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_markModifiedAttrDirty(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_markModifiedAttrDirty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:markModifiedAttrDirty");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:markModifiedAttrDirty");
        if(!ok)
            return 0;
        cobj->markModifiedAttrDirty(arg0, arg1);
        return 0;
    }

    gxError("CBufferImpactBase:markModifiedAttrDirty has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_markModifiedAttrDirty'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_onEffectAtStart(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferImpactBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferImpactBase_onEffectAtStart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBufferEffect* arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferImpactBase:onEffectAtStart");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CBufferImpactBase:onEffectAtStart");
        if(!ok)
            return 0;
        cobj->onEffectAtStart(arg0, arg1);
        return 0;
    }

    gxError("CBufferImpactBase:onEffectAtStart has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferImpactBase_onEffectAtStart'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferImpactBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CBufferImpactBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CBufferImpactBase:CBufferImpactBase");
        if(!ok)
            return 0;
        cobj = new CBufferImpactBase(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CBufferImpactBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CBufferImpactBase:CBufferImpactBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_mapserver_CBufferImpactBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBufferImpactBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBufferImpactBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CBufferImpactBase* self = (CBufferImpactBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CBufferImpactBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBufferImpactBase");
    tolua_cclass(tolua_S,"CBufferImpactBase","CBufferImpactBase","",lua_mapserver_CBufferImpactBase_finalize);

    tolua_beginmodule(tolua_S,"CBufferImpactBase");
        tolua_function(tolua_S,"new",lua_mapserver_CBufferImpactBase_constructor);
        tolua_function(tolua_S,"getRange",lua_mapserver_CBufferImpactBase_getRange);
        tolua_function(tolua_S,"getAttrs",lua_mapserver_CBufferImpactBase_getAttrs);
        tolua_function(tolua_S,"onDamage",lua_mapserver_CBufferImpactBase_onDamage);
        tolua_function(tolua_S,"isRangeBuff",lua_mapserver_CBufferImpactBase_isRangeBuff);
        tolua_function(tolua_S,"onReload",lua_mapserver_CBufferImpactBase_onReload);
        tolua_function(tolua_S,"getActionBan",lua_mapserver_CBufferImpactBase_getActionBan);
        tolua_function(tolua_S,"getBufferConfig",lua_mapserver_CBufferImpactBase_getBufferConfig);
        tolua_function(tolua_S,"getEffectType",lua_mapserver_CBufferImpactBase_getEffectType);
        tolua_function(tolua_S,"enterView",lua_mapserver_CBufferImpactBase_enterView);
        tolua_function(tolua_S,"onHit",lua_mapserver_CBufferImpactBase_onHit);
        tolua_function(tolua_S,"onAdd",lua_mapserver_CBufferImpactBase_onAdd);
        tolua_function(tolua_S,"initFromData",lua_mapserver_CBufferImpactBase_initFromData);
        tolua_function(tolua_S,"onActive",lua_mapserver_CBufferImpactBase_onActive);
        tolua_function(tolua_S,"onFadeout",lua_mapserver_CBufferImpactBase_onFadeout);
        tolua_function(tolua_S,"isEvent",lua_mapserver_CBufferImpactBase_isEvent);
        tolua_function(tolua_S,"getBuffEvent",lua_mapserver_CBufferImpactBase_getBuffEvent);
        tolua_function(tolua_S,"update",lua_mapserver_CBufferImpactBase_update);
        tolua_function(tolua_S,"logBuffer",lua_mapserver_CBufferImpactBase_logBuffer);
        tolua_function(tolua_S,"updateBuff",lua_mapserver_CBufferImpactBase_updateBuff);
        tolua_function(tolua_S,"isActionBan",lua_mapserver_CBufferImpactBase_isActionBan);
        tolua_function(tolua_S,"isRefreshAttr",lua_mapserver_CBufferImpactBase_isRefreshAttr);
        tolua_function(tolua_S,"loadFromDb",lua_mapserver_CBufferImpactBase_loadFromDb);
        tolua_function(tolua_S,"isCountTime",lua_mapserver_CBufferImpactBase_isCountTime);
        tolua_function(tolua_S,"onDie",lua_mapserver_CBufferImpactBase_onDie);
        tolua_function(tolua_S,"isTimeout",lua_mapserver_CBufferImpactBase_isTimeout);
        tolua_function(tolua_S,"reload",lua_mapserver_CBufferImpactBase_reload);
        tolua_function(tolua_S,"isIntervaled",lua_mapserver_CBufferImpactBase_isIntervaled);
        tolua_function(tolua_S,"isDurationTime",lua_mapserver_CBufferImpactBase_isDurationTime);
        tolua_function(tolua_S,"markModifiedAttrDirty",lua_mapserver_CBufferImpactBase_markModifiedAttrDirty);
        tolua_function(tolua_S,"onEffectAtStart",lua_mapserver_CBufferImpactBase_onEffectAtStart);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CBufferImpactBase).name();
    g_luaType[typeName] = "CBufferImpactBase";
    g_typeCast["CBufferImpactBase"] = "CBufferImpactBase";
    return 1;
}

static int lua_mapserver_TUserFlag_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (TUserFlag)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"TUserFlag",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        TUserFlag* self = (TUserFlag*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_TUserFlag(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"TUserFlag");
    tolua_cclass(tolua_S,"TUserFlag","TUserFlag","TDBStructBase",nullptr);

    tolua_beginmodule(tolua_S,"TUserFlag");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(TUserFlag).name();
    g_luaType[typeName] = "TUserFlag";
    g_typeCast["TUserFlag"] = "TUserFlag";
    return 1;
}

static int lua_mapserver_UserDbData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (UserDbData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"UserDbData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        UserDbData* self = (UserDbData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_UserDbData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"UserDbData");
    tolua_cclass(tolua_S,"UserDbData","UserDbData","",nullptr);

    tolua_beginmodule(tolua_S,"UserDbData");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(UserDbData).name();
    g_luaType[typeName] = "UserDbData";
    g_typeCast["UserDbData"] = "UserDbData";
    return 1;
}

int lua_mapserver_CWorldUserData_isValid(lua_State* tolua_S)
{
    int argc = 0;
    CWorldUserData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CWorldUserData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CWorldUserData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CWorldUserData_isValid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isValid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CWorldUserData:isValid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CWorldUserData_isValid'.",&tolua_err);
	return 0;
}
int lua_mapserver_CWorldUserData_toString(lua_State* tolua_S)
{
    int argc = 0;
    CWorldUserData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CWorldUserData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CWorldUserData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CWorldUserData_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CWorldUserData:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CWorldUserData_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CWorldUserData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CWorldUserData* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CWorldUserData();
        tolua_pushusertype(tolua_S,(void*)cobj,"CWorldUserData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CWorldUserData:CWorldUserData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CWorldUserData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CWorldUserData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CWorldUserData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CWorldUserData* self = (CWorldUserData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CWorldUserData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CWorldUserData");
    tolua_cclass(tolua_S,"CWorldUserData","CWorldUserData","",lua_mapserver_CWorldUserData_finalize);

    tolua_beginmodule(tolua_S,"CWorldUserData");
        tolua_function(tolua_S,"new",lua_mapserver_CWorldUserData_constructor);
        tolua_function(tolua_S,"isValid",lua_mapserver_CWorldUserData_isValid);
        tolua_function(tolua_S,"toString",lua_mapserver_CWorldUserData_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CWorldUserData).name();
    g_luaType[typeName] = "CWorldUserData";
    g_typeCast["CWorldUserData"] = "CWorldUserData";
    return 1;
}

static int lua_mapserver_W2MUserDataUpdate_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (W2MUserDataUpdate)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"W2MUserDataUpdate",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        W2MUserDataUpdate* self = (W2MUserDataUpdate*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_W2MUserDataUpdate(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"W2MUserDataUpdate");
    tolua_cclass(tolua_S,"W2MUserDataUpdate","W2MUserDataUpdate","",nullptr);

    tolua_beginmodule(tolua_S,"W2MUserDataUpdate");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(W2MUserDataUpdate).name();
    g_luaType[typeName] = "W2MUserDataUpdate";
    g_typeCast["W2MUserDataUpdate"] = "W2MUserDataUpdate";
    return 1;
}

static int lua_mapserver_M2WRoleDataUpdate_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (M2WRoleDataUpdate)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"M2WRoleDataUpdate",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        M2WRoleDataUpdate* self = (M2WRoleDataUpdate*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_M2WRoleDataUpdate(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"M2WRoleDataUpdate");
    tolua_cclass(tolua_S,"M2WRoleDataUpdate","M2WRoleDataUpdate","",nullptr);

    tolua_beginmodule(tolua_S,"M2WRoleDataUpdate");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(M2WRoleDataUpdate).name();
    g_luaType[typeName] = "M2WRoleDataUpdate";
    g_typeCast["M2WRoleDataUpdate"] = "M2WRoleDataUpdate";
    return 1;
}

static int lua_mapserver__ChangeMapSaveData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_ChangeMapSaveData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_ChangeMapSaveData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _ChangeMapSaveData* self = (_ChangeMapSaveData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__ChangeMapSaveData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_ChangeMapSaveData");
    tolua_cclass(tolua_S,"_ChangeMapSaveData","_ChangeMapSaveData","",nullptr);

    tolua_beginmodule(tolua_S,"_ChangeMapSaveData");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_ChangeMapSaveData).name();
    g_luaType[typeName] = "_ChangeMapSaveData";
    g_typeCast["_ChangeMapSaveData"] = "_ChangeMapSaveData";
    return 1;
}

int lua_mapserver_ChangeLineTempData_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    ChangeLineTempData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ChangeLineTempData",0,&tolua_err)) goto tolua_lerror;
    cobj = (ChangeLineTempData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_ChangeLineTempData_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("ChangeLineTempData:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_ChangeLineTempData_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_ChangeLineTempData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ChangeLineTempData* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new ChangeLineTempData();
        tolua_pushusertype(tolua_S,(void*)cobj,"ChangeLineTempData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("ChangeLineTempData:ChangeLineTempData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_ChangeLineTempData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ChangeLineTempData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ChangeLineTempData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ChangeLineTempData* self = (ChangeLineTempData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ChangeLineTempData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ChangeLineTempData");
    tolua_cclass(tolua_S,"ChangeLineTempData","ChangeLineTempData","",lua_mapserver_ChangeLineTempData_finalize);

    tolua_beginmodule(tolua_S,"ChangeLineTempData");
        tolua_function(tolua_S,"new",lua_mapserver_ChangeLineTempData_constructor);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_ChangeLineTempData_cleanUp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ChangeLineTempData).name();
    g_luaType[typeName] = "ChangeLineTempData";
    g_typeCast["ChangeLineTempData"] = "ChangeLineTempData";
    return 1;
}

static int lua_mapserver_RoleManageInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (RoleManageInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"RoleManageInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        RoleManageInfo* self = (RoleManageInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_RoleManageInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"RoleManageInfo");
    tolua_cclass(tolua_S,"RoleManageInfo","RoleManageInfo","",nullptr);

    tolua_beginmodule(tolua_S,"RoleManageInfo");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(RoleManageInfo).name();
    g_luaType[typeName] = "RoleManageInfo";
    g_typeCast["RoleManageInfo"] = "RoleManageInfo";
    return 1;
}

int lua_mapserver_CBufferManager_isBuffIDExist(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_isBuffIDExist'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CBufferManager:isBuffIDExist");
        if(!ok)
            return 0;
        bool ret = cobj->isBuffIDExist(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferManager:isBuffIDExist has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_isBuffIDExist'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_isReflectEvt(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_isReflectEvt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isReflectEvt();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferManager:isReflectEvt has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_isReflectEvt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_isForceHateEvt(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_isForceHateEvt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isForceHateEvt();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferManager:isForceHateEvt has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_isForceHateEvt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_addEffect(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CBufferManager_addEffect'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            CItemBuff* arg0;
            ok &= luaval_to_object<CItemBuff>(tolua_S, 2, "CItemBuff", &arg0, "CBufferManager:addEffect");

            if (!ok) { break; }
            int ret = (int)cobj->addEffect(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            CItemBuff* arg0;
            ok &= luaval_to_object<CItemBuff>(tolua_S, 2, "CItemBuff", &arg0, "CBufferManager:addEffect");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CBufferManager:addEffect");

            if (!ok) { break; }
            int ret = (int)cobj->addEffect(arg0, arg1);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            CSkillBuff* arg0;
            ok &= luaval_to_object<CSkillBuff>(tolua_S, 2, "CSkillBuff", &arg0, "CBufferManager:addEffect");

            if (!ok) { break; }
            int ret = (int)cobj->addEffect(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            CSkillBuff* arg0;
            ok &= luaval_to_object<CSkillBuff>(tolua_S, 2, "CSkillBuff", &arg0, "CBufferManager:addEffect");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CBufferManager:addEffect");

            if (!ok) { break; }
            int ret = (int)cobj->addEffect(arg0, arg1);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CBufferManager:addEffect has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_addEffect'.",&tolua_err);
    return 0;
}
int lua_mapserver_CBufferManager_isOnDamageEvt(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_isOnDamageEvt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isOnDamageEvt();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferManager:isOnDamageEvt has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_isOnDamageEvt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_getBuff(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_getBuff'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CBufferManager:getBuff");
        if(!ok)
            return 0;
        CBufferEffect* ret = cobj->getBuff(arg0);
        object_to_luaval<CBufferEffect>(tolua_S, "CBufferEffect",(CBufferEffect*)ret);
        return 1;
    }

    gxError("CBufferManager:getBuff has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_getBuff'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_sendDelAllEffect(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_sendDelAllEffect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->sendDelAllEffect();
        return 0;
    }

    gxError("CBufferManager:sendDelAllEffect has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_sendDelAllEffect'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_onHurt(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_onHurt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onHurt();
        return 0;
    }

    gxError("CBufferManager:onHurt has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_onHurt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_calcItemAttr(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_calcItemAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->calcItemAttr();
        return 0;
    }

    gxError("CBufferManager:calcItemAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_calcItemAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_onBeforeChangeLine(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_onBeforeChangeLine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ChangeLineTempData* arg0;

        ok &= luaval_to_object<ChangeLineTempData>(tolua_S, 2, "ChangeLineTempData", &arg0, "CBufferManager:onBeforeChangeLine");
        if(!ok)
            return 0;
        bool ret = cobj->onBeforeChangeLine(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferManager:onBeforeChangeLine has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_onBeforeChangeLine'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_clearActiveEffect(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_clearActiveEffect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->clearActiveEffect();
        return 0;
    }

    gxError("CBufferManager:clearActiveEffect has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_clearActiveEffect'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_isOnDieEvt(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_isOnDieEvt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isOnDieEvt();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferManager:isOnDieEvt has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_isOnDieEvt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_logAttr(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_logAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CBufferManager:logAttr");
        if(!ok)
            return 0;
        cobj->logAttr(arg0);
        return 0;
    }

    gxError("CBufferManager:logAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_logAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_onHit(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_onHit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onHit();
        return 0;
    }

    gxError("CBufferManager:onHit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_onHit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_getExpRate(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_getExpRate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getExpRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBufferManager:getExpRate has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_getExpRate'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_onSave(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_onSave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CBufferManager:onSave");
        if(!ok)
            return 0;
        cobj->onSave(arg0);
        return 0;
    }

    gxError("CBufferManager:onSave has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_onSave'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_getItemAttrs(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_getItemAttrs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CBufferAttr* ret = cobj->getItemAttrs();
        object_to_luaval<CBufferAttr>(tolua_S, "CBufferAttr",(CBufferAttr*)ret);
        return 1;
    }

    gxError("CBufferManager:getItemAttrs has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_getItemAttrs'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_sendDel(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_sendDel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CBufferEffect* arg0;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferManager:sendDel");
        if(!ok)
            return 0;
        cobj->sendDel(arg0);
        return 0;
    }

    gxError("CBufferManager:sendDel has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_sendDel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_rebuildEventFlags(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_rebuildEventFlags'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->rebuildEventFlags();
        return 0;
    }

    gxError("CBufferManager:rebuildEventFlags has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_rebuildEventFlags'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_onLoad(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_onLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onLoad();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferManager:onLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_onLoad'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_processActiveEffect(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_processActiveEffect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CBufferManager:processActiveEffect");
        if(!ok)
            return 0;
        cobj->processActiveEffect(arg0);
        return 0;
    }

    gxError("CBufferManager:processActiveEffect has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_processActiveEffect'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_calcPassiveAttr(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_calcPassiveAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->calcPassiveAttr();
        return 0;
    }

    gxError("CBufferManager:calcPassiveAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_calcPassiveAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_getBuffAry(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_getBuffAry'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CArray1<_PackSimpleBuff, 250>* arg0;

        ok &= luaval_to_object<CArray1<_PackSimpleBuff, 250>>(tolua_S, 2, "CArray1<_PackSimpleBuff, 250>", &arg0, "CBufferManager:getBuffAry");
        if(!ok)
            return 0;
        cobj->getBuffAry(arg0);
        return 0;
    }

    gxError("CBufferManager:getBuffAry has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_getBuffAry'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_getPassiveAttrs(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_getPassiveAttrs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CBufferAttr* ret = cobj->getPassiveAttrs();
        object_to_luaval<CBufferAttr>(tolua_S, "CBufferAttr",(CBufferAttr*)ret);
        return 1;
    }

    gxError("CBufferManager:getPassiveAttrs has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_getPassiveAttrs'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_sendAddAllEffect(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_sendAddAllEffect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->sendAddAllEffect();
        return 0;
    }
    if (argc == 1) 
    {
        CRoleBase* arg0;

        ok &= luaval_to_object<CRoleBase>(tolua_S, 2, "CRoleBase", &arg0, "CBufferManager:sendAddAllEffect");
        if(!ok)
            return 0;
        cobj->sendAddAllEffect(arg0);
        return 0;
    }

    gxError("CBufferManager:sendAddAllEffect has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_sendAddAllEffect'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_update(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CBufferManager:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CBufferManager:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_clearItemEffect(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_clearItemEffect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->clearItemEffect();
        return 0;
    }

    gxError("CBufferManager:clearItemEffect has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_clearItemEffect'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_getBuffAttrs(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_getBuffAttrs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CBufferAttr* ret = cobj->getBuffAttrs();
        object_to_luaval<CBufferAttr>(tolua_S, "CBufferAttr",(CBufferAttr*)ret);
        return 1;
    }

    gxError("CBufferManager:getBuffAttrs has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_getBuffAttrs'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_rebuildActionFlags(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_rebuildActionFlags'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->rebuildActionFlags();
        return 0;
    }

    gxError("CBufferManager:rebuildActionFlags has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_rebuildActionFlags'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_isStopEvt(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_isStopEvt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isStopEvt();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferManager:isStopEvt has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_isStopEvt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_onBeUseSkill(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_onBeUseSkill'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CBufferManager:onBeUseSkill");
        if(!ok)
            return 0;
        cobj->onBeUseSkill(arg0);
        return 0;
    }

    gxError("CBufferManager:onBeUseSkill has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_onBeUseSkill'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_isSleepEvt(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_isSleepEvt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isSleepEvt();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferManager:isSleepEvt has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_isSleepEvt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_onAfterChangeLine(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_onAfterChangeLine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ChangeLineTempData* arg0;

        ok &= luaval_to_object<ChangeLineTempData>(tolua_S, 2, "ChangeLineTempData", &arg0, "CBufferManager:onAfterChangeLine");
        if(!ok)
            return 0;
        bool ret = cobj->onAfterChangeLine(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferManager:onAfterChangeLine has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_onAfterChangeLine'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_addPassiveEffect(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_addPassiveEffect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CSkillBuff* arg0;

        ok &= luaval_to_object<CSkillBuff>(tolua_S, 2, "CSkillBuff", &arg0, "CBufferManager:addPassiveEffect");
        if(!ok)
            return 0;
        int ret = (int)cobj->addPassiveEffect(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        CSkillBuff* arg0;
        bool arg1;

        ok &= luaval_to_object<CSkillBuff>(tolua_S, 2, "CSkillBuff", &arg0, "CBufferManager:addPassiveEffect");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CBufferManager:addPassiveEffect");
        if(!ok)
            return 0;
        int ret = (int)cobj->addPassiveEffect(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBufferManager:addPassiveEffect has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_addPassiveEffect'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_sendAdd(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_sendAdd'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CBufferEffect* arg0;

        ok &= luaval_to_object<CBufferEffect>(tolua_S, 2, "CBufferEffect", &arg0, "CBufferManager:sendAdd");
        if(!ok)
            return 0;
        cobj->sendAdd(arg0);
        return 0;
    }

    gxError("CBufferManager:sendAdd has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_sendAdd'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_onDie(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_onDie'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onDie();
        return 0;
    }

    gxError("CBufferManager:onDie has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_onDie'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_calcActiveAttr(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_calcActiveAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->calcActiveAttr();
        return 0;
    }

    gxError("CBufferManager:calcActiveAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_calcActiveAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_isDizzEvt(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_isDizzEvt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDizzEvt();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferManager:isDizzEvt has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_isDizzEvt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_processItemEffect(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_processItemEffect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CBufferManager:processItemEffect");
        if(!ok)
            return 0;
        cobj->processItemEffect(arg0);
        return 0;
    }

    gxError("CBufferManager:processItemEffect has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_processItemEffect'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_loadPassiveEffect(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_loadPassiveEffect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->loadPassiveEffect();
        return 0;
    }

    gxError("CBufferManager:loadPassiveEffect has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_loadPassiveEffect'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_processPassivEffect(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_processPassivEffect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->processPassivEffect();
        return 0;
    }

    gxError("CBufferManager:processPassivEffect has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_processPassivEffect'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_onStudySkill(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferManager_onStudySkill'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned short arg0;
        char arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CBufferManager:onStudySkill");

        ok &= luaval_to_sint8(tolua_S, 3,(sint8*)&arg1, "CBufferManager:onStudySkill");
        if(!ok)
            return 0;
        cobj->onStudySkill(arg0, arg1);
        return 0;
    }

    gxError("CBufferManager:onStudySkill has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_onStudySkill'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferManager_InitImpacts(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CBufferManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        bool ret = CBufferManager::InitImpacts();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CBufferManager:InitImpacts has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_InitImpacts'.", &tolua_err);
    return 0;
}
int lua_mapserver_CBufferManager_CalcPassiveAttr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CBufferManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        std::vector<OwnSkill, std::allocator<OwnSkill> >* arg0;
        CBufferAttr* arg1;
        ok &= luaval_to_object<std::vector<OwnSkill, std::allocator<OwnSkill> >>(tolua_S, 2, "std::vector<OwnSkill, std::allocator<OwnSkill> >*", &arg0, "CBufferManager:CalcPassiveAttr");
        ok &= luaval_to_object<CBufferAttr>(tolua_S, 3, "CBufferAttr", &arg1, "CBufferManager:CalcPassiveAttr");
        if(!ok)
            return 0;
        CBufferManager::CalcPassiveAttr(arg0, arg1);
        return 0;
    }
    gxError("CBufferManager:CalcPassiveAttr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferManager_CalcPassiveAttr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CBufferManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CBufferManager* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CBufferManager();
        tolua_pushusertype(tolua_S,(void*)cobj,"CBufferManager");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CBufferManager:CBufferManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CBufferManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBufferManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBufferManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CBufferManager* self = (CBufferManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CBufferManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBufferManager");
    tolua_cclass(tolua_S,"CBufferManager","CBufferManager","",lua_mapserver_CBufferManager_finalize);

    tolua_beginmodule(tolua_S,"CBufferManager");
        tolua_function(tolua_S,"new",lua_mapserver_CBufferManager_constructor);
        tolua_function(tolua_S,"isBuffIDExist",lua_mapserver_CBufferManager_isBuffIDExist);
        tolua_function(tolua_S,"isReflectEvt",lua_mapserver_CBufferManager_isReflectEvt);
        tolua_function(tolua_S,"isForceHateEvt",lua_mapserver_CBufferManager_isForceHateEvt);
        tolua_function(tolua_S,"addEffect",lua_mapserver_CBufferManager_addEffect);
        tolua_function(tolua_S,"isOnDamageEvt",lua_mapserver_CBufferManager_isOnDamageEvt);
        tolua_function(tolua_S,"getBuff",lua_mapserver_CBufferManager_getBuff);
        tolua_function(tolua_S,"sendDelAllEffect",lua_mapserver_CBufferManager_sendDelAllEffect);
        tolua_function(tolua_S,"onHurt",lua_mapserver_CBufferManager_onHurt);
        tolua_function(tolua_S,"calcItemAttr",lua_mapserver_CBufferManager_calcItemAttr);
        tolua_function(tolua_S,"onBeforeChangeLine",lua_mapserver_CBufferManager_onBeforeChangeLine);
        tolua_function(tolua_S,"clearActiveEffect",lua_mapserver_CBufferManager_clearActiveEffect);
        tolua_function(tolua_S,"isOnDieEvt",lua_mapserver_CBufferManager_isOnDieEvt);
        tolua_function(tolua_S,"logAttr",lua_mapserver_CBufferManager_logAttr);
        tolua_function(tolua_S,"onHit",lua_mapserver_CBufferManager_onHit);
        tolua_function(tolua_S,"getExpRate",lua_mapserver_CBufferManager_getExpRate);
        tolua_function(tolua_S,"onSave",lua_mapserver_CBufferManager_onSave);
        tolua_function(tolua_S,"getItemAttrs",lua_mapserver_CBufferManager_getItemAttrs);
        tolua_function(tolua_S,"sendDel",lua_mapserver_CBufferManager_sendDel);
        tolua_function(tolua_S,"rebuildEventFlags",lua_mapserver_CBufferManager_rebuildEventFlags);
        tolua_function(tolua_S,"onLoad",lua_mapserver_CBufferManager_onLoad);
        tolua_function(tolua_S,"processActiveEffect",lua_mapserver_CBufferManager_processActiveEffect);
        tolua_function(tolua_S,"calcPassiveAttr",lua_mapserver_CBufferManager_calcPassiveAttr);
        tolua_function(tolua_S,"getBuffAry",lua_mapserver_CBufferManager_getBuffAry);
        tolua_function(tolua_S,"getPassiveAttrs",lua_mapserver_CBufferManager_getPassiveAttrs);
        tolua_function(tolua_S,"sendAddAllEffect",lua_mapserver_CBufferManager_sendAddAllEffect);
        tolua_function(tolua_S,"update",lua_mapserver_CBufferManager_update);
        tolua_function(tolua_S,"clearItemEffect",lua_mapserver_CBufferManager_clearItemEffect);
        tolua_function(tolua_S,"getBuffAttrs",lua_mapserver_CBufferManager_getBuffAttrs);
        tolua_function(tolua_S,"rebuildActionFlags",lua_mapserver_CBufferManager_rebuildActionFlags);
        tolua_function(tolua_S,"isStopEvt",lua_mapserver_CBufferManager_isStopEvt);
        tolua_function(tolua_S,"onBeUseSkill",lua_mapserver_CBufferManager_onBeUseSkill);
        tolua_function(tolua_S,"isSleepEvt",lua_mapserver_CBufferManager_isSleepEvt);
        tolua_function(tolua_S,"onAfterChangeLine",lua_mapserver_CBufferManager_onAfterChangeLine);
        tolua_function(tolua_S,"addPassiveEffect",lua_mapserver_CBufferManager_addPassiveEffect);
        tolua_function(tolua_S,"sendAdd",lua_mapserver_CBufferManager_sendAdd);
        tolua_function(tolua_S,"onDie",lua_mapserver_CBufferManager_onDie);
        tolua_function(tolua_S,"calcActiveAttr",lua_mapserver_CBufferManager_calcActiveAttr);
        tolua_function(tolua_S,"isDizzEvt",lua_mapserver_CBufferManager_isDizzEvt);
        tolua_function(tolua_S,"processItemEffect",lua_mapserver_CBufferManager_processItemEffect);
        tolua_function(tolua_S,"loadPassiveEffect",lua_mapserver_CBufferManager_loadPassiveEffect);
        tolua_function(tolua_S,"processPassivEffect",lua_mapserver_CBufferManager_processPassivEffect);
        tolua_function(tolua_S,"onStudySkill",lua_mapserver_CBufferManager_onStudySkill);
        tolua_function(tolua_S,"InitImpacts", lua_mapserver_CBufferManager_InitImpacts);
        tolua_function(tolua_S,"CalcPassiveAttr", lua_mapserver_CBufferManager_CalcPassiveAttr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CBufferManager).name();
    g_luaType[typeName] = "CBufferManager";
    g_typeCast["CBufferManager"] = "CBufferManager";
    return 1;
}

int lua_mapserver_CCharAttributeCore_setStrength(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setStrength'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:setStrength");
        if(!ok)
            return 0;
        cobj->setStrength(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setStrength has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setStrength'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addMaxHp(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addMaxHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addMaxHp");
        if(!ok)
            return 0;
        int ret = cobj->addMaxHp(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addMaxHp");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCore:addMaxHp");
        if(!ok)
            return 0;
        int ret = cobj->addMaxHp(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addMaxHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addMaxHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setDamage(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setDamage'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:setDamage");
        if(!ok)
            return 0;
        cobj->setDamage(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setDamage has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setDamage'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addPhysicDefense(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addPhysicDefense'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addPhysicDefense");
        if(!ok)
            return 0;
        int ret = cobj->addPhysicDefense(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addPhysicDefense has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addPhysicDefense'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getFightPower(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getFightPower'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFightPower();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getFightPower has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getFightPower'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getMaxExp(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getMaxExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxExp();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CCharAttributeCore:getMaxExp");
        if(!ok)
            return 0;
        int ret = cobj->getMaxExp(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getMaxExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getMaxExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addPower(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addPower'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addPower");
        if(!ok)
            return 0;
        int ret = cobj->addPower(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addPower");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCore:addPower");
        if(!ok)
            return 0;
        int ret = cobj->addPower(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addPower has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addPower'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getDodge(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getDodge'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getDodge();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getDodge has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getDodge'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setCharacter(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setCharacter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharAttributeCore:setCharacter");
        if(!ok)
            return 0;
        cobj->setCharacter(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setCharacter has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setCharacter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_markAttrDirty(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_markAttrDirty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CCharAttributeCore:markAttrDirty");
        if(!ok)
            return 0;
        cobj->markAttrDirty(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:markAttrDirty has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_markAttrDirty'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getFightAgility(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getFightAgility'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFightAgility();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getFightAgility has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getFightAgility'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addAttackRange(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addAttackRange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addAttackRange");
        if(!ok)
            return 0;
        int ret = cobj->addAttackRange(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addAttackRange has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addAttackRange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setDodge(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setDodge'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:setDodge");
        if(!ok)
            return 0;
        cobj->setDodge(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setDodge has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setDodge'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getMoveSpeed(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getMoveSpeed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        short ret = cobj->getMoveSpeed();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getMoveSpeed has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getMoveSpeed'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getFormulaAttrValue(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getFormulaAttrValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CCharAttributeCore:getFormulaAttrValue");
        if(!ok)
            return 0;
        int ret = cobj->getFormulaAttrValue(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getFormulaAttrValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getFormulaAttrValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setAttackSpeed(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setAttackSpeed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:setAttackSpeed");
        if(!ok)
            return 0;
        cobj->setAttackSpeed(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setAttackSpeed has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setAttackSpeed'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addDamage(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addDamage'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addDamage");
        if(!ok)
            return 0;
        int ret = cobj->addDamage(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addDamage");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCore:addDamage");
        if(!ok)
            return 0;
        int ret = cobj->addDamage(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addDamage has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addDamage'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setAttackRange(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setAttackRange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:setAttackRange");
        if(!ok)
            return 0;
        cobj->setAttackRange(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setAttackRange has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setAttackRange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setExp(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:setExp");
        if(!ok)
            return 0;
        cobj->setExp(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_logBufferAttr(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_logBufferAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CCharAttributeCore:logBufferAttr");
        if(!ok)
            return 0;
        const std::string ret = cobj->logBufferAttr(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CCharAttributeCore:logBufferAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_logBufferAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addLevel(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CCharAttributeCore:addLevel");
        if(!ok)
            return 0;
        unsigned char ret = cobj->addLevel(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned char arg0;
        bool arg1;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CCharAttributeCore:addLevel");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCore:addLevel");
        if(!ok)
            return 0;
        unsigned char ret = cobj->addLevel(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getFightDamage(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getFightDamage'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFightDamage();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getFightDamage has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getFightDamage'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getCrit(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getCrit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getCrit();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getCrit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getCrit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_onLevelChanged(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_onLevelChanged'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        unsigned int arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharAttributeCore:onLevelChanged");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CCharAttributeCore:onLevelChanged");
        if(!ok)
            return 0;
        cobj->onLevelChanged(arg0, arg1);
        return 0;
    }

    gxError("CCharAttributeCore:onLevelChanged has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_onLevelChanged'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addPhysicAttack(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addPhysicAttack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addPhysicAttack");
        if(!ok)
            return 0;
        int ret = cobj->addPhysicAttack(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addPhysicAttack has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addPhysicAttack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setWisdom(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setWisdom'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:setWisdom");
        if(!ok)
            return 0;
        cobj->setWisdom(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setWisdom has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setWisdom'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getAttackRange(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getAttackRange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getAttackRange();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getAttackRange has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getAttackRange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_updateOutBlock(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_updateOutBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:updateOutBlock");
        if(!ok)
            return 0;
        bool ret = cobj->updateOutBlock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharAttributeCore:updateOutBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_updateOutBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getMaxLevel(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getMaxLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getMaxLevel();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getMaxLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getMaxLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getFightWisdom(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getFightWisdom'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFightWisdom();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getFightWisdom has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getFightWisdom'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getSkillAttr(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getSkillAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CSkillAttr* ret = cobj->getSkillAttr();
        object_to_luaval<CSkillAttr>(tolua_S, "CSkillAttr",(CSkillAttr*)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getSkillAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getSkillAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_logEquipAttr(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_logEquipAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CCharAttributeCore:logEquipAttr");
        if(!ok)
            return 0;
        const std::string ret = cobj->logEquipAttr(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CCharAttributeCore:logEquipAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_logEquipAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getPhysicDefense(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getPhysicDefense'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPhysicDefense();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getPhysicDefense has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getPhysicDefense'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_doExpLevelUp(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_doExpLevelUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:doExpLevelUp");
        if(!ok)
            return 0;
        int ret = cobj->doExpLevelUp(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:doExpLevelUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_doExpLevelUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setPower(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setPower'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:setPower");
        if(!ok)
            return 0;
        cobj->setPower(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setPower has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setPower'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_refreshFast(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_refreshFast'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->refreshFast();
        return 0;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CCharAttributeCore:refreshFast");
        if(!ok)
            return 0;
        cobj->refreshFast(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:refreshFast has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_refreshFast'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setHp(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:setHp");
        if(!ok)
            return 0;
        cobj->setHp(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getLevel(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getLevel();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setAgility(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setAgility'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:setAgility");
        if(!ok)
            return 0;
        cobj->setAgility(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setAgility has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setAgility'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getPhysicAttck(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getPhysicAttck'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPhysicAttck();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getPhysicAttck has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getPhysicAttck'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_logBaseAttr(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_logBaseAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CCharAttributeCore:logBaseAttr");
        if(!ok)
            return 0;
        const std::string ret = cobj->logBaseAttr(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CCharAttributeCore:logBaseAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_logBaseAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getWisdom(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getWisdom'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getWisdom();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getWisdom has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getWisdom'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_loadBaseAttr(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_loadBaseAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CAttrBase<int, 49>* arg0;

        ok &= luaval_to_object<CAttrBase<int, 49>>(tolua_S, 2, "CAttrBase<int, 49>", &arg0, "CCharAttributeCore:loadBaseAttr");
        if(!ok)
            return 0;
        cobj->loadBaseAttr(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:loadBaseAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_loadBaseAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setJob(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setJob'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CCharAttributeCore:setJob");
        if(!ok)
            return 0;
        cobj->setJob(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setJob has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setJob'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addAgility(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addAgility'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addAgility");
        if(!ok)
            return 0;
        int ret = cobj->addAgility(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addAgility");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCore:addAgility");
        if(!ok)
            return 0;
        int ret = cobj->addAgility(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addAgility has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addAgility'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getFightStrength(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getFightStrength'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFightStrength();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getFightStrength has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getFightStrength'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getPower(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getPower'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPower();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getPower has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getPower'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getFightDodge(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getFightDodge'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFightDodge();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getFightDodge has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getFightDodge'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addCrit(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addCrit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addCrit");
        if(!ok)
            return 0;
        int ret = cobj->addCrit(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addCrit has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addCrit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getNeedAddHpToMax(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getNeedAddHpToMax'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getNeedAddHpToMax();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getNeedAddHpToMax has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getNeedAddHpToMax'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getFightAttrValue(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getFightAttrValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CCharAttributeCore:getFightAttrValue");
        if(!ok)
            return 0;
        int ret = cobj->getFightAttrValue(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getFightAttrValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getFightAttrValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_markAllAttrDirty(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_markAllAttrDirty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->markAllAttrDirty();
        return 0;
    }

    gxError("CCharAttributeCore:markAllAttrDirty has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_markAllAttrDirty'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getStrength(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getStrength'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getStrength();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getStrength has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getStrength'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setLevel(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CCharAttributeCore:setLevel");
        if(!ok)
            return 0;
        cobj->setLevel(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addAttrValue(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addAttrValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char arg0;
        int arg1;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CCharAttributeCore:addAttrValue");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CCharAttributeCore:addAttrValue");
        if(!ok)
            return 0;
        int ret = cobj->addAttrValue(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addAttrValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addAttrValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addAttackSpeed(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addAttackSpeed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addAttackSpeed");
        if(!ok)
            return 0;
        int ret = cobj->addAttackSpeed(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addAttackSpeed has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addAttackSpeed'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_update(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharAttributeCore:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getMaxHp(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getMaxHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxHp();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getMaxHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getMaxHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getAttrValue(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getAttrValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CCharAttributeCore:getAttrValue");
        if(!ok)
            return 0;
        int ret = cobj->getAttrValue(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getAttrValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getAttrValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getJob(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getJob'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getJob();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getJob has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getJob'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addDodge(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addDodge'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addDodge");
        if(!ok)
            return 0;
        int ret = cobj->addDodge(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addDodge");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCore:addDodge");
        if(!ok)
            return 0;
        int ret = cobj->addDodge(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addDodge has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addDodge'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addStrength(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addStrength'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addStrength");
        if(!ok)
            return 0;
        int ret = cobj->addStrength(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addStrength");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCore:addStrength");
        if(!ok)
            return 0;
        int ret = cobj->addStrength(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addStrength has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addStrength'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addExp(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addExp");
        if(!ok)
            return 0;
        int ret = cobj->addExp(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addExp");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCore:addExp");
        if(!ok)
            return 0;
        int ret = cobj->addExp(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addWisdom(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addWisdom'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addWisdom");
        if(!ok)
            return 0;
        int ret = cobj->addWisdom(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addWisdom");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCore:addWisdom");
        if(!ok)
            return 0;
        int ret = cobj->addWisdom(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addWisdom has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addWisdom'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getFightPhysicDefense(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getFightPhysicDefense'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFightPhysicDefense();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getFightPhysicDefense has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getFightPhysicDefense'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_hpChange(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_hpChange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:hpChange");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CCharAttributeCore:hpChange");
        if(!ok)
            return 0;
        int ret = cobj->hpChange(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:hpChange has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_hpChange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getBaseAttrValue(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getBaseAttrValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CCharAttributeCore:getBaseAttrValue");
        if(!ok)
            return 0;
        int ret = cobj->getBaseAttrValue(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getBaseAttrValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getBaseAttrValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getFightCrit(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getFightCrit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFightCrit();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getFightCrit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getFightCrit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getExp(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getExp();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getAgility(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getAgility'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getAgility();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getAgility has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getAgility'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addHp(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addHp");
        if(!ok)
            return 0;
        int ret = cobj->addHp(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addHp");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCore:addHp");
        if(!ok)
            return 0;
        int ret = cobj->addHp(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getDamage(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getDamage'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getDamage();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getDamage has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getDamage'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_logTotalAttr(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_logTotalAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CCharAttributeCore:logTotalAttr");
        if(!ok)
            return 0;
        const std::string ret = cobj->logTotalAttr(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CCharAttributeCore:logTotalAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_logTotalAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getFightPhysicAttack(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getFightPhysicAttack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFightPhysicAttack();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getFightPhysicAttack has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getFightPhysicAttack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setAttrValue(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setAttrValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char arg0;
        unsigned int arg1;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CCharAttributeCore:setAttrValue");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CCharAttributeCore:setAttrValue");
        if(!ok)
            return 0;
        cobj->setAttrValue(arg0, arg1);
        return 0;
    }

    gxError("CCharAttributeCore:setAttrValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setAttrValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getAttackSpeed(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getAttackSpeed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getAttackSpeed();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getAttackSpeed has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getAttackSpeed'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_addMoveSpeed(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_addMoveSpeed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addMoveSpeed");
        if(!ok)
            return 0;
        short ret = cobj->addMoveSpeed(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:addMoveSpeed");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCore:addMoveSpeed");
        if(!ok)
            return 0;
        short ret = cobj->addMoveSpeed(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:addMoveSpeed has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_addMoveSpeed'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setMoveSpeed(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setMoveSpeed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        short arg0;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CCharAttributeCore:setMoveSpeed");
        if(!ok)
            return 0;
        cobj->setMoveSpeed(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setMoveSpeed has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setMoveSpeed'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CCharAttributeCore:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getHp(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getHp();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_setCrit(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_setCrit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCore:setCrit");
        if(!ok)
            return 0;
        cobj->setCrit(arg0);
        return 0;
    }

    gxError("CCharAttributeCore:setCrit has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_setCrit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_getNeedAddToMax(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_getNeedAddToMax'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CCharAttributeCore:getNeedAddToMax");
        if(!ok)
            return 0;
        int ret = cobj->getNeedAddToMax(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCore:getNeedAddToMax has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_getNeedAddToMax'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCore_logCombatResult(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCore_logCombatResult'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CCharAttributeCore:logCombatResult");
        if(!ok)
            return 0;
        const std::string ret = cobj->logCombatResult(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CCharAttributeCore:logCombatResult has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCore_logCombatResult'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CCharAttributeCore_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCharAttributeCore)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCharAttributeCore",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CCharAttributeCore* self = (CCharAttributeCore*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CCharAttributeCore(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCharAttributeCore");
    tolua_cclass(tolua_S,"CCharAttributeCore","CCharAttributeCore","",nullptr);

    tolua_beginmodule(tolua_S,"CCharAttributeCore");
        tolua_function(tolua_S,"setStrength",lua_mapserver_CCharAttributeCore_setStrength);
        tolua_function(tolua_S,"addMaxHp",lua_mapserver_CCharAttributeCore_addMaxHp);
        tolua_function(tolua_S,"setDamage",lua_mapserver_CCharAttributeCore_setDamage);
        tolua_function(tolua_S,"addPhysicDefense",lua_mapserver_CCharAttributeCore_addPhysicDefense);
        tolua_function(tolua_S,"getFightPower",lua_mapserver_CCharAttributeCore_getFightPower);
        tolua_function(tolua_S,"getMaxExp",lua_mapserver_CCharAttributeCore_getMaxExp);
        tolua_function(tolua_S,"addPower",lua_mapserver_CCharAttributeCore_addPower);
        tolua_function(tolua_S,"getDodge",lua_mapserver_CCharAttributeCore_getDodge);
        tolua_function(tolua_S,"setCharacter",lua_mapserver_CCharAttributeCore_setCharacter);
        tolua_function(tolua_S,"markAttrDirty",lua_mapserver_CCharAttributeCore_markAttrDirty);
        tolua_function(tolua_S,"getFightAgility",lua_mapserver_CCharAttributeCore_getFightAgility);
        tolua_function(tolua_S,"addAttackRange",lua_mapserver_CCharAttributeCore_addAttackRange);
        tolua_function(tolua_S,"setDodge",lua_mapserver_CCharAttributeCore_setDodge);
        tolua_function(tolua_S,"getMoveSpeed",lua_mapserver_CCharAttributeCore_getMoveSpeed);
        tolua_function(tolua_S,"getFormulaAttrValue",lua_mapserver_CCharAttributeCore_getFormulaAttrValue);
        tolua_function(tolua_S,"setAttackSpeed",lua_mapserver_CCharAttributeCore_setAttackSpeed);
        tolua_function(tolua_S,"addDamage",lua_mapserver_CCharAttributeCore_addDamage);
        tolua_function(tolua_S,"setAttackRange",lua_mapserver_CCharAttributeCore_setAttackRange);
        tolua_function(tolua_S,"setExp",lua_mapserver_CCharAttributeCore_setExp);
        tolua_function(tolua_S,"logBufferAttr",lua_mapserver_CCharAttributeCore_logBufferAttr);
        tolua_function(tolua_S,"addLevel",lua_mapserver_CCharAttributeCore_addLevel);
        tolua_function(tolua_S,"getFightDamage",lua_mapserver_CCharAttributeCore_getFightDamage);
        tolua_function(tolua_S,"getCrit",lua_mapserver_CCharAttributeCore_getCrit);
        tolua_function(tolua_S,"onLevelChanged",lua_mapserver_CCharAttributeCore_onLevelChanged);
        tolua_function(tolua_S,"addPhysicAttack",lua_mapserver_CCharAttributeCore_addPhysicAttack);
        tolua_function(tolua_S,"setWisdom",lua_mapserver_CCharAttributeCore_setWisdom);
        tolua_function(tolua_S,"getAttackRange",lua_mapserver_CCharAttributeCore_getAttackRange);
        tolua_function(tolua_S,"updateOutBlock",lua_mapserver_CCharAttributeCore_updateOutBlock);
        tolua_function(tolua_S,"getMaxLevel",lua_mapserver_CCharAttributeCore_getMaxLevel);
        tolua_function(tolua_S,"getFightWisdom",lua_mapserver_CCharAttributeCore_getFightWisdom);
        tolua_function(tolua_S,"getSkillAttr",lua_mapserver_CCharAttributeCore_getSkillAttr);
        tolua_function(tolua_S,"logEquipAttr",lua_mapserver_CCharAttributeCore_logEquipAttr);
        tolua_function(tolua_S,"getPhysicDefense",lua_mapserver_CCharAttributeCore_getPhysicDefense);
        tolua_function(tolua_S,"doExpLevelUp",lua_mapserver_CCharAttributeCore_doExpLevelUp);
        tolua_function(tolua_S,"setPower",lua_mapserver_CCharAttributeCore_setPower);
        tolua_function(tolua_S,"refreshFast",lua_mapserver_CCharAttributeCore_refreshFast);
        tolua_function(tolua_S,"setHp",lua_mapserver_CCharAttributeCore_setHp);
        tolua_function(tolua_S,"getLevel",lua_mapserver_CCharAttributeCore_getLevel);
        tolua_function(tolua_S,"setAgility",lua_mapserver_CCharAttributeCore_setAgility);
        tolua_function(tolua_S,"getPhysicAttck",lua_mapserver_CCharAttributeCore_getPhysicAttck);
        tolua_function(tolua_S,"logBaseAttr",lua_mapserver_CCharAttributeCore_logBaseAttr);
        tolua_function(tolua_S,"getWisdom",lua_mapserver_CCharAttributeCore_getWisdom);
        tolua_function(tolua_S,"loadBaseAttr",lua_mapserver_CCharAttributeCore_loadBaseAttr);
        tolua_function(tolua_S,"setJob",lua_mapserver_CCharAttributeCore_setJob);
        tolua_function(tolua_S,"addAgility",lua_mapserver_CCharAttributeCore_addAgility);
        tolua_function(tolua_S,"getFightStrength",lua_mapserver_CCharAttributeCore_getFightStrength);
        tolua_function(tolua_S,"getPower",lua_mapserver_CCharAttributeCore_getPower);
        tolua_function(tolua_S,"getFightDodge",lua_mapserver_CCharAttributeCore_getFightDodge);
        tolua_function(tolua_S,"addCrit",lua_mapserver_CCharAttributeCore_addCrit);
        tolua_function(tolua_S,"getNeedAddHpToMax",lua_mapserver_CCharAttributeCore_getNeedAddHpToMax);
        tolua_function(tolua_S,"getFightAttrValue",lua_mapserver_CCharAttributeCore_getFightAttrValue);
        tolua_function(tolua_S,"markAllAttrDirty",lua_mapserver_CCharAttributeCore_markAllAttrDirty);
        tolua_function(tolua_S,"getStrength",lua_mapserver_CCharAttributeCore_getStrength);
        tolua_function(tolua_S,"setLevel",lua_mapserver_CCharAttributeCore_setLevel);
        tolua_function(tolua_S,"addAttrValue",lua_mapserver_CCharAttributeCore_addAttrValue);
        tolua_function(tolua_S,"addAttackSpeed",lua_mapserver_CCharAttributeCore_addAttackSpeed);
        tolua_function(tolua_S,"update",lua_mapserver_CCharAttributeCore_update);
        tolua_function(tolua_S,"getMaxHp",lua_mapserver_CCharAttributeCore_getMaxHp);
        tolua_function(tolua_S,"getAttrValue",lua_mapserver_CCharAttributeCore_getAttrValue);
        tolua_function(tolua_S,"getJob",lua_mapserver_CCharAttributeCore_getJob);
        tolua_function(tolua_S,"addDodge",lua_mapserver_CCharAttributeCore_addDodge);
        tolua_function(tolua_S,"addStrength",lua_mapserver_CCharAttributeCore_addStrength);
        tolua_function(tolua_S,"addExp",lua_mapserver_CCharAttributeCore_addExp);
        tolua_function(tolua_S,"addWisdom",lua_mapserver_CCharAttributeCore_addWisdom);
        tolua_function(tolua_S,"getFightPhysicDefense",lua_mapserver_CCharAttributeCore_getFightPhysicDefense);
        tolua_function(tolua_S,"hpChange",lua_mapserver_CCharAttributeCore_hpChange);
        tolua_function(tolua_S,"getBaseAttrValue",lua_mapserver_CCharAttributeCore_getBaseAttrValue);
        tolua_function(tolua_S,"getFightCrit",lua_mapserver_CCharAttributeCore_getFightCrit);
        tolua_function(tolua_S,"getExp",lua_mapserver_CCharAttributeCore_getExp);
        tolua_function(tolua_S,"getAgility",lua_mapserver_CCharAttributeCore_getAgility);
        tolua_function(tolua_S,"addHp",lua_mapserver_CCharAttributeCore_addHp);
        tolua_function(tolua_S,"getDamage",lua_mapserver_CCharAttributeCore_getDamage);
        tolua_function(tolua_S,"logTotalAttr",lua_mapserver_CCharAttributeCore_logTotalAttr);
        tolua_function(tolua_S,"getFightPhysicAttack",lua_mapserver_CCharAttributeCore_getFightPhysicAttack);
        tolua_function(tolua_S,"setAttrValue",lua_mapserver_CCharAttributeCore_setAttrValue);
        tolua_function(tolua_S,"getAttackSpeed",lua_mapserver_CCharAttributeCore_getAttackSpeed);
        tolua_function(tolua_S,"addMoveSpeed",lua_mapserver_CCharAttributeCore_addMoveSpeed);
        tolua_function(tolua_S,"setMoveSpeed",lua_mapserver_CCharAttributeCore_setMoveSpeed);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CCharAttributeCore_cleanUp);
        tolua_function(tolua_S,"getHp",lua_mapserver_CCharAttributeCore_getHp);
        tolua_function(tolua_S,"setCrit",lua_mapserver_CCharAttributeCore_setCrit);
        tolua_function(tolua_S,"getNeedAddToMax",lua_mapserver_CCharAttributeCore_getNeedAddToMax);
        tolua_function(tolua_S,"logCombatResult",lua_mapserver_CCharAttributeCore_logCombatResult);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CCharAttributeCore).name();
    g_luaType[typeName] = "CCharAttributeCore";
    g_typeCast["CCharAttributeCore"] = "CCharAttributeCore";
    return 1;
}

int lua_mapserver_CCharAttributeCoreExt_energyChange(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_energyChange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCoreExt:energyChange");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CCharAttributeCoreExt:energyChange");
        if(!ok)
            return 0;
        int ret = cobj->energyChange(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:energyChange has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_energyChange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_getMaxEnergy(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_getMaxEnergy'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxEnergy();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:getMaxEnergy has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_getMaxEnergy'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_getFightSkillAttack(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_getFightSkillAttack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFightSkillAttack();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:getFightSkillAttack has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_getFightSkillAttack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_setEnergy(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_setEnergy'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCoreExt:setEnergy");
        if(!ok)
            return 0;
        cobj->setEnergy(arg0);
        return 0;
    }

    gxError("CCharAttributeCoreExt:setEnergy has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_setEnergy'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_getDamageReduce(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_getDamageReduce'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getDamageReduce();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:getDamageReduce has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_getDamageReduce'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_getNeedAddEnergyToMax(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_getNeedAddEnergyToMax'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getNeedAddEnergyToMax();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:getNeedAddEnergyToMax has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_getNeedAddEnergyToMax'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_getEnergy(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_getEnergy'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getEnergy();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:getEnergy has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_getEnergy'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_addSkillAttack(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_addSkillAttack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCoreExt:addSkillAttack");
        if(!ok)
            return 0;
        int ret = cobj->addSkillAttack(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:addSkillAttack has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_addSkillAttack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_getFightDamageReduce(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_getFightDamageReduce'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFightDamageReduce();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:getFightDamageReduce has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_getFightDamageReduce'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_addEnergy(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_addEnergy'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCoreExt:addEnergy");
        if(!ok)
            return 0;
        int ret = cobj->addEnergy(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCoreExt:addEnergy");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCoreExt:addEnergy");
        if(!ok)
            return 0;
        int ret = cobj->addEnergy(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:addEnergy has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_addEnergy'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_setDamageReduce(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_setDamageReduce'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCoreExt:setDamageReduce");
        if(!ok)
            return 0;
        cobj->setDamageReduce(arg0);
        return 0;
    }

    gxError("CCharAttributeCoreExt:setDamageReduce has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_setDamageReduce'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_addMaxEnergy(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_addMaxEnergy'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCoreExt:addMaxEnergy");
        if(!ok)
            return 0;
        int ret = cobj->addMaxEnergy(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCoreExt:addMaxEnergy");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCoreExt:addMaxEnergy");
        if(!ok)
            return 0;
        int ret = cobj->addMaxEnergy(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:addMaxEnergy has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_addMaxEnergy'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_init(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const _CharacterInit* arg0;

        ok &= luaval_to_object<const _CharacterInit>(tolua_S, 2, "_CharacterInit", &arg0, "CCharAttributeCoreExt:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_getBufferManager(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_getBufferManager'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CBufferManager* ret = cobj->getBufferManager();
        object_to_luaval<CBufferManager>(tolua_S, "CBufferManager",(CBufferManager*)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:getBufferManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_getBufferManager'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_addDamageReduce(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_addDamageReduce'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCoreExt:addDamageReduce");
        if(!ok)
            return 0;
        int ret = cobj->addDamageReduce(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAttributeCoreExt:addDamageReduce");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharAttributeCoreExt:addDamageReduce");
        if(!ok)
            return 0;
        int ret = cobj->addDamageReduce(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:addDamageReduce has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_addDamageReduce'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAttributeCoreExt_getSkillAttack(lua_State* tolua_S)
{
    int argc = 0;
    CCharAttributeCoreExt* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAttributeCoreExt*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAttributeCoreExt_getSkillAttack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getSkillAttack();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAttributeCoreExt:getSkillAttack has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAttributeCoreExt_getSkillAttack'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CCharAttributeCoreExt_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCharAttributeCoreExt)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCharAttributeCoreExt",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CCharAttributeCoreExt* self = (CCharAttributeCoreExt*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CCharAttributeCoreExt(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCharAttributeCoreExt");
    tolua_cclass(tolua_S,"CCharAttributeCoreExt","CCharAttributeCoreExt","CCharAttributeCore",nullptr);

    tolua_beginmodule(tolua_S,"CCharAttributeCoreExt");
        tolua_function(tolua_S,"energyChange",lua_mapserver_CCharAttributeCoreExt_energyChange);
        tolua_function(tolua_S,"getMaxEnergy",lua_mapserver_CCharAttributeCoreExt_getMaxEnergy);
        tolua_function(tolua_S,"getFightSkillAttack",lua_mapserver_CCharAttributeCoreExt_getFightSkillAttack);
        tolua_function(tolua_S,"setEnergy",lua_mapserver_CCharAttributeCoreExt_setEnergy);
        tolua_function(tolua_S,"getDamageReduce",lua_mapserver_CCharAttributeCoreExt_getDamageReduce);
        tolua_function(tolua_S,"getNeedAddEnergyToMax",lua_mapserver_CCharAttributeCoreExt_getNeedAddEnergyToMax);
        tolua_function(tolua_S,"getEnergy",lua_mapserver_CCharAttributeCoreExt_getEnergy);
        tolua_function(tolua_S,"addSkillAttack",lua_mapserver_CCharAttributeCoreExt_addSkillAttack);
        tolua_function(tolua_S,"getFightDamageReduce",lua_mapserver_CCharAttributeCoreExt_getFightDamageReduce);
        tolua_function(tolua_S,"addEnergy",lua_mapserver_CCharAttributeCoreExt_addEnergy);
        tolua_function(tolua_S,"setDamageReduce",lua_mapserver_CCharAttributeCoreExt_setDamageReduce);
        tolua_function(tolua_S,"addMaxEnergy",lua_mapserver_CCharAttributeCoreExt_addMaxEnergy);
        tolua_function(tolua_S,"init",lua_mapserver_CCharAttributeCoreExt_init);
        tolua_function(tolua_S,"getBufferManager",lua_mapserver_CCharAttributeCoreExt_getBufferManager);
        tolua_function(tolua_S,"addDamageReduce",lua_mapserver_CCharAttributeCoreExt_addDamageReduce);
        tolua_function(tolua_S,"getSkillAttack",lua_mapserver_CCharAttributeCoreExt_getSkillAttack);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CCharAttributeCoreExt).name();
    g_luaType[typeName] = "CCharAttributeCoreExt";
    g_typeCast["CCharAttributeCoreExt"] = "CCharAttributeCoreExt";
    return 1;
}

static int lua_mapserver__PathPoint_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_PathPoint)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_PathPoint",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _PathPoint* self = (_PathPoint*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__PathPoint(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_PathPoint");
    tolua_cclass(tolua_S,"_PathPoint","_PathPoint","",nullptr);

    tolua_beginmodule(tolua_S,"_PathPoint");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_PathPoint).name();
    g_luaType[typeName] = "_PathPoint";
    g_typeCast["_PathPoint"] = "_PathPoint";
    return 1;
}

int lua_mapserver_CCharMoveCore_updateOutBlock(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_updateOutBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharMoveCore:updateOutBlock");
        if(!ok)
            return 0;
        bool ret = cobj->updateOutBlock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharMoveCore:updateOutBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_updateOutBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_isRangeEmptyPos(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_isRangeEmptyPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CCharMoveCore:isRangeEmptyPos");
        if(!ok)
            return 0;
        bool ret = cobj->isRangeEmptyPos(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharMoveCore:isRangeEmptyPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_isRangeEmptyPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_posListEmpty(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_posListEmpty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->posListEmpty();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharMoveCore:posListEmpty has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_posListEmpty'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_getRange(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_getRange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CCharMoveCore:getRange");
        if(!ok)
            return 0;
        unsigned short ret = cobj->getRange(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharMoveCore:getRange has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_getRange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_isSafeZone(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_isSafeZone'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isSafeZone();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharMoveCore:isSafeZone has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_isSafeZone'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_setCharacter(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_setCharacter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharMoveCore:setCharacter");
        if(!ok)
            return 0;
        cobj->setCharacter(arg0);
        return 0;
    }

    gxError("CCharMoveCore:setCharacter has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_setCharacter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_move(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CCharMoveCore_move'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::list<AxisPos, std::allocator<AxisPos> >* arg0;
            ok &= luaval_to_object<std::list<AxisPos, std::allocator<AxisPos> >>(tolua_S, 2, "std::list<AxisPos, std::allocator<AxisPos> >*", &arg0, "CCharMoveCore:move");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharMoveCore:move");

            if (!ok) { break; }
            bool ret = cobj->move(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            const AxisPos* arg0;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CCharMoveCore:move");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharMoveCore:move");

            if (!ok) { break; }
            bool ret = cobj->move(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            CArray1<AxisPos, 100>* arg0;
            ok &= luaval_to_object<CArray1<AxisPos, 100>>(tolua_S, 2, "CArray1<AxisPos, 100>", &arg0, "CCharMoveCore:move");

            if (!ok) { break; }
            bool ret = cobj->move(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CCharMoveCore:move has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_move'.",&tolua_err);
    return 0;
}
int lua_mapserver_CCharMoveCore_update(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharMoveCore:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharMoveCore:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_findRandEmptyPos(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_findRandEmptyPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        AxisPos* arg0;
        unsigned short arg1;

        ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CCharMoveCore:findRandEmptyPos");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CCharMoveCore:findRandEmptyPos");
        if(!ok)
            return 0;
        bool ret = cobj->findRandEmptyPos(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharMoveCore:findRandEmptyPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_findRandEmptyPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_init(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const _CharacterInit* arg0;

        ok &= luaval_to_object<const _CharacterInit>(tolua_S, 2, "_CharacterInit", &arg0, "CCharMoveCore:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharMoveCore:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CCharMoveCore:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_directMoveTo(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_directMoveTo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CCharMoveCore:directMoveTo");
        if(!ok)
            return 0;
        cobj->directMoveTo(arg0);
        return 0;
    }

    gxError("CCharMoveCore:directMoveTo has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_directMoveTo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_findEmptyPos(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_findEmptyPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        AxisPos* arg0;
        unsigned short arg1;

        ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CCharMoveCore:findEmptyPos");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CCharMoveCore:findEmptyPos");
        if(!ok)
            return 0;
        bool ret = cobj->findEmptyPos(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharMoveCore:findEmptyPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_findEmptyPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_isMoving(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_isMoving'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isMoving();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharMoveCore:isMoving has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_isMoving'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_moveLine(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_moveLine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CCharMoveCore:moveLine");
        if(!ok)
            return 0;
        bool ret = cobj->moveLine(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharMoveCore:moveLine has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_moveLine'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_getFinalTarPos(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMoveCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMoveCore_getFinalTarPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        AxisPos* ret = cobj->getFinalTarPos();
        object_to_luaval<AxisPos>(tolua_S, "AxisPos",(AxisPos*)ret);
        return 1;
    }

    gxError("CCharMoveCore:getFinalTarPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMoveCore_getFinalTarPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMoveCore_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CCharMoveCore* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CCharMoveCore();
        tolua_pushusertype(tolua_S,(void*)cobj,"CCharMoveCore");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CCharMoveCore:CCharMoveCore has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CCharMoveCore_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCharMoveCore)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCharMoveCore",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CCharMoveCore* self = (CCharMoveCore*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CCharMoveCore(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCharMoveCore");
    tolua_cclass(tolua_S,"CCharMoveCore","CCharMoveCore","CAStar<1, 15, 25>",lua_mapserver_CCharMoveCore_finalize);

    tolua_beginmodule(tolua_S,"CCharMoveCore");
        tolua_function(tolua_S,"new",lua_mapserver_CCharMoveCore_constructor);
        tolua_function(tolua_S,"updateOutBlock",lua_mapserver_CCharMoveCore_updateOutBlock);
        tolua_function(tolua_S,"isRangeEmptyPos",lua_mapserver_CCharMoveCore_isRangeEmptyPos);
        tolua_function(tolua_S,"posListEmpty",lua_mapserver_CCharMoveCore_posListEmpty);
        tolua_function(tolua_S,"getRange",lua_mapserver_CCharMoveCore_getRange);
        tolua_function(tolua_S,"isSafeZone",lua_mapserver_CCharMoveCore_isSafeZone);
        tolua_function(tolua_S,"setCharacter",lua_mapserver_CCharMoveCore_setCharacter);
        tolua_function(tolua_S,"move",lua_mapserver_CCharMoveCore_move);
        tolua_function(tolua_S,"update",lua_mapserver_CCharMoveCore_update);
        tolua_function(tolua_S,"findRandEmptyPos",lua_mapserver_CCharMoveCore_findRandEmptyPos);
        tolua_function(tolua_S,"init",lua_mapserver_CCharMoveCore_init);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CCharMoveCore_cleanUp);
        tolua_function(tolua_S,"directMoveTo",lua_mapserver_CCharMoveCore_directMoveTo);
        tolua_function(tolua_S,"findEmptyPos",lua_mapserver_CCharMoveCore_findEmptyPos);
        tolua_function(tolua_S,"isMoving",lua_mapserver_CCharMoveCore_isMoving);
        tolua_function(tolua_S,"moveLine",lua_mapserver_CCharMoveCore_moveLine);
        tolua_function(tolua_S,"getFinalTarPos",lua_mapserver_CCharMoveCore_getFinalTarPos);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CCharMoveCore).name();
    g_luaType[typeName] = "CCharMoveCore";
    g_typeCast["CCharMoveCore"] = "CCharMoveCore";
    return 1;
}

int lua_mapserver_CCharMsgHandle_onResetPos(lua_State* tolua_S)
{
    int argc = 0;
    CCharMsgHandle* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMsgHandle",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMsgHandle*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMsgHandle_onResetPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        unsigned int arg0;
        short arg1;
        short arg2;
        EResetPosType arg3;
        bool arg4;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharMsgHandle:onResetPos");

        ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CCharMsgHandle:onResetPos");

        ok &= luaval_to_sint16(tolua_S, 4,(sint16*)&arg2, "CCharMsgHandle:onResetPos");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CCharMsgHandle:onResetPos");

        ok &= luaval_to_boolean(tolua_S, 6,(bool*)&arg4, "CCharMsgHandle:onResetPos");
        if(!ok)
            return 0;
        cobj->onResetPos(arg0, arg1, arg2, arg3, arg4);
        return 0;
    }

    gxError("CCharMsgHandle:onResetPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMsgHandle_onResetPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMsgHandle_onActionBanChange(lua_State* tolua_S)
{
    int argc = 0;
    CCharMsgHandle* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMsgHandle",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMsgHandle*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMsgHandle_onActionBanChange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EActionBan arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharMsgHandle:onActionBanChange");
        if(!ok)
            return 0;
        cobj->onActionBanChange(arg0);
        return 0;
    }

    gxError("CCharMsgHandle:onActionBanChange has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMsgHandle_onActionBanChange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharMsgHandle_onMoveUpdate(lua_State* tolua_S)
{
    int argc = 0;
    CCharMsgHandle* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharMsgHandle",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharMsgHandle*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharMsgHandle_onMoveUpdate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CArray1<AxisPos, 100>* arg0;
        unsigned int arg1;

        ok &= luaval_to_object<CArray1<AxisPos, 100>>(tolua_S, 2, "CArray1<AxisPos, 100>", &arg0, "CCharMsgHandle:onMoveUpdate");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CCharMsgHandle:onMoveUpdate");
        if(!ok)
            return 0;
        cobj->onMoveUpdate(arg0, arg1);
        return 0;
    }

    gxError("CCharMsgHandle:onMoveUpdate has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharMsgHandle_onMoveUpdate'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CCharMsgHandle_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCharMsgHandle)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCharMsgHandle",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CCharMsgHandle* self = (CCharMsgHandle*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CCharMsgHandle(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCharMsgHandle");
    tolua_cclass(tolua_S,"CCharMsgHandle","CCharMsgHandle","",nullptr);

    tolua_beginmodule(tolua_S,"CCharMsgHandle");
        tolua_function(tolua_S,"onResetPos",lua_mapserver_CCharMsgHandle_onResetPos);
        tolua_function(tolua_S,"onActionBanChange",lua_mapserver_CCharMsgHandle_onActionBanChange);
        tolua_function(tolua_S,"onMoveUpdate",lua_mapserver_CCharMsgHandle_onMoveUpdate);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CCharMsgHandle).name();
    g_luaType[typeName] = "CCharMsgHandle";
    g_typeCast["CCharMsgHandle"] = "CCharMsgHandle";
    return 1;
}

int lua_mapserver__ScanOperatorInit_getScene(lua_State* tolua_S)
{
    int argc = 0;
    _ScanOperatorInit* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_ScanOperatorInit",0,&tolua_err)) goto tolua_lerror;
    cobj = (_ScanOperatorInit*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__ScanOperatorInit_getScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapSceneBase* ret = cobj->getScene();
        object_to_luaval<CMapSceneBase>(tolua_S, "CMapSceneBase",(CMapSceneBase*)ret);
        return 1;
    }

    gxError("_ScanOperatorInit:getScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__ScanOperatorInit_getScene'.",&tolua_err);
	return 0;
}
int lua_mapserver__ScanOperatorInit_constructor(lua_State* tolua_S)
{
    int argc = 0;
    _ScanOperatorInit* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new _ScanOperatorInit();
        tolua_pushusertype(tolua_S,(void*)cobj,"_ScanOperatorInit");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("_ScanOperatorInit:_ScanOperatorInit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver__ScanOperatorInit_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_ScanOperatorInit)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_ScanOperatorInit",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _ScanOperatorInit* self = (_ScanOperatorInit*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__ScanOperatorInit(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_ScanOperatorInit");
    tolua_cclass(tolua_S,"_ScanOperatorInit","_ScanOperatorInit","",lua_mapserver__ScanOperatorInit_finalize);

    tolua_beginmodule(tolua_S,"_ScanOperatorInit");
        tolua_function(tolua_S,"new",lua_mapserver__ScanOperatorInit_constructor);
        tolua_function(tolua_S,"getScene",lua_mapserver__ScanOperatorInit_getScene);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_ScanOperatorInit).name();
    g_luaType[typeName] = "_ScanOperatorInit";
    g_typeCast["_ScanOperatorInit"] = "_ScanOperatorInit";
    return 1;
}

int lua_mapserver_CScanOperator_isOnlyScanRole(lua_State* tolua_S)
{
    int argc = 0;
    CScanOperator* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScanOperator",0,&tolua_err)) goto tolua_lerror;
    cobj = (CScanOperator*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CScanOperator_isOnlyScanRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isOnlyScanRole();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CScanOperator:isOnlyScanRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CScanOperator_isOnlyScanRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CScanOperator_onBeforeScan(lua_State* tolua_S)
{
    int argc = 0;
    CScanOperator* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScanOperator",0,&tolua_err)) goto tolua_lerror;
    cobj = (CScanOperator*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CScanOperator_onBeforeScan'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onBeforeScan();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CScanOperator:onBeforeScan has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CScanOperator_onBeforeScan'.",&tolua_err);
	return 0;
}
int lua_mapserver_CScanOperator_getScanRange(lua_State* tolua_S)
{
    int argc = 0;
    CScanOperator* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScanOperator",0,&tolua_err)) goto tolua_lerror;
    cobj = (CScanOperator*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CScanOperator_getScanRange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getScanRange();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CScanOperator:getScanRange has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CScanOperator_getScanRange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CScanOperator_onFindObject(lua_State* tolua_S)
{
    int argc = 0;
    CScanOperator* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScanOperator",0,&tolua_err)) goto tolua_lerror;
    cobj = (CScanOperator*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CScanOperator_onFindObject'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CGameObject* arg0;

        ok &= luaval_to_object<CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CScanOperator:onFindObject");
        if(!ok)
            return 0;
        int ret = (int)cobj->onFindObject(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CScanOperator:onFindObject has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CScanOperator_onFindObject'.",&tolua_err);
	return 0;
}
int lua_mapserver_CScanOperator_isNeedScan(lua_State* tolua_S)
{
    int argc = 0;
    CScanOperator* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScanOperator",0,&tolua_err)) goto tolua_lerror;
    cobj = (CScanOperator*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CScanOperator_isNeedScan'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CScanOperator:isNeedScan");
        if(!ok)
            return 0;
        bool ret = cobj->isNeedScan(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CScanOperator:isNeedScan has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CScanOperator_isNeedScan'.",&tolua_err);
	return 0;
}
int lua_mapserver_CScanOperator_getBlockID(lua_State* tolua_S)
{
    int argc = 0;
    CScanOperator* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScanOperator",0,&tolua_err)) goto tolua_lerror;
    cobj = (CScanOperator*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CScanOperator_getBlockID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getBlockID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CScanOperator:getBlockID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CScanOperator_getBlockID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CScanOperator_onAfterScan(lua_State* tolua_S)
{
    int argc = 0;
    CScanOperator* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScanOperator",0,&tolua_err)) goto tolua_lerror;
    cobj = (CScanOperator*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CScanOperator_onAfterScan'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onAfterScan();
        return 0;
    }

    gxError("CScanOperator:onAfterScan has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CScanOperator_onAfterScan'.",&tolua_err);
	return 0;
}
int lua_mapserver_CScanOperator_init(lua_State* tolua_S)
{
    int argc = 0;
    CScanOperator* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScanOperator",0,&tolua_err)) goto tolua_lerror;
    cobj = (CScanOperator*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CScanOperator_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _ScanOperatorInit* arg0;

        ok &= luaval_to_object<_ScanOperatorInit>(tolua_S, 2, "_ScanOperatorInit", &arg0, "CScanOperator:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CScanOperator:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CScanOperator_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CScanOperator_getScene(lua_State* tolua_S)
{
    int argc = 0;
    CScanOperator* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScanOperator",0,&tolua_err)) goto tolua_lerror;
    cobj = (CScanOperator*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CScanOperator_getScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapSceneBase* ret = cobj->getScene();
        object_to_luaval<CMapSceneBase>(tolua_S, "CMapSceneBase",(CMapSceneBase*)ret);
        return 1;
    }

    gxError("CScanOperator:getScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CScanOperator_getScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CScanOperator_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CScanOperator* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CScanOperator();
        tolua_pushusertype(tolua_S,(void*)cobj,"CScanOperator");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CScanOperator:CScanOperator has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CScanOperator_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CScanOperator)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CScanOperator",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CScanOperator* self = (CScanOperator*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CScanOperator(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CScanOperator");
    tolua_cclass(tolua_S,"CScanOperator","CScanOperator","",lua_mapserver_CScanOperator_finalize);

    tolua_beginmodule(tolua_S,"CScanOperator");
        tolua_function(tolua_S,"new",lua_mapserver_CScanOperator_constructor);
        tolua_function(tolua_S,"isOnlyScanRole",lua_mapserver_CScanOperator_isOnlyScanRole);
        tolua_function(tolua_S,"onBeforeScan",lua_mapserver_CScanOperator_onBeforeScan);
        tolua_function(tolua_S,"getScanRange",lua_mapserver_CScanOperator_getScanRange);
        tolua_function(tolua_S,"onFindObject",lua_mapserver_CScanOperator_onFindObject);
        tolua_function(tolua_S,"isNeedScan",lua_mapserver_CScanOperator_isNeedScan);
        tolua_function(tolua_S,"getBlockID",lua_mapserver_CScanOperator_getBlockID);
        tolua_function(tolua_S,"onAfterScan",lua_mapserver_CScanOperator_onAfterScan);
        tolua_function(tolua_S,"init",lua_mapserver_CScanOperator_init);
        tolua_function(tolua_S,"getScene",lua_mapserver_CScanOperator_getScene);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CScanOperator).name();
    g_luaType[typeName] = "CScanOperator";
    g_typeCast["CScanOperator"] = "CScanOperator";
    return 1;
}

int lua_mapserver_CAttackPos_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CAttackPos* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAttackPos",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAttackPos*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAttackPos_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CAttackPos:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAttackPos_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAttackPos_toString(lua_State* tolua_S)
{
    int argc = 0;
    CAttackPos* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAttackPos",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAttackPos*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAttackPos_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CAttackPos:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAttackPos_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAttackPos_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CAttackPos* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CAttackPos();
        tolua_pushusertype(tolua_S,(void*)cobj,"CAttackPos");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CAttackPos:CAttackPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CAttackPos_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CAttackPos)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CAttackPos",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CAttackPos* self = (CAttackPos*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CAttackPos(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CAttackPos");
    tolua_cclass(tolua_S,"CAttackPos","CAttackPos","",lua_mapserver_CAttackPos_finalize);

    tolua_beginmodule(tolua_S,"CAttackPos");
        tolua_function(tolua_S,"new",lua_mapserver_CAttackPos_constructor);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CAttackPos_cleanUp);
        tolua_function(tolua_S,"toString",lua_mapserver_CAttackPos_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CAttackPos).name();
    g_luaType[typeName] = "CAttackPos";
    g_typeCast["CAttackPos"] = "CAttackPos";
    return 1;
}

int lua_mapserver_CAttackorList_logImpact(lua_State* tolua_S)
{
    int argc = 0;
    CAttackorList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAttackorList",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAttackorList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAttackorList_logImpact'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->logImpact();
        return 0;
    }

    gxError("CAttackorList:logImpact has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAttackorList_logImpact'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAttackorList_getAttactorList(lua_State* tolua_S)
{
    int argc = 0;
    CAttackorList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAttackorList",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAttackorList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAttackorList_getAttactorList'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CArray1<unsigned int, 50>* arg0;

        ok &= luaval_to_object<CArray1<unsigned int, 50>>(tolua_S, 2, "CArray1<unsigned int, 50>", &arg0, "CAttackorList:getAttactorList");
        if(!ok)
            return 0;
        cobj->getAttactorList(arg0);
        return 0;
    }

    gxError("CAttackorList:getAttactorList has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAttackorList_getAttactorList'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAttackorList_getImpactSize(lua_State* tolua_S)
{
    int argc = 0;
    CAttackorList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAttackorList",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAttackorList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAttackorList_getImpactSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getImpactSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CAttackorList:getImpactSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAttackorList_getImpactSize'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAttackorList_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CAttackorList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAttackorList",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAttackorList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAttackorList_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CAttackorList:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAttackorList_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAttackorList_push(lua_State* tolua_S)
{
    int argc = 0;
    CAttackorList* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAttackorList",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAttackorList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CAttackorList_push'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            AttackorImpact* arg0;
            ok &= luaval_to_object<AttackorImpact>(tolua_S, 2, "AttackorImpact", &arg0, "CAttackorList:push");

            if (!ok) { break; }
            cobj->push(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            CCharacterObject* arg0;
            ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CAttackorList:push");

            if (!ok) { break; }
            cobj->push(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CAttackorList:push has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAttackorList_push'.",&tolua_err);
    return 0;
}
int lua_mapserver_CAttackorList_getAttackObjSize(lua_State* tolua_S)
{
    int argc = 0;
    CAttackorList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAttackorList",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAttackorList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAttackorList_getAttackObjSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getAttackObjSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CAttackorList:getAttackObjSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAttackorList_getAttackObjSize'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAttackorList_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CAttackorList* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CAttackorList();
        tolua_pushusertype(tolua_S,(void*)cobj,"CAttackorList");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CAttackorList:CAttackorList has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CAttackorList_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CAttackorList)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CAttackorList",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CAttackorList* self = (CAttackorList*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CAttackorList(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CAttackorList");
    tolua_cclass(tolua_S,"CAttackorList","CAttackorList","",lua_mapserver_CAttackorList_finalize);

    tolua_beginmodule(tolua_S,"CAttackorList");
        tolua_function(tolua_S,"new",lua_mapserver_CAttackorList_constructor);
        tolua_function(tolua_S,"logImpact",lua_mapserver_CAttackorList_logImpact);
        tolua_function(tolua_S,"getAttactorList",lua_mapserver_CAttackorList_getAttactorList);
        tolua_function(tolua_S,"getImpactSize",lua_mapserver_CAttackorList_getImpactSize);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CAttackorList_cleanUp);
        tolua_function(tolua_S,"push",lua_mapserver_CAttackorList_push);
        tolua_function(tolua_S,"getAttackObjSize",lua_mapserver_CAttackorList_getAttackObjSize);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CAttackorList).name();
    g_luaType[typeName] = "CAttackorList";
    g_typeCast["CAttackorList"] = "CAttackorList";
    return 1;
}

int lua_mapserver_CAttackTarget_getTotalAddHp(lua_State* tolua_S)
{
    int argc = 0;
    CAttackTarget* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAttackTarget",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAttackTarget*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAttackTarget_getTotalAddHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        bool arg0;
        unsigned int arg1;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CAttackTarget:getTotalAddHp");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CAttackTarget:getTotalAddHp");
        if(!ok)
            return 0;
        double ret = cobj->getTotalAddHp(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CAttackTarget:getTotalAddHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAttackTarget_getTotalAddHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAttackTarget_single(lua_State* tolua_S)
{
    int argc = 0;
    CAttackTarget* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAttackTarget",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAttackTarget*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAttackTarget_single'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->single();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CAttackTarget:single has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAttackTarget_single'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAttackTarget_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CAttackTarget* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAttackTarget",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAttackTarget*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAttackTarget_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CAttackTarget:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAttackTarget_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAttackTarget_getTotalDescHp(lua_State* tolua_S)
{
    int argc = 0;
    CAttackTarget* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAttackTarget",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAttackTarget*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAttackTarget_getTotalDescHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        bool arg0;
        unsigned int arg1;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CAttackTarget:getTotalDescHp");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CAttackTarget:getTotalDescHp");
        if(!ok)
            return 0;
        double ret = cobj->getTotalDescHp(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CAttackTarget:getTotalDescHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAttackTarget_getTotalDescHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAttackTarget_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CAttackTarget* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CAttackTarget();
        tolua_pushusertype(tolua_S,(void*)cobj,"CAttackTarget");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CAttackTarget:CAttackTarget has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CAttackTarget_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CAttackTarget)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CAttackTarget",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CAttackTarget* self = (CAttackTarget*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CAttackTarget(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CAttackTarget");
    tolua_cclass(tolua_S,"CAttackTarget","CAttackTarget","",lua_mapserver_CAttackTarget_finalize);

    tolua_beginmodule(tolua_S,"CAttackTarget");
        tolua_function(tolua_S,"new",lua_mapserver_CAttackTarget_constructor);
        tolua_function(tolua_S,"getTotalAddHp",lua_mapserver_CAttackTarget_getTotalAddHp);
        tolua_function(tolua_S,"single",lua_mapserver_CAttackTarget_single);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CAttackTarget_cleanUp);
        tolua_function(tolua_S,"getTotalDescHp",lua_mapserver_CAttackTarget_getTotalDescHp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CAttackTarget).name();
    g_luaType[typeName] = "CAttackTarget";
    g_typeCast["CAttackTarget"] = "CAttackTarget";
    return 1;
}

int lua_mapserver_CCharSkillCore_getSkillList(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_getSkillList'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::vector<OwnSkill, std::allocator<OwnSkill> >* arg0;

        ok &= luaval_to_object<std::vector<OwnSkill, std::allocator<OwnSkill> >>(tolua_S, 2, "std::vector<OwnSkill, std::allocator<OwnSkill> >*", &arg0, "CCharSkillCore:getSkillList");
        if(!ok)
            return 0;
        cobj->getSkillList(arg0);
        return 0;
    }

    gxError("CCharSkillCore:getSkillList has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_getSkillList'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_getSkillLogicBase(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_getSkillLogicBase'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CSkillLogicBase* ret = cobj->getSkillLogicBase();
        object_to_luaval<CSkillLogicBase>(tolua_S, "CSkillLogicBase",(CSkillLogicBase*)ret);
        return 1;
    }

    gxError("CCharSkillCore:getSkillLogicBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_getSkillLogicBase'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_updateOutBlock(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_updateOutBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharSkillCore:updateOutBlock");
        if(!ok)
            return 0;
        bool ret = cobj->updateOutBlock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharSkillCore:updateOutBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_updateOutBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_getCommonSkill(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_getCommonSkill'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        OwnSkill* ret = cobj->getCommonSkill();
        object_to_luaval<OwnSkill>(tolua_S, "OwnSkill",(OwnSkill*)ret);
        return 1;
    }

    gxError("CCharSkillCore:getCommonSkill has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_getCommonSkill'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_getSkillID(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_getSkillID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getSkillID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharSkillCore:getSkillID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_getSkillID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_setCommSkillID(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_setCommSkillID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned short arg0;
        char arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CCharSkillCore:setCommSkillID");

        ok &= luaval_to_sint8(tolua_S, 3,(sint8*)&arg1, "CCharSkillCore:setCommSkillID");
        if(!ok)
            return 0;
        cobj->setCommSkillID(arg0, arg1);
        return 0;
    }

    gxError("CCharSkillCore:setCommSkillID has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_setCommSkillID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_setCharacter(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_setCharacter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharSkillCore:setCharacter");
        if(!ok)
            return 0;
        cobj->setCharacter(arg0);
        return 0;
    }

    gxError("CCharSkillCore:setCharacter has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_setCharacter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_getAttackors(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_getAttackors'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CArray1<AttackorImpact, 50>* arg0;

        ok &= luaval_to_object<CArray1<AttackorImpact, 50>>(tolua_S, 2, "CArray1<AttackorImpact, 50>", &arg0, "CCharSkillCore:getAttackors");
        if(!ok)
            return 0;
        cobj->getAttackors(arg0);
        return 0;
    }

    gxError("CCharSkillCore:getAttackors has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_getAttackors'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_use(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_use'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        unsigned int arg0;
        unsigned short arg1;
        short arg2;
        short arg3;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharSkillCore:use");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CCharSkillCore:use");

        ok &= luaval_to_sint16(tolua_S, 4,(sint16*)&arg2, "CCharSkillCore:use");

        ok &= luaval_to_sint16(tolua_S, 5,(sint16*)&arg3, "CCharSkillCore:use");
        if(!ok)
            return 0;
        int ret = (int)cobj->use(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharSkillCore:use has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_use'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_update(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharSkillCore:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharSkillCore:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_onAfterUse(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_onAfterUse'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onAfterUse();
        return 0;
    }

    gxError("CCharSkillCore:onAfterUse has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_onAfterUse'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_init(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const _CharacterInit* arg0;

        ok &= luaval_to_object<const _CharacterInit>(tolua_S, 2, "_CharacterInit", &arg0, "CCharSkillCore:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharSkillCore:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CCharSkillCore:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_getSN(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_getSN'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getSN();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharSkillCore:getSN has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_getSN'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_getCommSkillAttackDis(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_getCommSkillAttackDis'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getCommSkillAttackDis();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharSkillCore:getCommSkillAttackDis has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_getCommSkillAttackDis'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_getCommSkillID(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_getCommSkillID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getCommSkillID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharSkillCore:getCommSkillID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_getCommSkillID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_getSkillLevel(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharSkillCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharSkillCore_getSkillLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CCharSkillCore:getSkillLevel");
        if(!ok)
            return 0;
        char ret = cobj->getSkillLevel(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharSkillCore:getSkillLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharSkillCore_getSkillLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharSkillCore_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CCharSkillCore* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CCharSkillCore();
        tolua_pushusertype(tolua_S,(void*)cobj,"CCharSkillCore");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CCharSkillCore:CCharSkillCore has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CCharSkillCore_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCharSkillCore)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCharSkillCore",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CCharSkillCore* self = (CCharSkillCore*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CCharSkillCore(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCharSkillCore");
    tolua_cclass(tolua_S,"CCharSkillCore","CCharSkillCore","",lua_mapserver_CCharSkillCore_finalize);

    tolua_beginmodule(tolua_S,"CCharSkillCore");
        tolua_function(tolua_S,"new",lua_mapserver_CCharSkillCore_constructor);
        tolua_function(tolua_S,"getSkillList",lua_mapserver_CCharSkillCore_getSkillList);
        tolua_function(tolua_S,"getSkillLogicBase",lua_mapserver_CCharSkillCore_getSkillLogicBase);
        tolua_function(tolua_S,"updateOutBlock",lua_mapserver_CCharSkillCore_updateOutBlock);
        tolua_function(tolua_S,"getCommonSkill",lua_mapserver_CCharSkillCore_getCommonSkill);
        tolua_function(tolua_S,"getSkillID",lua_mapserver_CCharSkillCore_getSkillID);
        tolua_function(tolua_S,"setCommSkillID",lua_mapserver_CCharSkillCore_setCommSkillID);
        tolua_function(tolua_S,"setCharacter",lua_mapserver_CCharSkillCore_setCharacter);
        tolua_function(tolua_S,"getAttackors",lua_mapserver_CCharSkillCore_getAttackors);
        tolua_function(tolua_S,"use",lua_mapserver_CCharSkillCore_use);
        tolua_function(tolua_S,"update",lua_mapserver_CCharSkillCore_update);
        tolua_function(tolua_S,"onAfterUse",lua_mapserver_CCharSkillCore_onAfterUse);
        tolua_function(tolua_S,"init",lua_mapserver_CCharSkillCore_init);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CCharSkillCore_cleanUp);
        tolua_function(tolua_S,"getSN",lua_mapserver_CCharSkillCore_getSN);
        tolua_function(tolua_S,"getCommSkillAttackDis",lua_mapserver_CCharSkillCore_getCommSkillAttackDis);
        tolua_function(tolua_S,"getCommSkillID",lua_mapserver_CCharSkillCore_getCommSkillID);
        tolua_function(tolua_S,"getSkillLevel",lua_mapserver_CCharSkillCore_getSkillLevel);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CCharSkillCore).name();
    g_luaType[typeName] = "CCharSkillCore";
    g_typeCast["CCharSkillCore"] = "CCharSkillCore";
    return 1;
}

int lua_mapserver_CCooldown_reset(lua_State* tolua_S)
{
    int argc = 0;
    CCooldown* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCooldown",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCooldown*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCooldown_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }

    gxError("CCooldown:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCooldown_reset'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCooldown_setCoolDownID(lua_State* tolua_S)
{
    int argc = 0;
    CCooldown* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCooldown",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCooldown*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCooldown_setCoolDownID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCooldown:setCoolDownID");
        if(!ok)
            return 0;
        cobj->setCoolDownID(arg0);
        return 0;
    }

    gxError("CCooldown:setCoolDownID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCooldown_setCoolDownID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCooldown_getCooldownTime(lua_State* tolua_S)
{
    int argc = 0;
    CCooldown* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCooldown",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCooldown*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCooldown_getCooldownTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getCooldownTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCooldown:getCooldownTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCooldown_getCooldownTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCooldown_isInvalid(lua_State* tolua_S)
{
    int argc = 0;
    CCooldown* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCooldown",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCooldown*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCooldown_isInvalid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isInvalid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCooldown:isInvalid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCooldown_isInvalid'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCooldown_setCooldownTime(lua_State* tolua_S)
{
    int argc = 0;
    CCooldown* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCooldown",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCooldown*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCooldown_setCooldownTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCooldown:setCooldownTime");
        if(!ok)
            return 0;
        cobj->setCooldownTime(arg0);
        return 0;
    }

    gxError("CCooldown:setCooldownTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCooldown_setCooldownTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCooldown_getCoolDownID(lua_State* tolua_S)
{
    int argc = 0;
    CCooldown* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCooldown",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCooldown*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCooldown_getCoolDownID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getCoolDownID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCooldown:getCoolDownID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCooldown_getCoolDownID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCooldown_setCooldownElapsed(lua_State* tolua_S)
{
    int argc = 0;
    CCooldown* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCooldown",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCooldown*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCooldown_setCooldownElapsed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCooldown:setCooldownElapsed");
        if(!ok)
            return 0;
        cobj->setCooldownElapsed(arg0);
        return 0;
    }

    gxError("CCooldown:setCooldownElapsed has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCooldown_setCooldownElapsed'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCooldown_heartBeat(lua_State* tolua_S)
{
    int argc = 0;
    CCooldown* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCooldown",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCooldown*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCooldown_heartBeat'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCooldown:heartBeat");
        if(!ok)
            return 0;
        cobj->heartBeat(arg0);
        return 0;
    }

    gxError("CCooldown:heartBeat has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCooldown_heartBeat'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCooldown_getCooldownElapsed(lua_State* tolua_S)
{
    int argc = 0;
    CCooldown* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCooldown",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCooldown*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCooldown_getCooldownElapsed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getCooldownElapsed();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCooldown:getCooldownElapsed has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCooldown_getCooldownElapsed'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCooldown_isCooldowned(lua_State* tolua_S)
{
    int argc = 0;
    CCooldown* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCooldown",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCooldown*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCooldown_isCooldowned'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCooldowned();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCooldown:isCooldowned has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCooldown_isCooldowned'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCooldown_getRemainTime(lua_State* tolua_S)
{
    int argc = 0;
    CCooldown* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCooldown",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCooldown*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCooldown_getRemainTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getRemainTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCooldown:getRemainTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCooldown_getRemainTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCooldown_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CCooldown* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CCooldown();
        tolua_pushusertype(tolua_S,(void*)cobj,"CCooldown");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CCooldown:CCooldown has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CCooldown_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCooldown)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCooldown",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CCooldown* self = (CCooldown*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CCooldown(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCooldown");
    tolua_cclass(tolua_S,"CCooldown","CCooldown","",lua_mapserver_CCooldown_finalize);

    tolua_beginmodule(tolua_S,"CCooldown");
        tolua_function(tolua_S,"new",lua_mapserver_CCooldown_constructor);
        tolua_function(tolua_S,"reset",lua_mapserver_CCooldown_reset);
        tolua_function(tolua_S,"setCoolDownID",lua_mapserver_CCooldown_setCoolDownID);
        tolua_function(tolua_S,"getCooldownTime",lua_mapserver_CCooldown_getCooldownTime);
        tolua_function(tolua_S,"isInvalid",lua_mapserver_CCooldown_isInvalid);
        tolua_function(tolua_S,"setCooldownTime",lua_mapserver_CCooldown_setCooldownTime);
        tolua_function(tolua_S,"getCoolDownID",lua_mapserver_CCooldown_getCoolDownID);
        tolua_function(tolua_S,"setCooldownElapsed",lua_mapserver_CCooldown_setCooldownElapsed);
        tolua_function(tolua_S,"heartBeat",lua_mapserver_CCooldown_heartBeat);
        tolua_function(tolua_S,"getCooldownElapsed",lua_mapserver_CCooldown_getCooldownElapsed);
        tolua_function(tolua_S,"isCooldowned",lua_mapserver_CCooldown_isCooldowned);
        tolua_function(tolua_S,"getRemainTime",lua_mapserver_CCooldown_getRemainTime);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CCooldown).name();
    g_luaType[typeName] = "CCooldown";
    g_typeCast["CCooldown"] = "CCooldown";
    return 1;
}

static int lua_mapserver_DBSkillCoolDown_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (DBSkillCoolDown)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"DBSkillCoolDown",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        DBSkillCoolDown* self = (DBSkillCoolDown*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_DBSkillCoolDown(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"DBSkillCoolDown");
    tolua_cclass(tolua_S,"DBSkillCoolDown","DBSkillCoolDown","TDBStructBase",nullptr);

    tolua_beginmodule(tolua_S,"DBSkillCoolDown");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(DBSkillCoolDown).name();
    g_luaType[typeName] = "DBSkillCoolDown";
    g_typeCast["DBSkillCoolDown"] = "DBSkillCoolDown";
    return 1;
}

static int lua_mapserver_DBItemCoolDown_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (DBItemCoolDown)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"DBItemCoolDown",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        DBItemCoolDown* self = (DBItemCoolDown*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_DBItemCoolDown(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"DBItemCoolDown");
    tolua_cclass(tolua_S,"DBItemCoolDown","DBItemCoolDown","TDBStructBase",nullptr);

    tolua_beginmodule(tolua_S,"DBItemCoolDown");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(DBItemCoolDown).name();
    g_luaType[typeName] = "DBItemCoolDown";
    g_typeCast["DBItemCoolDown"] = "DBItemCoolDown";
    return 1;
}

int lua_mapserver_CSkillInfo_load(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_load'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned short arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CSkillInfo:load");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CSkillInfo:load");
        if(!ok)
            return 0;
        int ret = (int)cobj->load(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:load has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_load'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_isSingle(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_isSingle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isSingle();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSkillInfo:isSingle has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_isSingle'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_isGroup(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_isGroup'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isGroup();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSkillInfo:isGroup has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_isGroup'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_isUseOwner(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_isUseOwner'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isUseOwner();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSkillInfo:isUseOwner has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_isUseOwner'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CSkillInfo:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_isPassiveSkill(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_isPassiveSkill'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isPassiveSkill();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSkillInfo:isPassiveSkill has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_isPassiveSkill'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getNeedEnery(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getNeedEnery'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getNeedEnery();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getNeedEnery has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getNeedEnery'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getCommCD(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getCommCD'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getCommCD();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getCommCD has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getCommCD'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getEffectSize(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getEffectSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getEffectSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getEffectSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getEffectSize'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getSkillTypeID(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getSkillTypeID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getSkillTypeID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getSkillTypeID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getSkillTypeID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getCD(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getCD'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getCD();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getCD has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getCD'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getAttackType(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getAttackType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getAttackType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getAttackType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getAttackType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getLevel(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        char ret = cobj->getLevel();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getParamSize(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getParamSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getParamSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getParamSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getParamSize'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getDistance(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getDistance'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getDistance();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getDistance has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getDistance'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_doEffect(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_doEffect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CCharacterObject* arg0;
        bool arg1;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillInfo:doEffect");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CSkillInfo:doEffect");
        if(!ok)
            return 0;
        cobj->doEffect(arg0, arg1);
        return 0;
    }

    gxError("CSkillInfo:doEffect has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_doEffect'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_isNeedJobCheck(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_isNeedJobCheck'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNeedJobCheck();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSkillInfo:isNeedJobCheck has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_isNeedJobCheck'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getType(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getJob(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getJob'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getJob();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getJob has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getJob'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_isToEmeny(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_isToEmeny'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isToEmeny();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSkillInfo:isToEmeny has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_isToEmeny'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getOdds(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getOdds'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getOdds();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getOdds has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getOdds'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_isActive(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_isActive'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isActive();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSkillInfo:isActive has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_isActive'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_isToSelf(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_isToSelf'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isToSelf();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSkillInfo:isToSelf has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_isToSelf'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getTargetType(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getTargetType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getTargetType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getTargetType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getTargetType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_getDelayTime(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillInfo_getDelayTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getDelayTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillInfo:getDelayTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillInfo_getDelayTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CSkillInfo* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CSkillInfo();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSkillInfo");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSkillInfo:CSkillInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CSkillInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSkillInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSkillInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CSkillInfo* self = (CSkillInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CSkillInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSkillInfo");
    tolua_cclass(tolua_S,"CSkillInfo","CSkillInfo","",lua_mapserver_CSkillInfo_finalize);

    tolua_beginmodule(tolua_S,"CSkillInfo");
        tolua_function(tolua_S,"new",lua_mapserver_CSkillInfo_constructor);
        tolua_function(tolua_S,"load",lua_mapserver_CSkillInfo_load);
        tolua_function(tolua_S,"isSingle",lua_mapserver_CSkillInfo_isSingle);
        tolua_function(tolua_S,"isGroup",lua_mapserver_CSkillInfo_isGroup);
        tolua_function(tolua_S,"isUseOwner",lua_mapserver_CSkillInfo_isUseOwner);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CSkillInfo_cleanUp);
        tolua_function(tolua_S,"isPassiveSkill",lua_mapserver_CSkillInfo_isPassiveSkill);
        tolua_function(tolua_S,"getNeedEnery",lua_mapserver_CSkillInfo_getNeedEnery);
        tolua_function(tolua_S,"getCommCD",lua_mapserver_CSkillInfo_getCommCD);
        tolua_function(tolua_S,"getEffectSize",lua_mapserver_CSkillInfo_getEffectSize);
        tolua_function(tolua_S,"getSkillTypeID",lua_mapserver_CSkillInfo_getSkillTypeID);
        tolua_function(tolua_S,"getCD",lua_mapserver_CSkillInfo_getCD);
        tolua_function(tolua_S,"getAttackType",lua_mapserver_CSkillInfo_getAttackType);
        tolua_function(tolua_S,"getLevel",lua_mapserver_CSkillInfo_getLevel);
        tolua_function(tolua_S,"getParamSize",lua_mapserver_CSkillInfo_getParamSize);
        tolua_function(tolua_S,"getDistance",lua_mapserver_CSkillInfo_getDistance);
        tolua_function(tolua_S,"doEffect",lua_mapserver_CSkillInfo_doEffect);
        tolua_function(tolua_S,"isNeedJobCheck",lua_mapserver_CSkillInfo_isNeedJobCheck);
        tolua_function(tolua_S,"getType",lua_mapserver_CSkillInfo_getType);
        tolua_function(tolua_S,"getJob",lua_mapserver_CSkillInfo_getJob);
        tolua_function(tolua_S,"isToEmeny",lua_mapserver_CSkillInfo_isToEmeny);
        tolua_function(tolua_S,"getOdds",lua_mapserver_CSkillInfo_getOdds);
        tolua_function(tolua_S,"isActive",lua_mapserver_CSkillInfo_isActive);
        tolua_function(tolua_S,"isToSelf",lua_mapserver_CSkillInfo_isToSelf);
        tolua_function(tolua_S,"getTargetType",lua_mapserver_CSkillInfo_getTargetType);
        tolua_function(tolua_S,"getDelayTime",lua_mapserver_CSkillInfo_getDelayTime);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CSkillInfo).name();
    g_luaType[typeName] = "CSkillInfo";
    g_typeCast["CSkillInfo"] = "CSkillInfo";
    return 1;
}

int lua_mapserver_CSkillTargetScanInit_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CSkillTargetScanInit* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CAttackorList* arg0;
        CSkillInfo* arg1;

        ok &= luaval_to_object<CAttackorList>(tolua_S, 2, "CAttackorList", &arg0, "CSkillTargetScanInit:CSkillTargetScanInit");

        ok &= luaval_to_object<CSkillInfo>(tolua_S, 3, "CSkillInfo", &arg1, "CSkillTargetScanInit:CSkillTargetScanInit");
        if(!ok)
            return 0;
        cobj = new CSkillTargetScanInit(arg0, arg1);
        tolua_pushusertype(tolua_S,(void*)cobj,"CSkillTargetScanInit");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSkillTargetScanInit:CSkillTargetScanInit has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

}

static int lua_mapserver_CSkillTargetScanInit_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSkillTargetScanInit)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSkillTargetScanInit",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CSkillTargetScanInit* self = (CSkillTargetScanInit*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CSkillTargetScanInit(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSkillTargetScanInit");
    tolua_cclass(tolua_S,"CSkillTargetScanInit","CSkillTargetScanInit","TScanOperatorInit",lua_mapserver_CSkillTargetScanInit_finalize);

    tolua_beginmodule(tolua_S,"CSkillTargetScanInit");
        tolua_function(tolua_S,"new",lua_mapserver_CSkillTargetScanInit_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CSkillTargetScanInit).name();
    g_luaType[typeName] = "CSkillTargetScanInit";
    g_typeCast["CSkillTargetScanInit"] = "CSkillTargetScanInit";
    return 1;
}

int lua_mapserver_CSkillTargetScan_onFindObject(lua_State* tolua_S)
{
    int argc = 0;
    CSkillTargetScan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillTargetScan",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillTargetScan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillTargetScan_onFindObject'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CGameObject* arg0;

        ok &= luaval_to_object<CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CSkillTargetScan:onFindObject");
        if(!ok)
            return 0;
        int ret = (int)cobj->onFindObject(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillTargetScan:onFindObject has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillTargetScan_onFindObject'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillTargetScan_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CSkillTargetScan* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillTargetScan:CSkillTargetScan");
        if(!ok)
            return 0;
        cobj = new CSkillTargetScan(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CSkillTargetScan");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSkillTargetScan:CSkillTargetScan has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_mapserver_CSkillTargetScan_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSkillTargetScan)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSkillTargetScan",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CSkillTargetScan* self = (CSkillTargetScan*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CSkillTargetScan(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSkillTargetScan");
    tolua_cclass(tolua_S,"CSkillTargetScan","CSkillTargetScan","CScanOperator",lua_mapserver_CSkillTargetScan_finalize);

    tolua_beginmodule(tolua_S,"CSkillTargetScan");
        tolua_function(tolua_S,"new",lua_mapserver_CSkillTargetScan_constructor);
        tolua_function(tolua_S,"onFindObject",lua_mapserver_CSkillTargetScan_onFindObject);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CSkillTargetScan).name();
    g_luaType[typeName] = "CSkillTargetScan";
    g_typeCast["CSkillTargetScan"] = "CSkillTargetScan";
    return 1;
}

int lua_mapserver_CSkillLogicBase_load(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_load'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CCharacterObject* arg0;
        const CAttackPos* arg1;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillLogicBase:load");

        ok &= luaval_to_object<const CAttackPos>(tolua_S, 3, "CAttackPos", &arg1, "CSkillLogicBase:load");
        if(!ok)
            return 0;
        int ret = (int)cobj->load(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillLogicBase:load has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_load'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_checkLevel(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_checkLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->checkLevel();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSkillLogicBase:checkLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_checkLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_onAfterCalcHurt(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_onAfterCalcHurt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CCharacterObject* arg0;
        const CAttackPos* arg1;
        CAttackTarget* arg2;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillLogicBase:onAfterCalcHurt");

        ok &= luaval_to_object<const CAttackPos>(tolua_S, 3, "CAttackPos", &arg1, "CSkillLogicBase:onAfterCalcHurt");

        ok &= luaval_to_object<CAttackTarget>(tolua_S, 4, "CAttackTarget", &arg2, "CSkillLogicBase:onAfterCalcHurt");
        if(!ok)
            return 0;
        cobj->onAfterCalcHurt(arg0, arg1, arg2);
        return 0;
    }

    gxError("CSkillLogicBase:onAfterCalcHurt has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_onAfterCalcHurt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_onLoad(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_onLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CCharacterObject* arg0;
        const CAttackPos* arg1;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillLogicBase:onLoad");

        ok &= luaval_to_object<const CAttackPos>(tolua_S, 3, "CAttackPos", &arg1, "CSkillLogicBase:onLoad");
        if(!ok)
            return 0;
        bool ret = cobj->onLoad(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSkillLogicBase:onLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_onLoad'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_needCalcHurt(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_needCalcHurt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->needCalcHurt();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSkillLogicBase:needCalcHurt has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_needCalcHurt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_onBeforeCalcHurt(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_onBeforeCalcHurt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CCharacterObject* arg0;
        const CAttackPos* arg1;
        CAttackTarget* arg2;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillLogicBase:onBeforeCalcHurt");

        ok &= luaval_to_object<const CAttackPos>(tolua_S, 3, "CAttackPos", &arg1, "CSkillLogicBase:onBeforeCalcHurt");

        ok &= luaval_to_object<CAttackTarget>(tolua_S, 4, "CAttackTarget", &arg2, "CSkillLogicBase:onBeforeCalcHurt");
        if(!ok)
            return 0;
        cobj->onBeforeCalcHurt(arg0, arg1, arg2);
        return 0;
    }

    gxError("CSkillLogicBase:onBeforeCalcHurt has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_onBeforeCalcHurt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_selectTarget(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_selectTarget'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CCharacterObject* arg0;
        const CAttackPos* arg1;
        CAttackTarget* arg2;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillLogicBase:selectTarget");

        ok &= luaval_to_object<const CAttackPos>(tolua_S, 3, "CAttackPos", &arg1, "CSkillLogicBase:selectTarget");

        ok &= luaval_to_object<CAttackTarget>(tolua_S, 4, "CAttackTarget", &arg2, "CSkillLogicBase:selectTarget");
        if(!ok)
            return 0;
        int ret = (int)cobj->selectTarget(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillLogicBase:selectTarget has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_selectTarget'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_showImpact(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_showImpact'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CCharacterObject* arg0;
        const CAttackPos* arg1;
        CAttackTarget* arg2;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillLogicBase:showImpact");

        ok &= luaval_to_object<const CAttackPos>(tolua_S, 3, "CAttackPos", &arg1, "CSkillLogicBase:showImpact");

        ok &= luaval_to_object<CAttackTarget>(tolua_S, 4, "CAttackTarget", &arg2, "CSkillLogicBase:showImpact");
        if(!ok)
            return 0;
        cobj->showImpact(arg0, arg1, arg2);
        return 0;
    }

    gxError("CSkillLogicBase:showImpact has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_showImpact'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_onAfterUse(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_onAfterUse'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CCharacterObject* arg0;
        const CAttackPos* arg1;
        CAttackTarget* arg2;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillLogicBase:onAfterUse");

        ok &= luaval_to_object<const CAttackPos>(tolua_S, 3, "CAttackPos", &arg1, "CSkillLogicBase:onAfterUse");

        ok &= luaval_to_object<CAttackTarget>(tolua_S, 4, "CAttackTarget", &arg2, "CSkillLogicBase:onAfterUse");
        if(!ok)
            return 0;
        int ret = (int)cobj->onAfterUse(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillLogicBase:onAfterUse has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_onAfterUse'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_getSkillInfo(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_getSkillInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CSkillInfo* ret = cobj->getSkillInfo();
        object_to_luaval<CSkillInfo>(tolua_S, "CSkillInfo",(CSkillInfo*)ret);
        return 1;
    }

    gxError("CSkillLogicBase:getSkillInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_getSkillInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_init(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->init();
        return 0;
    }

    gxError("CSkillLogicBase:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CSkillLogicBase:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_getMaxAttackNum(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_getMaxAttackNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getMaxAttackNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillLogicBase:getMaxAttackNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_getMaxAttackNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_onActivate(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_onActivate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CCharacterObject* arg0;
        const CAttackPos* arg1;
        CAttackTarget* arg2;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillLogicBase:onActivate");

        ok &= luaval_to_object<const CAttackPos>(tolua_S, 3, "CAttackPos", &arg1, "CSkillLogicBase:onActivate");

        ok &= luaval_to_object<CAttackTarget>(tolua_S, 4, "CAttackTarget", &arg2, "CSkillLogicBase:onActivate");
        if(!ok)
            return 0;
        cobj->onActivate(arg0, arg1, arg2);
        return 0;
    }

    gxError("CSkillLogicBase:onActivate has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_onActivate'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_calcHurt(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_calcHurt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CCharacterObject* arg0;
        const CAttackPos* arg1;
        CAttackTarget* arg2;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillLogicBase:calcHurt");

        ok &= luaval_to_object<const CAttackPos>(tolua_S, 3, "CAttackPos", &arg1, "CSkillLogicBase:calcHurt");

        ok &= luaval_to_object<CAttackTarget>(tolua_S, 4, "CAttackTarget", &arg2, "CSkillLogicBase:calcHurt");
        if(!ok)
            return 0;
        cobj->calcHurt(arg0, arg1, arg2);
        return 0;
    }

    gxError("CSkillLogicBase:calcHurt has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_calcHurt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_onAfterSelectTarget(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_onAfterSelectTarget'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CCharacterObject* arg0;
        const CAttackPos* arg1;
        CAttackTarget* arg2;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillLogicBase:onAfterSelectTarget");

        ok &= luaval_to_object<const CAttackPos>(tolua_S, 3, "CAttackPos", &arg1, "CSkillLogicBase:onAfterSelectTarget");

        ok &= luaval_to_object<CAttackTarget>(tolua_S, 4, "CAttackTarget", &arg2, "CSkillLogicBase:onAfterSelectTarget");
        if(!ok)
            return 0;
        cobj->onAfterSelectTarget(arg0, arg1, arg2);
        return 0;
    }

    gxError("CSkillLogicBase:onAfterSelectTarget has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_onAfterSelectTarget'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_onBeforeUse(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_onBeforeUse'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CCharacterObject* arg0;
        const CAttackPos* arg1;
        CAttackTarget* arg2;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillLogicBase:onBeforeUse");

        ok &= luaval_to_object<const CAttackPos>(tolua_S, 3, "CAttackPos", &arg1, "CSkillLogicBase:onBeforeUse");

        ok &= luaval_to_object<CAttackTarget>(tolua_S, 4, "CAttackTarget", &arg2, "CSkillLogicBase:onBeforeUse");
        if(!ok)
            return 0;
        int ret = (int)cobj->onBeforeUse(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillLogicBase:onBeforeUse has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_onBeforeUse'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_check(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_check'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CCharacterObject* arg0;
        const CAttackPos* arg1;
        CAttackTarget* arg2;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillLogicBase:check");

        ok &= luaval_to_object<const CAttackPos>(tolua_S, 3, "CAttackPos", &arg1, "CSkillLogicBase:check");

        ok &= luaval_to_object<CAttackTarget>(tolua_S, 4, "CAttackTarget", &arg2, "CSkillLogicBase:check");
        if(!ok)
            return 0;
        int ret = (int)cobj->check(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSkillLogicBase:check has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_check'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_doConsume(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicBase_doConsume'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CCharacterObject* arg0;
        const CAttackPos* arg1;
        CAttackTarget* arg2;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CSkillLogicBase:doConsume");

        ok &= luaval_to_object<const CAttackPos>(tolua_S, 3, "CAttackPos", &arg1, "CSkillLogicBase:doConsume");

        ok &= luaval_to_object<CAttackTarget>(tolua_S, 4, "CAttackTarget", &arg2, "CSkillLogicBase:doConsume");
        if(!ok)
            return 0;
        cobj->doConsume(arg0, arg1, arg2);
        return 0;
    }

    gxError("CSkillLogicBase:doConsume has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicBase_doConsume'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CSkillLogicBase:CSkillLogicBase");
        if(!ok)
            return 0;
        cobj = new CSkillLogicBase(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CSkillLogicBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSkillLogicBase:CSkillLogicBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_mapserver_CSkillLogicBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSkillLogicBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSkillLogicBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CSkillLogicBase* self = (CSkillLogicBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CSkillLogicBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSkillLogicBase");
    tolua_cclass(tolua_S,"CSkillLogicBase","CSkillLogicBase","",lua_mapserver_CSkillLogicBase_finalize);

    tolua_beginmodule(tolua_S,"CSkillLogicBase");
        tolua_function(tolua_S,"new",lua_mapserver_CSkillLogicBase_constructor);
        tolua_function(tolua_S,"load",lua_mapserver_CSkillLogicBase_load);
        tolua_function(tolua_S,"checkLevel",lua_mapserver_CSkillLogicBase_checkLevel);
        tolua_function(tolua_S,"onAfterCalcHurt",lua_mapserver_CSkillLogicBase_onAfterCalcHurt);
        tolua_function(tolua_S,"onLoad",lua_mapserver_CSkillLogicBase_onLoad);
        tolua_function(tolua_S,"needCalcHurt",lua_mapserver_CSkillLogicBase_needCalcHurt);
        tolua_function(tolua_S,"onBeforeCalcHurt",lua_mapserver_CSkillLogicBase_onBeforeCalcHurt);
        tolua_function(tolua_S,"selectTarget",lua_mapserver_CSkillLogicBase_selectTarget);
        tolua_function(tolua_S,"showImpact",lua_mapserver_CSkillLogicBase_showImpact);
        tolua_function(tolua_S,"onAfterUse",lua_mapserver_CSkillLogicBase_onAfterUse);
        tolua_function(tolua_S,"getSkillInfo",lua_mapserver_CSkillLogicBase_getSkillInfo);
        tolua_function(tolua_S,"init",lua_mapserver_CSkillLogicBase_init);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CSkillLogicBase_cleanUp);
        tolua_function(tolua_S,"getMaxAttackNum",lua_mapserver_CSkillLogicBase_getMaxAttackNum);
        tolua_function(tolua_S,"onActivate",lua_mapserver_CSkillLogicBase_onActivate);
        tolua_function(tolua_S,"calcHurt",lua_mapserver_CSkillLogicBase_calcHurt);
        tolua_function(tolua_S,"onAfterSelectTarget",lua_mapserver_CSkillLogicBase_onAfterSelectTarget);
        tolua_function(tolua_S,"onBeforeUse",lua_mapserver_CSkillLogicBase_onBeforeUse);
        tolua_function(tolua_S,"check",lua_mapserver_CSkillLogicBase_check);
        tolua_function(tolua_S,"doConsume",lua_mapserver_CSkillLogicBase_doConsume);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CSkillLogicBase).name();
    g_luaType[typeName] = "CSkillLogicBase";
    g_typeCast["CSkillLogicBase"] = "CSkillLogicBase";
    return 1;
}

int lua_mapserver_CSkillLogicManager_initSkills(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicManager_initSkills'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->initSkills();
        return 0;
    }

    gxError("CSkillLogicManager:initSkills has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicManager_initSkills'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicManager_getSkillLogic(lua_State* tolua_S)
{
    int argc = 0;
    CSkillLogicManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSkillLogicManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSkillLogicManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSkillLogicManager_getSkillLogic'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CSkillLogicManager:getSkillLogic");
        if(!ok)
            return 0;
        CSkillLogicBase* ret = cobj->getSkillLogic(arg0);
        object_to_luaval<CSkillLogicBase>(tolua_S, "CSkillLogicBase",(CSkillLogicBase*)ret);
        return 1;
    }

    gxError("CSkillLogicManager:getSkillLogic has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicManager_getSkillLogic'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSkillLogicManager_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CSkillLogicManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CSkillLogicManager* ret = CSkillLogicManager::GetPtr();
        object_to_luaval<CSkillLogicManager>(tolua_S, "CSkillLogicManager",(CSkillLogicManager*)ret);
        return 1;
    }
    gxError("CSkillLogicManager:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSkillLogicManager_GetPtr'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CSkillLogicManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSkillLogicManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSkillLogicManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CSkillLogicManager* self = (CSkillLogicManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CSkillLogicManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSkillLogicManager");
    tolua_cclass(tolua_S,"CSkillLogicManager","CSkillLogicManager","CManualSingleton<CSkillLogicManager>",nullptr);

    tolua_beginmodule(tolua_S,"CSkillLogicManager");
        tolua_function(tolua_S,"initSkills",lua_mapserver_CSkillLogicManager_initSkills);
        tolua_function(tolua_S,"getSkillLogic",lua_mapserver_CSkillLogicManager_getSkillLogic);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CSkillLogicManager_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CSkillLogicManager).name();
    g_luaType[typeName] = "CSkillLogicManager";
    g_typeCast["CSkillLogicManager"] = "CSkillLogicManager";
    return 1;
}

int lua_mapserver_CCombatResult_getMpChanged(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_getMpChanged'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMpChanged();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCombatResult:getMpChanged has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_getMpChanged'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_setParam(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_setParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCombatResult:setParam");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CCombatResult:setParam");
        if(!ok)
            return 0;
        cobj->setParam(arg0, arg1);
        return 0;
    }

    gxError("CCombatResult:setParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_setParam'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_setMpChanged(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_setMpChanged'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCombatResult:setMpChanged");
        if(!ok)
            return 0;
        cobj->setMpChanged(arg0);
        return 0;
    }

    gxError("CCombatResult:setMpChanged has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_setMpChanged'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_setHit(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_setHit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setHit();
        return 0;
    }

    gxError("CCombatResult:setHit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_setHit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_setHpChanged(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_setHpChanged'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCombatResult:setHpChanged");
        if(!ok)
            return 0;
        cobj->setHpChanged(arg0);
        return 0;
    }

    gxError("CCombatResult:setHpChanged has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_setHpChanged'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_isHitBack(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_isHitBack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isHitBack();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCombatResult:isHitBack has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_isHitBack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_getImpactType(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_getImpactType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getImpactType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCombatResult:getImpactType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_getImpactType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_isCrit(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_isCrit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCrit();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCombatResult:isCrit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_isCrit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CCombatResult:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_isDoubleHit(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_isDoubleHit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDoubleHit();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCombatResult:isDoubleHit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_isDoubleHit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_isHit(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_isHit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isHit();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCombatResult:isHit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_isHit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_setImpactType(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_setImpactType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EAttackImpactType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCombatResult:setImpactType");
        if(!ok)
            return 0;
        cobj->setImpactType(arg0);
        return 0;
    }

    gxError("CCombatResult:setImpactType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_setImpactType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_getHpChanged(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_getHpChanged'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getHpChanged();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCombatResult:getHpChanged has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_getHpChanged'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_pushDoubleHitHp(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_pushDoubleHitHp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCombatResult:pushDoubleHitHp");
        if(!ok)
            return 0;
        cobj->pushDoubleHitHp(arg0);
        return 0;
    }

    gxError("CCombatResult:pushDoubleHitHp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_pushDoubleHitHp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_addHpChanged(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatResult*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatResult_addHpChanged'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCombatResult:addHpChanged");
        if(!ok)
            return 0;
        int ret = cobj->addHpChanged(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCombatResult:addHpChanged has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatResult_addHpChanged'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatResult_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CCombatResult* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CCombatResult();
        tolua_pushusertype(tolua_S,(void*)cobj,"CCombatResult");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CCombatResult:CCombatResult has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CCombatResult_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCombatResult)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCombatResult",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CCombatResult* self = (CCombatResult*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CCombatResult(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCombatResult");
    tolua_cclass(tolua_S,"CCombatResult","CCombatResult","",lua_mapserver_CCombatResult_finalize);

    tolua_beginmodule(tolua_S,"CCombatResult");
        tolua_function(tolua_S,"new",lua_mapserver_CCombatResult_constructor);
        tolua_function(tolua_S,"getMpChanged",lua_mapserver_CCombatResult_getMpChanged);
        tolua_function(tolua_S,"setParam",lua_mapserver_CCombatResult_setParam);
        tolua_function(tolua_S,"setMpChanged",lua_mapserver_CCombatResult_setMpChanged);
        tolua_function(tolua_S,"setHit",lua_mapserver_CCombatResult_setHit);
        tolua_function(tolua_S,"setHpChanged",lua_mapserver_CCombatResult_setHpChanged);
        tolua_function(tolua_S,"isHitBack",lua_mapserver_CCombatResult_isHitBack);
        tolua_function(tolua_S,"getImpactType",lua_mapserver_CCombatResult_getImpactType);
        tolua_function(tolua_S,"isCrit",lua_mapserver_CCombatResult_isCrit);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CCombatResult_cleanUp);
        tolua_function(tolua_S,"isDoubleHit",lua_mapserver_CCombatResult_isDoubleHit);
        tolua_function(tolua_S,"isHit",lua_mapserver_CCombatResult_isHit);
        tolua_function(tolua_S,"setImpactType",lua_mapserver_CCombatResult_setImpactType);
        tolua_function(tolua_S,"getHpChanged",lua_mapserver_CCombatResult_getHpChanged);
        tolua_function(tolua_S,"pushDoubleHitHp",lua_mapserver_CCombatResult_pushDoubleHitHp);
        tolua_function(tolua_S,"addHpChanged",lua_mapserver_CCombatResult_addHpChanged);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CCombatResult).name();
    g_luaType[typeName] = "CCombatResult";
    g_typeCast["CCombatResult"] = "CCombatResult";
    return 1;
}

int lua_mapserver_CCombatTempData_reset(lua_State* tolua_S)
{
    int argc = 0;
    CCombatTempData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatTempData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatTempData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatTempData_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }

    gxError("CCombatTempData:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatTempData_reset'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCombatTempData_canAttackTeammer(lua_State* tolua_S)
{
    int argc = 0;
    CCombatTempData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCombatTempData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCombatTempData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCombatTempData_canAttackTeammer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canAttackTeammer();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCombatTempData:canAttackTeammer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCombatTempData_canAttackTeammer'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CCombatTempData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCombatTempData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCombatTempData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CCombatTempData* self = (CCombatTempData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CCombatTempData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCombatTempData");
    tolua_cclass(tolua_S,"CCombatTempData","CCombatTempData","",nullptr);

    tolua_beginmodule(tolua_S,"CCombatTempData");
        tolua_function(tolua_S,"reset",lua_mapserver_CCombatTempData_reset);
        tolua_function(tolua_S,"canAttackTeammer",lua_mapserver_CCombatTempData_canAttackTeammer);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CCombatTempData).name();
    g_luaType[typeName] = "CCombatTempData";
    g_typeCast["CCombatTempData"] = "CCombatTempData";
    return 1;
}

static int lua_mapserver__ReliveInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_ReliveInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_ReliveInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _ReliveInfo* self = (_ReliveInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__ReliveInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_ReliveInfo");
    tolua_cclass(tolua_S,"_ReliveInfo","_ReliveInfo","",nullptr);

    tolua_beginmodule(tolua_S,"_ReliveInfo");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_ReliveInfo).name();
    g_luaType[typeName] = "_ReliveInfo";
    g_typeCast["_ReliveInfo"] = "_ReliveInfo";
    return 1;
}

static int lua_mapserver_CAttackInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CAttackInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CAttackInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CAttackInfo* self = (CAttackInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CAttackInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CAttackInfo");
    tolua_cclass(tolua_S,"CAttackInfo","CAttackInfo","",nullptr);

    tolua_beginmodule(tolua_S,"CAttackInfo");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CAttackInfo).name();
    g_luaType[typeName] = "CAttackInfo";
    g_typeCast["CAttackInfo"] = "CAttackInfo";
    return 1;
}

int lua_mapserver_CCharFightCore_onAfterUseSkill(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onAfterUseSkill'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onAfterUseSkill();
        return 0;
    }

    gxError("CCharFightCore:onAfterUseSkill has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onAfterUseSkill'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_canBeAttack(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_canBeAttack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canBeAttack();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:canBeAttack has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_canBeAttack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_useSkill(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_useSkill'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        unsigned int arg0;
        unsigned short arg1;
        short arg2;
        short arg3;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharFightCore:useSkill");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CCharFightCore:useSkill");

        ok &= luaval_to_sint16(tolua_S, 4,(sint16*)&arg2, "CCharFightCore:useSkill");

        ok &= luaval_to_sint16(tolua_S, 5,(sint16*)&arg3, "CCharFightCore:useSkill");
        if(!ok)
            return 0;
        int ret = (int)cobj->useSkill(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharFightCore:useSkill has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_useSkill'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_setCharacter(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_setCharacter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharFightCore:setCharacter");
        if(!ok)
            return 0;
        cobj->setCharacter(arg0);
        return 0;
    }

    gxError("CCharFightCore:setCharacter has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_setCharacter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onBeforeHit(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onBeforeHit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharFightCore:onBeforeHit");
        if(!ok)
            return 0;
        int ret = (int)cobj->onBeforeHit(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharFightCore:onBeforeHit has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onBeforeHit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_attackBack(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_attackBack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned char arg0;
        unsigned short arg1;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CCharFightCore:attackBack");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CCharFightCore:attackBack");
        if(!ok)
            return 0;
        cobj->attackBack(arg0, arg1);
        return 0;
    }

    gxError("CCharFightCore:attackBack has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_attackBack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_isCommonSkillCdDown(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_isCommonSkillCdDown'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCommonSkillCdDown();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CCharFightCore:isCommonSkillCdDown");
        if(!ok)
            return 0;
        bool ret = cobj->isCommonSkillCdDown(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:isCommonSkillCdDown has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_isCommonSkillCdDown'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_getCombatState(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_getCombatState'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getCombatState();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharFightCore:getCombatState has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_getCombatState'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onBeKill(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onBeKill'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharFightCore:onBeKill");
        if(!ok)
            return 0;
        cobj->onBeKill(arg0);
        return 0;
    }

    gxError("CCharFightCore:onBeKill has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onBeKill'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_cleanLastCombatData(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_cleanLastCombatData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanLastCombatData();
        return 0;
    }

    gxError("CCharFightCore:cleanLastCombatData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_cleanLastCombatData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onBeUseSkill(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onBeUseSkill'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CCharacterObject* arg0;
        unsigned short arg1;
        bool arg2;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharFightCore:onBeUseSkill");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CCharFightCore:onBeUseSkill");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CCharFightCore:onBeUseSkill");
        if(!ok)
            return 0;
        bool ret = cobj->onBeUseSkill(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:onBeUseSkill has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onBeUseSkill'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CCharFightCore:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onAfterAttackOther(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onAfterAttackOther'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharFightCore:onAfterAttackOther");
        if(!ok)
            return 0;
        cobj->onAfterAttackOther(arg0);
        return 0;
    }

    gxError("CCharFightCore:onAfterAttackOther has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onAfterAttackOther'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_setUnBeAttack(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_setUnBeAttack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setUnBeAttack();
        return 0;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CCharFightCore:setUnBeAttack");
        if(!ok)
            return 0;
        cobj->setUnBeAttack(arg0);
        return 0;
    }

    gxError("CCharFightCore:setUnBeAttack has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_setUnBeAttack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_setActionBan(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_setActionBan'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EActionBan arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharFightCore:setActionBan");
        if(!ok)
            return 0;
        cobj->setActionBan(arg0);
        return 0;
    }

    gxError("CCharFightCore:setActionBan has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_setActionBan'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_canBeUseItem(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_canBeUseItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canBeUseItem();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:canBeUseItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_canBeUseItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_getActionBan(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CCharFightCore_getActionBan'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            EActionBan arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharFightCore:getActionBan");

            if (!ok) { break; }
            bool ret = cobj->getActionBan(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            GXMISC::CBit16* ret = cobj->getActionBan();
            object_to_luaval<GXMISC::CBit16>(tolua_S, "CBit16",(GXMISC::CBit16*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CCharFightCore:getActionBan has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_getActionBan'.",&tolua_err);
    return 0;
}
int lua_mapserver_CCharFightCore_relive(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_relive'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        _ReliveInfo* arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_object<_ReliveInfo>(tolua_S, 2, "_ReliveInfo", &arg0, "CCharFightCore:relive");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CCharFightCore:relive");
        if(!ok)
            return 0;
        bool ret = cobj->relive(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:relive has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_relive'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onRelive(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onRelive'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharFightCore:onRelive");
        if(!ok)
            return 0;
        cobj->onRelive(arg0);
        return 0;
    }

    gxError("CCharFightCore:onRelive has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onRelive'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_getCombatResult(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_getCombatResult'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CCombatResult* ret = cobj->getCombatResult();
        object_to_luaval<CCombatResult>(tolua_S, "CCombatResult",(CCombatResult*)ret);
        return 1;
    }

    gxError("CCharFightCore:getCombatResult has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_getCombatResult'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_updateOutBlock(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_updateOutBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharFightCore:updateOutBlock");
        if(!ok)
            return 0;
        bool ret = cobj->updateOutBlock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:updateOutBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_updateOutBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onCombatStart(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onCombatStart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onCombatStart();
        return 0;
    }

    gxError("CCharFightCore:onCombatStart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onCombatStart'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_logState(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_logState'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->logState();
        return 0;
    }

    gxError("CCharFightCore:logState has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_logState'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_canAttackMe(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_canAttackMe'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharFightCore:canAttackMe");
        if(!ok)
            return 0;
        int ret = (int)cobj->canAttackMe(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharFightCore:canAttackMe has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_canAttackMe'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_isCombatEnd(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_isCombatEnd'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCombatEnd();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:isCombatEnd has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_isCombatEnd'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_getLastAttackMeTime(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_getLastAttackMeTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastAttackMeTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharFightCore:getLastAttackMeTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_getLastAttackMeTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_setLastHurtOtherObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_setLastHurtOtherObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharFightCore:setLastHurtOtherObjUID");
        if(!ok)
            return 0;
        cobj->setLastHurtOtherObjUID(arg0);
        return 0;
    }

    gxError("CCharFightCore:setLastHurtOtherObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_setLastHurtOtherObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_init(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const _CharacterInit* arg0;

        ok &= luaval_to_object<const _CharacterInit>(tolua_S, 2, "_CharacterInit", &arg0, "CCharFightCore:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_logActionBan(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_logActionBan'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->logActionBan();
        return 0;
    }

    gxError("CCharFightCore:logActionBan has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_logActionBan'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onEnterArea(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onEnterArea'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onEnterArea();
        return 0;
    }

    gxError("CCharFightCore:onEnterArea has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onEnterArea'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_getSkillCore(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_getSkillCore'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CCharSkillCore* ret = cobj->getSkillCore();
        object_to_luaval<CCharSkillCore>(tolua_S, "CCharSkillCore",(CCharSkillCore*)ret);
        return 1;
    }

    gxError("CCharFightCore:getSkillCore has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_getSkillCore'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_getAssistantUID(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_getAssistantUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getAssistantUID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharFightCore:getAssistantUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_getAssistantUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_setLastAttackMeTime(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_setLastAttackMeTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharFightCore:setLastAttackMeTime");
        if(!ok)
            return 0;
        cobj->setLastAttackMeTime(arg0);
        return 0;
    }

    gxError("CCharFightCore:setLastAttackMeTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_setLastAttackMeTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_isCombatStart(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_isCombatStart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCombatStart();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:isCombatStart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_isCombatStart'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_isSkillCoolDown(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_isSkillCoolDown'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CCharFightCore:isSkillCoolDown");
        if(!ok)
            return 0;
        bool ret = cobj->isSkillCoolDown(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:isSkillCoolDown has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_isSkillCoolDown'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_appendSkillBuff(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_appendSkillBuff'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CCharacterObject* arg0;
        CSkillInfo* arg1;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharFightCore:appendSkillBuff");

        ok &= luaval_to_object<CSkillInfo>(tolua_S, 3, "CSkillInfo", &arg1, "CCharFightCore:appendSkillBuff");
        if(!ok)
            return 0;
        cobj->appendSkillBuff(arg0, arg1);
        return 0;
    }

    gxError("CCharFightCore:appendSkillBuff has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_appendSkillBuff'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onCombatChange(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onCombatChange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ECombatStateType arg0;
        ECombatStateType arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharFightCore:onCombatChange");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CCharFightCore:onCombatChange");
        if(!ok)
            return 0;
        cobj->onCombatChange(arg0, arg1);
        return 0;
    }

    gxError("CCharFightCore:onCombatChange has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onCombatChange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onStartAttackOther(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onStartAttackOther'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharFightCore:onStartAttackOther");
        if(!ok)
            return 0;
        cobj->onStartAttackOther(arg0);
        return 0;
    }

    gxError("CCharFightCore:onStartAttackOther has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onStartAttackOther'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onAfterBeSkill(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onAfterBeSkill'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onAfterBeSkill();
        return 0;
    }

    gxError("CCharFightCore:onAfterBeSkill has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onAfterBeSkill'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_setLastAttackDieObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_setLastAttackDieObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharFightCore:setLastAttackDieObjUID");
        if(!ok)
            return 0;
        cobj->setLastAttackDieObjUID(arg0);
        return 0;
    }

    gxError("CCharFightCore:setLastAttackDieObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_setLastAttackDieObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_update(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharFightCore:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_combatEnd(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_combatEnd'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->combatEnd();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:combatEnd has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_combatEnd'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onCombatEnd(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onCombatEnd'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onCombatEnd();
        return 0;
    }

    gxError("CCharFightCore:onCombatEnd has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onCombatEnd'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_canMove(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_canMove'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canMove();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:canMove has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_canMove'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_canAttackTeammer(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_canAttackTeammer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canAttackTeammer();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:canAttackTeammer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_canAttackTeammer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_setLastHurtOtherObjType(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_setLastHurtOtherObjType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EObjType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharFightCore:setLastHurtOtherObjType");
        if(!ok)
            return 0;
        cobj->setLastHurtOtherObjType(arg0);
        return 0;
    }

    gxError("CCharFightCore:setLastHurtOtherObjType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_setLastHurtOtherObjType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onStateChange(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onStateChange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onStateChange();
        return 0;
    }

    gxError("CCharFightCore:onStateChange has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onStateChange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_resetReliveInfo(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_resetReliveInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->resetReliveInfo();
        return 0;
    }

    gxError("CCharFightCore:resetReliveInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_resetReliveInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_setReliveInfo(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_setReliveInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _ReliveInfo* arg0;

        ok &= luaval_to_object<_ReliveInfo>(tolua_S, 2, "_ReliveInfo", &arg0, "CCharFightCore:setReliveInfo");
        if(!ok)
            return 0;
        cobj->setReliveInfo(arg0);
        return 0;
    }

    gxError("CCharFightCore:setReliveInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_setReliveInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_clearActionBan(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_clearActionBan'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EActionBan arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharFightCore:clearActionBan");
        if(!ok)
            return 0;
        cobj->clearActionBan(arg0);
        return 0;
    }

    gxError("CCharFightCore:clearActionBan has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_clearActionBan'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_getLastHurtMeObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_getLastHurtMeObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastHurtMeObjUID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharFightCore:getLastHurtMeObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_getLastHurtMeObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_combatStart(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_combatStart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->combatStart();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:combatStart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_combatStart'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_getLastHurtMeObjType(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_getLastHurtMeObjType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getLastHurtMeObjType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharFightCore:getLastHurtMeObjType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_getLastHurtMeObjType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onHurt(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onHurt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        unsigned int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharFightCore:onHurt");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CCharFightCore:onHurt");
        if(!ok)
            return 0;
        cobj->onHurt(arg0, arg1);
        return 0;
    }

    gxError("CCharFightCore:onHurt has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onHurt'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onActionBanChange(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onActionBanChange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EActionBan arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharFightCore:onActionBanChange");
        if(!ok)
            return 0;
        cobj->onActionBanChange(arg0);
        return 0;
    }

    gxError("CCharFightCore:onActionBanChange has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onActionBanChange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onStartBeAttack(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onStartBeAttack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharFightCore:onStartBeAttack");
        if(!ok)
            return 0;
        cobj->onStartBeAttack(arg0);
        return 0;
    }

    gxError("CCharFightCore:onStartBeAttack has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onStartBeAttack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onDie(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onDie'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onDie();
        return 0;
    }

    gxError("CCharFightCore:onDie has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onDie'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_checkAction(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_checkAction'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        bool arg0;
        bool arg1;
        bool arg2;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CCharFightCore:checkAction");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CCharFightCore:checkAction");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CCharFightCore:checkAction");
        if(!ok)
            return 0;
        int ret = (int)cobj->checkAction(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharFightCore:checkAction has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_checkAction'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onAttackChart(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onAttackChart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharFightCore:onAttackChart");
        if(!ok)
            return 0;
        cobj->onAttackChart(arg0);
        return 0;
    }

    gxError("CCharFightCore:onAttackChart has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onAttackChart'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_getLastHurtOtherObjType(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_getLastHurtOtherObjType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getLastHurtOtherObjType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharFightCore:getLastHurtOtherObjType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_getLastHurtOtherObjType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_getLastAttackDieObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_getLastAttackDieObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastAttackDieObjUID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharFightCore:getLastAttackDieObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_getLastAttackDieObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onAfterBeAttack(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onAfterBeAttack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharFightCore:onAfterBeAttack");
        if(!ok)
            return 0;
        cobj->onAfterBeAttack(arg0);
        return 0;
    }

    gxError("CCharFightCore:onAfterBeAttack has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onAfterBeAttack'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_onKillObject(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_onKillObject'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharFightCore:onKillObject");
        if(!ok)
            return 0;
        cobj->onKillObject(arg0);
        return 0;
    }

    gxError("CCharFightCore:onKillObject has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_onKillObject'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_getLastHurtOtherObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_getLastHurtOtherObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastHurtOtherObjUID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharFightCore:getLastHurtOtherObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_getLastHurtOtherObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_canHit(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_canHit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharFightCore:canHit");
        if(!ok)
            return 0;
        bool ret = cobj->canHit(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:canHit has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_canHit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_canUseSkill(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_canUseSkill'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canUseSkill();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:canUseSkill has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_canUseSkill'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_getReliveInfo(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_getReliveInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        _ReliveInfo* ret = cobj->getReliveInfo();
        object_to_luaval<_ReliveInfo>(tolua_S, "_ReliveInfo",(_ReliveInfo*)ret);
        return 1;
    }

    gxError("CCharFightCore:getReliveInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_getReliveInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharFightCore_canCrit(lua_State* tolua_S)
{
    int argc = 0;
    CCharFightCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharFightCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharFightCore_canCrit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canCrit();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharFightCore:canCrit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharFightCore_canCrit'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CCharFightCore_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCharFightCore)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCharFightCore",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CCharFightCore* self = (CCharFightCore*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CCharFightCore(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCharFightCore");
    tolua_cclass(tolua_S,"CCharFightCore","CCharFightCore","",nullptr);

    tolua_beginmodule(tolua_S,"CCharFightCore");
        tolua_function(tolua_S,"onAfterUseSkill",lua_mapserver_CCharFightCore_onAfterUseSkill);
        tolua_function(tolua_S,"canBeAttack",lua_mapserver_CCharFightCore_canBeAttack);
        tolua_function(tolua_S,"useSkill",lua_mapserver_CCharFightCore_useSkill);
        tolua_function(tolua_S,"setCharacter",lua_mapserver_CCharFightCore_setCharacter);
        tolua_function(tolua_S,"onBeforeHit",lua_mapserver_CCharFightCore_onBeforeHit);
        tolua_function(tolua_S,"attackBack",lua_mapserver_CCharFightCore_attackBack);
        tolua_function(tolua_S,"isCommonSkillCdDown",lua_mapserver_CCharFightCore_isCommonSkillCdDown);
        tolua_function(tolua_S,"getCombatState",lua_mapserver_CCharFightCore_getCombatState);
        tolua_function(tolua_S,"onBeKill",lua_mapserver_CCharFightCore_onBeKill);
        tolua_function(tolua_S,"cleanLastCombatData",lua_mapserver_CCharFightCore_cleanLastCombatData);
        tolua_function(tolua_S,"onBeUseSkill",lua_mapserver_CCharFightCore_onBeUseSkill);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CCharFightCore_cleanUp);
        tolua_function(tolua_S,"onAfterAttackOther",lua_mapserver_CCharFightCore_onAfterAttackOther);
        tolua_function(tolua_S,"setUnBeAttack",lua_mapserver_CCharFightCore_setUnBeAttack);
        tolua_function(tolua_S,"setActionBan",lua_mapserver_CCharFightCore_setActionBan);
        tolua_function(tolua_S,"canBeUseItem",lua_mapserver_CCharFightCore_canBeUseItem);
        tolua_function(tolua_S,"getActionBan",lua_mapserver_CCharFightCore_getActionBan);
        tolua_function(tolua_S,"relive",lua_mapserver_CCharFightCore_relive);
        tolua_function(tolua_S,"onRelive",lua_mapserver_CCharFightCore_onRelive);
        tolua_function(tolua_S,"getCombatResult",lua_mapserver_CCharFightCore_getCombatResult);
        tolua_function(tolua_S,"updateOutBlock",lua_mapserver_CCharFightCore_updateOutBlock);
        tolua_function(tolua_S,"onCombatStart",lua_mapserver_CCharFightCore_onCombatStart);
        tolua_function(tolua_S,"logState",lua_mapserver_CCharFightCore_logState);
        tolua_function(tolua_S,"canAttackMe",lua_mapserver_CCharFightCore_canAttackMe);
        tolua_function(tolua_S,"isCombatEnd",lua_mapserver_CCharFightCore_isCombatEnd);
        tolua_function(tolua_S,"getLastAttackMeTime",lua_mapserver_CCharFightCore_getLastAttackMeTime);
        tolua_function(tolua_S,"setLastHurtOtherObjUID",lua_mapserver_CCharFightCore_setLastHurtOtherObjUID);
        tolua_function(tolua_S,"init",lua_mapserver_CCharFightCore_init);
        tolua_function(tolua_S,"logActionBan",lua_mapserver_CCharFightCore_logActionBan);
        tolua_function(tolua_S,"onEnterArea",lua_mapserver_CCharFightCore_onEnterArea);
        tolua_function(tolua_S,"getSkillCore",lua_mapserver_CCharFightCore_getSkillCore);
        tolua_function(tolua_S,"getAssistantUID",lua_mapserver_CCharFightCore_getAssistantUID);
        tolua_function(tolua_S,"setLastAttackMeTime",lua_mapserver_CCharFightCore_setLastAttackMeTime);
        tolua_function(tolua_S,"isCombatStart",lua_mapserver_CCharFightCore_isCombatStart);
        tolua_function(tolua_S,"isSkillCoolDown",lua_mapserver_CCharFightCore_isSkillCoolDown);
        tolua_function(tolua_S,"appendSkillBuff",lua_mapserver_CCharFightCore_appendSkillBuff);
        tolua_function(tolua_S,"onCombatChange",lua_mapserver_CCharFightCore_onCombatChange);
        tolua_function(tolua_S,"onStartAttackOther",lua_mapserver_CCharFightCore_onStartAttackOther);
        tolua_function(tolua_S,"onAfterBeSkill",lua_mapserver_CCharFightCore_onAfterBeSkill);
        tolua_function(tolua_S,"setLastAttackDieObjUID",lua_mapserver_CCharFightCore_setLastAttackDieObjUID);
        tolua_function(tolua_S,"update",lua_mapserver_CCharFightCore_update);
        tolua_function(tolua_S,"combatEnd",lua_mapserver_CCharFightCore_combatEnd);
        tolua_function(tolua_S,"onCombatEnd",lua_mapserver_CCharFightCore_onCombatEnd);
        tolua_function(tolua_S,"canMove",lua_mapserver_CCharFightCore_canMove);
        tolua_function(tolua_S,"canAttackTeammer",lua_mapserver_CCharFightCore_canAttackTeammer);
        tolua_function(tolua_S,"setLastHurtOtherObjType",lua_mapserver_CCharFightCore_setLastHurtOtherObjType);
        tolua_function(tolua_S,"onStateChange",lua_mapserver_CCharFightCore_onStateChange);
        tolua_function(tolua_S,"resetReliveInfo",lua_mapserver_CCharFightCore_resetReliveInfo);
        tolua_function(tolua_S,"setReliveInfo",lua_mapserver_CCharFightCore_setReliveInfo);
        tolua_function(tolua_S,"clearActionBan",lua_mapserver_CCharFightCore_clearActionBan);
        tolua_function(tolua_S,"getLastHurtMeObjUID",lua_mapserver_CCharFightCore_getLastHurtMeObjUID);
        tolua_function(tolua_S,"combatStart",lua_mapserver_CCharFightCore_combatStart);
        tolua_function(tolua_S,"getLastHurtMeObjType",lua_mapserver_CCharFightCore_getLastHurtMeObjType);
        tolua_function(tolua_S,"onHurt",lua_mapserver_CCharFightCore_onHurt);
        tolua_function(tolua_S,"onActionBanChange",lua_mapserver_CCharFightCore_onActionBanChange);
        tolua_function(tolua_S,"onStartBeAttack",lua_mapserver_CCharFightCore_onStartBeAttack);
        tolua_function(tolua_S,"onDie",lua_mapserver_CCharFightCore_onDie);
        tolua_function(tolua_S,"checkAction",lua_mapserver_CCharFightCore_checkAction);
        tolua_function(tolua_S,"onAttackChart",lua_mapserver_CCharFightCore_onAttackChart);
        tolua_function(tolua_S,"getLastHurtOtherObjType",lua_mapserver_CCharFightCore_getLastHurtOtherObjType);
        tolua_function(tolua_S,"getLastAttackDieObjUID",lua_mapserver_CCharFightCore_getLastAttackDieObjUID);
        tolua_function(tolua_S,"onAfterBeAttack",lua_mapserver_CCharFightCore_onAfterBeAttack);
        tolua_function(tolua_S,"onKillObject",lua_mapserver_CCharFightCore_onKillObject);
        tolua_function(tolua_S,"getLastHurtOtherObjUID",lua_mapserver_CCharFightCore_getLastHurtOtherObjUID);
        tolua_function(tolua_S,"canHit",lua_mapserver_CCharFightCore_canHit);
        tolua_function(tolua_S,"canUseSkill",lua_mapserver_CCharFightCore_canUseSkill);
        tolua_function(tolua_S,"getReliveInfo",lua_mapserver_CCharFightCore_getReliveInfo);
        tolua_function(tolua_S,"canCrit",lua_mapserver_CCharFightCore_canCrit);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CCharFightCore).name();
    g_luaType[typeName] = "CCharFightCore";
    g_typeCast["CCharFightCore"] = "CCharFightCore";
    return 1;
}

static int lua_mapserver__ChartCampData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_ChartCampData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_ChartCampData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _ChartCampData* self = (_ChartCampData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__ChartCampData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_ChartCampData");
    tolua_cclass(tolua_S,"_ChartCampData","_ChartCampData","",nullptr);

    tolua_beginmodule(tolua_S,"_ChartCampData");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_ChartCampData).name();
    g_luaType[typeName] = "_ChartCampData";
    g_typeCast["_ChartCampData"] = "_ChartCampData";
    return 1;
}

int lua_mapserver_CCharRelationCore_setCampID(lua_State* tolua_S)
{
    int argc = 0;
    CCharRelationCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharRelationCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharRelationCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharRelationCore_setCampID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharRelationCore:setCampID");
        if(!ok)
            return 0;
        cobj->setCampID(arg0);
        return 0;
    }

    gxError("CCharRelationCore:setCampID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharRelationCore_setCampID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharRelationCore_updateOutBlock(lua_State* tolua_S)
{
    int argc = 0;
    CCharRelationCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharRelationCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharRelationCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharRelationCore_updateOutBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharRelationCore:updateOutBlock");
        if(!ok)
            return 0;
        bool ret = cobj->updateOutBlock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharRelationCore:updateOutBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharRelationCore_updateOutBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharRelationCore_setCharacter(lua_State* tolua_S)
{
    int argc = 0;
    CCharRelationCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharRelationCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharRelationCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharRelationCore_setCharacter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharRelationCore:setCharacter");
        if(!ok)
            return 0;
        cobj->setCharacter(arg0);
        return 0;
    }

    gxError("CCharRelationCore:setCharacter has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharRelationCore_setCharacter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharRelationCore_update(lua_State* tolua_S)
{
    int argc = 0;
    CCharRelationCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharRelationCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharRelationCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharRelationCore_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharRelationCore:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharRelationCore:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharRelationCore_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharRelationCore_isSameCamp(lua_State* tolua_S)
{
    int argc = 0;
    CCharRelationCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharRelationCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharRelationCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharRelationCore_isSameCamp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharRelationCore:isSameCamp");
        if(!ok)
            return 0;
        bool ret = cobj->isSameCamp(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharRelationCore:isSameCamp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharRelationCore_isSameCamp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharRelationCore_getCampData(lua_State* tolua_S)
{
    int argc = 0;
    CCharRelationCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharRelationCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharRelationCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharRelationCore_getCampData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        _ChartCampData* ret = cobj->getCampData();
        object_to_luaval<_ChartCampData>(tolua_S, "_ChartCampData",(_ChartCampData*)ret);
        return 1;
    }

    gxError("CCharRelationCore:getCampData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharRelationCore_getCampData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharRelationCore_init(lua_State* tolua_S)
{
    int argc = 0;
    CCharRelationCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharRelationCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharRelationCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharRelationCore_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const _CharacterInit* arg0;

        ok &= luaval_to_object<const _CharacterInit>(tolua_S, 2, "_CharacterInit", &arg0, "CCharRelationCore:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharRelationCore:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharRelationCore_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharRelationCore_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CCharRelationCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharRelationCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharRelationCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharRelationCore_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CCharRelationCore:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharRelationCore_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharRelationCore_getCampID(lua_State* tolua_S)
{
    int argc = 0;
    CCharRelationCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharRelationCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharRelationCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharRelationCore_getCampID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getCampID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharRelationCore:getCampID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharRelationCore_getCampID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharRelationCore_isTeamMember(lua_State* tolua_S)
{
    int argc = 0;
    CCharRelationCore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharRelationCore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharRelationCore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharRelationCore_isTeamMember'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharRelationCore:isTeamMember");
        if(!ok)
            return 0;
        bool ret = cobj->isTeamMember(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharRelationCore:isTeamMember has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharRelationCore_isTeamMember'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CCharRelationCore_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCharRelationCore)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCharRelationCore",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CCharRelationCore* self = (CCharRelationCore*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CCharRelationCore(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCharRelationCore");
    tolua_cclass(tolua_S,"CCharRelationCore","CCharRelationCore","",nullptr);

    tolua_beginmodule(tolua_S,"CCharRelationCore");
        tolua_function(tolua_S,"setCampID",lua_mapserver_CCharRelationCore_setCampID);
        tolua_function(tolua_S,"updateOutBlock",lua_mapserver_CCharRelationCore_updateOutBlock);
        tolua_function(tolua_S,"setCharacter",lua_mapserver_CCharRelationCore_setCharacter);
        tolua_function(tolua_S,"update",lua_mapserver_CCharRelationCore_update);
        tolua_function(tolua_S,"isSameCamp",lua_mapserver_CCharRelationCore_isSameCamp);
        tolua_function(tolua_S,"getCampData",lua_mapserver_CCharRelationCore_getCampData);
        tolua_function(tolua_S,"init",lua_mapserver_CCharRelationCore_init);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CCharRelationCore_cleanUp);
        tolua_function(tolua_S,"getCampID",lua_mapserver_CCharRelationCore_getCampID);
        tolua_function(tolua_S,"isTeamMember",lua_mapserver_CCharRelationCore_isTeamMember);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CCharRelationCore).name();
    g_luaType[typeName] = "CCharRelationCore";
    g_typeCast["CCharRelationCore"] = "CCharRelationCore";
    return 1;
}

static int lua_mapserver__ApproachObject_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_ApproachObject)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_ApproachObject",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _ApproachObject* self = (_ApproachObject*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__ApproachObject(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_ApproachObject");
    tolua_cclass(tolua_S,"_ApproachObject","_ApproachObject","",nullptr);

    tolua_beginmodule(tolua_S,"_ApproachObject");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_ApproachObject).name();
    g_luaType[typeName] = "_ApproachObject";
    g_typeCast["_ApproachObject"] = "_ApproachObject";
    return 1;
}

static int lua_mapserver_ApproachObjectList_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ApproachObjectList)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ApproachObjectList",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ApproachObjectList* self = (ApproachObjectList*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ApproachObjectList(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ApproachObjectList");
    tolua_cclass(tolua_S,"ApproachObjectList","ApproachObjectList","",nullptr);

    tolua_beginmodule(tolua_S,"ApproachObjectList");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ApproachObjectList).name();
    g_luaType[typeName] = "ApproachObjectList";
    g_typeCast["ApproachObjectList"] = "ApproachObjectList";
    return 1;
}

int lua_mapserver_CCharAICore_getCharacterAI(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_getCharacterAI'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CAICharacter* ret = cobj->getCharacterAI();
        object_to_luaval<CAICharacter>(tolua_S, "CAICharacter",(CAICharacter*)ret);
        return 1;
    }

    gxError("CCharAICore:getCharacterAI has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_getCharacterAI'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_updateOutBlock(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_updateOutBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAICore:updateOutBlock");
        if(!ok)
            return 0;
        bool ret = cobj->updateOutBlock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharAICore:updateOutBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_updateOutBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_clearAllApproachMon(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_clearAllApproachMon'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->clearAllApproachMon();
        return 0;
    }

    gxError("CCharAICore:clearAllApproachMon has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_clearAllApproachMon'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_addApproachMon(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_addApproachMon'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        EAddApproachObjectType arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharAICore:addApproachMon");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CCharAICore:addApproachMon");
        if(!ok)
            return 0;
        cobj->addApproachMon(arg0, arg1);
        return 0;
    }

    gxError("CCharAICore:addApproachMon has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_addApproachMon'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_canBeApproach(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_canBeApproach'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canBeApproach();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharAICore:canBeApproach has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_canBeApproach'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_setCharacter(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_setCharacter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharacterObject* arg0;

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 2, "CCharacterObject", &arg0, "CCharAICore:setCharacter");
        if(!ok)
            return 0;
        cobj->setCharacter(arg0);
        return 0;
    }

    gxError("CCharAICore:setCharacter has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_setCharacter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_setCharacterAI(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_setCharacterAI'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CAICharacter* arg0;

        ok &= luaval_to_object<CAICharacter>(tolua_S, 2, "CAICharacter", &arg0, "CCharAICore:setCharacterAI");
        if(!ok)
            return 0;
        cobj->setCharacterAI(arg0);
        return 0;
    }

    gxError("CCharAICore:setCharacterAI has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_setCharacterAI'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_delApproachByEnemy(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_delApproachByEnemy'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharAICore:delApproachByEnemy");
        if(!ok)
            return 0;
        cobj->delApproachByEnemy(arg0);
        return 0;
    }

    gxError("CCharAICore:delApproachByEnemy has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_delApproachByEnemy'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_update(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAICore:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharAICore:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_onDamageTarget(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_onDamageTarget'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        CCharacterObject* arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAICore:onDamageTarget");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CCharAICore:onDamageTarget");
        if(!ok)
            return 0;
        cobj->onDamageTarget(arg0, arg1);
        return 0;
    }
    if (argc == 3) 
    {
        int arg0;
        CCharacterObject* arg1;
        unsigned short arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAICore:onDamageTarget");

        ok &= luaval_to_object<CCharacterObject>(tolua_S, 3, "CCharacterObject", &arg1, "CCharAICore:onDamageTarget");

        ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CCharAICore:onDamageTarget");
        if(!ok)
            return 0;
        cobj->onDamageTarget(arg0, arg1, arg2);
        return 0;
    }

    gxError("CCharAICore:onDamageTarget has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_onDamageTarget'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_init(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const _CharacterInit* arg0;

        ok &= luaval_to_object<const _CharacterInit>(tolua_S, 2, "_CharacterInit", &arg0, "CCharAICore:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharAICore:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CCharAICore:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_onDamage(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_onDamage'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        unsigned int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAICore:onDamage");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CCharAICore:onDamage");
        if(!ok)
            return 0;
        cobj->onDamage(arg0, arg1);
        return 0;
    }
    if (argc == 3) 
    {
        int arg0;
        unsigned int arg1;
        bool arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAICore:onDamage");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CCharAICore:onDamage");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CCharAICore:onDamage");
        if(!ok)
            return 0;
        cobj->onDamage(arg0, arg1, arg2);
        return 0;
    }
    if (argc == 4) 
    {
        int arg0;
        unsigned int arg1;
        bool arg2;
        unsigned short arg3;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharAICore:onDamage");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CCharAICore:onDamage");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CCharAICore:onDamage");

        ok &= luaval_to_uint16(tolua_S, 5, (uint16*)&arg3, "CCharAICore:onDamage");
        if(!ok)
            return 0;
        cobj->onDamage(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CCharAICore:onDamage has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_onDamage'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_delApproachMon(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_delApproachMon'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        EDelApproachObjectType arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharAICore:delApproachMon");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CCharAICore:delApproachMon");
        if(!ok)
            return 0;
        cobj->delApproachMon(arg0, arg1);
        return 0;
    }

    gxError("CCharAICore:delApproachMon has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_delApproachMon'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_needDropApproach(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_needDropApproach'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->needDropApproach();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharAICore:needDropApproach has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_needDropApproach'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_getApproachMonSize(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_getApproachMonSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getApproachMonSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharAICore:getApproachMonSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_getApproachMonSize'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_onAddApproach(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_onAddApproach'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharAICore:onAddApproach");
        if(!ok)
            return 0;
        cobj->onAddApproach(arg0);
        return 0;
    }

    gxError("CCharAICore:onAddApproach has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_onAddApproach'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharAICore_onDelApproach(lua_State* tolua_S)
{
    int argc = 0;
    CCharAICore* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharAICore*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharAICore_onDelApproach'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharAICore:onDelApproach");
        if(!ok)
            return 0;
        cobj->onDelApproach(arg0);
        return 0;
    }

    gxError("CCharAICore:onDelApproach has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharAICore_onDelApproach'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CCharAICore_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCharAICore)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCharAICore",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CCharAICore* self = (CCharAICore*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CCharAICore(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCharAICore");
    tolua_cclass(tolua_S,"CCharAICore","CCharAICore","",nullptr);

    tolua_beginmodule(tolua_S,"CCharAICore");
        tolua_function(tolua_S,"getCharacterAI",lua_mapserver_CCharAICore_getCharacterAI);
        tolua_function(tolua_S,"updateOutBlock",lua_mapserver_CCharAICore_updateOutBlock);
        tolua_function(tolua_S,"clearAllApproachMon",lua_mapserver_CCharAICore_clearAllApproachMon);
        tolua_function(tolua_S,"addApproachMon",lua_mapserver_CCharAICore_addApproachMon);
        tolua_function(tolua_S,"canBeApproach",lua_mapserver_CCharAICore_canBeApproach);
        tolua_function(tolua_S,"setCharacter",lua_mapserver_CCharAICore_setCharacter);
        tolua_function(tolua_S,"setCharacterAI",lua_mapserver_CCharAICore_setCharacterAI);
        tolua_function(tolua_S,"delApproachByEnemy",lua_mapserver_CCharAICore_delApproachByEnemy);
        tolua_function(tolua_S,"update",lua_mapserver_CCharAICore_update);
        tolua_function(tolua_S,"onDamageTarget",lua_mapserver_CCharAICore_onDamageTarget);
        tolua_function(tolua_S,"init",lua_mapserver_CCharAICore_init);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CCharAICore_cleanUp);
        tolua_function(tolua_S,"onDamage",lua_mapserver_CCharAICore_onDamage);
        tolua_function(tolua_S,"delApproachMon",lua_mapserver_CCharAICore_delApproachMon);
        tolua_function(tolua_S,"needDropApproach",lua_mapserver_CCharAICore_needDropApproach);
        tolua_function(tolua_S,"getApproachMonSize",lua_mapserver_CCharAICore_getApproachMonSize);
        tolua_function(tolua_S,"onAddApproach",lua_mapserver_CCharAICore_onAddApproach);
        tolua_function(tolua_S,"onDelApproach",lua_mapserver_CCharAICore_onDelApproach);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CCharAICore).name();
    g_luaType[typeName] = "CCharAICore";
    g_typeCast["CCharAICore"] = "CCharAICore";
    return 1;
}

int lua_mapserver_CCharacterObject_toRoleBase(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_toRoleBase'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->toRoleBase();
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CCharacterObject:toRoleBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_toRoleBase'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_updateOutBlock(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_updateOutBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharacterObject:updateOutBlock");
        if(!ok)
            return 0;
        bool ret = cobj->updateOutBlock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharacterObject:updateOutBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_updateOutBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_getRoleBaseOwner(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_getRoleBaseOwner'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->getRoleBaseOwner();
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CCharacterObject:getRoleBaseOwner has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_getRoleBaseOwner'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_getOwner(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_getOwner'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CCharacterObject* ret = cobj->getOwner();
        object_to_luaval<CCharacterObject>(tolua_S, "CCharacterObject",(CCharacterObject*)ret);
        return 1;
    }

    gxError("CCharacterObject:getOwner has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_getOwner'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_setOwnerUID(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_setOwnerUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharacterObject:setOwnerUID");
        if(!ok)
            return 0;
        cobj->setOwnerUID(arg0);
        return 0;
    }

    gxError("CCharacterObject:setOwnerUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_setOwnerUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_resetPos(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_resetPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        const AxisPos* arg0;
        EResetPosType arg1;
        bool arg2;
        bool arg3;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CCharacterObject:resetPos");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CCharacterObject:resetPos");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CCharacterObject:resetPos");

        ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CCharacterObject:resetPos");
        if(!ok)
            return 0;
        cobj->resetPos(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CCharacterObject:resetPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_resetPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_setDie(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_setDie'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setDie();
        return 0;
    }

    gxError("CCharacterObject:setDie has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_setDie'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_update(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCharacterObject:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharacterObject:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_onLeaveScene(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_onLeaveScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapSceneBase* arg0;

        ok &= luaval_to_object<CMapSceneBase>(tolua_S, 2, "CMapSceneBase", &arg0, "CCharacterObject:onLeaveScene");
        if(!ok)
            return 0;
        cobj->onLeaveScene(arg0);
        return 0;
    }

    gxError("CCharacterObject:onLeaveScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_onLeaveScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_onEnterScene(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_onEnterScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapSceneBase* arg0;

        ok &= luaval_to_object<CMapSceneBase>(tolua_S, 2, "CMapSceneBase", &arg0, "CCharacterObject:onEnterScene");
        if(!ok)
            return 0;
        cobj->onEnterScene(arg0);
        return 0;
    }

    gxError("CCharacterObject:onEnterScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_onEnterScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_init(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const _CharacterInit* arg0;

        ok &= luaval_to_object<const _CharacterInit>(tolua_S, 2, "_CharacterInit", &arg0, "CCharacterObject:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharacterObject:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CCharacterObject:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_getOwnerUID(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_getOwnerUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getOwnerUID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharacterObject:getOwnerUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_getOwnerUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_isDie(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_isDie'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDie();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharacterObject:isDie has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_isDie'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_isTimeToLeaveScene(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_isTimeToLeaveScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CCharacterObject:isTimeToLeaveScene");
        if(!ok)
            return 0;
        bool ret = cobj->isTimeToLeaveScene(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CCharacterObject:isTimeToLeaveScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_isTimeToLeaveScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_getLogicTime(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_getLogicTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getLogicTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCharacterObject:getLogicTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_getLogicTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CCharacterObject_onRegisterToBlock(lua_State* tolua_S)
{
    int argc = 0;
    CCharacterObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (CCharacterObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CCharacterObject_onRegisterToBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onRegisterToBlock();
        return 0;
    }

    gxError("CCharacterObject:onRegisterToBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CCharacterObject_onRegisterToBlock'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CCharacterObject_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCharacterObject)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCharacterObject",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CCharacterObject* self = (CCharacterObject*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CCharacterObject(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCharacterObject");
    tolua_cclass(tolua_S,"CCharacterObject","CCharacterObject","CDynamicObject",nullptr);

    tolua_beginmodule(tolua_S,"CCharacterObject");
        tolua_function(tolua_S,"toRoleBase",lua_mapserver_CCharacterObject_toRoleBase);
        tolua_function(tolua_S,"updateOutBlock",lua_mapserver_CCharacterObject_updateOutBlock);
        tolua_function(tolua_S,"getRoleBaseOwner",lua_mapserver_CCharacterObject_getRoleBaseOwner);
        tolua_function(tolua_S,"getOwner",lua_mapserver_CCharacterObject_getOwner);
        tolua_function(tolua_S,"setOwnerUID",lua_mapserver_CCharacterObject_setOwnerUID);
        tolua_function(tolua_S,"resetPos",lua_mapserver_CCharacterObject_resetPos);
        tolua_function(tolua_S,"setDie",lua_mapserver_CCharacterObject_setDie);
        tolua_function(tolua_S,"update",lua_mapserver_CCharacterObject_update);
        tolua_function(tolua_S,"onLeaveScene",lua_mapserver_CCharacterObject_onLeaveScene);
        tolua_function(tolua_S,"onEnterScene",lua_mapserver_CCharacterObject_onEnterScene);
        tolua_function(tolua_S,"init",lua_mapserver_CCharacterObject_init);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CCharacterObject_cleanUp);
        tolua_function(tolua_S,"getOwnerUID",lua_mapserver_CCharacterObject_getOwnerUID);
        tolua_function(tolua_S,"isDie",lua_mapserver_CCharacterObject_isDie);
        tolua_function(tolua_S,"isTimeToLeaveScene",lua_mapserver_CCharacterObject_isTimeToLeaveScene);
        tolua_function(tolua_S,"getLogicTime",lua_mapserver_CCharacterObject_getLogicTime);
        tolua_function(tolua_S,"onRegisterToBlock",lua_mapserver_CCharacterObject_onRegisterToBlock);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CCharacterObject).name();
    g_luaType[typeName] = "CCharacterObject";
    g_typeCast["CCharacterObject"] = "CCharacterObject";
    return 1;
}

int lua_mapserver_CGameServerSocketPacketHandler_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CGameServerSocketPacketHandler* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CGameServerSocketPacketHandler();
        tolua_pushusertype(tolua_S,(void*)cobj,"CGameServerSocketPacketHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CGameServerSocketPacketHandler:CGameServerSocketPacketHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CGameServerSocketPacketHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGameServerSocketPacketHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGameServerSocketPacketHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CGameServerSocketPacketHandler* self = (CGameServerSocketPacketHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CGameServerSocketPacketHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGameServerSocketPacketHandler");
    tolua_cclass(tolua_S,"CGameServerSocketPacketHandler","CGameServerSocketPacketHandler","CGameSocketPacketHandler",lua_mapserver_CGameServerSocketPacketHandler_finalize);

    tolua_beginmodule(tolua_S,"CGameServerSocketPacketHandler");
        tolua_function(tolua_S,"new",lua_mapserver_CGameServerSocketPacketHandler_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CGameServerSocketPacketHandler).name();
    g_luaType[typeName] = "CGameServerSocketPacketHandler";
    g_typeCast["CGameServerSocketPacketHandler"] = "CGameServerSocketPacketHandler";
    return 1;
}

static int lua_mapserver_CharmsItemBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CharmsItemBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CharmsItemBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CharmsItemBeanReader* self = (CharmsItemBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CharmsItemBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CharmsItemBeanReader");
    tolua_cclass(tolua_S,"CharmsItemBeanReader","CharmsItemBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"CharmsItemBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CharmsItemBeanReader).name();
    g_luaType[typeName] = "CharmsItemBeanReader";
    g_typeCast["CharmsItemBeanReader"] = "CharmsItemBeanReader";
    return 1;
}

static int lua_mapserver_GiftBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (GiftBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"GiftBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GiftBeanReader* self = (GiftBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_GiftBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"GiftBeanReader");
    tolua_cclass(tolua_S,"GiftBeanReader","GiftBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"GiftBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GiftBeanReader).name();
    g_luaType[typeName] = "GiftBeanReader";
    g_typeCast["GiftBeanReader"] = "GiftBeanReader";
    return 1;
}

static int lua_mapserver_PlayerInfoBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PlayerInfoBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PlayerInfoBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PlayerInfoBeanReader* self = (PlayerInfoBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PlayerInfoBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PlayerInfoBeanReader");
    tolua_cclass(tolua_S,"PlayerInfoBeanReader","PlayerInfoBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"PlayerInfoBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PlayerInfoBeanReader).name();
    g_luaType[typeName] = "PlayerInfoBeanReader";
    g_typeCast["PlayerInfoBeanReader"] = "PlayerInfoBeanReader";
    return 1;
}

static int lua_mapserver_GiveGiftBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (GiveGiftBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"GiveGiftBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GiveGiftBeanReader* self = (GiveGiftBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_GiveGiftBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"GiveGiftBeanReader");
    tolua_cclass(tolua_S,"GiveGiftBeanReader","GiveGiftBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"GiveGiftBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GiveGiftBeanReader).name();
    g_luaType[typeName] = "GiveGiftBeanReader";
    g_typeCast["GiveGiftBeanReader"] = "GiveGiftBeanReader";
    return 1;
}

static int lua_mapserver_FriendPageBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (FriendPageBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"FriendPageBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        FriendPageBeanReader* self = (FriendPageBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_FriendPageBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"FriendPageBeanReader");
    tolua_cclass(tolua_S,"FriendPageBeanReader","FriendPageBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"FriendPageBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(FriendPageBeanReader).name();
    g_luaType[typeName] = "FriendPageBeanReader";
    g_typeCast["FriendPageBeanReader"] = "FriendPageBeanReader";
    return 1;
}

static int lua_mapserver_SimplePlayerInfoBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (SimplePlayerInfoBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"SimplePlayerInfoBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        SimplePlayerInfoBeanReader* self = (SimplePlayerInfoBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_SimplePlayerInfoBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"SimplePlayerInfoBeanReader");
    tolua_cclass(tolua_S,"SimplePlayerInfoBeanReader","SimplePlayerInfoBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"SimplePlayerInfoBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(SimplePlayerInfoBeanReader).name();
    g_luaType[typeName] = "SimplePlayerInfoBeanReader";
    g_typeCast["SimplePlayerInfoBeanReader"] = "SimplePlayerInfoBeanReader";
    return 1;
}

static int lua_mapserver_GiveGiftSimpleBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (GiveGiftSimpleBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"GiveGiftSimpleBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GiveGiftSimpleBeanReader* self = (GiveGiftSimpleBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_GiveGiftSimpleBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"GiveGiftSimpleBeanReader");
    tolua_cclass(tolua_S,"GiveGiftSimpleBeanReader","GiveGiftSimpleBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"GiveGiftSimpleBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GiveGiftSimpleBeanReader).name();
    g_luaType[typeName] = "GiveGiftSimpleBeanReader";
    g_typeCast["GiveGiftSimpleBeanReader"] = "GiveGiftSimpleBeanReader";
    return 1;
}

static int lua_mapserver_FriendSimplePageBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (FriendSimplePageBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"FriendSimplePageBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        FriendSimplePageBeanReader* self = (FriendSimplePageBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_FriendSimplePageBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"FriendSimplePageBeanReader");
    tolua_cclass(tolua_S,"FriendSimplePageBeanReader","FriendSimplePageBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"FriendSimplePageBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(FriendSimplePageBeanReader).name();
    g_luaType[typeName] = "FriendSimplePageBeanReader";
    g_typeCast["FriendSimplePageBeanReader"] = "FriendSimplePageBeanReader";
    return 1;
}

static int lua_mapserver_GuessBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (GuessBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"GuessBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GuessBeanReader* self = (GuessBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_GuessBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"GuessBeanReader");
    tolua_cclass(tolua_S,"GuessBeanReader","GuessBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"GuessBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GuessBeanReader).name();
    g_luaType[typeName] = "GuessBeanReader";
    g_typeCast["GuessBeanReader"] = "GuessBeanReader";
    return 1;
}

static int lua_mapserver_LoginAwardBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (LoginAwardBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"LoginAwardBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        LoginAwardBeanReader* self = (LoginAwardBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_LoginAwardBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"LoginAwardBeanReader");
    tolua_cclass(tolua_S,"LoginAwardBeanReader","LoginAwardBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"LoginAwardBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(LoginAwardBeanReader).name();
    g_luaType[typeName] = "LoginAwardBeanReader";
    g_typeCast["LoginAwardBeanReader"] = "LoginAwardBeanReader";
    return 1;
}

static int lua_mapserver_MailBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MailBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MailBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MailBeanReader* self = (MailBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MailBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MailBeanReader");
    tolua_cclass(tolua_S,"MailBeanReader","MailBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"MailBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MailBeanReader).name();
    g_luaType[typeName] = "MailBeanReader";
    g_typeCast["MailBeanReader"] = "MailBeanReader";
    return 1;
}

static int lua_mapserver_MyGuessBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MyGuessBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MyGuessBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MyGuessBeanReader* self = (MyGuessBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MyGuessBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MyGuessBeanReader");
    tolua_cclass(tolua_S,"MyGuessBeanReader","MyGuessBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"MyGuessBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MyGuessBeanReader).name();
    g_luaType[typeName] = "MyGuessBeanReader";
    g_typeCast["MyGuessBeanReader"] = "MyGuessBeanReader";
    return 1;
}

static int lua_mapserver_PeriodReportReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PeriodReportReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PeriodReportReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PeriodReportReader* self = (PeriodReportReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PeriodReportReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PeriodReportReader");
    tolua_cclass(tolua_S,"PeriodReportReader","PeriodReportReader","",nullptr);

    tolua_beginmodule(tolua_S,"PeriodReportReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PeriodReportReader).name();
    g_luaType[typeName] = "PeriodReportReader";
    g_typeCast["PeriodReportReader"] = "PeriodReportReader";
    return 1;
}

static int lua_mapserver_PlayerPeriodActionReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PlayerPeriodActionReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PlayerPeriodActionReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PlayerPeriodActionReader* self = (PlayerPeriodActionReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PlayerPeriodActionReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PlayerPeriodActionReader");
    tolua_cclass(tolua_S,"PlayerPeriodActionReader","PlayerPeriodActionReader","",nullptr);

    tolua_beginmodule(tolua_S,"PlayerPeriodActionReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PlayerPeriodActionReader).name();
    g_luaType[typeName] = "PlayerPeriodActionReader";
    g_typeCast["PlayerPeriodActionReader"] = "PlayerPeriodActionReader";
    return 1;
}

static int lua_mapserver_PlayerSeatBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PlayerSeatBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PlayerSeatBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PlayerSeatBeanReader* self = (PlayerSeatBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PlayerSeatBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PlayerSeatBeanReader");
    tolua_cclass(tolua_S,"PlayerSeatBeanReader","PlayerSeatBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"PlayerSeatBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PlayerSeatBeanReader).name();
    g_luaType[typeName] = "PlayerSeatBeanReader";
    g_typeCast["PlayerSeatBeanReader"] = "PlayerSeatBeanReader";
    return 1;
}

static int lua_mapserver_RankBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (RankBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"RankBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        RankBeanReader* self = (RankBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_RankBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"RankBeanReader");
    tolua_cclass(tolua_S,"RankBeanReader","RankBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"RankBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(RankBeanReader).name();
    g_luaType[typeName] = "RankBeanReader";
    g_typeCast["RankBeanReader"] = "RankBeanReader";
    return 1;
}

static int lua_mapserver_RankDayBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (RankDayBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"RankDayBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        RankDayBeanReader* self = (RankDayBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_RankDayBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"RankDayBeanReader");
    tolua_cclass(tolua_S,"RankDayBeanReader","RankDayBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"RankDayBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(RankDayBeanReader).name();
    g_luaType[typeName] = "RankDayBeanReader";
    g_typeCast["RankDayBeanReader"] = "RankDayBeanReader";
    return 1;
}

static int lua_mapserver_RechargeOrderBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (RechargeOrderBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"RechargeOrderBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        RechargeOrderBeanReader* self = (RechargeOrderBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_RechargeOrderBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"RechargeOrderBeanReader");
    tolua_cclass(tolua_S,"RechargeOrderBeanReader","RechargeOrderBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"RechargeOrderBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(RechargeOrderBeanReader).name();
    g_luaType[typeName] = "RechargeOrderBeanReader";
    g_typeCast["RechargeOrderBeanReader"] = "RechargeOrderBeanReader";
    return 1;
}

static int lua_mapserver_SeatPlayerBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (SeatPlayerBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"SeatPlayerBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        SeatPlayerBeanReader* self = (SeatPlayerBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_SeatPlayerBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"SeatPlayerBeanReader");
    tolua_cclass(tolua_S,"SeatPlayerBeanReader","SeatPlayerBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"SeatPlayerBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(SeatPlayerBeanReader).name();
    g_luaType[typeName] = "SeatPlayerBeanReader";
    g_typeCast["SeatPlayerBeanReader"] = "SeatPlayerBeanReader";
    return 1;
}

static int lua_mapserver_SelfPeriodReportReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (SelfPeriodReportReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"SelfPeriodReportReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        SelfPeriodReportReader* self = (SelfPeriodReportReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_SelfPeriodReportReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"SelfPeriodReportReader");
    tolua_cclass(tolua_S,"SelfPeriodReportReader","SelfPeriodReportReader","",nullptr);

    tolua_beginmodule(tolua_S,"SelfPeriodReportReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(SelfPeriodReportReader).name();
    g_luaType[typeName] = "SelfPeriodReportReader";
    g_typeCast["SelfPeriodReportReader"] = "SelfPeriodReportReader";
    return 1;
}

static int lua_mapserver_ServerBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ServerBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ServerBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ServerBeanReader* self = (ServerBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ServerBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ServerBeanReader");
    tolua_cclass(tolua_S,"ServerBeanReader","ServerBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"ServerBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ServerBeanReader).name();
    g_luaType[typeName] = "ServerBeanReader";
    g_typeCast["ServerBeanReader"] = "ServerBeanReader";
    return 1;
}

static int lua_mapserver_ShopItemBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ShopItemBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ShopItemBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ShopItemBeanReader* self = (ShopItemBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ShopItemBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ShopItemBeanReader");
    tolua_cclass(tolua_S,"ShopItemBeanReader","ShopItemBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"ShopItemBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ShopItemBeanReader).name();
    g_luaType[typeName] = "ShopItemBeanReader";
    g_typeCast["ShopItemBeanReader"] = "ShopItemBeanReader";
    return 1;
}

static int lua_mapserver_SimpleRankBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (SimpleRankBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"SimpleRankBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        SimpleRankBeanReader* self = (SimpleRankBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_SimpleRankBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"SimpleRankBeanReader");
    tolua_cclass(tolua_S,"SimpleRankBeanReader","SimpleRankBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"SimpleRankBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(SimpleRankBeanReader).name();
    g_luaType[typeName] = "SimpleRankBeanReader";
    g_typeCast["SimpleRankBeanReader"] = "SimpleRankBeanReader";
    return 1;
}

static int lua_mapserver_TradeItemBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (TradeItemBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"TradeItemBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        TradeItemBeanReader* self = (TradeItemBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_TradeItemBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"TradeItemBeanReader");
    tolua_cclass(tolua_S,"TradeItemBeanReader","TradeItemBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"TradeItemBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(TradeItemBeanReader).name();
    g_luaType[typeName] = "TradeItemBeanReader";
    g_typeCast["TradeItemBeanReader"] = "TradeItemBeanReader";
    return 1;
}

static int lua_mapserver_TwoValueBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (TwoValueBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"TwoValueBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        TwoValueBeanReader* self = (TwoValueBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_TwoValueBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"TwoValueBeanReader");
    tolua_cclass(tolua_S,"TwoValueBeanReader","TwoValueBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"TwoValueBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(TwoValueBeanReader).name();
    g_luaType[typeName] = "TwoValueBeanReader";
    g_typeCast["TwoValueBeanReader"] = "TwoValueBeanReader";
    return 1;
}

static int lua_mapserver_VipInfoBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (VipInfoBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"VipInfoBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        VipInfoBeanReader* self = (VipInfoBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_VipInfoBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"VipInfoBeanReader");
    tolua_cclass(tolua_S,"VipInfoBeanReader","VipInfoBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"VipInfoBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(VipInfoBeanReader).name();
    g_luaType[typeName] = "VipInfoBeanReader";
    g_typeCast["VipInfoBeanReader"] = "VipInfoBeanReader";
    return 1;
}

static int lua_mapserver_ChatMsgBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ChatMsgBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ChatMsgBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ChatMsgBeanReader* self = (ChatMsgBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ChatMsgBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ChatMsgBeanReader");
    tolua_cclass(tolua_S,"ChatMsgBeanReader","ChatMsgBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"ChatMsgBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ChatMsgBeanReader).name();
    g_luaType[typeName] = "ChatMsgBeanReader";
    g_typeCast["ChatMsgBeanReader"] = "ChatMsgBeanReader";
    return 1;
}

static int lua_mapserver_CannonBeanReader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CannonBeanReader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CannonBeanReader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CannonBeanReader* self = (CannonBeanReader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CannonBeanReader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CannonBeanReader");
    tolua_cclass(tolua_S,"CannonBeanReader","CannonBeanReader","",nullptr);

    tolua_beginmodule(tolua_S,"CannonBeanReader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CannonBeanReader).name();
    g_luaType[typeName] = "CannonBeanReader";
    g_typeCast["CannonBeanReader"] = "CannonBeanReader";
    return 1;
}

int lua_mapserver_CMLocalLoginGame_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMLocalLoginGame* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMLocalLoginGame",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMLocalLoginGame*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMLocalLoginGame_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMLocalLoginGame:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMLocalLoginGame_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMLocalLoginGame_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMLocalLoginGame* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMLocalLoginGame();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMLocalLoginGame");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMLocalLoginGame:CMLocalLoginGame has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMLocalLoginGame_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMLocalLoginGame)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMLocalLoginGame",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMLocalLoginGame* self = (CMLocalLoginGame*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMLocalLoginGame(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMLocalLoginGame");
    tolua_cclass(tolua_S,"CMLocalLoginGame","CMLocalLoginGame","CRequestPacket",lua_mapserver_CMLocalLoginGame_finalize);

    tolua_beginmodule(tolua_S,"CMLocalLoginGame");
        tolua_function(tolua_S,"new",lua_mapserver_CMLocalLoginGame_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMLocalLoginGame_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMLocalLoginGame).name();
    g_luaType[typeName] = "CMLocalLoginGame";
    g_typeCast["CMLocalLoginGame"] = "CMLocalLoginGame";
    return 1;
}

int lua_mapserver_MCLocalLoginGameRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCLocalLoginGameRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCLocalLoginGameRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCLocalLoginGameRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCLocalLoginGameRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCLocalLoginGameRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCLocalLoginGameRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCLocalLoginGameRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCLocalLoginGameRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCLocalLoginGameRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCLocalLoginGameRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCLocalLoginGameRet:MCLocalLoginGameRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCLocalLoginGameRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCLocalLoginGameRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCLocalLoginGameRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCLocalLoginGameRet* self = (MCLocalLoginGameRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCLocalLoginGameRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCLocalLoginGameRet");
    tolua_cclass(tolua_S,"MCLocalLoginGameRet","MCLocalLoginGameRet","CResponsePacket",lua_mapserver_MCLocalLoginGameRet_finalize);

    tolua_beginmodule(tolua_S,"MCLocalLoginGameRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCLocalLoginGameRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCLocalLoginGameRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCLocalLoginGameRet).name();
    g_luaType[typeName] = "MCLocalLoginGameRet";
    g_typeCast["MCLocalLoginGameRet"] = "MCLocalLoginGameRet";
    return 1;
}

int lua_mapserver_CMLocalLoginGameAccount_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMLocalLoginGameAccount* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMLocalLoginGameAccount",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMLocalLoginGameAccount*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMLocalLoginGameAccount_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMLocalLoginGameAccount:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMLocalLoginGameAccount_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMLocalLoginGameAccount_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMLocalLoginGameAccount",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMLocalLoginGameAccount::Setup();
        return 0;
    }
    gxError("CMLocalLoginGameAccount:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMLocalLoginGameAccount_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMLocalLoginGameAccount_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMLocalLoginGameAccount",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMLocalLoginGameAccount::Unsetup();
        return 0;
    }
    gxError("CMLocalLoginGameAccount:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMLocalLoginGameAccount_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMLocalLoginGameAccount_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMLocalLoginGameAccount",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        CMLocalLoginGameAccount* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<CMLocalLoginGameAccount>(tolua_S, 2, "CMLocalLoginGameAccount", &arg0, "CMLocalLoginGameAccount:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CMLocalLoginGameAccount:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CMLocalLoginGameAccount:Unpacket");
        if(!ok)
            return 0;
        bool ret = CMLocalLoginGameAccount::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CMLocalLoginGameAccount:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMLocalLoginGameAccount_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMLocalLoginGameAccount_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMLocalLoginGameAccount* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMLocalLoginGameAccount();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMLocalLoginGameAccount");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMLocalLoginGameAccount:CMLocalLoginGameAccount has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMLocalLoginGameAccount_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMLocalLoginGameAccount)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMLocalLoginGameAccount",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMLocalLoginGameAccount* self = (CMLocalLoginGameAccount*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMLocalLoginGameAccount(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMLocalLoginGameAccount");
    tolua_cclass(tolua_S,"CMLocalLoginGameAccount","CMLocalLoginGameAccount","CRequestPacket",lua_mapserver_CMLocalLoginGameAccount_finalize);

    tolua_beginmodule(tolua_S,"CMLocalLoginGameAccount");
        tolua_function(tolua_S,"new",lua_mapserver_CMLocalLoginGameAccount_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMLocalLoginGameAccount_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_CMLocalLoginGameAccount_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_CMLocalLoginGameAccount_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_CMLocalLoginGameAccount_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMLocalLoginGameAccount).name();
    g_luaType[typeName] = "CMLocalLoginGameAccount";
    g_typeCast["CMLocalLoginGameAccount"] = "CMLocalLoginGameAccount";
    return 1;
}

int lua_mapserver_MCLocalLoginGameAccountRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCLocalLoginGameAccountRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCLocalLoginGameAccountRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCLocalLoginGameAccountRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCLocalLoginGameAccountRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCLocalLoginGameAccountRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCLocalLoginGameAccountRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCLocalLoginGameAccountRet_initData(lua_State* tolua_S)
{
    int argc = 0;
    MCLocalLoginGameAccountRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCLocalLoginGameAccountRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCLocalLoginGameAccountRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCLocalLoginGameAccountRet_initData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->initData();
        return 0;
    }

    gxError("MCLocalLoginGameAccountRet:initData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCLocalLoginGameAccountRet_initData'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCLocalLoginGameAccountRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCLocalLoginGameAccountRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCLocalLoginGameAccountRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCLocalLoginGameAccountRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCLocalLoginGameAccountRet:MCLocalLoginGameAccountRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCLocalLoginGameAccountRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCLocalLoginGameAccountRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCLocalLoginGameAccountRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCLocalLoginGameAccountRet* self = (MCLocalLoginGameAccountRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCLocalLoginGameAccountRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCLocalLoginGameAccountRet");
    tolua_cclass(tolua_S,"MCLocalLoginGameAccountRet","MCLocalLoginGameAccountRet","CResponsePacket",lua_mapserver_MCLocalLoginGameAccountRet_finalize);

    tolua_beginmodule(tolua_S,"MCLocalLoginGameAccountRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCLocalLoginGameAccountRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCLocalLoginGameAccountRet_getPackLen);
        tolua_function(tolua_S,"initData",lua_mapserver_MCLocalLoginGameAccountRet_initData);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCLocalLoginGameAccountRet).name();
    g_luaType[typeName] = "MCLocalLoginGameAccountRet";
    g_typeCast["MCLocalLoginGameAccountRet"] = "MCLocalLoginGameAccountRet";
    return 1;
}

int lua_mapserver_CMEnterGame_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMEnterGame* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMEnterGame",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMEnterGame*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMEnterGame_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMEnterGame:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMEnterGame_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMEnterGame_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMEnterGame* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMEnterGame();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMEnterGame");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMEnterGame:CMEnterGame has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMEnterGame_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMEnterGame)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMEnterGame",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMEnterGame* self = (CMEnterGame*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMEnterGame(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMEnterGame");
    tolua_cclass(tolua_S,"CMEnterGame","CMEnterGame","CRequestPacket",lua_mapserver_CMEnterGame_finalize);

    tolua_beginmodule(tolua_S,"CMEnterGame");
        tolua_function(tolua_S,"new",lua_mapserver_CMEnterGame_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMEnterGame_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMEnterGame).name();
    g_luaType[typeName] = "CMEnterGame";
    g_typeCast["CMEnterGame"] = "CMEnterGame";
    return 1;
}

int lua_mapserver_MCEnterGameRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCEnterGameRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCEnterGameRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCEnterGameRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCEnterGameRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCEnterGameRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterGameRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCEnterGameRet_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCEnterGameRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCEnterGameRet::Setup();
        return 0;
    }
    gxError("MCEnterGameRet:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterGameRet_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCEnterGameRet_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCEnterGameRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCEnterGameRet::Unsetup();
        return 0;
    }
    gxError("MCEnterGameRet:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterGameRet_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCEnterGameRet_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCEnterGameRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCEnterGameRet* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCEnterGameRet>(tolua_S, 2, "MCEnterGameRet", &arg0, "MCEnterGameRet:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCEnterGameRet:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCEnterGameRet:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCEnterGameRet::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCEnterGameRet:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCEnterGameRet_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCEnterGameRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCEnterGameRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCEnterGameRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCEnterGameRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCEnterGameRet:MCEnterGameRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCEnterGameRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCEnterGameRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCEnterGameRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCEnterGameRet* self = (MCEnterGameRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCEnterGameRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCEnterGameRet");
    tolua_cclass(tolua_S,"MCEnterGameRet","MCEnterGameRet","CResponsePacket",lua_mapserver_MCEnterGameRet_finalize);

    tolua_beginmodule(tolua_S,"MCEnterGameRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCEnterGameRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCEnterGameRet_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCEnterGameRet_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCEnterGameRet_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCEnterGameRet_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCEnterGameRet).name();
    g_luaType[typeName] = "MCEnterGameRet";
    g_typeCast["MCEnterGameRet"] = "MCEnterGameRet";
    return 1;
}

int lua_mapserver_MCPlayerHeart_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCPlayerHeart* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCPlayerHeart",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCPlayerHeart*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCPlayerHeart_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCPlayerHeart:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCPlayerHeart_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCPlayerHeart_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCPlayerHeart* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCPlayerHeart();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCPlayerHeart");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCPlayerHeart:MCPlayerHeart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCPlayerHeart_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCPlayerHeart)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCPlayerHeart",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCPlayerHeart* self = (MCPlayerHeart*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCPlayerHeart(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCPlayerHeart");
    tolua_cclass(tolua_S,"MCPlayerHeart","MCPlayerHeart","CResponsePacket",lua_mapserver_MCPlayerHeart_finalize);

    tolua_beginmodule(tolua_S,"MCPlayerHeart");
        tolua_function(tolua_S,"new",lua_mapserver_MCPlayerHeart_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCPlayerHeart_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCPlayerHeart).name();
    g_luaType[typeName] = "MCPlayerHeart";
    g_typeCast["MCPlayerHeart"] = "MCPlayerHeart";
    return 1;
}

int lua_mapserver_CMPlayerHeartRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMPlayerHeartRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMPlayerHeartRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMPlayerHeartRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMPlayerHeartRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMPlayerHeartRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMPlayerHeartRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMPlayerHeartRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMPlayerHeartRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMPlayerHeartRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMPlayerHeartRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMPlayerHeartRet:CMPlayerHeartRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMPlayerHeartRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMPlayerHeartRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMPlayerHeartRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMPlayerHeartRet* self = (CMPlayerHeartRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMPlayerHeartRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMPlayerHeartRet");
    tolua_cclass(tolua_S,"CMPlayerHeartRet","CMPlayerHeartRet","CRequestPacket",lua_mapserver_CMPlayerHeartRet_finalize);

    tolua_beginmodule(tolua_S,"CMPlayerHeartRet");
        tolua_function(tolua_S,"new",lua_mapserver_CMPlayerHeartRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMPlayerHeartRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMPlayerHeartRet).name();
    g_luaType[typeName] = "CMPlayerHeartRet";
    g_typeCast["CMPlayerHeartRet"] = "CMPlayerHeartRet";
    return 1;
}

int lua_mapserver_CMapPlayerHandlerBase_getLastHeartTime(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_getLastHeartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastHeartTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:getLastHeartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_getLastHeartTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_getWorldPlayerSockIndex(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_getWorldPlayerSockIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getWorldPlayerSockIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:getWorldPlayerSockIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_getWorldPlayerSockIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_getAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_getAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getAccountID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:getAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_getAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_onBeforeHandlePacket(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_onBeforeHandlePacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CBasePacket* arg0;

        ok &= luaval_to_object<CBasePacket>(tolua_S, 2, "CBasePacket", &arg0, "CMapPlayerHandlerBase:onBeforeHandlePacket");
        if(!ok)
            return 0;
        bool ret = cobj->onBeforeHandlePacket(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:onBeforeHandlePacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_onBeforeHandlePacket'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_doCloseWaitReconnect(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_doCloseWaitReconnect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doCloseWaitReconnect();
        return 0;
    }

    gxError("CMapPlayerHandlerBase:doCloseWaitReconnect has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_doCloseWaitReconnect'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_breath(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_breath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapPlayerHandlerBase:breath");
        if(!ok)
            return 0;
        cobj->breath(arg0);
        return 0;
    }

    gxError("CMapPlayerHandlerBase:breath has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_breath'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_setHeartOutDiffTime(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_setHeartOutDiffTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapPlayerHandlerBase:setHeartOutDiffTime");
        if(!ok)
            return 0;
        cobj->setHeartOutDiffTime(arg0);
        return 0;
    }

    gxError("CMapPlayerHandlerBase:setHeartOutDiffTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_setHeartOutDiffTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_handlePlayerHeart(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_handlePlayerHeart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        MCPlayerHeart* arg0;

        ok &= luaval_to_object<MCPlayerHeart>(tolua_S, 2, "MCPlayerHeart", &arg0, "CMapPlayerHandlerBase:handlePlayerHeart");
        if(!ok)
            return 0;
        int ret = (int)cobj->handlePlayerHeart(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:handlePlayerHeart has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_handlePlayerHeart'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_close(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_close'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->close();
        return 0;
    }

    gxError("CMapPlayerHandlerBase:close has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_close'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_setAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_setAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapPlayerHandlerBase:setAccountID");
        if(!ok)
            return 0;
        cobj->setAccountID(arg0);
        return 0;
    }

    gxError("CMapPlayerHandlerBase:setAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_setAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_setLastSendHeartTime(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_setLastSendHeartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CMapPlayerHandlerBase:setLastSendHeartTime");
        if(!ok)
            return 0;
        cobj->setLastSendHeartTime(arg0);
        return 0;
    }

    gxError("CMapPlayerHandlerBase:setLastSendHeartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_setLastSendHeartTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_setRoleInfo(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_setRoleInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned long long arg0;
        unsigned long long arg1;
        unsigned int arg2;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapPlayerHandlerBase:setRoleInfo");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CMapPlayerHandlerBase:setRoleInfo");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CMapPlayerHandlerBase:setRoleInfo");
        if(!ok)
            return 0;
        cobj->setRoleInfo(arg0, arg1, arg2);
        return 0;
    }

    gxError("CMapPlayerHandlerBase:setRoleInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_setRoleInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_quit(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_quit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapPlayerHandlerBase:quit");
        if(!ok)
            return 0;
        cobj->quit(arg0);
        return 0;
    }

    gxError("CMapPlayerHandlerBase:quit has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_quit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_setHeartDiffTime(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_setHeartDiffTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapPlayerHandlerBase:setHeartDiffTime");
        if(!ok)
            return 0;
        cobj->setHeartDiffTime(arg0);
        return 0;
    }

    gxError("CMapPlayerHandlerBase:setHeartDiffTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_setHeartDiffTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_getLastSendHeartTime(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_getLastSendHeartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastSendHeartTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:getLastSendHeartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_getLastSendHeartTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_getRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_getRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getRoleUID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:getRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_getRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_start(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_start'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_getHeartDiffTime(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_getHeartDiffTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getHeartDiffTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:getHeartDiffTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_getHeartDiffTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_toString(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_checkPlayerHeart(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_checkPlayerHeart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->checkPlayerHeart();
        return 0;
    }

    gxError("CMapPlayerHandlerBase:checkPlayerHeart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_checkPlayerHeart'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_setWorldPlayerSockIndex(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_setWorldPlayerSockIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapPlayerHandlerBase:setWorldPlayerSockIndex");
        if(!ok)
            return 0;
        cobj->setWorldPlayerSockIndex(arg0);
        return 0;
    }

    gxError("CMapPlayerHandlerBase:setWorldPlayerSockIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_setWorldPlayerSockIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_getRole(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_getRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->getRole();
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 1) 
    {
        EManagerQueType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapPlayerHandlerBase:getRole");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->getRole(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:getRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_getRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_setRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_setRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapPlayerHandlerBase:setRoleUID");
        if(!ok)
            return 0;
        cobj->setRoleUID(arg0);
        return 0;
    }

    gxError("CMapPlayerHandlerBase:setRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_setRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_setLastHeartTime(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_setLastHeartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CMapPlayerHandlerBase:setLastHeartTime");
        if(!ok)
            return 0;
        cobj->setLastHeartTime(arg0);
        return 0;
    }

    gxError("CMapPlayerHandlerBase:setLastHeartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_setLastHeartTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_isNeedFreeWorldRole(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_isNeedFreeWorldRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNeedFreeWorldRole();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:isNeedFreeWorldRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_isNeedFreeWorldRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_getHeartOutDiffTime(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_getHeartOutDiffTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getHeartOutDiffTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:getHeartOutDiffTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_getHeartOutDiffTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_initData(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_initData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->initData();
        return 0;
    }

    gxError("CMapPlayerHandlerBase:initData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_initData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_getObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_getObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getObjUID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:getObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_getObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_isHeartOutTime(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_isHeartOutTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isHeartOutTime();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:isHeartOutTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_isHeartOutTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_setObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_setObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CMapPlayerHandlerBase:setObjUID");
        if(!ok)
            return 0;
        cobj->setObjUID(arg0);
        return 0;
    }

    gxError("CMapPlayerHandlerBase:setObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_setObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_doPlayerHeart(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_doPlayerHeart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doPlayerHeart();
        return 0;
    }

    gxError("CMapPlayerHandlerBase:doPlayerHeart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_doPlayerHeart'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_isNeedSendHeart(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_isNeedSendHeart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNeedSendHeart();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapPlayerHandlerBase:isNeedSendHeart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_isNeedSendHeart'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_clean(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandlerBase_clean'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->clean();
        return 0;
    }

    gxError("CMapPlayerHandlerBase:clean has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandlerBase_clean'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandlerBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapPlayerHandlerBase();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapPlayerHandlerBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapPlayerHandlerBase:CMapPlayerHandlerBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapPlayerHandlerBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapPlayerHandlerBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapPlayerHandlerBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapPlayerHandlerBase* self = (CMapPlayerHandlerBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapPlayerHandlerBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapPlayerHandlerBase");
    tolua_cclass(tolua_S,"CMapPlayerHandlerBase","CMapPlayerHandlerBase","CScriptSocketHandler",lua_mapserver_CMapPlayerHandlerBase_finalize);

    tolua_beginmodule(tolua_S,"CMapPlayerHandlerBase");
        tolua_function(tolua_S,"new",lua_mapserver_CMapPlayerHandlerBase_constructor);
        tolua_function(tolua_S,"getLastHeartTime",lua_mapserver_CMapPlayerHandlerBase_getLastHeartTime);
        tolua_function(tolua_S,"getWorldPlayerSockIndex",lua_mapserver_CMapPlayerHandlerBase_getWorldPlayerSockIndex);
        tolua_function(tolua_S,"getAccountID",lua_mapserver_CMapPlayerHandlerBase_getAccountID);
        tolua_function(tolua_S,"onBeforeHandlePacket",lua_mapserver_CMapPlayerHandlerBase_onBeforeHandlePacket);
        tolua_function(tolua_S,"doCloseWaitReconnect",lua_mapserver_CMapPlayerHandlerBase_doCloseWaitReconnect);
        tolua_function(tolua_S,"breath",lua_mapserver_CMapPlayerHandlerBase_breath);
        tolua_function(tolua_S,"setHeartOutDiffTime",lua_mapserver_CMapPlayerHandlerBase_setHeartOutDiffTime);
        tolua_function(tolua_S,"handlePlayerHeart",lua_mapserver_CMapPlayerHandlerBase_handlePlayerHeart);
        tolua_function(tolua_S,"close",lua_mapserver_CMapPlayerHandlerBase_close);
        tolua_function(tolua_S,"setAccountID",lua_mapserver_CMapPlayerHandlerBase_setAccountID);
        tolua_function(tolua_S,"setLastSendHeartTime",lua_mapserver_CMapPlayerHandlerBase_setLastSendHeartTime);
        tolua_function(tolua_S,"setRoleInfo",lua_mapserver_CMapPlayerHandlerBase_setRoleInfo);
        tolua_function(tolua_S,"quit",lua_mapserver_CMapPlayerHandlerBase_quit);
        tolua_function(tolua_S,"setHeartDiffTime",lua_mapserver_CMapPlayerHandlerBase_setHeartDiffTime);
        tolua_function(tolua_S,"getLastSendHeartTime",lua_mapserver_CMapPlayerHandlerBase_getLastSendHeartTime);
        tolua_function(tolua_S,"getRoleUID",lua_mapserver_CMapPlayerHandlerBase_getRoleUID);
        tolua_function(tolua_S,"start",lua_mapserver_CMapPlayerHandlerBase_start);
        tolua_function(tolua_S,"getHeartDiffTime",lua_mapserver_CMapPlayerHandlerBase_getHeartDiffTime);
        tolua_function(tolua_S,"toString",lua_mapserver_CMapPlayerHandlerBase_toString);
        tolua_function(tolua_S,"checkPlayerHeart",lua_mapserver_CMapPlayerHandlerBase_checkPlayerHeart);
        tolua_function(tolua_S,"setWorldPlayerSockIndex",lua_mapserver_CMapPlayerHandlerBase_setWorldPlayerSockIndex);
        tolua_function(tolua_S,"getRole",lua_mapserver_CMapPlayerHandlerBase_getRole);
        tolua_function(tolua_S,"setRoleUID",lua_mapserver_CMapPlayerHandlerBase_setRoleUID);
        tolua_function(tolua_S,"setLastHeartTime",lua_mapserver_CMapPlayerHandlerBase_setLastHeartTime);
        tolua_function(tolua_S,"isNeedFreeWorldRole",lua_mapserver_CMapPlayerHandlerBase_isNeedFreeWorldRole);
        tolua_function(tolua_S,"getHeartOutDiffTime",lua_mapserver_CMapPlayerHandlerBase_getHeartOutDiffTime);
        tolua_function(tolua_S,"initData",lua_mapserver_CMapPlayerHandlerBase_initData);
        tolua_function(tolua_S,"getObjUID",lua_mapserver_CMapPlayerHandlerBase_getObjUID);
        tolua_function(tolua_S,"isHeartOutTime",lua_mapserver_CMapPlayerHandlerBase_isHeartOutTime);
        tolua_function(tolua_S,"setObjUID",lua_mapserver_CMapPlayerHandlerBase_setObjUID);
        tolua_function(tolua_S,"doPlayerHeart",lua_mapserver_CMapPlayerHandlerBase_doPlayerHeart);
        tolua_function(tolua_S,"isNeedSendHeart",lua_mapserver_CMapPlayerHandlerBase_isNeedSendHeart);
        tolua_function(tolua_S,"clean",lua_mapserver_CMapPlayerHandlerBase_clean);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapPlayerHandlerBase).name();
    g_luaType[typeName] = "CMapPlayerHandlerBase";
    g_typeCast["CMapPlayerHandlerBase"] = "CMapPlayerHandlerBase";
    return 1;
}

int lua_mapserver_ServerData_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    ServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (ServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_ServerData_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("ServerData:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_ServerData_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_ServerData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ServerData* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new ServerData();
        tolua_pushusertype(tolua_S,(void*)cobj,"ServerData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("ServerData:ServerData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_ServerData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ServerData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ServerData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ServerData* self = (ServerData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_ServerData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ServerData");
    tolua_cclass(tolua_S,"ServerData","ServerData","",lua_mapserver_ServerData_finalize);

    tolua_beginmodule(tolua_S,"ServerData");
        tolua_function(tolua_S,"new",lua_mapserver_ServerData_constructor);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_ServerData_cleanUp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ServerData).name();
    g_luaType[typeName] = "ServerData";
    g_typeCast["ServerData"] = "ServerData";
    return 1;
}

int lua_mapserver_LoginServerData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    LoginServerData* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new LoginServerData();
        tolua_pushusertype(tolua_S,(void*)cobj,"LoginServerData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("LoginServerData:LoginServerData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_LoginServerData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (LoginServerData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"LoginServerData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        LoginServerData* self = (LoginServerData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_LoginServerData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"LoginServerData");
    tolua_cclass(tolua_S,"LoginServerData","LoginServerData","",lua_mapserver_LoginServerData_finalize);

    tolua_beginmodule(tolua_S,"LoginServerData");
        tolua_function(tolua_S,"new",lua_mapserver_LoginServerData_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(LoginServerData).name();
    g_luaType[typeName] = "LoginServerData";
    g_typeCast["LoginServerData"] = "LoginServerData";
    return 1;
}

int lua_mapserver_WorldServerName_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WorldServerName* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WorldServerName();
        tolua_pushusertype(tolua_S,(void*)cobj,"WorldServerName");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WorldServerName:WorldServerName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WorldServerName_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WorldServerName)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WorldServerName",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WorldServerName* self = (WorldServerName*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WorldServerName(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WorldServerName");
    tolua_cclass(tolua_S,"WorldServerName","WorldServerName","IArrayEnable<WorldServerName>",lua_mapserver_WorldServerName_finalize);

    tolua_beginmodule(tolua_S,"WorldServerName");
        tolua_function(tolua_S,"new",lua_mapserver_WorldServerName_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WorldServerName).name();
    g_luaType[typeName] = "WorldServerName";
    g_typeCast["WorldServerName"] = "WorldServerName";
    return 1;
}

int lua_mapserver_WorldServerData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WorldServerData* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WorldServerData();
        tolua_pushusertype(tolua_S,(void*)cobj,"WorldServerData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WorldServerData:WorldServerData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WorldServerData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WorldServerData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WorldServerData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WorldServerData* self = (WorldServerData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WorldServerData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WorldServerData");
    tolua_cclass(tolua_S,"WorldServerData","WorldServerData","",lua_mapserver_WorldServerData_finalize);

    tolua_beginmodule(tolua_S,"WorldServerData");
        tolua_function(tolua_S,"new",lua_mapserver_WorldServerData_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WorldServerData).name();
    g_luaType[typeName] = "WorldServerData";
    g_typeCast["WorldServerData"] = "WorldServerData";
    return 1;
}

static int lua_mapserver_RoleHeart_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (RoleHeart)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"RoleHeart",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        RoleHeart* self = (RoleHeart*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_RoleHeart(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"RoleHeart");
    tolua_cclass(tolua_S,"RoleHeart","RoleHeart","",nullptr);

    tolua_beginmodule(tolua_S,"RoleHeart");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(RoleHeart).name();
    g_luaType[typeName] = "RoleHeart";
    g_typeCast["RoleHeart"] = "RoleHeart";
    return 1;
}

int lua_mapserver_MWRegiste_toString(lua_State* tolua_S)
{
    int argc = 0;
    MWRegiste* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWRegiste",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWRegiste*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWRegiste_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("MWRegiste:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWRegiste_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWRegiste_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWRegiste* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWRegiste",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWRegiste*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWRegiste_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWRegiste:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWRegiste_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWRegiste_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWRegiste* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWRegiste();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWRegiste");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWRegiste:MWRegiste has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWRegiste_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWRegiste)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWRegiste",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWRegiste* self = (MWRegiste*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWRegiste(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWRegiste");
    tolua_cclass(tolua_S,"MWRegiste","MWRegiste","CRequestPacket",lua_mapserver_MWRegiste_finalize);

    tolua_beginmodule(tolua_S,"MWRegiste");
        tolua_function(tolua_S,"new",lua_mapserver_MWRegiste_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_MWRegiste_toString);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWRegiste_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWRegiste).name();
    g_luaType[typeName] = "MWRegiste";
    g_typeCast["MWRegiste"] = "MWRegiste";
    return 1;
}

int lua_mapserver_WMRegisteRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMRegisteRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMRegisteRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMRegisteRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMRegisteRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMRegisteRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMRegisteRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMRegisteRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMRegisteRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMRegisteRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMRegisteRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMRegisteRet:WMRegisteRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMRegisteRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMRegisteRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMRegisteRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMRegisteRet* self = (WMRegisteRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMRegisteRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMRegisteRet");
    tolua_cclass(tolua_S,"WMRegisteRet","WMRegisteRet","CResponsePacket",lua_mapserver_WMRegisteRet_finalize);

    tolua_beginmodule(tolua_S,"WMRegisteRet");
        tolua_function(tolua_S,"new",lua_mapserver_WMRegisteRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMRegisteRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMRegisteRet).name();
    g_luaType[typeName] = "WMRegisteRet";
    g_typeCast["WMRegisteRet"] = "WMRegisteRet";
    return 1;
}

int lua_mapserver_MWBroadPacket_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWBroadPacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWBroadPacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWBroadPacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWBroadPacket_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWBroadPacket:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWBroadPacket_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWBroadPacket_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWBroadPacket* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWBroadPacket();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWBroadPacket");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWBroadPacket:MWBroadPacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWBroadPacket_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWBroadPacket)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWBroadPacket",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWBroadPacket* self = (MWBroadPacket*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWBroadPacket(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWBroadPacket");
    tolua_cclass(tolua_S,"MWBroadPacket","MWBroadPacket","CRequestPacket",lua_mapserver_MWBroadPacket_finalize);

    tolua_beginmodule(tolua_S,"MWBroadPacket");
        tolua_function(tolua_S,"new",lua_mapserver_MWBroadPacket_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWBroadPacket_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWBroadPacket).name();
    g_luaType[typeName] = "MWBroadPacket";
    g_typeCast["MWBroadPacket"] = "MWBroadPacket";
    return 1;
}

int lua_mapserver_MWTransPacket_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWTransPacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWTransPacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWTransPacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWTransPacket_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWTransPacket:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWTransPacket_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWTransPacket_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWTransPacket* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWTransPacket();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWTransPacket");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWTransPacket:MWTransPacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWTransPacket_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWTransPacket)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWTransPacket",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWTransPacket* self = (MWTransPacket*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWTransPacket(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWTransPacket");
    tolua_cclass(tolua_S,"MWTransPacket","MWTransPacket","CRequestPacket",lua_mapserver_MWTransPacket_finalize);

    tolua_beginmodule(tolua_S,"MWTransPacket");
        tolua_function(tolua_S,"new",lua_mapserver_MWTransPacket_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWTransPacket_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWTransPacket).name();
    g_luaType[typeName] = "MWTransPacket";
    g_typeCast["MWTransPacket"] = "MWTransPacket";
    return 1;
}

int lua_mapserver_MWTrans2WorldPacket_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWTrans2WorldPacket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWTrans2WorldPacket",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWTrans2WorldPacket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWTrans2WorldPacket_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWTrans2WorldPacket:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWTrans2WorldPacket_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWTrans2WorldPacket_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWTrans2WorldPacket* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWTrans2WorldPacket();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWTrans2WorldPacket");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWTrans2WorldPacket:MWTrans2WorldPacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWTrans2WorldPacket_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWTrans2WorldPacket)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWTrans2WorldPacket",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWTrans2WorldPacket* self = (MWTrans2WorldPacket*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWTrans2WorldPacket(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWTrans2WorldPacket");
    tolua_cclass(tolua_S,"MWTrans2WorldPacket","MWTrans2WorldPacket","CRequestPacket",lua_mapserver_MWTrans2WorldPacket_finalize);

    tolua_beginmodule(tolua_S,"MWTrans2WorldPacket");
        tolua_function(tolua_S,"new",lua_mapserver_MWTrans2WorldPacket_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWTrans2WorldPacket_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWTrans2WorldPacket).name();
    g_luaType[typeName] = "MWTrans2WorldPacket";
    g_typeCast["MWTrans2WorldPacket"] = "MWTrans2WorldPacket";
    return 1;
}

int lua_mapserver_WMTransPacketError_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMTransPacketError* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMTransPacketError",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMTransPacketError*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMTransPacketError_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMTransPacketError:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMTransPacketError_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMTransPacketError_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMTransPacketError* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMTransPacketError();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMTransPacketError");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMTransPacketError:WMTransPacketError has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMTransPacketError_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMTransPacketError)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMTransPacketError",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMTransPacketError* self = (WMTransPacketError*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMTransPacketError(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMTransPacketError");
    tolua_cclass(tolua_S,"WMTransPacketError","WMTransPacketError","CResponsePacket",lua_mapserver_WMTransPacketError_finalize);

    tolua_beginmodule(tolua_S,"WMTransPacketError");
        tolua_function(tolua_S,"new",lua_mapserver_WMTransPacketError_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMTransPacketError_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMTransPacketError).name();
    g_luaType[typeName] = "WMTransPacketError";
    g_typeCast["WMTransPacketError"] = "WMTransPacketError";
    return 1;
}

int lua_mapserver_WMUpdateServer_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMUpdateServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMUpdateServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMUpdateServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMUpdateServer_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMUpdateServer:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMUpdateServer_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMUpdateServer_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"WMUpdateServer",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        WMUpdateServer::Setup();
        return 0;
    }
    gxError("WMUpdateServer:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMUpdateServer_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_WMUpdateServer_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"WMUpdateServer",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        WMUpdateServer::Unsetup();
        return 0;
    }
    gxError("WMUpdateServer:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMUpdateServer_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_WMUpdateServer_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"WMUpdateServer",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        WMUpdateServer* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<WMUpdateServer>(tolua_S, 2, "WMUpdateServer", &arg0, "WMUpdateServer:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "WMUpdateServer:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "WMUpdateServer:Unpacket");
        if(!ok)
            return 0;
        bool ret = WMUpdateServer::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("WMUpdateServer:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMUpdateServer_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_WMUpdateServer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMUpdateServer* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMUpdateServer();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMUpdateServer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMUpdateServer:WMUpdateServer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMUpdateServer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMUpdateServer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMUpdateServer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMUpdateServer* self = (WMUpdateServer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMUpdateServer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMUpdateServer");
    tolua_cclass(tolua_S,"WMUpdateServer","WMUpdateServer","CServerPacket",lua_mapserver_WMUpdateServer_finalize);

    tolua_beginmodule(tolua_S,"WMUpdateServer");
        tolua_function(tolua_S,"new",lua_mapserver_WMUpdateServer_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMUpdateServer_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_WMUpdateServer_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_WMUpdateServer_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_WMUpdateServer_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMUpdateServer).name();
    g_luaType[typeName] = "WMUpdateServer";
    g_typeCast["WMUpdateServer"] = "WMUpdateServer";
    return 1;
}

int lua_mapserver_MWUpdateServer_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWUpdateServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWUpdateServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWUpdateServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWUpdateServer_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWUpdateServer:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWUpdateServer_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWUpdateServer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWUpdateServer* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWUpdateServer();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWUpdateServer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWUpdateServer:MWUpdateServer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWUpdateServer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWUpdateServer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWUpdateServer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWUpdateServer* self = (MWUpdateServer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWUpdateServer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWUpdateServer");
    tolua_cclass(tolua_S,"MWUpdateServer","MWUpdateServer","CServerPacket",lua_mapserver_MWUpdateServer_finalize);

    tolua_beginmodule(tolua_S,"MWUpdateServer");
        tolua_function(tolua_S,"new",lua_mapserver_MWUpdateServer_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWUpdateServer_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWUpdateServer).name();
    g_luaType[typeName] = "MWUpdateServer";
    g_typeCast["MWUpdateServer"] = "MWUpdateServer";
    return 1;
}

int lua_mapserver_MWOpenScene_toString(lua_State* tolua_S)
{
    int argc = 0;
    MWOpenScene* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWOpenScene",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWOpenScene*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWOpenScene_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("MWOpenScene:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWOpenScene_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWOpenScene_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWOpenScene* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWOpenScene",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWOpenScene*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWOpenScene_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWOpenScene:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWOpenScene_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWOpenScene_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWOpenScene* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWOpenScene();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWOpenScene");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWOpenScene:MWOpenScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWOpenScene_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWOpenScene)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWOpenScene",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWOpenScene* self = (MWOpenScene*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWOpenScene(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWOpenScene");
    tolua_cclass(tolua_S,"MWOpenScene","MWOpenScene","CServerPacket",lua_mapserver_MWOpenScene_finalize);

    tolua_beginmodule(tolua_S,"MWOpenScene");
        tolua_function(tolua_S,"new",lua_mapserver_MWOpenScene_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_MWOpenScene_toString);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWOpenScene_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWOpenScene).name();
    g_luaType[typeName] = "MWOpenScene";
    g_typeCast["MWOpenScene"] = "MWOpenScene";
    return 1;
}

int lua_mapserver_MWCloseScene_toString(lua_State* tolua_S)
{
    int argc = 0;
    MWCloseScene* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWCloseScene",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWCloseScene*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWCloseScene_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("MWCloseScene:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWCloseScene_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWCloseScene_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWCloseScene* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWCloseScene",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWCloseScene*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWCloseScene_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWCloseScene:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWCloseScene_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWCloseScene_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWCloseScene* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWCloseScene();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWCloseScene");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWCloseScene:MWCloseScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWCloseScene_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWCloseScene)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWCloseScene",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWCloseScene* self = (MWCloseScene*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWCloseScene(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWCloseScene");
    tolua_cclass(tolua_S,"MWCloseScene","MWCloseScene","CServerPacket",lua_mapserver_MWCloseScene_finalize);

    tolua_beginmodule(tolua_S,"MWCloseScene");
        tolua_function(tolua_S,"new",lua_mapserver_MWCloseScene_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_MWCloseScene_toString);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWCloseScene_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWCloseScene).name();
    g_luaType[typeName] = "MWCloseScene";
    g_typeCast["MWCloseScene"] = "MWCloseScene";
    return 1;
}

int lua_mapserver_MMChangeScene_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MMChangeScene* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MMChangeScene",0,&tolua_err)) goto tolua_lerror;
    cobj = (MMChangeScene*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MMChangeScene_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MMChangeScene:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MMChangeScene_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MMChangeScene_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MMChangeScene* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MMChangeScene();
        tolua_pushusertype(tolua_S,(void*)cobj,"MMChangeScene");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MMChangeScene:MMChangeScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MMChangeScene_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MMChangeScene)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MMChangeScene",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MMChangeScene* self = (MMChangeScene*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MMChangeScene(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MMChangeScene");
    tolua_cclass(tolua_S,"MMChangeScene","MMChangeScene","CServerPacket",lua_mapserver_MMChangeScene_finalize);

    tolua_beginmodule(tolua_S,"MMChangeScene");
        tolua_function(tolua_S,"new",lua_mapserver_MMChangeScene_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MMChangeScene_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MMChangeScene).name();
    g_luaType[typeName] = "MMChangeScene";
    g_typeCast["MMChangeScene"] = "MMChangeScene";
    return 1;
}

int lua_mapserver_MWChangeLine_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWChangeLine* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWChangeLine",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWChangeLine*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWChangeLine_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWChangeLine:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWChangeLine_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWChangeLine_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWChangeLine* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWChangeLine();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWChangeLine");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWChangeLine:MWChangeLine has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWChangeLine_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWChangeLine)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWChangeLine",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWChangeLine* self = (MWChangeLine*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWChangeLine(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWChangeLine");
    tolua_cclass(tolua_S,"MWChangeLine","MWChangeLine","CRequestPacket",lua_mapserver_MWChangeLine_finalize);

    tolua_beginmodule(tolua_S,"MWChangeLine");
        tolua_function(tolua_S,"new",lua_mapserver_MWChangeLine_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWChangeLine_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWChangeLine).name();
    g_luaType[typeName] = "MWChangeLine";
    g_typeCast["MWChangeLine"] = "MWChangeLine";
    return 1;
}

int lua_mapserver_WMChangeLine_toString(lua_State* tolua_S)
{
    int argc = 0;
    WMChangeLine* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMChangeLine",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMChangeLine*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMChangeLine_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("WMChangeLine:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMChangeLine_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMChangeLine_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMChangeLine* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMChangeLine",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMChangeLine*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMChangeLine_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMChangeLine:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMChangeLine_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMChangeLine_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMChangeLine* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMChangeLine();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMChangeLine");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMChangeLine:WMChangeLine has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMChangeLine_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMChangeLine)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMChangeLine",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMChangeLine* self = (WMChangeLine*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMChangeLine(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMChangeLine");
    tolua_cclass(tolua_S,"WMChangeLine","WMChangeLine","CServerPacket",lua_mapserver_WMChangeLine_finalize);

    tolua_beginmodule(tolua_S,"WMChangeLine");
        tolua_function(tolua_S,"new",lua_mapserver_WMChangeLine_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_WMChangeLine_toString);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMChangeLine_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMChangeLine).name();
    g_luaType[typeName] = "WMChangeLine";
    g_typeCast["WMChangeLine"] = "WMChangeLine";
    return 1;
}

int lua_mapserver_WMChangeLineRet_toString(lua_State* tolua_S)
{
    int argc = 0;
    WMChangeLineRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMChangeLineRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMChangeLineRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMChangeLineRet_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("WMChangeLineRet:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMChangeLineRet_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMChangeLineRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMChangeLineRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMChangeLineRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMChangeLineRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMChangeLineRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMChangeLineRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMChangeLineRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMChangeLineRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMChangeLineRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMChangeLineRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMChangeLineRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMChangeLineRet:WMChangeLineRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMChangeLineRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMChangeLineRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMChangeLineRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMChangeLineRet* self = (WMChangeLineRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMChangeLineRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMChangeLineRet");
    tolua_cclass(tolua_S,"WMChangeLineRet","WMChangeLineRet","CResponsePacket",lua_mapserver_WMChangeLineRet_finalize);

    tolua_beginmodule(tolua_S,"WMChangeLineRet");
        tolua_function(tolua_S,"new",lua_mapserver_WMChangeLineRet_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_WMChangeLineRet_toString);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMChangeLineRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMChangeLineRet).name();
    g_luaType[typeName] = "WMChangeLineRet";
    g_typeCast["WMChangeLineRet"] = "WMChangeLineRet";
    return 1;
}

int lua_mapserver_WMLoadRoleData_toString(lua_State* tolua_S)
{
    int argc = 0;
    WMLoadRoleData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMLoadRoleData",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMLoadRoleData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMLoadRoleData_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("WMLoadRoleData:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMLoadRoleData_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMLoadRoleData_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMLoadRoleData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMLoadRoleData",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMLoadRoleData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMLoadRoleData_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMLoadRoleData:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMLoadRoleData_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMLoadRoleData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMLoadRoleData* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMLoadRoleData();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMLoadRoleData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMLoadRoleData:WMLoadRoleData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMLoadRoleData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMLoadRoleData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMLoadRoleData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMLoadRoleData* self = (WMLoadRoleData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMLoadRoleData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMLoadRoleData");
    tolua_cclass(tolua_S,"WMLoadRoleData","WMLoadRoleData","CRequestPacket",lua_mapserver_WMLoadRoleData_finalize);

    tolua_beginmodule(tolua_S,"WMLoadRoleData");
        tolua_function(tolua_S,"new",lua_mapserver_WMLoadRoleData_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_WMLoadRoleData_toString);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMLoadRoleData_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMLoadRoleData).name();
    g_luaType[typeName] = "WMLoadRoleData";
    g_typeCast["WMLoadRoleData"] = "WMLoadRoleData";
    return 1;
}

int lua_mapserver_MWLoadRoleDataRet_toString(lua_State* tolua_S)
{
    int argc = 0;
    MWLoadRoleDataRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWLoadRoleDataRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWLoadRoleDataRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWLoadRoleDataRet_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("MWLoadRoleDataRet:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWLoadRoleDataRet_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWLoadRoleDataRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWLoadRoleDataRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWLoadRoleDataRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWLoadRoleDataRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWLoadRoleDataRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWLoadRoleDataRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWLoadRoleDataRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWLoadRoleDataRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWLoadRoleDataRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWLoadRoleDataRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWLoadRoleDataRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWLoadRoleDataRet:MWLoadRoleDataRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWLoadRoleDataRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWLoadRoleDataRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWLoadRoleDataRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWLoadRoleDataRet* self = (MWLoadRoleDataRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWLoadRoleDataRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWLoadRoleDataRet");
    tolua_cclass(tolua_S,"MWLoadRoleDataRet","MWLoadRoleDataRet","CResponsePacket",lua_mapserver_MWLoadRoleDataRet_finalize);

    tolua_beginmodule(tolua_S,"MWLoadRoleDataRet");
        tolua_function(tolua_S,"new",lua_mapserver_MWLoadRoleDataRet_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_MWLoadRoleDataRet_toString);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWLoadRoleDataRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWLoadRoleDataRet).name();
    g_luaType[typeName] = "MWLoadRoleDataRet";
    g_typeCast["MWLoadRoleDataRet"] = "MWLoadRoleDataRet";
    return 1;
}

int lua_mapserver_WMUnloadRoleData_toString(lua_State* tolua_S)
{
    int argc = 0;
    WMUnloadRoleData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMUnloadRoleData",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMUnloadRoleData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMUnloadRoleData_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("WMUnloadRoleData:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMUnloadRoleData_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMUnloadRoleData_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMUnloadRoleData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMUnloadRoleData",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMUnloadRoleData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMUnloadRoleData_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMUnloadRoleData:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMUnloadRoleData_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMUnloadRoleData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMUnloadRoleData* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMUnloadRoleData();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMUnloadRoleData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMUnloadRoleData:WMUnloadRoleData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMUnloadRoleData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMUnloadRoleData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMUnloadRoleData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMUnloadRoleData* self = (WMUnloadRoleData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMUnloadRoleData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMUnloadRoleData");
    tolua_cclass(tolua_S,"WMUnloadRoleData","WMUnloadRoleData","CRequestPacket",lua_mapserver_WMUnloadRoleData_finalize);

    tolua_beginmodule(tolua_S,"WMUnloadRoleData");
        tolua_function(tolua_S,"new",lua_mapserver_WMUnloadRoleData_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_WMUnloadRoleData_toString);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMUnloadRoleData_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMUnloadRoleData).name();
    g_luaType[typeName] = "WMUnloadRoleData";
    g_typeCast["WMUnloadRoleData"] = "WMUnloadRoleData";
    return 1;
}

int lua_mapserver_MWUnloadRoleDataRet_toString(lua_State* tolua_S)
{
    int argc = 0;
    MWUnloadRoleDataRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWUnloadRoleDataRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWUnloadRoleDataRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWUnloadRoleDataRet_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("MWUnloadRoleDataRet:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWUnloadRoleDataRet_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWUnloadRoleDataRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWUnloadRoleDataRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWUnloadRoleDataRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWUnloadRoleDataRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWUnloadRoleDataRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWUnloadRoleDataRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWUnloadRoleDataRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWUnloadRoleDataRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWUnloadRoleDataRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWUnloadRoleDataRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWUnloadRoleDataRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWUnloadRoleDataRet:MWUnloadRoleDataRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWUnloadRoleDataRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWUnloadRoleDataRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWUnloadRoleDataRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWUnloadRoleDataRet* self = (MWUnloadRoleDataRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWUnloadRoleDataRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWUnloadRoleDataRet");
    tolua_cclass(tolua_S,"MWUnloadRoleDataRet","MWUnloadRoleDataRet","CResponsePacket",lua_mapserver_MWUnloadRoleDataRet_finalize);

    tolua_beginmodule(tolua_S,"MWUnloadRoleDataRet");
        tolua_function(tolua_S,"new",lua_mapserver_MWUnloadRoleDataRet_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_MWUnloadRoleDataRet_toString);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWUnloadRoleDataRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWUnloadRoleDataRet).name();
    g_luaType[typeName] = "MWUnloadRoleDataRet";
    g_typeCast["MWUnloadRoleDataRet"] = "MWUnloadRoleDataRet";
    return 1;
}

int lua_mapserver_MWRoleQuit_toString(lua_State* tolua_S)
{
    int argc = 0;
    MWRoleQuit* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWRoleQuit",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWRoleQuit*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWRoleQuit_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("MWRoleQuit:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWRoleQuit_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWRoleQuit_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWRoleQuit* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWRoleQuit",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWRoleQuit*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWRoleQuit_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWRoleQuit:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWRoleQuit_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWRoleQuit_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWRoleQuit* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWRoleQuit();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWRoleQuit");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWRoleQuit:MWRoleQuit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWRoleQuit_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWRoleQuit)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWRoleQuit",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWRoleQuit* self = (MWRoleQuit*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWRoleQuit(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWRoleQuit");
    tolua_cclass(tolua_S,"MWRoleQuit","MWRoleQuit","CRequestPacket",lua_mapserver_MWRoleQuit_finalize);

    tolua_beginmodule(tolua_S,"MWRoleQuit");
        tolua_function(tolua_S,"new",lua_mapserver_MWRoleQuit_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_MWRoleQuit_toString);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWRoleQuit_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWRoleQuit).name();
    g_luaType[typeName] = "MWRoleQuit";
    g_typeCast["MWRoleQuit"] = "MWRoleQuit";
    return 1;
}

int lua_mapserver_MWUserLogin_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWUserLogin* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWUserLogin",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWUserLogin*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWUserLogin_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWUserLogin:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWUserLogin_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWUserLogin_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWUserLogin* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWUserLogin();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWUserLogin");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWUserLogin:MWUserLogin has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWUserLogin_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWUserLogin)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWUserLogin",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWUserLogin* self = (MWUserLogin*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWUserLogin(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWUserLogin");
    tolua_cclass(tolua_S,"MWUserLogin","MWUserLogin","CServerPacket",lua_mapserver_MWUserLogin_finalize);

    tolua_beginmodule(tolua_S,"MWUserLogin");
        tolua_function(tolua_S,"new",lua_mapserver_MWUserLogin_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWUserLogin_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWUserLogin).name();
    g_luaType[typeName] = "MWUserLogin";
    g_typeCast["MWUserLogin"] = "MWUserLogin";
    return 1;
}

int lua_mapserver_MWRoleHeart_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWRoleHeart* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWRoleHeart",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWRoleHeart*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWRoleHeart_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWRoleHeart:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWRoleHeart_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWRoleHeart_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWRoleHeart* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWRoleHeart();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWRoleHeart");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWRoleHeart:MWRoleHeart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWRoleHeart_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWRoleHeart)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWRoleHeart",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWRoleHeart* self = (MWRoleHeart*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWRoleHeart(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWRoleHeart");
    tolua_cclass(tolua_S,"MWRoleHeart","MWRoleHeart","CRequestPacket",lua_mapserver_MWRoleHeart_finalize);

    tolua_beginmodule(tolua_S,"MWRoleHeart");
        tolua_function(tolua_S,"new",lua_mapserver_MWRoleHeart_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWRoleHeart_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWRoleHeart).name();
    g_luaType[typeName] = "MWRoleHeart";
    g_typeCast["MWRoleHeart"] = "MWRoleHeart";
    return 1;
}

int lua_mapserver_WMRoleHeartRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMRoleHeartRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMRoleHeartRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMRoleHeartRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMRoleHeartRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMRoleHeartRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMRoleHeartRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMRoleHeartRet_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"WMRoleHeartRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        WMRoleHeartRet::Setup();
        return 0;
    }
    gxError("WMRoleHeartRet:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMRoleHeartRet_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_WMRoleHeartRet_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"WMRoleHeartRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        WMRoleHeartRet::Unsetup();
        return 0;
    }
    gxError("WMRoleHeartRet:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMRoleHeartRet_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_WMRoleHeartRet_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"WMRoleHeartRet",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        WMRoleHeartRet* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<WMRoleHeartRet>(tolua_S, 2, "WMRoleHeartRet", &arg0, "WMRoleHeartRet:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "WMRoleHeartRet:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "WMRoleHeartRet:Unpacket");
        if(!ok)
            return 0;
        bool ret = WMRoleHeartRet::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("WMRoleHeartRet:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMRoleHeartRet_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_WMRoleHeartRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMRoleHeartRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMRoleHeartRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMRoleHeartRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMRoleHeartRet:WMRoleHeartRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMRoleHeartRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMRoleHeartRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMRoleHeartRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMRoleHeartRet* self = (WMRoleHeartRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMRoleHeartRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMRoleHeartRet");
    tolua_cclass(tolua_S,"WMRoleHeartRet","WMRoleHeartRet","CResponsePacket",lua_mapserver_WMRoleHeartRet_finalize);

    tolua_beginmodule(tolua_S,"WMRoleHeartRet");
        tolua_function(tolua_S,"new",lua_mapserver_WMRoleHeartRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMRoleHeartRet_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_WMRoleHeartRet_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_WMRoleHeartRet_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_WMRoleHeartRet_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMRoleHeartRet).name();
    g_luaType[typeName] = "WMRoleHeartRet";
    g_typeCast["WMRoleHeartRet"] = "WMRoleHeartRet";
    return 1;
}

int lua_mapserver_MWRoleKick_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWRoleKick* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWRoleKick",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWRoleKick*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWRoleKick_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWRoleKick:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWRoleKick_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWRoleKick_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWRoleKick* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWRoleKick();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWRoleKick");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWRoleKick:MWRoleKick has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWRoleKick_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWRoleKick)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWRoleKick",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWRoleKick* self = (MWRoleKick*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWRoleKick(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWRoleKick");
    tolua_cclass(tolua_S,"MWRoleKick","MWRoleKick","CServerPacket",lua_mapserver_MWRoleKick_finalize);

    tolua_beginmodule(tolua_S,"MWRoleKick");
        tolua_function(tolua_S,"new",lua_mapserver_MWRoleKick_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWRoleKick_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWRoleKick).name();
    g_luaType[typeName] = "MWRoleKick";
    g_typeCast["MWRoleKick"] = "MWRoleKick";
    return 1;
}

int lua_mapserver_WMUpdateUserData_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMUpdateUserData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMUpdateUserData",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMUpdateUserData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMUpdateUserData_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMUpdateUserData:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMUpdateUserData_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMUpdateUserData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMUpdateUserData* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMUpdateUserData();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMUpdateUserData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMUpdateUserData:WMUpdateUserData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMUpdateUserData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMUpdateUserData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMUpdateUserData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMUpdateUserData* self = (WMUpdateUserData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMUpdateUserData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMUpdateUserData");
    tolua_cclass(tolua_S,"WMUpdateUserData","WMUpdateUserData","CServerPacket",lua_mapserver_WMUpdateUserData_finalize);

    tolua_beginmodule(tolua_S,"WMUpdateUserData");
        tolua_function(tolua_S,"new",lua_mapserver_WMUpdateUserData_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMUpdateUserData_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMUpdateUserData).name();
    g_luaType[typeName] = "WMUpdateUserData";
    g_typeCast["WMUpdateUserData"] = "WMUpdateUserData";
    return 1;
}

int lua_mapserver_MWUpdateRoleData_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWUpdateRoleData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWUpdateRoleData",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWUpdateRoleData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWUpdateRoleData_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWUpdateRoleData:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWUpdateRoleData_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWUpdateRoleData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWUpdateRoleData* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWUpdateRoleData();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWUpdateRoleData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWUpdateRoleData:MWUpdateRoleData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWUpdateRoleData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWUpdateRoleData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWUpdateRoleData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWUpdateRoleData* self = (MWUpdateRoleData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWUpdateRoleData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWUpdateRoleData");
    tolua_cclass(tolua_S,"MWUpdateRoleData","MWUpdateRoleData","CServerPacket",lua_mapserver_MWUpdateRoleData_finalize);

    tolua_beginmodule(tolua_S,"MWUpdateRoleData");
        tolua_function(tolua_S,"new",lua_mapserver_MWUpdateRoleData_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWUpdateRoleData_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWUpdateRoleData).name();
    g_luaType[typeName] = "MWUpdateRoleData";
    g_typeCast["MWUpdateRoleData"] = "MWUpdateRoleData";
    return 1;
}

int lua_mapserver_MWRandRoleName_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWRandRoleName* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWRandRoleName",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWRandRoleName*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWRandRoleName_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWRandRoleName:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWRandRoleName_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWRandRoleName_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWRandRoleName* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWRandRoleName();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWRandRoleName");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWRandRoleName:MWRandRoleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWRandRoleName_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWRandRoleName)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWRandRoleName",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWRandRoleName* self = (MWRandRoleName*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWRandRoleName(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWRandRoleName");
    tolua_cclass(tolua_S,"MWRandRoleName","MWRandRoleName","CRequestPacket",lua_mapserver_MWRandRoleName_finalize);

    tolua_beginmodule(tolua_S,"MWRandRoleName");
        tolua_function(tolua_S,"new",lua_mapserver_MWRandRoleName_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWRandRoleName_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWRandRoleName).name();
    g_luaType[typeName] = "MWRandRoleName";
    g_typeCast["MWRandRoleName"] = "MWRandRoleName";
    return 1;
}

int lua_mapserver_WMRandRoleNameRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMRandRoleNameRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMRandRoleNameRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMRandRoleNameRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMRandRoleNameRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMRandRoleNameRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMRandRoleNameRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMRandRoleNameRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMRandRoleNameRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMRandRoleNameRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMRandRoleNameRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMRandRoleNameRet:WMRandRoleNameRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMRandRoleNameRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMRandRoleNameRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMRandRoleNameRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMRandRoleNameRet* self = (WMRandRoleNameRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMRandRoleNameRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMRandRoleNameRet");
    tolua_cclass(tolua_S,"WMRandRoleNameRet","WMRandRoleNameRet","CResponsePacket",lua_mapserver_WMRandRoleNameRet_finalize);

    tolua_beginmodule(tolua_S,"WMRandRoleNameRet");
        tolua_function(tolua_S,"new",lua_mapserver_WMRandRoleNameRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMRandRoleNameRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMRandRoleNameRet).name();
    g_luaType[typeName] = "WMRandRoleNameRet";
    g_typeCast["WMRandRoleNameRet"] = "WMRandRoleNameRet";
    return 1;
}

int lua_mapserver_MWRenameRoleName_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWRenameRoleName* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWRenameRoleName",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWRenameRoleName*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWRenameRoleName_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWRenameRoleName:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWRenameRoleName_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWRenameRoleName_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWRenameRoleName* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWRenameRoleName();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWRenameRoleName");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWRenameRoleName:MWRenameRoleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWRenameRoleName_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWRenameRoleName)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWRenameRoleName",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWRenameRoleName* self = (MWRenameRoleName*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWRenameRoleName(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWRenameRoleName");
    tolua_cclass(tolua_S,"MWRenameRoleName","MWRenameRoleName","CRequestPacket",lua_mapserver_MWRenameRoleName_finalize);

    tolua_beginmodule(tolua_S,"MWRenameRoleName");
        tolua_function(tolua_S,"new",lua_mapserver_MWRenameRoleName_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWRenameRoleName_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWRenameRoleName).name();
    g_luaType[typeName] = "MWRenameRoleName";
    g_typeCast["MWRenameRoleName"] = "MWRenameRoleName";
    return 1;
}

int lua_mapserver_WMRenameRoleNameRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMRenameRoleNameRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMRenameRoleNameRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMRenameRoleNameRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMRenameRoleNameRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMRenameRoleNameRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMRenameRoleNameRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMRenameRoleNameRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMRenameRoleNameRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMRenameRoleNameRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMRenameRoleNameRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMRenameRoleNameRet:WMRenameRoleNameRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMRenameRoleNameRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMRenameRoleNameRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMRenameRoleNameRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMRenameRoleNameRet* self = (WMRenameRoleNameRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMRenameRoleNameRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMRenameRoleNameRet");
    tolua_cclass(tolua_S,"WMRenameRoleNameRet","WMRenameRoleNameRet","CResponsePacket",lua_mapserver_WMRenameRoleNameRet_finalize);

    tolua_beginmodule(tolua_S,"WMRenameRoleNameRet");
        tolua_function(tolua_S,"new",lua_mapserver_WMRenameRoleNameRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMRenameRoleNameRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMRenameRoleNameRet).name();
    g_luaType[typeName] = "WMRenameRoleNameRet";
    g_typeCast["WMRenameRoleNameRet"] = "WMRenameRoleNameRet";
    return 1;
}

int lua_mapserver_MWGetRandNameList_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWGetRandNameList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWGetRandNameList",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWGetRandNameList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWGetRandNameList_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWGetRandNameList:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWGetRandNameList_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWGetRandNameList_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWGetRandNameList* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWGetRandNameList();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWGetRandNameList");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWGetRandNameList:MWGetRandNameList has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWGetRandNameList_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWGetRandNameList)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWGetRandNameList",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWGetRandNameList* self = (MWGetRandNameList*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWGetRandNameList(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWGetRandNameList");
    tolua_cclass(tolua_S,"MWGetRandNameList","MWGetRandNameList","CRequestPacket",lua_mapserver_MWGetRandNameList_finalize);

    tolua_beginmodule(tolua_S,"MWGetRandNameList");
        tolua_function(tolua_S,"new",lua_mapserver_MWGetRandNameList_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWGetRandNameList_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWGetRandNameList).name();
    g_luaType[typeName] = "MWGetRandNameList";
    g_typeCast["MWGetRandNameList"] = "MWGetRandNameList";
    return 1;
}

int lua_mapserver_WMGetRandNameListRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMGetRandNameListRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMGetRandNameListRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMGetRandNameListRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMGetRandNameListRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMGetRandNameListRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMGetRandNameListRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMGetRandNameListRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMGetRandNameListRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMGetRandNameListRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMGetRandNameListRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMGetRandNameListRet:WMGetRandNameListRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMGetRandNameListRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMGetRandNameListRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMGetRandNameListRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMGetRandNameListRet* self = (WMGetRandNameListRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMGetRandNameListRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMGetRandNameListRet");
    tolua_cclass(tolua_S,"WMGetRandNameListRet","WMGetRandNameListRet","CResponsePacket",lua_mapserver_WMGetRandNameListRet_finalize);

    tolua_beginmodule(tolua_S,"WMGetRandNameListRet");
        tolua_function(tolua_S,"new",lua_mapserver_WMGetRandNameListRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMGetRandNameListRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMGetRandNameListRet).name();
    g_luaType[typeName] = "WMGetRandNameListRet";
    g_typeCast["WMGetRandNameListRet"] = "WMGetRandNameListRet";
    return 1;
}

int lua_mapserver_WMRecharge_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMRecharge* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMRecharge",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMRecharge*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMRecharge_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMRecharge:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMRecharge_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMRecharge_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMRecharge* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMRecharge();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMRecharge");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMRecharge:WMRecharge has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMRecharge_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMRecharge)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMRecharge",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMRecharge* self = (WMRecharge*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMRecharge(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMRecharge");
    tolua_cclass(tolua_S,"WMRecharge","WMRecharge","CRequestPacket",lua_mapserver_WMRecharge_finalize);

    tolua_beginmodule(tolua_S,"WMRecharge");
        tolua_function(tolua_S,"new",lua_mapserver_WMRecharge_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMRecharge_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMRecharge).name();
    g_luaType[typeName] = "WMRecharge";
    g_typeCast["WMRecharge"] = "WMRecharge";
    return 1;
}

int lua_mapserver_MWRechargeRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWRechargeRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWRechargeRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWRechargeRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWRechargeRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWRechargeRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWRechargeRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWRechargeRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWRechargeRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWRechargeRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWRechargeRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWRechargeRet:MWRechargeRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWRechargeRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWRechargeRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWRechargeRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWRechargeRet* self = (MWRechargeRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWRechargeRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWRechargeRet");
    tolua_cclass(tolua_S,"MWRechargeRet","MWRechargeRet","CResponsePacket",lua_mapserver_MWRechargeRet_finalize);

    tolua_beginmodule(tolua_S,"MWRechargeRet");
        tolua_function(tolua_S,"new",lua_mapserver_MWRechargeRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWRechargeRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWRechargeRet).name();
    g_luaType[typeName] = "MWRechargeRet";
    g_typeCast["MWRechargeRet"] = "MWRechargeRet";
    return 1;
}

int lua_mapserver_WMServerInfo_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMServerInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMServerInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMServerInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMServerInfo_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMServerInfo:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMServerInfo_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMServerInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMServerInfo* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMServerInfo();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMServerInfo");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMServerInfo:WMServerInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMServerInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMServerInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMServerInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMServerInfo* self = (WMServerInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMServerInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMServerInfo");
    tolua_cclass(tolua_S,"WMServerInfo","WMServerInfo","CServerPacket",lua_mapserver_WMServerInfo_finalize);

    tolua_beginmodule(tolua_S,"WMServerInfo");
        tolua_function(tolua_S,"new",lua_mapserver_WMServerInfo_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMServerInfo_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMServerInfo).name();
    g_luaType[typeName] = "WMServerInfo";
    g_typeCast["WMServerInfo"] = "WMServerInfo";
    return 1;
}

int lua_mapserver_WMAwardBindRmb_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMAwardBindRmb* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMAwardBindRmb",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMAwardBindRmb*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMAwardBindRmb_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMAwardBindRmb:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMAwardBindRmb_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMAwardBindRmb_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMAwardBindRmb* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMAwardBindRmb();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMAwardBindRmb");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMAwardBindRmb:WMAwardBindRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMAwardBindRmb_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMAwardBindRmb)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMAwardBindRmb",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMAwardBindRmb* self = (WMAwardBindRmb*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMAwardBindRmb(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMAwardBindRmb");
    tolua_cclass(tolua_S,"WMAwardBindRmb","WMAwardBindRmb","CServerPacket",lua_mapserver_WMAwardBindRmb_finalize);

    tolua_beginmodule(tolua_S,"WMAwardBindRmb");
        tolua_function(tolua_S,"new",lua_mapserver_WMAwardBindRmb_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMAwardBindRmb_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMAwardBindRmb).name();
    g_luaType[typeName] = "WMAwardBindRmb";
    g_typeCast["WMAwardBindRmb"] = "WMAwardBindRmb";
    return 1;
}

int lua_mapserver_MWAnnoucement_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWAnnoucement* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWAnnoucement",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWAnnoucement*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWAnnoucement_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWAnnoucement:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWAnnoucement_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWAnnoucement_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MWAnnoucement",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MWAnnoucement::Setup();
        return 0;
    }
    gxError("MWAnnoucement:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWAnnoucement_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MWAnnoucement_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MWAnnoucement",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MWAnnoucement::Unsetup();
        return 0;
    }
    gxError("MWAnnoucement:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWAnnoucement_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MWAnnoucement_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MWAnnoucement",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MWAnnoucement* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MWAnnoucement>(tolua_S, 2, "MWAnnoucement", &arg0, "MWAnnoucement:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MWAnnoucement:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MWAnnoucement:Unpacket");
        if(!ok)
            return 0;
        bool ret = MWAnnoucement::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MWAnnoucement:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWAnnoucement_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MWAnnoucement_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWAnnoucement* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWAnnoucement();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWAnnoucement");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWAnnoucement:MWAnnoucement has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWAnnoucement_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWAnnoucement)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWAnnoucement",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWAnnoucement* self = (MWAnnoucement*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWAnnoucement(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWAnnoucement");
    tolua_cclass(tolua_S,"MWAnnoucement","MWAnnoucement","CServerPacket",lua_mapserver_MWAnnoucement_finalize);

    tolua_beginmodule(tolua_S,"MWAnnoucement");
        tolua_function(tolua_S,"new",lua_mapserver_MWAnnoucement_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWAnnoucement_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MWAnnoucement_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MWAnnoucement_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MWAnnoucement_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWAnnoucement).name();
    g_luaType[typeName] = "MWAnnoucement";
    g_typeCast["MWAnnoucement"] = "MWAnnoucement";
    return 1;
}

int lua_mapserver_CWMLimitAccountInfo_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CWMLimitAccountInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CWMLimitAccountInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CWMLimitAccountInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CWMLimitAccountInfo_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CWMLimitAccountInfo:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CWMLimitAccountInfo_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CWMLimitAccountInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CWMLimitAccountInfo* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CWMLimitAccountInfo();
        tolua_pushusertype(tolua_S,(void*)cobj,"CWMLimitAccountInfo");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CWMLimitAccountInfo:CWMLimitAccountInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CWMLimitAccountInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CWMLimitAccountInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CWMLimitAccountInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CWMLimitAccountInfo* self = (CWMLimitAccountInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CWMLimitAccountInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CWMLimitAccountInfo");
    tolua_cclass(tolua_S,"CWMLimitAccountInfo","CWMLimitAccountInfo","CServerPacket",lua_mapserver_CWMLimitAccountInfo_finalize);

    tolua_beginmodule(tolua_S,"CWMLimitAccountInfo");
        tolua_function(tolua_S,"new",lua_mapserver_CWMLimitAccountInfo_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CWMLimitAccountInfo_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CWMLimitAccountInfo).name();
    g_luaType[typeName] = "CWMLimitAccountInfo";
    g_typeCast["CWMLimitAccountInfo"] = "CWMLimitAccountInfo";
    return 1;
}

int lua_mapserver_CWMLimitChatInfo_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CWMLimitChatInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CWMLimitChatInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CWMLimitChatInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CWMLimitChatInfo_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CWMLimitChatInfo:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CWMLimitChatInfo_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CWMLimitChatInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CWMLimitChatInfo* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CWMLimitChatInfo();
        tolua_pushusertype(tolua_S,(void*)cobj,"CWMLimitChatInfo");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CWMLimitChatInfo:CWMLimitChatInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CWMLimitChatInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CWMLimitChatInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CWMLimitChatInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CWMLimitChatInfo* self = (CWMLimitChatInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CWMLimitChatInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CWMLimitChatInfo");
    tolua_cclass(tolua_S,"CWMLimitChatInfo","CWMLimitChatInfo","CServerPacket",lua_mapserver_CWMLimitChatInfo_finalize);

    tolua_beginmodule(tolua_S,"CWMLimitChatInfo");
        tolua_function(tolua_S,"new",lua_mapserver_CWMLimitChatInfo_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CWMLimitChatInfo_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CWMLimitChatInfo).name();
    g_luaType[typeName] = "CWMLimitChatInfo";
    g_typeCast["CWMLimitChatInfo"] = "CWMLimitChatInfo";
    return 1;
}

int lua_mapserver_CMWLimitInfoReq_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMWLimitInfoReq* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMWLimitInfoReq",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMWLimitInfoReq*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMWLimitInfoReq_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMWLimitInfoReq:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMWLimitInfoReq_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMWLimitInfoReq_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMWLimitInfoReq* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMWLimitInfoReq();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMWLimitInfoReq");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMWLimitInfoReq:CMWLimitInfoReq has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMWLimitInfoReq_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMWLimitInfoReq)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMWLimitInfoReq",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMWLimitInfoReq* self = (CMWLimitInfoReq*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMWLimitInfoReq(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMWLimitInfoReq");
    tolua_cclass(tolua_S,"CMWLimitInfoReq","CMWLimitInfoReq","CServerPacket",lua_mapserver_CMWLimitInfoReq_finalize);

    tolua_beginmodule(tolua_S,"CMWLimitInfoReq");
        tolua_function(tolua_S,"new",lua_mapserver_CMWLimitInfoReq_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMWLimitInfoReq_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMWLimitInfoReq).name();
    g_luaType[typeName] = "CMWLimitInfoReq";
    g_typeCast["CMWLimitInfoReq"] = "CMWLimitInfoReq";
    return 1;
}

int lua_mapserver_MWExchangeGiftReq_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MWExchangeGiftReq* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MWExchangeGiftReq",0,&tolua_err)) goto tolua_lerror;
    cobj = (MWExchangeGiftReq*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MWExchangeGiftReq_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MWExchangeGiftReq:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MWExchangeGiftReq_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MWExchangeGiftReq_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MWExchangeGiftReq* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MWExchangeGiftReq();
        tolua_pushusertype(tolua_S,(void*)cobj,"MWExchangeGiftReq");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MWExchangeGiftReq:MWExchangeGiftReq has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MWExchangeGiftReq_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MWExchangeGiftReq)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MWExchangeGiftReq",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MWExchangeGiftReq* self = (MWExchangeGiftReq*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MWExchangeGiftReq(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MWExchangeGiftReq");
    tolua_cclass(tolua_S,"MWExchangeGiftReq","MWExchangeGiftReq","CRequestPacket",lua_mapserver_MWExchangeGiftReq_finalize);

    tolua_beginmodule(tolua_S,"MWExchangeGiftReq");
        tolua_function(tolua_S,"new",lua_mapserver_MWExchangeGiftReq_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MWExchangeGiftReq_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MWExchangeGiftReq).name();
    g_luaType[typeName] = "MWExchangeGiftReq";
    g_typeCast["MWExchangeGiftReq"] = "MWExchangeGiftReq";
    return 1;
}

int lua_mapserver_WMExchangeGiftRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    WMExchangeGiftRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"WMExchangeGiftRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (WMExchangeGiftRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_WMExchangeGiftRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("WMExchangeGiftRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_WMExchangeGiftRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_WMExchangeGiftRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    WMExchangeGiftRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new WMExchangeGiftRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"WMExchangeGiftRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("WMExchangeGiftRet:WMExchangeGiftRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_WMExchangeGiftRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WMExchangeGiftRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WMExchangeGiftRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WMExchangeGiftRet* self = (WMExchangeGiftRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WMExchangeGiftRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WMExchangeGiftRet");
    tolua_cclass(tolua_S,"WMExchangeGiftRet","WMExchangeGiftRet","CResponsePacket",lua_mapserver_WMExchangeGiftRet_finalize);

    tolua_beginmodule(tolua_S,"WMExchangeGiftRet");
        tolua_function(tolua_S,"new",lua_mapserver_WMExchangeGiftRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_WMExchangeGiftRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WMExchangeGiftRet).name();
    g_luaType[typeName] = "WMExchangeGiftRet";
    g_typeCast["WMExchangeGiftRet"] = "WMExchangeGiftRet";
    return 1;
}

int lua_mapserver_CMapWorldServerHandlerBase_sendRegisteToWorld(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_sendRegisteToWorld'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        unsigned short arg0;
        EServerType arg1;
        unsigned int arg2;
        GXMISC::CFixString<20> arg3;
        unsigned short arg4;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapWorldServerHandlerBase:sendRegisteToWorld");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapWorldServerHandlerBase:sendRegisteToWorld");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CMapWorldServerHandlerBase:sendRegisteToWorld");

        ok &= luaval_to_fixstring(tolua_S, 5,&arg3, "CMapWorldServerHandlerBase:sendRegisteToWorld");

        ok &= luaval_to_uint16(tolua_S, 6, (uint16*)&arg4, "CMapWorldServerHandlerBase:sendRegisteToWorld");
        if(!ok)
            return 0;
        cobj->sendRegisteToWorld(arg0, arg1, arg2, arg3, arg4);
        return 0;
    }

    gxError("CMapWorldServerHandlerBase:sendRegisteToWorld has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_sendRegisteToWorld'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_quit(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_quit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->quit();
        return 0;
    }

    gxError("CMapWorldServerHandlerBase:quit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_quit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_doBroadCast(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_doBroadCast'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBasePacket* arg0;
        unsigned int arg1;

        ok &= luaval_to_object<CBasePacket>(tolua_S, 2, "CBasePacket", &arg0, "CMapWorldServerHandlerBase:doBroadCast");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CMapWorldServerHandlerBase:doBroadCast");
        if(!ok)
            return 0;
        int ret = (int)cobj->doBroadCast(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandlerBase:doBroadCast has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_doBroadCast'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_handleRoleHeartRet(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_handleRoleHeartRet'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        WMRoleHeartRet* arg0;

        ok &= luaval_to_object<WMRoleHeartRet>(tolua_S, 2, "WMRoleHeartRet", &arg0, "CMapWorldServerHandlerBase:handleRoleHeartRet");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleRoleHeartRet(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandlerBase:handleRoleHeartRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_handleRoleHeartRet'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_handleRegisteToWorldRet(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_handleRegisteToWorldRet'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        WMRegisteRet* arg0;

        ok &= luaval_to_object<WMRegisteRet>(tolua_S, 2, "WMRegisteRet", &arg0, "CMapWorldServerHandlerBase:handleRegisteToWorldRet");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleRegisteToWorldRet(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandlerBase:handleRegisteToWorldRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_handleRegisteToWorldRet'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_handleRename(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_handleRename'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        WMRenameRoleNameRet* arg0;

        ok &= luaval_to_object<WMRenameRoleNameRet>(tolua_S, 2, "WMRenameRoleNameRet", &arg0, "CMapWorldServerHandlerBase:handleRename");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleRename(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandlerBase:handleRename has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_handleRename'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_handleTransError(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_handleTransError'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        WMTransPacketError* arg0;

        ok &= luaval_to_object<WMTransPacketError>(tolua_S, 2, "WMTransPacketError", &arg0, "CMapWorldServerHandlerBase:handleTransError");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleTransError(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandlerBase:handleTransError has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_handleTransError'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_doTransError(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_doTransError'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        CBasePacket* arg0;
        unsigned int arg1;
        unsigned int arg2;
        EGameRetCode arg3;

        ok &= luaval_to_object<CBasePacket>(tolua_S, 2, "CBasePacket", &arg0, "CMapWorldServerHandlerBase:doTransError");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CMapWorldServerHandlerBase:doTransError");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CMapWorldServerHandlerBase:doTransError");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CMapWorldServerHandlerBase:doTransError");
        if(!ok)
            return 0;
        cobj->doTransError(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CMapWorldServerHandlerBase:doTransError has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_doTransError'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_breath(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_breath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapWorldServerHandlerBase:breath");
        if(!ok)
            return 0;
        cobj->breath(arg0);
        return 0;
    }

    gxError("CMapWorldServerHandlerBase:breath has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_breath'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_start(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapWorldServerHandlerBase:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_start'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_handleTrans(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_handleTrans'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        MWTransPacket* arg0;

        ok &= luaval_to_object<MWTransPacket>(tolua_S, 2, "MWTransPacket", &arg0, "CMapWorldServerHandlerBase:handleTrans");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleTrans(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandlerBase:handleTrans has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_handleTrans'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_doTrans(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_doTrans'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CBasePacket* arg0;
        unsigned int arg1;
        unsigned int arg2;

        ok &= luaval_to_object<CBasePacket>(tolua_S, 2, "CBasePacket", &arg0, "CMapWorldServerHandlerBase:doTrans");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CMapWorldServerHandlerBase:doTrans");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CMapWorldServerHandlerBase:doTrans");
        if(!ok)
            return 0;
        int ret = (int)cobj->doTrans(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandlerBase:doTrans has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_doTrans'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_close(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_close'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->close();
        return 0;
    }

    gxError("CMapWorldServerHandlerBase:close has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_close'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_handleServerInfo(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_handleServerInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        WMServerInfo* arg0;

        ok &= luaval_to_object<WMServerInfo>(tolua_S, 2, "WMServerInfo", &arg0, "CMapWorldServerHandlerBase:handleServerInfo");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleServerInfo(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandlerBase:handleServerInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_handleServerInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_handleBroadCast(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandlerBase_handleBroadCast'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        MWBroadPacket* arg0;

        ok &= luaval_to_object<MWBroadPacket>(tolua_S, 2, "MWBroadPacket", &arg0, "CMapWorldServerHandlerBase:handleBroadCast");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleBroadCast(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandlerBase:handleBroadCast has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_handleBroadCast'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_IsActive(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        bool ret = CMapWorldServerHandlerBase::IsActive();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CMapWorldServerHandlerBase:IsActive has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandlerBase_IsActive'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMapWorldServerHandlerBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandlerBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapWorldServerHandlerBase();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapWorldServerHandlerBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapWorldServerHandlerBase:CMapWorldServerHandlerBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapWorldServerHandlerBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapWorldServerHandlerBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapWorldServerHandlerBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapWorldServerHandlerBase* self = (CMapWorldServerHandlerBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapWorldServerHandlerBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapWorldServerHandlerBase");
    tolua_cclass(tolua_S,"CMapWorldServerHandlerBase","CMapWorldServerHandlerBase","CGameSocketHandler<CMapWorldServerHandlerBase>",lua_mapserver_CMapWorldServerHandlerBase_finalize);

    tolua_beginmodule(tolua_S,"CMapWorldServerHandlerBase");
        tolua_function(tolua_S,"new",lua_mapserver_CMapWorldServerHandlerBase_constructor);
        tolua_function(tolua_S,"sendRegisteToWorld",lua_mapserver_CMapWorldServerHandlerBase_sendRegisteToWorld);
        tolua_function(tolua_S,"quit",lua_mapserver_CMapWorldServerHandlerBase_quit);
        tolua_function(tolua_S,"doBroadCast",lua_mapserver_CMapWorldServerHandlerBase_doBroadCast);
        tolua_function(tolua_S,"handleRoleHeartRet",lua_mapserver_CMapWorldServerHandlerBase_handleRoleHeartRet);
        tolua_function(tolua_S,"handleRegisteToWorldRet",lua_mapserver_CMapWorldServerHandlerBase_handleRegisteToWorldRet);
        tolua_function(tolua_S,"handleRename",lua_mapserver_CMapWorldServerHandlerBase_handleRename);
        tolua_function(tolua_S,"handleTransError",lua_mapserver_CMapWorldServerHandlerBase_handleTransError);
        tolua_function(tolua_S,"doTransError",lua_mapserver_CMapWorldServerHandlerBase_doTransError);
        tolua_function(tolua_S,"breath",lua_mapserver_CMapWorldServerHandlerBase_breath);
        tolua_function(tolua_S,"start",lua_mapserver_CMapWorldServerHandlerBase_start);
        tolua_function(tolua_S,"handleTrans",lua_mapserver_CMapWorldServerHandlerBase_handleTrans);
        tolua_function(tolua_S,"doTrans",lua_mapserver_CMapWorldServerHandlerBase_doTrans);
        tolua_function(tolua_S,"close",lua_mapserver_CMapWorldServerHandlerBase_close);
        tolua_function(tolua_S,"handleServerInfo",lua_mapserver_CMapWorldServerHandlerBase_handleServerInfo);
        tolua_function(tolua_S,"handleBroadCast",lua_mapserver_CMapWorldServerHandlerBase_handleBroadCast);
        tolua_function(tolua_S,"IsActive", lua_mapserver_CMapWorldServerHandlerBase_IsActive);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapWorldServerHandlerBase).name();
    g_luaType[typeName] = "CMapWorldServerHandlerBase";
    g_typeCast["CMapWorldServerHandlerBase"] = "CMapWorldServerHandlerBase";
    return 1;
}

int lua_mapserver_CRoleBase_isReady(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_isReady'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isReady();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:isReady has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_isReady'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onUpdateLogoutQue(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onUpdateLogoutQue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleBase:onUpdateLogoutQue");
        if(!ok)
            return 0;
        cobj->onUpdateLogoutQue(arg0);
        return 0;
    }

    gxError("CRoleBase:onUpdateLogoutQue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onUpdateLogoutQue'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleBase:setAccountID");
        if(!ok)
            return 0;
        cobj->setAccountID(arg0);
        return 0;
    }

    gxError("CRoleBase:setAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getLoginLastTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getLoginLastTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getLoginLastTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getLoginLastTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getLoginLastTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_isEnter(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_isEnter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isEnter();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:isEnter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_isEnter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getIsAdult(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getIsAdult'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getIsAdult();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:getIsAdult has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getIsAdult'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getLoginTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getLoginTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLoginTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getLoginTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getLoginTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onUpdateReadyQue(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onUpdateReadyQue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleBase:onUpdateReadyQue");
        if(!ok)
            return 0;
        cobj->onUpdateReadyQue(arg0);
        return 0;
    }

    gxError("CRoleBase:onUpdateReadyQue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onUpdateReadyQue'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_key3ToString(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_key3ToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->key3ToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CRoleBase:key3ToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_key3ToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setEnterGameTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setEnterGameTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleBase:setEnterGameTime");
        if(!ok)
            return 0;
        cobj->setEnterGameTime(arg0);
        return 0;
    }

    gxError("CRoleBase:setEnterGameTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setEnterGameTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onLeaveScene(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onLeaveScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapSceneBase* arg0;

        ok &= luaval_to_object<CMapSceneBase>(tolua_S, 2, "CMapSceneBase", &arg0, "CRoleBase:onLeaveScene");
        if(!ok)
            return 0;
        cobj->onLeaveScene(arg0);
        return 0;
    }

    gxError("CRoleBase:onLeaveScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onLeaveScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setLastAgainstIndulgeTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setLastAgainstIndulgeTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleBase:setLastAgainstIndulgeTime");
        if(!ok)
            return 0;
        cobj->setLastAgainstIndulgeTime(arg0);
        return 0;
    }

    gxError("CRoleBase:setLastAgainstIndulgeTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setLastAgainstIndulgeTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_init(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const _CharacterInit* arg0;

        ok &= luaval_to_object<const _CharacterInit>(tolua_S, 2, "_CharacterInit", &arg0, "CRoleBase:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_isKey2(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_isKey2'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey2();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:isKey2 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_isKey2'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getQuitRet(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getQuitRet'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getQuitRet();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:getQuitRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getQuitRet'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_resetLogoutTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_resetLogoutTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleBase:resetLogoutTime");
        if(!ok)
            return 0;
        cobj->resetLogoutTime(arg0);
        return 0;
    }

    gxError("CRoleBase:resetLogoutTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_resetLogoutTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setIPAddress(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setIPAddress'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CRoleBase:setIPAddress");
        if(!ok)
            return 0;
        cobj->setIPAddress(arg0);
        return 0;
    }

    gxError("CRoleBase:setIPAddress has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setIPAddress'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleBase:setRoleUID");
        if(!ok)
            return 0;
        cobj->setRoleUID(arg0);
        return 0;
    }

    gxError("CRoleBase:setRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getLastAgainstIndulgeNoticeTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getLastAgainstIndulgeNoticeTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastAgainstIndulgeNoticeTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getLastAgainstIndulgeNoticeTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getLastAgainstIndulgeNoticeTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setIsOffOverDay(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setIsOffOverDay'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRoleBase:setIsOffOverDay");
        if(!ok)
            return 0;
        cobj->setIsOffOverDay(arg0);
        return 0;
    }

    gxError("CRoleBase:setIsOffOverDay has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setIsOffOverDay'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onAddToEnter(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onAddToEnter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onAddToEnter();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:onAddToEnter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onAddToEnter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getDbHandlerBase(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getDbHandlerBase'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapDbPlayerHandlerBase* ret = cobj->getDbHandlerBase();
        object_to_luaval<CMapDbPlayerHandlerBase>(tolua_S, "CMapDbPlayerHandlerBase",(CMapDbPlayerHandlerBase*)ret);
        return 1;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRoleBase:getDbHandlerBase");
        if(!ok)
            return 0;
        CMapDbPlayerHandlerBase* ret = cobj->getDbHandlerBase(arg0);
        object_to_luaval<CMapDbPlayerHandlerBase>(tolua_S, "CMapDbPlayerHandlerBase",(CMapDbPlayerHandlerBase*)ret);
        return 1;
    }

    gxError("CRoleBase:getDbHandlerBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getDbHandlerBase'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getDbIndex(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getDbIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getDbIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CRoleBase:getDbIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getDbIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onHourTimer(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onHourTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CRoleBase:onHourTimer");
        if(!ok)
            return 0;
        cobj->onHourTimer(arg0);
        return 0;
    }

    gxError("CRoleBase:onHourTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onHourTimer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_key2ToString(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_key2ToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->key2ToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CRoleBase:key2ToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_key2ToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getLoginPlayerSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getLoginPlayerSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getLoginPlayerSocketIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CRoleBase:getLoginPlayerSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getLoginPlayerSocketIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onRemoveFromEnter(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onRemoveFromEnter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onRemoveFromEnter();
        return 0;
    }

    gxError("CRoleBase:onRemoveFromEnter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onRemoveFromEnter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setKey3(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setKey3'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleBase:setKey3");
        if(!ok)
            return 0;
        cobj->setKey3(arg0);
        return 0;
    }

    gxError("CRoleBase:setKey3 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setKey3'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onAddToReady(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onAddToReady'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onAddToReady();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:onAddToReady has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onAddToReady'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setDbSaveIndex(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setDbSaveIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleBase:setDbSaveIndex");
        if(!ok)
            return 0;
        cobj->setDbSaveIndex(arg0);
        return 0;
    }

    gxError("CRoleBase:setDbSaveIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setDbSaveIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_waitReconnect(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_waitReconnect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->waitReconnect();
        return 0;
    }

    gxError("CRoleBase:waitReconnect has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_waitReconnect'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getGmPower(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getGmPower'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getGmPower();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getGmPower has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getGmPower'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setGmPower(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setGmPower'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CRoleBase:setGmPower");
        if(!ok)
            return 0;
        cobj->setGmPower(arg0);
        return 0;
    }

    gxError("CRoleBase:setGmPower has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setGmPower'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setKey2(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setKey2'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleBase:setKey2");
        if(!ok)
            return 0;
        cobj->setKey2(arg0);
        return 0;
    }

    gxError("CRoleBase:setKey2 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setKey2'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setLastAgainstIndulgeNoticeTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setLastAgainstIndulgeNoticeTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleBase:setLastAgainstIndulgeNoticeTime");
        if(!ok)
            return 0;
        cobj->setLastAgainstIndulgeNoticeTime(arg0);
        return 0;
    }

    gxError("CRoleBase:setLastAgainstIndulgeNoticeTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setLastAgainstIndulgeNoticeTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getUpdateSaveDirty(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getUpdateSaveDirty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getUpdateSaveDirty();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:getUpdateSaveDirty has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getUpdateSaveDirty'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getPlayerHandlerBase(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getPlayerHandlerBase'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapPlayerHandlerBase* ret = cobj->getPlayerHandlerBase();
        object_to_luaval<CMapPlayerHandlerBase>(tolua_S, "CMapPlayerHandlerBase",(CMapPlayerHandlerBase*)ret);
        return 1;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRoleBase:getPlayerHandlerBase");
        if(!ok)
            return 0;
        CMapPlayerHandlerBase* ret = cobj->getPlayerHandlerBase(arg0);
        object_to_luaval<CMapPlayerHandlerBase>(tolua_S, "CMapPlayerHandlerBase",(CMapPlayerHandlerBase*)ret);
        return 1;
    }

    gxError("CRoleBase:getPlayerHandlerBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getPlayerHandlerBase'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getDbSaveIndex(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getDbSaveIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getDbSaveIndex();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getDbSaveIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getDbSaveIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getLastAgainstIndulgeTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getLastAgainstIndulgeTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getLastAgainstIndulgeTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getLastAgainstIndulgeTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getLastAgainstIndulgeTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onEnterScene(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onEnterScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapSceneBase* arg0;

        ok &= luaval_to_object<CMapSceneBase>(tolua_S, 2, "CMapSceneBase", &arg0, "CRoleBase:onEnterScene");
        if(!ok)
            return 0;
        cobj->onEnterScene(arg0);
        return 0;
    }

    gxError("CRoleBase:onEnterScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onEnterScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setQuitRet(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setQuitRet'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRoleBase:setQuitRet");
        if(!ok)
            return 0;
        cobj->setQuitRet(arg0);
        return 0;
    }

    gxError("CRoleBase:setQuitRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setQuitRet'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getStatus(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getStatus'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getStatus();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getStatus has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getStatus'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setDbIndex(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setDbIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleBase:setDbIndex");
        if(!ok)
            return 0;
        cobj->setDbIndex(arg0);
        return 0;
    }

    gxError("CRoleBase:setDbIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setDbIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getLogoutLastTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getLogoutLastTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getLogoutLastTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getLogoutLastTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getLogoutLastTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onAddToLogout(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onAddToLogout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onAddToLogout();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:onAddToLogout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onAddToLogout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getIPAddress(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getIPAddress'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getIPAddress();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CRoleBase:getIPAddress has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getIPAddress'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onLogout(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onLogout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onLogout();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:onLogout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onLogout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_isTimeOutForReady(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_isTimeOutForReady'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isTimeOutForReady();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:isTimeOutForReady has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_isTimeOutForReady'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getKey3(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getKey3'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getKey3();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CRoleBase:getKey3 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getKey3'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getKey2(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getKey2'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getKey2();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getKey2 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getKey2'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_on12Timer(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_on12Timer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->on12Timer();
        return 0;
    }

    gxError("CRoleBase:on12Timer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_on12Timer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onRemoveFromReady(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onRemoveFromReady'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onRemoveFromReady();
        return 0;
    }

    gxError("CRoleBase:onRemoveFromReady has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onRemoveFromReady'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getKey();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CRoleBase:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_addRoleToLogout(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_addRoleToLogout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->addRoleToLogout();
        return 0;
    }
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleBase:addRoleToLogout");
        if(!ok)
            return 0;
        cobj->addRoleToLogout(arg0);
        return 0;
    }

    gxError("CRoleBase:addRoleToLogout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_addRoleToLogout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_isLogout(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_isLogout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isLogout();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:isLogout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_isLogout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onEnter(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onEnter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onEnter();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:onEnter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onEnter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getAccountID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CRoleBase:getAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CRoleBase:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getLastSaveTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getLastSaveTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastSaveTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getLastSaveTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getLastSaveTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_on0Timer(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_on0Timer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->on0Timer();
        return 0;
    }

    gxError("CRoleBase:on0Timer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_on0Timer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CRoleBase:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_isCanViewMe(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_isCanViewMe'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const CGameObject* arg0;

        ok &= luaval_to_object<const CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CRoleBase:isCanViewMe");
        if(!ok)
            return 0;
        bool ret = cobj->isCanViewMe(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:isCanViewMe has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_isCanViewMe'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setRoleName(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setRoleName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CRoleBase:setRoleName");
        if(!ok)
            return 0;
        cobj->setRoleName(arg0);
        return 0;
    }

    gxError("CRoleBase:setRoleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setRoleName'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setStatus(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setStatus'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ERoleStatus arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleBase:setStatus");
        if(!ok)
            return 0;
        cobj->setStatus(arg0);
        return 0;
    }

    gxError("CRoleBase:setStatus has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setStatus'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getLogoutTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getLogoutTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLogoutTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getLogoutTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getLogoutTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setSceneGroupID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setSceneGroupID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleBase:setSceneGroupID");
        if(!ok)
            return 0;
        cobj->setSceneGroupID(arg0);
        return 0;
    }

    gxError("CRoleBase:setSceneGroupID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setSceneGroupID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_quitGame(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_quitGame'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->quitGame();
        return 0;
    }

    gxError("CRoleBase:quitGame has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_quitGame'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_quit(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_quit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        bool arg0;
        const char* arg1;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRoleBase:quit");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CRoleBase:quit"); arg1 = (char*)arg1_tmp.buffer;
        if(!ok)
            return 0;
        cobj->quit(arg0, arg1);
        return 0;
    }
    if (argc == 3) 
    {
        bool arg0;
        const char* arg1;
        int arg2;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRoleBase:quit");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CRoleBase:quit"); arg1 = (char*)arg1_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CRoleBase:quit");
        if(!ok)
            return 0;
        cobj->quit(arg0, arg1, arg2);
        return 0;
    }

    gxError("CRoleBase:quit has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_quit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setManagerQueType(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setManagerQueType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EManagerQueType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleBase:setManagerQueType");
        if(!ok)
            return 0;
        cobj->setManagerQueType(arg0);
        return 0;
    }

    gxError("CRoleBase:setManagerQueType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setManagerQueType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onLogoutTimeout(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onLogoutTimeout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onLogoutTimeout();
        return 0;
    }

    gxError("CRoleBase:onLogoutTimeout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onLogoutTimeout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getDbHandlerTag(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getDbHandlerTag'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getDbHandlerTag();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getDbHandlerTag has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getDbHandlerTag'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setLoginPlayerSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setLoginPlayerSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleBase:setLoginPlayerSocketIndex");
        if(!ok)
            return 0;
        cobj->setLoginPlayerSocketIndex(arg0);
        return 0;
    }

    gxError("CRoleBase:setLoginPlayerSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setLoginPlayerSocketIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onUpdateEnterQue(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onUpdateEnterQue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleBase:onUpdateEnterQue");
        if(!ok)
            return 0;
        cobj->onUpdateEnterQue(arg0);
        return 0;
    }

    gxError("CRoleBase:onUpdateEnterQue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onUpdateEnterQue'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getIsOffOverDay(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getIsOffOverDay'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getIsOffOverDay();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:getIsOffOverDay has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getIsOffOverDay'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onIdle(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onIdle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onIdle();
        return 0;
    }

    gxError("CRoleBase:onIdle has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onIdle'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getRoleUIDString(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getRoleUIDString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getRoleUIDString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CRoleBase:getRoleUIDString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getRoleUIDString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setLogoutLastTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setLogoutLastTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleBase:setLogoutLastTime");
        if(!ok)
            return 0;
        cobj->setLogoutLastTime(arg0);
        return 0;
    }

    gxError("CRoleBase:setLogoutLastTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setLogoutLastTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getSocketIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CRoleBase:getSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getSocketIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_directKick(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_directKick'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        bool arg0;
        bool arg1;
        bool arg2;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRoleBase:directKick");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleBase:directKick");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CRoleBase:directKick");
        if(!ok)
            return 0;
        cobj->directKick(arg0, arg1, arg2);
        return 0;
    }
    if (argc == 4) 
    {
        bool arg0;
        bool arg1;
        bool arg2;
        EKickType arg3;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRoleBase:directKick");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleBase:directKick");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CRoleBase:directKick");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CRoleBase:directKick");
        if(!ok)
            return 0;
        cobj->directKick(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CRoleBase:directKick has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_directKick'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onRename(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onRename'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EGameRetCode arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleBase:onRename");
        if(!ok)
            return 0;
        cobj->onRename(arg0);
        return 0;
    }

    gxError("CRoleBase:onRename has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onRename'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setLastSaveTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setLastSaveTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleBase:setLastSaveTime");
        if(!ok)
            return 0;
        cobj->setLastSaveTime(arg0);
        return 0;
    }

    gxError("CRoleBase:setLastSaveTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setLastSaveTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getEnterGameTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getEnterGameTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getEnterGameTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getEnterGameTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getEnterGameTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getGroupID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getGroupID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getGroupID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getGroupID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getGroupID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getSceneGroupID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getSceneGroupID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getSceneGroupID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getSceneGroupID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getSceneGroupID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setLogoutTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setLogoutTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleBase:setLogoutTime");
        if(!ok)
            return 0;
        cobj->setLogoutTime(arg0);
        return 0;
    }

    gxError("CRoleBase:setLogoutTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setLogoutTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_updateOutBlock(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_updateOutBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleBase:updateOutBlock");
        if(!ok)
            return 0;
        bool ret = cobj->updateOutBlock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:updateOutBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_updateOutBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getRoleUID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CRoleBase:getRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_isKey3(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_isKey3'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey3();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:isKey3 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_isKey3'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleBase:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CRoleBase:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleBase:setSocketIndex");
        if(!ok)
            return 0;
        cobj->setSocketIndex(arg0);
        return 0;
    }

    gxError("CRoleBase:setSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setSocketIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_addRoleToReady(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_addRoleToReady'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->addRoleToReady();
        return 0;
    }

    gxError("CRoleBase:addRoleToReady has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_addRoleToReady'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getManagerQueType(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getManagerQueType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getManagerQueType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleBase:getManagerQueType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getManagerQueType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setLoginLastTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setLoginLastTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleBase:setLoginLastTime");
        if(!ok)
            return 0;
        cobj->setLoginLastTime(arg0);
        return 0;
    }

    gxError("CRoleBase:setLoginLastTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setLoginLastTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_update(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleBase:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setIsAdult(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setIsAdult'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRoleBase:setIsAdult");
        if(!ok)
            return 0;
        cobj->setIsAdult(arg0);
        return 0;
    }

    gxError("CRoleBase:setIsAdult has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setIsAdult'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setUpdateSaveDirty(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setUpdateSaveDirty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRoleBase:setUpdateSaveDirty");
        if(!ok)
            return 0;
        cobj->setUpdateSaveDirty(arg0);
        return 0;
    }

    gxError("CRoleBase:setUpdateSaveDirty has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setUpdateSaveDirty'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_setLoginTime(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_setLoginTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleBase:setLoginTime");
        if(!ok)
            return 0;
        cobj->setLoginTime(arg0);
        return 0;
    }

    gxError("CRoleBase:setLoginTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_setLoginTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_isTimeOutForLogout(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_isTimeOutForLogout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isTimeOutForLogout();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleBase:isTimeOutForLogout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_isTimeOutForLogout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_getRoleNode(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_getRoleNode'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        _ObjListNode* ret = cobj->getRoleNode();
        object_to_luaval<_ObjListNode>(tolua_S, "_ObjListNode",(_ObjListNode*)ret);
        return 1;
    }

    gxError("CRoleBase:getRoleNode has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_getRoleNode'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onRemoveFromLogout(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onRemoveFromLogout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onRemoveFromLogout();
        return 0;
    }

    gxError("CRoleBase:onRemoveFromLogout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onRemoveFromLogout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleBase_onLoginTimeout(lua_State* tolua_S)
{
    int argc = 0;
    CRoleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleBase_onLoginTimeout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onLoginTimeout();
        return 0;
    }

    gxError("CRoleBase:onLoginTimeout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleBase_onLoginTimeout'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CRoleBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CRoleBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CRoleBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CRoleBase* self = (CRoleBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CRoleBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CRoleBase");
    tolua_cclass(tolua_S,"CRoleBase","CRoleBase","CCharacterObject",nullptr);

    tolua_beginmodule(tolua_S,"CRoleBase");
        tolua_function(tolua_S,"isReady",lua_mapserver_CRoleBase_isReady);
        tolua_function(tolua_S,"onUpdateLogoutQue",lua_mapserver_CRoleBase_onUpdateLogoutQue);
        tolua_function(tolua_S,"setAccountID",lua_mapserver_CRoleBase_setAccountID);
        tolua_function(tolua_S,"getLoginLastTime",lua_mapserver_CRoleBase_getLoginLastTime);
        tolua_function(tolua_S,"isEnter",lua_mapserver_CRoleBase_isEnter);
        tolua_function(tolua_S,"getIsAdult",lua_mapserver_CRoleBase_getIsAdult);
        tolua_function(tolua_S,"getLoginTime",lua_mapserver_CRoleBase_getLoginTime);
        tolua_function(tolua_S,"onUpdateReadyQue",lua_mapserver_CRoleBase_onUpdateReadyQue);
        tolua_function(tolua_S,"key3ToString",lua_mapserver_CRoleBase_key3ToString);
        tolua_function(tolua_S,"setEnterGameTime",lua_mapserver_CRoleBase_setEnterGameTime);
        tolua_function(tolua_S,"onLeaveScene",lua_mapserver_CRoleBase_onLeaveScene);
        tolua_function(tolua_S,"setLastAgainstIndulgeTime",lua_mapserver_CRoleBase_setLastAgainstIndulgeTime);
        tolua_function(tolua_S,"init",lua_mapserver_CRoleBase_init);
        tolua_function(tolua_S,"isKey2",lua_mapserver_CRoleBase_isKey2);
        tolua_function(tolua_S,"getQuitRet",lua_mapserver_CRoleBase_getQuitRet);
        tolua_function(tolua_S,"resetLogoutTime",lua_mapserver_CRoleBase_resetLogoutTime);
        tolua_function(tolua_S,"setIPAddress",lua_mapserver_CRoleBase_setIPAddress);
        tolua_function(tolua_S,"setRoleUID",lua_mapserver_CRoleBase_setRoleUID);
        tolua_function(tolua_S,"getLastAgainstIndulgeNoticeTime",lua_mapserver_CRoleBase_getLastAgainstIndulgeNoticeTime);
        tolua_function(tolua_S,"setIsOffOverDay",lua_mapserver_CRoleBase_setIsOffOverDay);
        tolua_function(tolua_S,"onAddToEnter",lua_mapserver_CRoleBase_onAddToEnter);
        tolua_function(tolua_S,"getDbHandlerBase",lua_mapserver_CRoleBase_getDbHandlerBase);
        tolua_function(tolua_S,"getDbIndex",lua_mapserver_CRoleBase_getDbIndex);
        tolua_function(tolua_S,"onHourTimer",lua_mapserver_CRoleBase_onHourTimer);
        tolua_function(tolua_S,"key2ToString",lua_mapserver_CRoleBase_key2ToString);
        tolua_function(tolua_S,"getLoginPlayerSocketIndex",lua_mapserver_CRoleBase_getLoginPlayerSocketIndex);
        tolua_function(tolua_S,"onRemoveFromEnter",lua_mapserver_CRoleBase_onRemoveFromEnter);
        tolua_function(tolua_S,"setKey3",lua_mapserver_CRoleBase_setKey3);
        tolua_function(tolua_S,"onAddToReady",lua_mapserver_CRoleBase_onAddToReady);
        tolua_function(tolua_S,"setDbSaveIndex",lua_mapserver_CRoleBase_setDbSaveIndex);
        tolua_function(tolua_S,"waitReconnect",lua_mapserver_CRoleBase_waitReconnect);
        tolua_function(tolua_S,"getGmPower",lua_mapserver_CRoleBase_getGmPower);
        tolua_function(tolua_S,"setGmPower",lua_mapserver_CRoleBase_setGmPower);
        tolua_function(tolua_S,"setKey2",lua_mapserver_CRoleBase_setKey2);
        tolua_function(tolua_S,"setLastAgainstIndulgeNoticeTime",lua_mapserver_CRoleBase_setLastAgainstIndulgeNoticeTime);
        tolua_function(tolua_S,"getUpdateSaveDirty",lua_mapserver_CRoleBase_getUpdateSaveDirty);
        tolua_function(tolua_S,"getPlayerHandlerBase",lua_mapserver_CRoleBase_getPlayerHandlerBase);
        tolua_function(tolua_S,"getDbSaveIndex",lua_mapserver_CRoleBase_getDbSaveIndex);
        tolua_function(tolua_S,"getLastAgainstIndulgeTime",lua_mapserver_CRoleBase_getLastAgainstIndulgeTime);
        tolua_function(tolua_S,"onEnterScene",lua_mapserver_CRoleBase_onEnterScene);
        tolua_function(tolua_S,"setQuitRet",lua_mapserver_CRoleBase_setQuitRet);
        tolua_function(tolua_S,"getStatus",lua_mapserver_CRoleBase_getStatus);
        tolua_function(tolua_S,"setDbIndex",lua_mapserver_CRoleBase_setDbIndex);
        tolua_function(tolua_S,"getLogoutLastTime",lua_mapserver_CRoleBase_getLogoutLastTime);
        tolua_function(tolua_S,"onAddToLogout",lua_mapserver_CRoleBase_onAddToLogout);
        tolua_function(tolua_S,"getIPAddress",lua_mapserver_CRoleBase_getIPAddress);
        tolua_function(tolua_S,"onLogout",lua_mapserver_CRoleBase_onLogout);
        tolua_function(tolua_S,"isTimeOutForReady",lua_mapserver_CRoleBase_isTimeOutForReady);
        tolua_function(tolua_S,"getKey3",lua_mapserver_CRoleBase_getKey3);
        tolua_function(tolua_S,"getKey2",lua_mapserver_CRoleBase_getKey2);
        tolua_function(tolua_S,"on12Timer",lua_mapserver_CRoleBase_on12Timer);
        tolua_function(tolua_S,"onRemoveFromReady",lua_mapserver_CRoleBase_onRemoveFromReady);
        tolua_function(tolua_S,"getKey",lua_mapserver_CRoleBase_getKey);
        tolua_function(tolua_S,"addRoleToLogout",lua_mapserver_CRoleBase_addRoleToLogout);
        tolua_function(tolua_S,"isLogout",lua_mapserver_CRoleBase_isLogout);
        tolua_function(tolua_S,"onEnter",lua_mapserver_CRoleBase_onEnter);
        tolua_function(tolua_S,"getAccountID",lua_mapserver_CRoleBase_getAccountID);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CRoleBase_keyToString);
        tolua_function(tolua_S,"getLastSaveTime",lua_mapserver_CRoleBase_getLastSaveTime);
        tolua_function(tolua_S,"on0Timer",lua_mapserver_CRoleBase_on0Timer);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CRoleBase_cleanUp);
        tolua_function(tolua_S,"isCanViewMe",lua_mapserver_CRoleBase_isCanViewMe);
        tolua_function(tolua_S,"setRoleName",lua_mapserver_CRoleBase_setRoleName);
        tolua_function(tolua_S,"setStatus",lua_mapserver_CRoleBase_setStatus);
        tolua_function(tolua_S,"getLogoutTime",lua_mapserver_CRoleBase_getLogoutTime);
        tolua_function(tolua_S,"setSceneGroupID",lua_mapserver_CRoleBase_setSceneGroupID);
        tolua_function(tolua_S,"quitGame",lua_mapserver_CRoleBase_quitGame);
        tolua_function(tolua_S,"quit",lua_mapserver_CRoleBase_quit);
        tolua_function(tolua_S,"setManagerQueType",lua_mapserver_CRoleBase_setManagerQueType);
        tolua_function(tolua_S,"onLogoutTimeout",lua_mapserver_CRoleBase_onLogoutTimeout);
        tolua_function(tolua_S,"getDbHandlerTag",lua_mapserver_CRoleBase_getDbHandlerTag);
        tolua_function(tolua_S,"setLoginPlayerSocketIndex",lua_mapserver_CRoleBase_setLoginPlayerSocketIndex);
        tolua_function(tolua_S,"onUpdateEnterQue",lua_mapserver_CRoleBase_onUpdateEnterQue);
        tolua_function(tolua_S,"getIsOffOverDay",lua_mapserver_CRoleBase_getIsOffOverDay);
        tolua_function(tolua_S,"onIdle",lua_mapserver_CRoleBase_onIdle);
        tolua_function(tolua_S,"getRoleUIDString",lua_mapserver_CRoleBase_getRoleUIDString);
        tolua_function(tolua_S,"setLogoutLastTime",lua_mapserver_CRoleBase_setLogoutLastTime);
        tolua_function(tolua_S,"getSocketIndex",lua_mapserver_CRoleBase_getSocketIndex);
        tolua_function(tolua_S,"directKick",lua_mapserver_CRoleBase_directKick);
        tolua_function(tolua_S,"onRename",lua_mapserver_CRoleBase_onRename);
        tolua_function(tolua_S,"setLastSaveTime",lua_mapserver_CRoleBase_setLastSaveTime);
        tolua_function(tolua_S,"isKey",lua_mapserver_CRoleBase_isKey);
        tolua_function(tolua_S,"getEnterGameTime",lua_mapserver_CRoleBase_getEnterGameTime);
        tolua_function(tolua_S,"getGroupID",lua_mapserver_CRoleBase_getGroupID);
        tolua_function(tolua_S,"getSceneGroupID",lua_mapserver_CRoleBase_getSceneGroupID);
        tolua_function(tolua_S,"setLogoutTime",lua_mapserver_CRoleBase_setLogoutTime);
        tolua_function(tolua_S,"updateOutBlock",lua_mapserver_CRoleBase_updateOutBlock);
        tolua_function(tolua_S,"getRoleUID",lua_mapserver_CRoleBase_getRoleUID);
        tolua_function(tolua_S,"isKey3",lua_mapserver_CRoleBase_isKey3);
        tolua_function(tolua_S,"setKey",lua_mapserver_CRoleBase_setKey);
        tolua_function(tolua_S,"setSocketIndex",lua_mapserver_CRoleBase_setSocketIndex);
        tolua_function(tolua_S,"addRoleToReady",lua_mapserver_CRoleBase_addRoleToReady);
        tolua_function(tolua_S,"getManagerQueType",lua_mapserver_CRoleBase_getManagerQueType);
        tolua_function(tolua_S,"setLoginLastTime",lua_mapserver_CRoleBase_setLoginLastTime);
        tolua_function(tolua_S,"update",lua_mapserver_CRoleBase_update);
        tolua_function(tolua_S,"setIsAdult",lua_mapserver_CRoleBase_setIsAdult);
        tolua_function(tolua_S,"setUpdateSaveDirty",lua_mapserver_CRoleBase_setUpdateSaveDirty);
        tolua_function(tolua_S,"setLoginTime",lua_mapserver_CRoleBase_setLoginTime);
        tolua_function(tolua_S,"isTimeOutForLogout",lua_mapserver_CRoleBase_isTimeOutForLogout);
        tolua_function(tolua_S,"getRoleNode",lua_mapserver_CRoleBase_getRoleNode);
        tolua_function(tolua_S,"onRemoveFromLogout",lua_mapserver_CRoleBase_onRemoveFromLogout);
        tolua_function(tolua_S,"onLoginTimeout",lua_mapserver_CRoleBase_onLoginTimeout);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CRoleBase).name();
    g_luaType[typeName] = "CRoleBase";
    g_typeCast["CRoleBase"] = "CRoleBase";
    return 1;
}

int lua_mapserver_CDBLoadBase_getLock(lua_State* tolua_S)
{
    int argc = 0;
    CDBLoadBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDBLoadBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDBLoadBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDBLoadBase_getLock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getLock();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDBLoadBase:getLock has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDBLoadBase_getLock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDBLoadBase_setLock(lua_State* tolua_S)
{
    int argc = 0;
    CDBLoadBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDBLoadBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDBLoadBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDBLoadBase_setLock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CDBLoadBase:setLock");
        if(!ok)
            return 0;
        bool ret = cobj->setLock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDBLoadBase:setLock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDBLoadBase_setLock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDBLoadBase_getRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CDBLoadBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDBLoadBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDBLoadBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDBLoadBase_getRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getRoleUID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CDBLoadBase:getRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDBLoadBase_getRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDBLoadBase_init(lua_State* tolua_S)
{
    int argc = 0;
    CDBLoadBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDBLoadBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDBLoadBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDBLoadBase_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned long long arg0;
        CHumanDB* arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CDBLoadBase:init");

        ok &= luaval_to_object<CHumanDB>(tolua_S, 3, "CHumanDB", &arg1, "CDBLoadBase:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDBLoadBase:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDBLoadBase_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CDBLoadBase_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CDBLoadBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDBLoadBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CDBLoadBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CDBLoadBase_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CDBLoadBase:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CDBLoadBase_cleanUp'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CDBLoadBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDBLoadBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDBLoadBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CDBLoadBase* self = (CDBLoadBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CDBLoadBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDBLoadBase");
    tolua_cclass(tolua_S,"CDBLoadBase","CDBLoadBase","",nullptr);

    tolua_beginmodule(tolua_S,"CDBLoadBase");
        tolua_function(tolua_S,"getLock",lua_mapserver_CDBLoadBase_getLock);
        tolua_function(tolua_S,"setLock",lua_mapserver_CDBLoadBase_setLock);
        tolua_function(tolua_S,"getRoleUID",lua_mapserver_CDBLoadBase_getRoleUID);
        tolua_function(tolua_S,"init",lua_mapserver_CDBLoadBase_init);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CDBLoadBase_cleanUp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CDBLoadBase).name();
    g_luaType[typeName] = "CDBLoadBase";
    g_typeCast["CDBLoadBase"] = "CDBLoadBase";
    return 1;
}

int lua_mapserver_MissionParam_setNParam(lua_State* tolua_S)
{
    int argc = 0;
    MissionParam* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionParam",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionParam*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionParam_setNParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "MissionParam:setNParam");
        if(!ok)
            return 0;
        cobj->setNParam(arg0);
        return 0;
    }

    gxError("MissionParam:setNParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionParam_setNParam'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionParam_setNMaxParam(lua_State* tolua_S)
{
    int argc = 0;
    MissionParam* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionParam",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionParam*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionParam_setNMaxParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "MissionParam:setNMaxParam");
        if(!ok)
            return 0;
        cobj->setNMaxParam(arg0);
        return 0;
    }

    gxError("MissionParam:setNMaxParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionParam_setNMaxParam'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionParam_getNParam(lua_State* tolua_S)
{
    int argc = 0;
    MissionParam* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionParam",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionParam*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionParam_getNParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getNParam();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MissionParam:getNParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionParam_getNParam'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionParam_isMaxParam(lua_State* tolua_S)
{
    int argc = 0;
    MissionParam* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionParam",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionParam*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionParam_isMaxParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isMaxParam();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("MissionParam:isMaxParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionParam_isMaxParam'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionParam_getNMaxParam(lua_State* tolua_S)
{
    int argc = 0;
    MissionParam* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionParam",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionParam*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionParam_getNMaxParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getNMaxParam();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MissionParam:getNMaxParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionParam_getNMaxParam'.",&tolua_err);
	return 0;
}
static int lua_mapserver_MissionParam_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MissionParam)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MissionParam",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MissionParam* self = (MissionParam*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MissionParam(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MissionParam");
    tolua_cclass(tolua_S,"MissionParam","MissionParam","",nullptr);

    tolua_beginmodule(tolua_S,"MissionParam");
        tolua_function(tolua_S,"setNParam",lua_mapserver_MissionParam_setNParam);
        tolua_function(tolua_S,"setNMaxParam",lua_mapserver_MissionParam_setNMaxParam);
        tolua_function(tolua_S,"getNParam",lua_mapserver_MissionParam_getNParam);
        tolua_function(tolua_S,"isMaxParam",lua_mapserver_MissionParam_isMaxParam);
        tolua_function(tolua_S,"getNMaxParam",lua_mapserver_MissionParam_getNMaxParam);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MissionParam).name();
    g_luaType[typeName] = "MissionParam";
    g_typeCast["MissionParam"] = "MissionParam";
    return 1;
}

int lua_mapserver_MissionBase_isDialog(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_isDialog'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDialog();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("MissionBase:isDialog has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_isDialog'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_getEventTypeStr(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_getEventTypeStr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EMissionEvent arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "MissionBase:getEventTypeStr");
        if(!ok)
            return 0;
        std::string ret = cobj->getEventTypeStr(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("MissionBase:getEventTypeStr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_getEventTypeStr'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_isCollectItem(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_isCollectItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCollectItem();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("MissionBase:isCollectItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_isCollectItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_isEvent(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_isEvent'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EMissionEvent arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "MissionBase:isEvent");
        if(!ok)
            return 0;
        bool ret = cobj->isEvent(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("MissionBase:isEvent has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_isEvent'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_getEventType(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_getEventType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getEventType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MissionBase:getEventType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_getEventType'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_isGuanQia(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_isGuanQia'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isGuanQia();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("MissionBase:isGuanQia has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_isGuanQia'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_getStatus(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_getStatus'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getStatus();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MissionBase:getStatus has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_getStatus'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_setEventType(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_setEventType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EMissionEvent arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "MissionBase:setEventType");
        if(!ok)
            return 0;
        cobj->setEventType(arg0);
        return 0;
    }

    gxError("MissionBase:setEventType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_setEventType'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_setMissionID(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_setMissionID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "MissionBase:setMissionID");
        if(!ok)
            return 0;
        cobj->setMissionID(arg0);
        return 0;
    }

    gxError("MissionBase:setMissionID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_setMissionID'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_isActiveMission(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_isActiveMission'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isActiveMission();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("MissionBase:isActiveMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_isActiveMission'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_setStatus(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_setStatus'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EMissionStatus arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "MissionBase:setStatus");
        if(!ok)
            return 0;
        cobj->setStatus(arg0);
        return 0;
    }

    gxError("MissionBase:setStatus has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_setStatus'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_getAcceptLevel(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_getAcceptLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getAcceptLevel();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MissionBase:getAcceptLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_getAcceptLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_getMissionID(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_getMissionID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getMissionID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MissionBase:getMissionID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_getMissionID'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("MissionBase:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_setAcceptLevel(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_setAcceptLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "MissionBase:setAcceptLevel");
        if(!ok)
            return 0;
        cobj->setAcceptLevel(arg0);
        return 0;
    }

    gxError("MissionBase:setAcceptLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_setAcceptLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_setAcceptTime(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_setAcceptTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "MissionBase:setAcceptTime");
        if(!ok)
            return 0;
        cobj->setAcceptTime(arg0);
        return 0;
    }

    gxError("MissionBase:setAcceptTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_setAcceptTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_isKillMonster(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_isKillMonster'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKillMonster();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("MissionBase:isKillMonster has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_isKillMonster'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_toString(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("MissionBase:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_getAcceptTime(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (MissionBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MissionBase_getAcceptTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getAcceptTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MissionBase:getAcceptTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MissionBase_getAcceptTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_MissionBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MissionBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MissionBase();
        tolua_pushusertype(tolua_S,(void*)cobj,"MissionBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MissionBase:MissionBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MissionBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MissionBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MissionBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MissionBase* self = (MissionBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MissionBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MissionBase");
    tolua_cclass(tolua_S,"MissionBase","MissionBase","",lua_mapserver_MissionBase_finalize);

    tolua_beginmodule(tolua_S,"MissionBase");
        tolua_function(tolua_S,"new",lua_mapserver_MissionBase_constructor);
        tolua_function(tolua_S,"isDialog",lua_mapserver_MissionBase_isDialog);
        tolua_function(tolua_S,"getEventTypeStr",lua_mapserver_MissionBase_getEventTypeStr);
        tolua_function(tolua_S,"isCollectItem",lua_mapserver_MissionBase_isCollectItem);
        tolua_function(tolua_S,"isEvent",lua_mapserver_MissionBase_isEvent);
        tolua_function(tolua_S,"getEventType",lua_mapserver_MissionBase_getEventType);
        tolua_function(tolua_S,"isGuanQia",lua_mapserver_MissionBase_isGuanQia);
        tolua_function(tolua_S,"getStatus",lua_mapserver_MissionBase_getStatus);
        tolua_function(tolua_S,"setEventType",lua_mapserver_MissionBase_setEventType);
        tolua_function(tolua_S,"setMissionID",lua_mapserver_MissionBase_setMissionID);
        tolua_function(tolua_S,"isActiveMission",lua_mapserver_MissionBase_isActiveMission);
        tolua_function(tolua_S,"setStatus",lua_mapserver_MissionBase_setStatus);
        tolua_function(tolua_S,"getAcceptLevel",lua_mapserver_MissionBase_getAcceptLevel);
        tolua_function(tolua_S,"getMissionID",lua_mapserver_MissionBase_getMissionID);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_MissionBase_cleanUp);
        tolua_function(tolua_S,"setAcceptLevel",lua_mapserver_MissionBase_setAcceptLevel);
        tolua_function(tolua_S,"setAcceptTime",lua_mapserver_MissionBase_setAcceptTime);
        tolua_function(tolua_S,"isKillMonster",lua_mapserver_MissionBase_isKillMonster);
        tolua_function(tolua_S,"toString",lua_mapserver_MissionBase_toString);
        tolua_function(tolua_S,"getAcceptTime",lua_mapserver_MissionBase_getAcceptTime);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MissionBase).name();
    g_luaType[typeName] = "MissionBase";
    g_typeCast["MissionBase"] = "MissionBase";
    return 1;
}

int lua_mapserver_PackMission_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    PackMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"PackMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (PackMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_PackMission_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("PackMission:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_PackMission_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_PackMission_constructor(lua_State* tolua_S)
{
    int argc = 0;
    PackMission* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new PackMission();
        tolua_pushusertype(tolua_S,(void*)cobj,"PackMission");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("PackMission:PackMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_PackMission_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PackMission)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PackMission",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PackMission* self = (PackMission*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PackMission(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PackMission");
    tolua_cclass(tolua_S,"PackMission","PackMission","IStreamableAll",lua_mapserver_PackMission_finalize);

    tolua_beginmodule(tolua_S,"PackMission");
        tolua_function(tolua_S,"new",lua_mapserver_PackMission_constructor);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_PackMission_cleanUp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PackMission).name();
    g_luaType[typeName] = "PackMission";
    g_typeCast["PackMission"] = "PackMission";
    return 1;
}

int lua_mapserver_PackMissionParams_constructor(lua_State* tolua_S)
{
    int argc = 0;
    PackMissionParams* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "PackMissionParams:PackMissionParams");

            if (!ok) { break; }
            CArray1<MissionParam, 5>* arg1;
            ok &= luaval_to_object<CArray1<MissionParam, 5>>(tolua_S, 3, "CArray1<MissionParam, 5>", &arg1, "PackMissionParams:PackMissionParams");

            if (!ok) { break; }
            cobj = new PackMissionParams(arg0, arg1);
            tolua_pushusertype(tolua_S,(void*)cobj,"PackMissionParams");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new PackMissionParams();
            tolua_pushusertype(tolua_S,(void*)cobj,"PackMissionParams");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("PackMissionParams:PackMissionParams has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_PackMissionParams_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (PackMissionParams)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"PackMissionParams",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        PackMissionParams* self = (PackMissionParams*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_PackMissionParams(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"PackMissionParams");
    tolua_cclass(tolua_S,"PackMissionParams","PackMissionParams","IStreamableAll",lua_mapserver_PackMissionParams_finalize);

    tolua_beginmodule(tolua_S,"PackMissionParams");
        tolua_function(tolua_S,"new",lua_mapserver_PackMissionParams_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(PackMissionParams).name();
    g_luaType[typeName] = "PackMissionParams";
    g_typeCast["PackMissionParams"] = "PackMissionParams";
    return 1;
}

static int lua_mapserver_DBAcceptMission_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (DBAcceptMission)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"DBAcceptMission",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        DBAcceptMission* self = (DBAcceptMission*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_DBAcceptMission(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"DBAcceptMission");
    tolua_cclass(tolua_S,"DBAcceptMission","DBAcceptMission","TDBStructBase",nullptr);

    tolua_beginmodule(tolua_S,"DBAcceptMission");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(DBAcceptMission).name();
    g_luaType[typeName] = "DBAcceptMission";
    g_typeCast["DBAcceptMission"] = "DBAcceptMission";
    return 1;
}

static int lua_mapserver_DBFinishMissionBit_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (DBFinishMissionBit)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"DBFinishMissionBit",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        DBFinishMissionBit* self = (DBFinishMissionBit*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_DBFinishMissionBit(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"DBFinishMissionBit");
    tolua_cclass(tolua_S,"DBFinishMissionBit","DBFinishMissionBit","TDBStructBase",nullptr);

    tolua_beginmodule(tolua_S,"DBFinishMissionBit");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(DBFinishMissionBit).name();
    g_luaType[typeName] = "DBFinishMissionBit";
    g_typeCast["DBFinishMissionBit"] = "DBFinishMissionBit";
    return 1;
}

static int lua_mapserver_CHumanMissionData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CHumanMissionData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CHumanMissionData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CHumanMissionData* self = (CHumanMissionData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CHumanMissionData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CHumanMissionData");
    tolua_cclass(tolua_S,"CHumanMissionData","CHumanMissionData","TDBStructBase",nullptr);

    tolua_beginmodule(tolua_S,"CHumanMissionData");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CHumanMissionData).name();
    g_luaType[typeName] = "CHumanMissionData";
    g_typeCast["CHumanMissionData"] = "CHumanMissionData";
    return 1;
}

int lua_mapserver_CHumanBaseData_setStrength(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setStrength'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CHumanBaseData:setStrength");
        if(!ok)
            return 0;
        cobj->setStrength(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setStrength has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setStrength'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setMapID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setMapID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CHumanBaseData:setMapID");
        if(!ok)
            return 0;
        cobj->setMapID(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setMapID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setMapID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getBindRmb(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getBindRmb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getBindRmb();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getBindRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getBindRmb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setbagOpenGridNum(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setbagOpenGridNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CHumanBaseData:setbagOpenGridNum");
        if(!ok)
            return 0;
        cobj->setbagOpenGridNum(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setbagOpenGridNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setbagOpenGridNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getCreateTime(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getCreateTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CGameTime ret = cobj->getCreateTime();
        tolua_pushnumber(tolua_S,(GXMISC::TGameTime_t)ret);
        return 1;
    }

    gxError("CHumanBaseData:getCreateTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getCreateTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getAccountID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CHumanBaseData:getAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getRmb(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getRmb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getRmb();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getRmb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setLogoutTime(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setLogoutTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CHumanBaseData:setLogoutTime");
        if(!ok)
            return 0;
        cobj->setLogoutTime(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setLogoutTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setLogoutTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getVipExp(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getVipExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getVipExp();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getVipExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getVipExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getStrength(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getStrength'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getStrength();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getStrength has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getStrength'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setGameMoney(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setGameMoney'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CHumanBaseData:setGameMoney");
        if(!ok)
            return 0;
        cobj->setGameMoney(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setGameMoney has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setGameMoney'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getbagOpenGridNum(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getbagOpenGridNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getbagOpenGridNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getbagOpenGridNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getbagOpenGridNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_isNewRole(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_isNewRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNewRole();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CHumanBaseData:isNewRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_isNewRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getGameMoney(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getGameMoney'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getGameMoney();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getGameMoney has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getGameMoney'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CHumanBaseData:setObjUID");
        if(!ok)
            return 0;
        cobj->setObjUID(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setLastSceneID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setLastSceneID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CHumanBaseData:setLastSceneID");
        if(!ok)
            return 0;
        cobj->setLastSceneID(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setLastSceneID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setLastSceneID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setLastMapPos(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setLastMapPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CHumanBaseData:setLastMapPos");
        if(!ok)
            return 0;
        cobj->setLastMapPos(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setLastMapPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setLastMapPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setRoleName(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setRoleName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CHumanBaseData:setRoleName");
        if(!ok)
            return 0;
        cobj->setRoleName(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setRoleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setRoleName'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getLogoutTime(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getLogoutTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLogoutTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getLogoutTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getLogoutTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CHumanBaseData:setAccountID");
        if(!ok)
            return 0;
        cobj->setAccountID(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getSource_way(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getSource_way'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getSource_way();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CHumanBaseData:getSource_way has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getSource_way'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setChisource_way(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setChisource_way'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CHumanBaseData:setChisource_way");
        if(!ok)
            return 0;
        cobj->setChisource_way(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setChisource_way has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setChisource_way'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getLastMapID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getLastMapID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getLastMapID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getLastMapID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getLastMapID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setSource_way(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setSource_way'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CHumanBaseData:setSource_way");
        if(!ok)
            return 0;
        cobj->setSource_way(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setSource_way has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setSource_way'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getOfflineOverunDays(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getOfflineOverunDays'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        char arg0;
        char arg1;
        char arg2;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CHumanBaseData:getOfflineOverunDays");

        ok &= luaval_to_sint8(tolua_S, 3,(sint8*)&arg1, "CHumanBaseData:getOfflineOverunDays");

        ok &= luaval_to_sint8(tolua_S, 4,(sint8*)&arg2, "CHumanBaseData:getOfflineOverunDays");
        if(!ok)
            return 0;
        int ret = cobj->getOfflineOverunDays(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getOfflineOverunDays has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getOfflineOverunDays'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getMapID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getMapID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getMapID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getMapID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getMapID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getLevel(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getLevel();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setMapPos(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setMapPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CHumanBaseData:setMapPos");
        if(!ok)
            return 0;
        cobj->setMapPos(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setMapPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setMapPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getRoleUID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CHumanBaseData:getRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getMapPos(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getMapPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const AxisPos* ret = cobj->getMapPos();
        object_to_luaval<AxisPos>(tolua_S, "AxisPos",(AxisPos*)ret);
        return 1;
    }

    gxError("CHumanBaseData:getMapPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getMapPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getLastMapPos(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getLastMapPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const AxisPos* ret = cobj->getLastMapPos();
        object_to_luaval<AxisPos>(tolua_S, "AxisPos",(AxisPos*)ret);
        return 1;
    }

    gxError("CHumanBaseData:getLastMapPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getLastMapPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getSceneID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getSceneID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getSceneID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CHumanBaseData:getSceneID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getSceneID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CHumanBaseData:setRoleUID");
        if(!ok)
            return 0;
        cobj->setRoleUID(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getLastSceneID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getLastSceneID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getLastSceneID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CHumanBaseData:getLastSceneID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getLastSceneID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setBindRmb(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setBindRmb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CHumanBaseData:setBindRmb");
        if(!ok)
            return 0;
        cobj->setBindRmb(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setBindRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setBindRmb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_addChargeRmb(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_addChargeRmb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CHumanBaseData:addChargeRmb");
        if(!ok)
            return 0;
        int ret = cobj->addChargeRmb(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:addChargeRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_addChargeRmb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setLastMapID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setLastMapID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CHumanBaseData:setLastMapID");
        if(!ok)
            return 0;
        cobj->setLastMapID(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setLastMapID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setLastMapID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setLevel(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CHumanBaseData:setLevel");
        if(!ok)
            return 0;
        cobj->setLevel(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getLoginCountOneDay(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getLoginCountOneDay'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getLoginCountOneDay();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getLoginCountOneDay has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getLoginCountOneDay'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getObjUID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setExp(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CHumanBaseData:setExp");
        if(!ok)
            return 0;
        cobj->setExp(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getChisource_way(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getChisource_way'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getChisource_way();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CHumanBaseData:getChisource_way has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getChisource_way'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setProtypeID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setProtypeID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CHumanBaseData:setProtypeID");
        if(!ok)
            return 0;
        cobj->setProtypeID(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setProtypeID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setProtypeID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getTotalChargeRmb(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getTotalChargeRmb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getTotalChargeRmb();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getTotalChargeRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getTotalChargeRmb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setVipLevel(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CHumanBaseData_setVipLevel'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CHumanBaseData:setVipLevel");

            if (!ok) { break; }
            cobj->setVipLevel(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            unsigned char arg0;
            ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CHumanBaseData:setVipLevel");

            if (!ok) { break; }
            cobj->setVipLevel(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CHumanBaseData:setVipLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setVipLevel'.",&tolua_err);
    return 0;
}
int lua_mapserver_CHumanBaseData_setSceneID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setSceneID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CHumanBaseData:setSceneID");
        if(!ok)
            return 0;
        cobj->setSceneID(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setSceneID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setSceneID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getExp(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getExp();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getRoleName(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getRoleName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getRoleName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CHumanBaseData:getRoleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getRoleName'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setRmb(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setRmb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CHumanBaseData:setRmb");
        if(!ok)
            return 0;
        cobj->setRmb(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setRmb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setCreateTime(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setCreateTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CGameTime arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(GXMISC::TGameTime_t*)&arg0, "CHumanBaseData:setCreateTime");
        if(!ok)
            return 0;
        cobj->setCreateTime(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setCreateTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setCreateTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getProtypeID(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getProtypeID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getProtypeID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getProtypeID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getProtypeID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setTotalChargeRmb(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setTotalChargeRmb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CHumanBaseData:setTotalChargeRmb");
        if(!ok)
            return 0;
        cobj->setTotalChargeRmb(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setTotalChargeRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setTotalChargeRmb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_setLoginCountOneDay(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_setLoginCountOneDay'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CHumanBaseData:setLoginCountOneDay");
        if(!ok)
            return 0;
        cobj->setLoginCountOneDay(arg0);
        return 0;
    }

    gxError("CHumanBaseData:setLoginCountOneDay has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_setLoginCountOneDay'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_getVipLevel(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanBaseData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanBaseData_getVipLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getVipLevel();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanBaseData:getVipLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanBaseData_getVipLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanBaseData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CHumanBaseData* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CHumanBaseData();
        tolua_pushusertype(tolua_S,(void*)cobj,"CHumanBaseData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CHumanBaseData:CHumanBaseData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CHumanBaseData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CHumanBaseData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CHumanBaseData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CHumanBaseData* self = (CHumanBaseData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CHumanBaseData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CHumanBaseData");
    tolua_cclass(tolua_S,"CHumanBaseData","CHumanBaseData","TDBStructBase",lua_mapserver_CHumanBaseData_finalize);

    tolua_beginmodule(tolua_S,"CHumanBaseData");
        tolua_function(tolua_S,"new",lua_mapserver_CHumanBaseData_constructor);
        tolua_function(tolua_S,"setStrength",lua_mapserver_CHumanBaseData_setStrength);
        tolua_function(tolua_S,"setMapID",lua_mapserver_CHumanBaseData_setMapID);
        tolua_function(tolua_S,"getBindRmb",lua_mapserver_CHumanBaseData_getBindRmb);
        tolua_function(tolua_S,"setbagOpenGridNum",lua_mapserver_CHumanBaseData_setbagOpenGridNum);
        tolua_function(tolua_S,"getCreateTime",lua_mapserver_CHumanBaseData_getCreateTime);
        tolua_function(tolua_S,"getAccountID",lua_mapserver_CHumanBaseData_getAccountID);
        tolua_function(tolua_S,"getRmb",lua_mapserver_CHumanBaseData_getRmb);
        tolua_function(tolua_S,"setLogoutTime",lua_mapserver_CHumanBaseData_setLogoutTime);
        tolua_function(tolua_S,"getVipExp",lua_mapserver_CHumanBaseData_getVipExp);
        tolua_function(tolua_S,"getStrength",lua_mapserver_CHumanBaseData_getStrength);
        tolua_function(tolua_S,"setGameMoney",lua_mapserver_CHumanBaseData_setGameMoney);
        tolua_function(tolua_S,"getbagOpenGridNum",lua_mapserver_CHumanBaseData_getbagOpenGridNum);
        tolua_function(tolua_S,"isNewRole",lua_mapserver_CHumanBaseData_isNewRole);
        tolua_function(tolua_S,"getGameMoney",lua_mapserver_CHumanBaseData_getGameMoney);
        tolua_function(tolua_S,"setObjUID",lua_mapserver_CHumanBaseData_setObjUID);
        tolua_function(tolua_S,"setLastSceneID",lua_mapserver_CHumanBaseData_setLastSceneID);
        tolua_function(tolua_S,"setLastMapPos",lua_mapserver_CHumanBaseData_setLastMapPos);
        tolua_function(tolua_S,"setRoleName",lua_mapserver_CHumanBaseData_setRoleName);
        tolua_function(tolua_S,"getLogoutTime",lua_mapserver_CHumanBaseData_getLogoutTime);
        tolua_function(tolua_S,"setAccountID",lua_mapserver_CHumanBaseData_setAccountID);
        tolua_function(tolua_S,"getSource_way",lua_mapserver_CHumanBaseData_getSource_way);
        tolua_function(tolua_S,"setChisource_way",lua_mapserver_CHumanBaseData_setChisource_way);
        tolua_function(tolua_S,"getLastMapID",lua_mapserver_CHumanBaseData_getLastMapID);
        tolua_function(tolua_S,"setSource_way",lua_mapserver_CHumanBaseData_setSource_way);
        tolua_function(tolua_S,"getOfflineOverunDays",lua_mapserver_CHumanBaseData_getOfflineOverunDays);
        tolua_function(tolua_S,"getMapID",lua_mapserver_CHumanBaseData_getMapID);
        tolua_function(tolua_S,"getLevel",lua_mapserver_CHumanBaseData_getLevel);
        tolua_function(tolua_S,"setMapPos",lua_mapserver_CHumanBaseData_setMapPos);
        tolua_function(tolua_S,"getRoleUID",lua_mapserver_CHumanBaseData_getRoleUID);
        tolua_function(tolua_S,"getMapPos",lua_mapserver_CHumanBaseData_getMapPos);
        tolua_function(tolua_S,"getLastMapPos",lua_mapserver_CHumanBaseData_getLastMapPos);
        tolua_function(tolua_S,"getSceneID",lua_mapserver_CHumanBaseData_getSceneID);
        tolua_function(tolua_S,"setRoleUID",lua_mapserver_CHumanBaseData_setRoleUID);
        tolua_function(tolua_S,"getLastSceneID",lua_mapserver_CHumanBaseData_getLastSceneID);
        tolua_function(tolua_S,"setBindRmb",lua_mapserver_CHumanBaseData_setBindRmb);
        tolua_function(tolua_S,"addChargeRmb",lua_mapserver_CHumanBaseData_addChargeRmb);
        tolua_function(tolua_S,"setLastMapID",lua_mapserver_CHumanBaseData_setLastMapID);
        tolua_function(tolua_S,"setLevel",lua_mapserver_CHumanBaseData_setLevel);
        tolua_function(tolua_S,"getLoginCountOneDay",lua_mapserver_CHumanBaseData_getLoginCountOneDay);
        tolua_function(tolua_S,"getObjUID",lua_mapserver_CHumanBaseData_getObjUID);
        tolua_function(tolua_S,"setExp",lua_mapserver_CHumanBaseData_setExp);
        tolua_function(tolua_S,"getChisource_way",lua_mapserver_CHumanBaseData_getChisource_way);
        tolua_function(tolua_S,"setProtypeID",lua_mapserver_CHumanBaseData_setProtypeID);
        tolua_function(tolua_S,"getTotalChargeRmb",lua_mapserver_CHumanBaseData_getTotalChargeRmb);
        tolua_function(tolua_S,"setVipLevel",lua_mapserver_CHumanBaseData_setVipLevel);
        tolua_function(tolua_S,"setSceneID",lua_mapserver_CHumanBaseData_setSceneID);
        tolua_function(tolua_S,"getExp",lua_mapserver_CHumanBaseData_getExp);
        tolua_function(tolua_S,"getRoleName",lua_mapserver_CHumanBaseData_getRoleName);
        tolua_function(tolua_S,"setRmb",lua_mapserver_CHumanBaseData_setRmb);
        tolua_function(tolua_S,"setCreateTime",lua_mapserver_CHumanBaseData_setCreateTime);
        tolua_function(tolua_S,"getProtypeID",lua_mapserver_CHumanBaseData_getProtypeID);
        tolua_function(tolua_S,"setTotalChargeRmb",lua_mapserver_CHumanBaseData_setTotalChargeRmb);
        tolua_function(tolua_S,"setLoginCountOneDay",lua_mapserver_CHumanBaseData_setLoginCountOneDay);
        tolua_function(tolua_S,"getVipLevel",lua_mapserver_CHumanBaseData_getVipLevel);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CHumanBaseData).name();
    g_luaType[typeName] = "CHumanBaseData";
    g_typeCast["CHumanBaseData"] = "CHumanBaseData";
    return 1;
}

int lua_mapserver_CHumanDBData_getUserData(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDBData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDBData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDBData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDBData_getUserData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CWorldUserData* arg0;

        ok &= luaval_to_object<CWorldUserData>(tolua_S, 2, "CWorldUserData", &arg0, "CHumanDBData:getUserData");
        if(!ok)
            return 0;
        cobj->getUserData(arg0);
        return 0;
    }

    gxError("CHumanDBData:getUserData has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDBData_getUserData'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CHumanDBData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CHumanDBData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CHumanDBData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CHumanDBData* self = (CHumanDBData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CHumanDBData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CHumanDBData");
    tolua_cclass(tolua_S,"CHumanDBData","CHumanDBData","TDBStructBase",nullptr);

    tolua_beginmodule(tolua_S,"CHumanDBData");
        tolua_function(tolua_S,"getUserData",lua_mapserver_CHumanDBData_getUserData);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CHumanDBData).name();
    g_luaType[typeName] = "CHumanDBData";
    g_typeCast["CHumanDBData"] = "CHumanDBData";
    return 1;
}

int lua_mapserver_CHumanDBMissionLoad_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDBMissionLoad* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDBMissionLoad",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDBMissionLoad*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDBMissionLoad_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CHumanDBMissionLoad:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDBMissionLoad_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDBMissionLoad_initData(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDBMissionLoad* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDBMissionLoad",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDBMissionLoad*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDBMissionLoad_initData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CHumanMissionData* arg0;

        ok &= luaval_to_object<CHumanMissionData>(tolua_S, 2, "CHumanMissionData", &arg0, "CHumanDBMissionLoad:initData");
        if(!ok)
            return 0;
        cobj->initData(arg0);
        return 0;
    }

    gxError("CHumanDBMissionLoad:initData has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDBMissionLoad_initData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDBMissionLoad_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDBMissionLoad* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CHumanDBMissionLoad();
        tolua_pushusertype(tolua_S,(void*)cobj,"CHumanDBMissionLoad");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CHumanDBMissionLoad:CHumanDBMissionLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CHumanDBMissionLoad_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CHumanDBMissionLoad)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CHumanDBMissionLoad",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CHumanDBMissionLoad* self = (CHumanDBMissionLoad*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CHumanDBMissionLoad(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CHumanDBMissionLoad");
    tolua_cclass(tolua_S,"CHumanDBMissionLoad","CHumanDBMissionLoad","CDBLoadBase",lua_mapserver_CHumanDBMissionLoad_finalize);

    tolua_beginmodule(tolua_S,"CHumanDBMissionLoad");
        tolua_function(tolua_S,"new",lua_mapserver_CHumanDBMissionLoad_constructor);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CHumanDBMissionLoad_cleanUp);
        tolua_function(tolua_S,"initData",lua_mapserver_CHumanDBMissionLoad_initData);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CHumanDBMissionLoad).name();
    g_luaType[typeName] = "CHumanDBMissionLoad";
    g_typeCast["CHumanDBMissionLoad"] = "CHumanDBMissionLoad";
    return 1;
}

int lua_mapserver_CHumanDB_initBufferData(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_initBufferData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CHumanDB:initBufferData"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CHumanDB:initBufferData");
        if(!ok)
            return 0;
        cobj->initBufferData(arg0, arg1);
        return 0;
    }

    gxError("CHumanDB:initBufferData has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_initBufferData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_setDataBuffer(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_setDataBuffer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CHumanDB:setDataBuffer"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CHumanDB:setDataBuffer");
        if(!ok)
            return 0;
        cobj->setDataBuffer(arg0, arg1);
        return 0;
    }

    gxError("CHumanDB:setDataBuffer has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_setDataBuffer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_initHumanDBBackup(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_initHumanDBBackup'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CHumanDBBackup* arg0;

        ok &= luaval_to_object<CHumanDBBackup>(tolua_S, 2, "CHumanDBBackup", &arg0, "CHumanDB:initHumanDBBackup");
        if(!ok)
            return 0;
        cobj->initHumanDBBackup(arg0);
        return 0;
    }

    gxError("CHumanDB:initHumanDBBackup has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_initHumanDBBackup'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_initLoad(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_initLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->initLoad();
        return 0;
    }

    gxError("CHumanDB:initLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_initLoad'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_getDataBuffer(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_getDataBuffer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->getDataBuffer();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CHumanDB:getDataBuffer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_getDataBuffer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_setSaveDataType(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_setSaveDataType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ESaveRoleType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CHumanDB:setSaveDataType");
        if(!ok)
            return 0;
        cobj->setSaveDataType(arg0);
        return 0;
    }

    gxError("CHumanDB:setSaveDataType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_setSaveDataType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_getHumanDbData(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_getHumanDbData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CHumanDBData* ret = cobj->getHumanDbData();
        object_to_luaval<CHumanDBData>(tolua_S, "CHumanDBData",(CHumanDBData*)ret);
        return 1;
    }

    gxError("CHumanDB:getHumanDbData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_getHumanDbData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_initData(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_initData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CHumanDBData* arg0;

        ok &= luaval_to_object<CHumanDBData>(tolua_S, 2, "CHumanDBData", &arg0, "CHumanDB:initData");
        if(!ok)
            return 0;
        cobj->initData(arg0);
        return 0;
    }

    gxError("CHumanDB:initData has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_initData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_dumpFromFile(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_dumpFromFile'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CHumanDB:dumpFromFile");
        if(!ok)
            return 0;
        bool ret = cobj->dumpFromFile(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CHumanDB:dumpFromFile has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_dumpFromFile'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_getBaseData(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_getBaseData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CHumanBaseData* ret = cobj->getBaseData();
        object_to_luaval<CHumanBaseData>(tolua_S, "CHumanBaseData",(CHumanBaseData*)ret);
        return 1;
    }

    gxError("CHumanDB:getBaseData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_getBaseData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_roleIsExist(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_roleIsExist'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CHumanDB:roleIsExist");
        if(!ok)
            return 0;
        bool ret = cobj->roleIsExist(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CHumanDB:roleIsExist has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_roleIsExist'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CHumanDB:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_getSaveDataType(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_getSaveDataType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getSaveDataType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CHumanDB:getSaveDataType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_getSaveDataType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_toString(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CHumanDB:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_dumpToFile(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDB*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDB_dumpToFile'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CHumanDB:dumpToFile");
        if(!ok)
            return 0;
        bool ret = cobj->dumpToFile(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CHumanDB:dumpToFile has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_dumpToFile'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDB_GenDBFileName(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CHumanDB",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned long long arg0;
        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CHumanDB:GenDBFileName");
        if(!ok)
            return 0;
        std::string ret = CHumanDB::GenDBFileName(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }
    gxError("CHumanDB:GenDBFileName has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDB_GenDBFileName'.", &tolua_err);
    return 0;
}
int lua_mapserver_CHumanDB_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDB* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CHumanDB();
        tolua_pushusertype(tolua_S,(void*)cobj,"CHumanDB");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CHumanDB:CHumanDB has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CHumanDB_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CHumanDB)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CHumanDB",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CHumanDB* self = (CHumanDB*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CHumanDB(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CHumanDB");
    tolua_cclass(tolua_S,"CHumanDB","CHumanDB","CDBLoadBase",lua_mapserver_CHumanDB_finalize);

    tolua_beginmodule(tolua_S,"CHumanDB");
        tolua_function(tolua_S,"new",lua_mapserver_CHumanDB_constructor);
        tolua_function(tolua_S,"initBufferData",lua_mapserver_CHumanDB_initBufferData);
        tolua_function(tolua_S,"setDataBuffer",lua_mapserver_CHumanDB_setDataBuffer);
        tolua_function(tolua_S,"initHumanDBBackup",lua_mapserver_CHumanDB_initHumanDBBackup);
        tolua_function(tolua_S,"initLoad",lua_mapserver_CHumanDB_initLoad);
        tolua_function(tolua_S,"getDataBuffer",lua_mapserver_CHumanDB_getDataBuffer);
        tolua_function(tolua_S,"setSaveDataType",lua_mapserver_CHumanDB_setSaveDataType);
        tolua_function(tolua_S,"getHumanDbData",lua_mapserver_CHumanDB_getHumanDbData);
        tolua_function(tolua_S,"initData",lua_mapserver_CHumanDB_initData);
        tolua_function(tolua_S,"dumpFromFile",lua_mapserver_CHumanDB_dumpFromFile);
        tolua_function(tolua_S,"getBaseData",lua_mapserver_CHumanDB_getBaseData);
        tolua_function(tolua_S,"roleIsExist",lua_mapserver_CHumanDB_roleIsExist);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CHumanDB_cleanUp);
        tolua_function(tolua_S,"getSaveDataType",lua_mapserver_CHumanDB_getSaveDataType);
        tolua_function(tolua_S,"toString",lua_mapserver_CHumanDB_toString);
        tolua_function(tolua_S,"dumpToFile",lua_mapserver_CHumanDB_dumpToFile);
        tolua_function(tolua_S,"GenDBFileName", lua_mapserver_CHumanDB_GenDBFileName);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CHumanDB).name();
    g_luaType[typeName] = "CHumanDB";
    g_typeCast["CHumanDB"] = "CHumanDB";
    return 1;
}

int lua_mapserver_CHumanDBBackup_initHumanData(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDBBackup* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CHumanDBBackup",0,&tolua_err)) goto tolua_lerror;
    cobj = (CHumanDBBackup*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CHumanDBBackup_initHumanData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CHumanDB* arg0;

        ok &= luaval_to_object<CHumanDB>(tolua_S, 2, "CHumanDB", &arg0, "CHumanDBBackup:initHumanData");
        if(!ok)
            return 0;
        cobj->initHumanData(arg0);
        return 0;
    }

    gxError("CHumanDBBackup:initHumanData has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CHumanDBBackup_initHumanData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CHumanDBBackup_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CHumanDBBackup* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CHumanDBBackup();
        tolua_pushusertype(tolua_S,(void*)cobj,"CHumanDBBackup");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CHumanDBBackup:CHumanDBBackup has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CHumanDBBackup_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CHumanDBBackup)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CHumanDBBackup",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CHumanDBBackup* self = (CHumanDBBackup*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CHumanDBBackup(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CHumanDBBackup");
    tolua_cclass(tolua_S,"CHumanDBBackup","CHumanDBBackup","CHumanDB",lua_mapserver_CHumanDBBackup_finalize);

    tolua_beginmodule(tolua_S,"CHumanDBBackup");
        tolua_function(tolua_S,"new",lua_mapserver_CHumanDBBackup_constructor);
        tolua_function(tolua_S,"initHumanData",lua_mapserver_CHumanDBBackup_initHumanData);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CHumanDBBackup).name();
    g_luaType[typeName] = "CHumanDBBackup";
    g_typeCast["CHumanDBBackup"] = "CHumanDBBackup";
    return 1;
}

int lua_mapserver_CModBag_isFullBagGuird(lua_State* tolua_S)
{
    int argc = 0;
    CModBag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModBag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModBag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModBag_isFullBagGuird'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isFullBagGuird();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModBag:isFullBagGuird has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModBag_isFullBagGuird'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModBag_onLoad(lua_State* tolua_S)
{
    int argc = 0;
    CModBag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModBag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModBag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModBag_onLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onLoad();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModBag:onLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModBag_onLoad'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModBag_getEmptyGirdNum(lua_State* tolua_S)
{
    int argc = 0;
    CModBag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModBag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModBag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModBag_getEmptyGirdNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getEmptyGirdNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModBag:getEmptyGirdNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModBag_getEmptyGirdNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModBag_isFullBag(lua_State* tolua_S)
{
    int argc = 0;
    CModBag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModBag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModBag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModBag_isFullBag'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned short arg0;
        short arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModBag:isFullBag");

        ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CModBag:isFullBag");
        if(!ok)
            return 0;
        bool ret = cobj->isFullBag(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModBag:isFullBag has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModBag_isFullBag'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModBag_onSendData(lua_State* tolua_S)
{
    int argc = 0;
    CModBag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModBag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModBag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModBag_onSendData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onSendData();
        return 0;
    }

    gxError("CModBag:onSendData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModBag_onSendData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModBag_onSave(lua_State* tolua_S)
{
    int argc = 0;
    CModBag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModBag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModBag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModBag_onSave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CModBag:onSave");
        if(!ok)
            return 0;
        cobj->onSave(arg0);
        return 0;
    }

    gxError("CModBag:onSave has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModBag_onSave'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModBag_getBag(lua_State* tolua_S)
{
    int argc = 0;
    CModBag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModBag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModBag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModBag_getBag'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CItemContainer* ret = cobj->getBag();
        object_to_luaval<CItemContainer>(tolua_S, "CItemContainer",(CItemContainer*)ret);
        return 1;
    }

    gxError("CModBag:getBag has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModBag_getBag'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModBag_findBagtype(lua_State* tolua_S)
{
    int argc = 0;
    CModBag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModBag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModBag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModBag_findBagtype'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EPackType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CModBag:findBagtype");
        if(!ok)
            return 0;
        CItemContainer* ret = cobj->findBagtype(arg0);
        object_to_luaval<CItemContainer>(tolua_S, "CItemContainer",(CItemContainer*)ret);
        return 1;
    }

    gxError("CModBag:findBagtype has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModBag_findBagtype'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModBag_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CModBag* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CModBag();
        tolua_pushusertype(tolua_S,(void*)cobj,"CModBag");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CModBag:CModBag has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CModBag_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CModBag)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CModBag",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CModBag* self = (CModBag*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CModBag(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CModBag");
    tolua_cclass(tolua_S,"CModBag","CModBag","CGameRoleModule",lua_mapserver_CModBag_finalize);

    tolua_beginmodule(tolua_S,"CModBag");
        tolua_function(tolua_S,"new",lua_mapserver_CModBag_constructor);
        tolua_function(tolua_S,"isFullBagGuird",lua_mapserver_CModBag_isFullBagGuird);
        tolua_function(tolua_S,"onLoad",lua_mapserver_CModBag_onLoad);
        tolua_function(tolua_S,"getEmptyGirdNum",lua_mapserver_CModBag_getEmptyGirdNum);
        tolua_function(tolua_S,"isFullBag",lua_mapserver_CModBag_isFullBag);
        tolua_function(tolua_S,"onSendData",lua_mapserver_CModBag_onSendData);
        tolua_function(tolua_S,"onSave",lua_mapserver_CModBag_onSave);
        tolua_function(tolua_S,"getBag",lua_mapserver_CModBag_getBag);
        tolua_function(tolua_S,"findBagtype",lua_mapserver_CModBag_findBagtype);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CModBag).name();
    g_luaType[typeName] = "CModBag";
    g_typeCast["CModBag"] = "CModBag";
    return 1;
}

int lua_mapserver_CModBuffer_onLoad(lua_State* tolua_S)
{
    int argc = 0;
    CModBuffer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModBuffer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModBuffer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModBuffer_onLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onLoad();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModBuffer:onLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModBuffer_onLoad'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModBuffer_onSave(lua_State* tolua_S)
{
    int argc = 0;
    CModBuffer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModBuffer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModBuffer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModBuffer_onSave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CModBuffer:onSave");
        if(!ok)
            return 0;
        cobj->onSave(arg0);
        return 0;
    }

    gxError("CModBuffer:onSave has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModBuffer_onSave'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModBuffer_onSendData(lua_State* tolua_S)
{
    int argc = 0;
    CModBuffer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModBuffer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModBuffer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModBuffer_onSendData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onSendData();
        return 0;
    }

    gxError("CModBuffer:onSendData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModBuffer_onSendData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModBuffer_update(lua_State* tolua_S)
{
    int argc = 0;
    CModBuffer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModBuffer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModBuffer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModBuffer_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CModBuffer:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CModBuffer:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModBuffer_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModBuffer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CModBuffer* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CModBuffer();
        tolua_pushusertype(tolua_S,(void*)cobj,"CModBuffer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CModBuffer:CModBuffer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CModBuffer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CModBuffer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CModBuffer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CModBuffer* self = (CModBuffer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CModBuffer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CModBuffer");
    tolua_cclass(tolua_S,"CModBuffer","CModBuffer","CGameRoleModule",lua_mapserver_CModBuffer_finalize);

    tolua_beginmodule(tolua_S,"CModBuffer");
        tolua_function(tolua_S,"new",lua_mapserver_CModBuffer_constructor);
        tolua_function(tolua_S,"onLoad",lua_mapserver_CModBuffer_onLoad);
        tolua_function(tolua_S,"onSave",lua_mapserver_CModBuffer_onSave);
        tolua_function(tolua_S,"onSendData",lua_mapserver_CModBuffer_onSendData);
        tolua_function(tolua_S,"update",lua_mapserver_CModBuffer_update);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CModBuffer).name();
    g_luaType[typeName] = "CModBuffer";
    g_typeCast["CModBuffer"] = "CModBuffer";
    return 1;
}

int lua_mapserver_AttrBackupBase_init(lua_State* tolua_S)
{
    int argc = 0;
    AttrBackupBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AttrBackupBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (AttrBackupBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AttrBackupBase_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->init();
        return 0;
    }

    gxError("AttrBackupBase:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AttrBackupBase_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_AttrBackupBase_getSyncData(lua_State* tolua_S)
{
    int argc = 0;
    AttrBackupBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AttrBackupBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (AttrBackupBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AttrBackupBase_getSyncData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        MCSyncRoleData* ret = cobj->getSyncData();
        object_to_luaval<MCSyncRoleData>(tolua_S, "MCSyncRoleData",(MCSyncRoleData*)ret);
        return 1;
    }

    gxError("AttrBackupBase:getSyncData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AttrBackupBase_getSyncData'.",&tolua_err);
	return 0;
}
int lua_mapserver_AttrBackupBase_setObjUID(lua_State* tolua_S)
{
    int argc = 0;
    AttrBackupBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AttrBackupBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (AttrBackupBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AttrBackupBase_setObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "AttrBackupBase:setObjUID");
        if(!ok)
            return 0;
        cobj->setObjUID(arg0);
        return 0;
    }

    gxError("AttrBackupBase:setObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AttrBackupBase_setObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_AttrBackupBase_isDirty(lua_State* tolua_S)
{
    int argc = 0;
    AttrBackupBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"AttrBackupBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (AttrBackupBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_AttrBackupBase_isDirty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDirty();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("AttrBackupBase:isDirty has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_AttrBackupBase_isDirty'.",&tolua_err);
	return 0;
}
static int lua_mapserver_AttrBackupBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (AttrBackupBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"AttrBackupBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        AttrBackupBase* self = (AttrBackupBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_AttrBackupBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"AttrBackupBase");
    tolua_cclass(tolua_S,"AttrBackupBase","AttrBackupBase","",nullptr);

    tolua_beginmodule(tolua_S,"AttrBackupBase");
        tolua_function(tolua_S,"init",lua_mapserver_AttrBackupBase_init);
        tolua_function(tolua_S,"getSyncData",lua_mapserver_AttrBackupBase_getSyncData);
        tolua_function(tolua_S,"setObjUID",lua_mapserver_AttrBackupBase_setObjUID);
        tolua_function(tolua_S,"isDirty",lua_mapserver_AttrBackupBase_isDirty);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(AttrBackupBase).name();
    g_luaType[typeName] = "AttrBackupBase";
    g_typeCast["AttrBackupBase"] = "AttrBackupBase";
    return 1;
}

int lua_mapserver_RoleAttrBackup_getValue(lua_State* tolua_S)
{
    int argc = 0;
    RoleAttrBackup* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"RoleAttrBackup",0,&tolua_err)) goto tolua_lerror;
    cobj = (RoleAttrBackup*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_RoleAttrBackup_getValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "RoleAttrBackup:getValue");
        if(!ok)
            return 0;
        int ret = cobj->getValue(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("RoleAttrBackup:getValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_RoleAttrBackup_getValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_RoleAttrBackup_isEqual(lua_State* tolua_S)
{
    int argc = 0;
    RoleAttrBackup* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"RoleAttrBackup",0,&tolua_err)) goto tolua_lerror;
    cobj = (RoleAttrBackup*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_RoleAttrBackup_isEqual'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned char arg0;
        int arg1;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "RoleAttrBackup:isEqual");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "RoleAttrBackup:isEqual");
        if(!ok)
            return 0;
        bool ret = cobj->isEqual(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("RoleAttrBackup:isEqual has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_RoleAttrBackup_isEqual'.",&tolua_err);
	return 0;
}
int lua_mapserver_RoleAttrBackup_setValue(lua_State* tolua_S)
{
    int argc = 0;
    RoleAttrBackup* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"RoleAttrBackup",0,&tolua_err)) goto tolua_lerror;
    cobj = (RoleAttrBackup*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_RoleAttrBackup_setValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned char arg0;
        int arg1;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "RoleAttrBackup:setValue");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "RoleAttrBackup:setValue");
        if(!ok)
            return 0;
        cobj->setValue(arg0, arg1);
        return 0;
    }

    gxError("RoleAttrBackup:setValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_RoleAttrBackup_setValue'.",&tolua_err);
	return 0;
}
int lua_mapserver_RoleAttrBackup_constructor(lua_State* tolua_S)
{
    int argc = 0;
    RoleAttrBackup* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new RoleAttrBackup();
        tolua_pushusertype(tolua_S,(void*)cobj,"RoleAttrBackup");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("RoleAttrBackup:RoleAttrBackup has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_RoleAttrBackup_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (RoleAttrBackup)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"RoleAttrBackup",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        RoleAttrBackup* self = (RoleAttrBackup*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_RoleAttrBackup(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"RoleAttrBackup");
    tolua_cclass(tolua_S,"RoleAttrBackup","RoleAttrBackup","AttrBackupBase",lua_mapserver_RoleAttrBackup_finalize);

    tolua_beginmodule(tolua_S,"RoleAttrBackup");
        tolua_function(tolua_S,"new",lua_mapserver_RoleAttrBackup_constructor);
        tolua_function(tolua_S,"getValue",lua_mapserver_RoleAttrBackup_getValue);
        tolua_function(tolua_S,"isEqual",lua_mapserver_RoleAttrBackup_isEqual);
        tolua_function(tolua_S,"setValue",lua_mapserver_RoleAttrBackup_setValue);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(RoleAttrBackup).name();
    g_luaType[typeName] = "RoleAttrBackup";
    g_typeCast["RoleAttrBackup"] = "RoleAttrBackup";
    return 1;
}

int lua_mapserver__MonsterAttrBackup_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    _MonsterAttrBackup* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_MonsterAttrBackup",0,&tolua_err)) goto tolua_lerror;
    cobj = (_MonsterAttrBackup*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__MonsterAttrBackup_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("_MonsterAttrBackup:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__MonsterAttrBackup_cleanUp'.",&tolua_err);
	return 0;
}
static int lua_mapserver__MonsterAttrBackup_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_MonsterAttrBackup)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_MonsterAttrBackup",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _MonsterAttrBackup* self = (_MonsterAttrBackup*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__MonsterAttrBackup(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_MonsterAttrBackup");
    tolua_cclass(tolua_S,"_MonsterAttrBackup","_MonsterAttrBackup","TAttrBackupBase",nullptr);

    tolua_beginmodule(tolua_S,"_MonsterAttrBackup");
        tolua_function(tolua_S,"cleanUp",lua_mapserver__MonsterAttrBackup_cleanUp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_MonsterAttrBackup).name();
    g_luaType[typeName] = "_MonsterAttrBackup";
    g_typeCast["_MonsterAttrBackup"] = "_MonsterAttrBackup";
    return 1;
}

static int lua_mapserver__MissionKills_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_MissionKills)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_MissionKills",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _MissionKills* self = (_MissionKills*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__MissionKills(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_MissionKills");
    tolua_cclass(tolua_S,"_MissionKills","_MissionKills","",nullptr);

    tolua_beginmodule(tolua_S,"_MissionKills");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_MissionKills).name();
    g_luaType[typeName] = "_MissionKills";
    g_typeCast["_MissionKills"] = "_MissionKills";
    return 1;
}

static int lua_mapserver__MissionItem_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_MissionItem)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_MissionItem",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _MissionItem* self = (_MissionItem*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__MissionItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_MissionItem");
    tolua_cclass(tolua_S,"_MissionItem","_MissionItem","",nullptr);

    tolua_beginmodule(tolua_S,"_MissionItem");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_MissionItem).name();
    g_luaType[typeName] = "_MissionItem";
    g_typeCast["_MissionItem"] = "_MissionItem";
    return 1;
}

int lua_mapserver_CMissionConfigTbl_isDialog(lua_State* tolua_S)
{
    int argc = 0;
    CMissionConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionConfigTbl_isDialog'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDialog();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMissionConfigTbl:isDialog has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionConfigTbl_isDialog'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionConfigTbl_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CMissionConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionConfigTbl_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMissionConfigTbl:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionConfigTbl_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionConfigTbl_isCollectItem(lua_State* tolua_S)
{
    int argc = 0;
    CMissionConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionConfigTbl_isCollectItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCollectItem();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMissionConfigTbl:isCollectItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionConfigTbl_isCollectItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionConfigTbl_isEvent(lua_State* tolua_S)
{
    int argc = 0;
    CMissionConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionConfigTbl_isEvent'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EMissionEvent arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMissionConfigTbl:isEvent");
        if(!ok)
            return 0;
        bool ret = cobj->isEvent(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMissionConfigTbl:isEvent has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionConfigTbl_isEvent'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionConfigTbl_getEventType(lua_State* tolua_S)
{
    int argc = 0;
    CMissionConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionConfigTbl_getEventType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getEventType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMissionConfigTbl:getEventType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionConfigTbl_getEventType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionConfigTbl_checkConfig(lua_State* tolua_S)
{
    int argc = 0;
    CMissionConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionConfigTbl_checkConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->checkConfig();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMissionConfigTbl:checkConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionConfigTbl_checkConfig'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionConfigTbl_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CMissionConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionConfigTbl_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMissionConfigTbl:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionConfigTbl_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionConfigTbl_initConfig(lua_State* tolua_S)
{
    int argc = 0;
    CMissionConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionConfigTbl_initConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->initConfig();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMissionConfigTbl:initConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionConfigTbl_initConfig'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionConfigTbl_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CMissionConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionConfigTbl_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMissionConfigTbl:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionConfigTbl_getKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionConfigTbl_isGuanQia(lua_State* tolua_S)
{
    int argc = 0;
    CMissionConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionConfigTbl_isGuanQia'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isGuanQia();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMissionConfigTbl:isGuanQia has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionConfigTbl_isGuanQia'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionConfigTbl_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CMissionConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionConfigTbl_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMissionConfigTbl:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CMissionConfigTbl:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionConfigTbl_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionConfigTbl_toString(lua_State* tolua_S)
{
    int argc = 0;
    CMissionConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionConfigTbl_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CMissionConfigTbl:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionConfigTbl_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionConfigTbl_isKillMonster(lua_State* tolua_S)
{
    int argc = 0;
    CMissionConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionConfigTbl_isKillMonster'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKillMonster();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMissionConfigTbl:isKillMonster has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionConfigTbl_isKillMonster'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CMissionConfigTbl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMissionConfigTbl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMissionConfigTbl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMissionConfigTbl* self = (CMissionConfigTbl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMissionConfigTbl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMissionConfigTbl");
    tolua_cclass(tolua_S,"CMissionConfigTbl","CMissionConfigTbl","CConfigTbl",nullptr);

    tolua_beginmodule(tolua_S,"CMissionConfigTbl");
        tolua_function(tolua_S,"isDialog",lua_mapserver_CMissionConfigTbl_isDialog);
        tolua_function(tolua_S,"isKey",lua_mapserver_CMissionConfigTbl_isKey);
        tolua_function(tolua_S,"isCollectItem",lua_mapserver_CMissionConfigTbl_isCollectItem);
        tolua_function(tolua_S,"isEvent",lua_mapserver_CMissionConfigTbl_isEvent);
        tolua_function(tolua_S,"getEventType",lua_mapserver_CMissionConfigTbl_getEventType);
        tolua_function(tolua_S,"checkConfig",lua_mapserver_CMissionConfigTbl_checkConfig);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CMissionConfigTbl_keyToString);
        tolua_function(tolua_S,"initConfig",lua_mapserver_CMissionConfigTbl_initConfig);
        tolua_function(tolua_S,"getKey",lua_mapserver_CMissionConfigTbl_getKey);
        tolua_function(tolua_S,"isGuanQia",lua_mapserver_CMissionConfigTbl_isGuanQia);
        tolua_function(tolua_S,"setKey",lua_mapserver_CMissionConfigTbl_setKey);
        tolua_function(tolua_S,"toString",lua_mapserver_CMissionConfigTbl_toString);
        tolua_function(tolua_S,"isKillMonster",lua_mapserver_CMissionConfigTbl_isKillMonster);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMissionConfigTbl).name();
    g_luaType[typeName] = "CMissionConfigTbl";
    g_typeCast["CMissionConfigTbl"] = "CMissionConfigTbl";
    return 1;
}

int lua_mapserver_CMissionTblLoader_readRow(lua_State* tolua_S)
{
    int argc = 0;
    CMissionTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionTblLoader_readRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        TiXmlElement* arg0;
        int arg1;
        CMissionConfigTbl* arg2;

        ok &= luaval_to_object<TiXmlElement>(tolua_S, 2, "TiXmlElement", &arg0, "CMissionTblLoader:readRow");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMissionTblLoader:readRow");

        ok &= luaval_to_object<CMissionConfigTbl>(tolua_S, 4, "CMissionConfigTbl", &arg2, "CMissionTblLoader:readRow");
        if(!ok)
            return 0;
        bool ret = cobj->readRow(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMissionTblLoader:readRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionTblLoader_readRow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionTblLoader_findByKey(lua_State* tolua_S)
{
    int argc = 0;
    CMissionTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMissionTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMissionTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMissionTblLoader_findByKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMissionTblLoader:findByKey");
        if(!ok)
            return 0;
        CMissionConfigTbl* ret = cobj->findByKey(arg0);
        object_to_luaval<CMissionConfigTbl>(tolua_S, "CMissionConfigTbl",(CMissionConfigTbl*)ret);
        return 1;
    }

    gxError("CMissionTblLoader:findByKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionTblLoader_findByKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMissionTblLoader_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMissionTblLoader",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMissionTblLoader* ret = CMissionTblLoader::GetPtr();
        object_to_luaval<CMissionTblLoader>(tolua_S, "CMissionTblLoader",(CMissionTblLoader*)ret);
        return 1;
    }
    gxError("CMissionTblLoader:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMissionTblLoader_GetPtr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMissionTblLoader_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMissionTblLoader* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMissionTblLoader();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMissionTblLoader");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMissionTblLoader:CMissionTblLoader has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMissionTblLoader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMissionTblLoader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMissionTblLoader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMissionTblLoader* self = (CMissionTblLoader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMissionTblLoader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMissionTblLoader");
    tolua_cclass(tolua_S,"CMissionTblLoader","CMissionTblLoader","CConfigLoader<CMissionTblLoader, CMissionConfigTbl>",lua_mapserver_CMissionTblLoader_finalize);

    tolua_beginmodule(tolua_S,"CMissionTblLoader");
        tolua_function(tolua_S,"new",lua_mapserver_CMissionTblLoader_constructor);
        tolua_function(tolua_S,"readRow",lua_mapserver_CMissionTblLoader_readRow);
        tolua_function(tolua_S,"findByKey",lua_mapserver_CMissionTblLoader_findByKey);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CMissionTblLoader_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMissionTblLoader).name();
    g_luaType[typeName] = "CMissionTblLoader";
    g_typeCast["CMissionTblLoader"] = "CMissionTblLoader";
    return 1;
}

static int lua_mapserver__MissionDropItem_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_MissionDropItem)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_MissionDropItem",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _MissionDropItem* self = (_MissionDropItem*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__MissionDropItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_MissionDropItem");
    tolua_cclass(tolua_S,"_MissionDropItem","_MissionDropItem","",nullptr);

    tolua_beginmodule(tolua_S,"_MissionDropItem");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_MissionDropItem).name();
    g_luaType[typeName] = "_MissionDropItem";
    g_typeCast["_MissionDropItem"] = "_MissionDropItem";
    return 1;
}

int lua_mapserver__OwnMission_getRemainItem(lua_State* tolua_S)
{
    int argc = 0;
    _OwnMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_OwnMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (_OwnMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__OwnMission_getRemainItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "_OwnMission:getRemainItem");
        if(!ok)
            return 0;
        unsigned int ret = cobj->getRemainItem(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("_OwnMission:getRemainItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__OwnMission_getRemainItem'.",&tolua_err);
	return 0;
}
int lua_mapserver__OwnMission_getMissionRow(lua_State* tolua_S)
{
    int argc = 0;
    _OwnMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_OwnMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (_OwnMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__OwnMission_getMissionRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMissionConfigTbl* ret = cobj->getMissionRow();
        object_to_luaval<CMissionConfigTbl>(tolua_S, "CMissionConfigTbl",(CMissionConfigTbl*)ret);
        return 1;
    }

    gxError("_OwnMission:getMissionRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__OwnMission_getMissionRow'.",&tolua_err);
	return 0;
}
int lua_mapserver__OwnMission_isItemFull(lua_State* tolua_S)
{
    int argc = 0;
    _OwnMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_OwnMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (_OwnMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__OwnMission_isItemFull'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CRole* arg0;

        ok &= luaval_to_object<CRole>(tolua_S, 2, "CRole", &arg0, "_OwnMission:isItemFull");
        if(!ok)
            return 0;
        bool ret = cobj->isItemFull(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("_OwnMission:isItemFull has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__OwnMission_isItemFull'.",&tolua_err);
	return 0;
}
int lua_mapserver__OwnMission_isFinish(lua_State* tolua_S)
{
    int argc = 0;
    _OwnMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"_OwnMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (_OwnMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver__OwnMission_isFinish'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isFinish();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("_OwnMission:isFinish has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver__OwnMission_isFinish'.",&tolua_err);
	return 0;
}
int lua_mapserver__OwnMission_constructor(lua_State* tolua_S)
{
    int argc = 0;
    _OwnMission* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new _OwnMission();
        tolua_pushusertype(tolua_S,(void*)cobj,"_OwnMission");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("_OwnMission:_OwnMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver__OwnMission_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_OwnMission)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_OwnMission",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _OwnMission* self = (_OwnMission*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__OwnMission(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_OwnMission");
    tolua_cclass(tolua_S,"_OwnMission","_OwnMission","TMissionBase",lua_mapserver__OwnMission_finalize);

    tolua_beginmodule(tolua_S,"_OwnMission");
        tolua_function(tolua_S,"new",lua_mapserver__OwnMission_constructor);
        tolua_function(tolua_S,"getRemainItem",lua_mapserver__OwnMission_getRemainItem);
        tolua_function(tolua_S,"getMissionRow",lua_mapserver__OwnMission_getMissionRow);
        tolua_function(tolua_S,"isItemFull",lua_mapserver__OwnMission_isItemFull);
        tolua_function(tolua_S,"isFinish",lua_mapserver__OwnMission_isFinish);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_OwnMission).name();
    g_luaType[typeName] = "_OwnMission";
    g_typeCast["_OwnMission"] = "_OwnMission";
    return 1;
}

int lua_mapserver_CModMission_getAcceptMissionPtrMap(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_getAcceptMissionPtrMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::map<unsigned short, _OwnMission *, std::less<unsigned short>, std::allocator<std::pair<const unsigned short, _OwnMission *> > > ret = cobj->getAcceptMissionPtrMap();
        map_to_luaval(tolua_S, "std::map<unsigned short, _OwnMission *, std::less<unsigned short>, std::allocator<std::pair<const unsigned short, _OwnMission *> > >", ret);
        return 1;
    }

    gxError("CModMission:getAcceptMissionPtrMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_getAcceptMissionPtrMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_onNpcDlg(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_onNpcDlg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModMission:onNpcDlg");
        if(!ok)
            return 0;
        cobj->onNpcDlg(arg0);
        return 0;
    }

    gxError("CModMission:onNpcDlg has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_onNpcDlg'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_awardExp(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_awardExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CRole* arg0;
        int arg1;

        ok &= luaval_to_object<CRole>(tolua_S, 2, "CRole", &arg0, "CModMission:awardExp");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CModMission:awardExp");
        if(!ok)
            return 0;
        cobj->awardExp(arg0, arg1);
        return 0;
    }

    gxError("CModMission:awardExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_awardExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_addGuanQiaCall(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_addGuanQiaCall'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _OwnMission* arg0;

        ok &= luaval_to_object<_OwnMission>(tolua_S, 2, "_OwnMission", &arg0, "CModMission:addGuanQiaCall");
        if(!ok)
            return 0;
        cobj->addGuanQiaCall(arg0);
        return 0;
    }

    gxError("CModMission:addGuanQiaCall has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_addGuanQiaCall'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_isCollectItem(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_isCollectItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCollectItem();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModMission:isCollectItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_isCollectItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_isKillMonster(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_isKillMonster'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKillMonster();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModMission:isKillMonster has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_isKillMonster'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_deleteFromAcceptMission(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_deleteFromAcceptMission'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModMission:deleteFromAcceptMission");
        if(!ok)
            return 0;
        cobj->deleteFromAcceptMission(arg0);
        return 0;
    }

    gxError("CModMission:deleteFromAcceptMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_deleteFromAcceptMission'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_rebuildItemFunc(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_rebuildItemFunc'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->rebuildItemFunc();
        return 0;
    }

    gxError("CModMission:rebuildItemFunc has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_rebuildItemFunc'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_onDesItem(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_onDesItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned short arg0;
        short arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModMission:onDesItem");

        ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CModMission:onDesItem");
        if(!ok)
            return 0;
        cobj->onDesItem(arg0, arg1);
        return 0;
    }

    gxError("CModMission:onDesItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_onDesItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_sendDelMission(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_sendDelMission'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModMission:sendDelMission");
        if(!ok)
            return 0;
        cobj->sendDelMission(arg0);
        return 0;
    }

    gxError("CModMission:sendDelMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_sendDelMission'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_getTaskItemRemainNum(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_getTaskItemRemainNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModMission:getTaskItemRemainNum");
        if(!ok)
            return 0;
        unsigned int ret = cobj->getTaskItemRemainNum(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModMission:getTaskItemRemainNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_getTaskItemRemainNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_isExist(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_isExist'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModMission:isExist");
        if(!ok)
            return 0;
        bool ret = cobj->isExist(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModMission:isExist has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_isExist'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_sendUpdateParams(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_sendUpdateParams'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _OwnMission* arg0;

        ok &= luaval_to_object<_OwnMission>(tolua_S, 2, "_OwnMission", &arg0, "CModMission:sendUpdateParams");
        if(!ok)
            return 0;
        cobj->sendUpdateParams(arg0);
        return 0;
    }

    gxError("CModMission:sendUpdateParams has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_sendUpdateParams'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_sendAcceptableMission(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_sendAcceptableMission'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->sendAcceptableMission();
        return 0;
    }

    gxError("CModMission:sendAcceptableMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_sendAcceptableMission'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_submitMission(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_submitMission'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModMission:submitMission");
        if(!ok)
            return 0;
        int ret = (int)cobj->submitMission(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModMission:submitMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_submitMission'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_setLastFinishMissionID(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_setLastFinishMissionID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModMission:setLastFinishMissionID");
        if(!ok)
            return 0;
        cobj->setLastFinishMissionID(arg0);
        return 0;
    }

    gxError("CModMission:setLastFinishMissionID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_setLastFinishMissionID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_submitNormalGains(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_submitNormalGains'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMissionConfigTbl* arg0;

        ok &= luaval_to_object<CMissionConfigTbl>(tolua_S, 2, "CMissionConfigTbl", &arg0, "CModMission:submitNormalGains");
        if(!ok)
            return 0;
        cobj->submitNormalGains(arg0);
        return 0;
    }

    gxError("CModMission:submitNormalGains has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_submitNormalGains'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_submitConsume(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_submitConsume'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMissionConfigTbl* arg0;

        ok &= luaval_to_object<CMissionConfigTbl>(tolua_S, 2, "CMissionConfigTbl", &arg0, "CModMission:submitConsume");
        if(!ok)
            return 0;
        int ret = (int)cobj->submitConsume(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModMission:submitConsume has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_submitConsume'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_onSendData(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_onSendData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onSendData();
        return 0;
    }

    gxError("CModMission:onSendData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_onSendData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_onAddItem(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_onAddItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned short arg0;
        short arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModMission:onAddItem");

        ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CModMission:onAddItem");
        if(!ok)
            return 0;
        cobj->onAddItem(arg0, arg1);
        return 0;
    }

    gxError("CModMission:onAddItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_onAddItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_onSave(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_onSave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CModMission:onSave");
        if(!ok)
            return 0;
        cobj->onSave(arg0);
        return 0;
    }

    gxError("CModMission:onSave has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_onSave'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_init(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CRole* arg0;

        ok &= luaval_to_object<CRole>(tolua_S, 2, "CRole", &arg0, "CModMission:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModMission:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_addCall(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_addCall'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _OwnMission* arg0;

        ok &= luaval_to_object<_OwnMission>(tolua_S, 2, "_OwnMission", &arg0, "CModMission:addCall");
        if(!ok)
            return 0;
        cobj->addCall(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        _OwnMission* arg0;
        bool arg1;

        ok &= luaval_to_object<_OwnMission>(tolua_S, 2, "_OwnMission", &arg0, "CModMission:addCall");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CModMission:addCall");
        if(!ok)
            return 0;
        cobj->addCall(arg0, arg1);
        return 0;
    }

    gxError("CModMission:addCall has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_addCall'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_acceptMission(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_acceptMission'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModMission:acceptMission");
        if(!ok)
            return 0;
        int ret = (int)cobj->acceptMission(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModMission:acceptMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_acceptMission'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_isDialog(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_isDialog'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDialog();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModMission:isDialog has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_isDialog'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_onLoad(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_onLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onLoad();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModMission:onLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_onLoad'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_checkSubmit(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_checkSubmit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _OwnMission* arg0;

        ok &= luaval_to_object<_OwnMission>(tolua_S, 2, "_OwnMission", &arg0, "CModMission:checkSubmit");
        if(!ok)
            return 0;
        int ret = (int)cobj->checkSubmit(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModMission:checkSubmit has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_checkSubmit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_isEvent(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_isEvent'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EMissionEvent arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CModMission:isEvent");
        if(!ok)
            return 0;
        bool ret = cobj->isEvent(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModMission:isEvent has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_isEvent'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_rebuildCallFunc(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CModMission_rebuildCallFunc'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            EMissionEvent arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CModMission:rebuildCallFunc");

            if (!ok) { break; }
            cobj->rebuildCallFunc(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj->rebuildCallFunc();
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CModMission:rebuildCallFunc has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_rebuildCallFunc'.",&tolua_err);
    return 0;
}
int lua_mapserver_CModMission_rebuildKillMonsterFunc(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_rebuildKillMonsterFunc'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->rebuildKillMonsterFunc();
        return 0;
    }

    gxError("CModMission:rebuildKillMonsterFunc has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_rebuildKillMonsterFunc'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_addKillCall(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_addKillCall'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _OwnMission* arg0;

        ok &= luaval_to_object<_OwnMission>(tolua_S, 2, "_OwnMission", &arg0, "CModMission:addKillCall");
        if(!ok)
            return 0;
        cobj->addKillCall(arg0);
        return 0;
    }

    gxError("CModMission:addKillCall has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_addKillCall'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_checkAccept(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_checkAccept'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMissionConfigTbl* arg0;

        ok &= luaval_to_object<CMissionConfigTbl>(tolua_S, 2, "CMissionConfigTbl", &arg0, "CModMission:checkAccept");
        if(!ok)
            return 0;
        int ret = (int)cobj->checkAccept(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModMission:checkAccept has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_checkAccept'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_rebuildData(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_rebuildData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->rebuildData();
        return 0;
    }

    gxError("CModMission:rebuildData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_rebuildData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_isTaksItem(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_isTaksItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModMission:isTaksItem");
        if(!ok)
            return 0;
        bool ret = cobj->isTaksItem(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModMission:isTaksItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_isTaksItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_rebuildEvent(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_rebuildEvent'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->rebuildEvent();
        return 0;
    }

    gxError("CModMission:rebuildEvent has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_rebuildEvent'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_addToAcceptMission(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_addToAcceptMission'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _OwnMission* arg0;

        ok &= luaval_to_object<_OwnMission>(tolua_S, 2, "_OwnMission", &arg0, "CModMission:addToAcceptMission");
        if(!ok)
            return 0;
        cobj->addToAcceptMission(arg0);
        return 0;
    }

    gxError("CModMission:addToAcceptMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_addToAcceptMission'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_sendUpdateCompleted(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CModMission_sendUpdateCompleted'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            CMissionConfigTbl* arg0;
            ok &= luaval_to_object<CMissionConfigTbl>(tolua_S, 2, "CMissionConfigTbl", &arg0, "CModMission:sendUpdateCompleted");

            if (!ok) { break; }
            cobj->sendUpdateCompleted(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            _OwnMission* arg0;
            ok &= luaval_to_object<_OwnMission>(tolua_S, 2, "_OwnMission", &arg0, "CModMission:sendUpdateCompleted");

            if (!ok) { break; }
            cobj->sendUpdateCompleted(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CModMission:sendUpdateCompleted has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_sendUpdateCompleted'.",&tolua_err);
    return 0;
}
int lua_mapserver_CModMission_afterAccept(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_afterAccept'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _OwnMission* arg0;

        ok &= luaval_to_object<_OwnMission>(tolua_S, 2, "_OwnMission", &arg0, "CModMission:afterAccept");
        if(!ok)
            return 0;
        int ret = (int)cobj->afterAccept(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModMission:afterAccept has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_afterAccept'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_sendAcceptedMission(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_sendAcceptedMission'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->sendAcceptedMission();
        return 0;
    }

    gxError("CModMission:sendAcceptedMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_sendAcceptedMission'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_addItemCall(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_addItemCall'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _OwnMission* arg0;

        ok &= luaval_to_object<_OwnMission>(tolua_S, 2, "_OwnMission", &arg0, "CModMission:addItemCall");
        if(!ok)
            return 0;
        cobj->addItemCall(arg0);
        return 0;
    }

    gxError("CModMission:addItemCall has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_addItemCall'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_rebuildNpcDlgFunc(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_rebuildNpcDlgFunc'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->rebuildNpcDlgFunc();
        return 0;
    }

    gxError("CModMission:rebuildNpcDlgFunc has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_rebuildNpcDlgFunc'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_rebuildGuanQiaFunc(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_rebuildGuanQiaFunc'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->rebuildGuanQiaFunc();
        return 0;
    }

    gxError("CModMission:rebuildGuanQiaFunc has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_rebuildGuanQiaFunc'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_sendUpdateMission(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_sendUpdateMission'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _OwnMission* arg0;

        ok &= luaval_to_object<_OwnMission>(tolua_S, 2, "_OwnMission", &arg0, "CModMission:sendUpdateMission");
        if(!ok)
            return 0;
        cobj->sendUpdateMission(arg0);
        return 0;
    }

    gxError("CModMission:sendUpdateMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_sendUpdateMission'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_addDlgCall(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_addDlgCall'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _OwnMission* arg0;

        ok &= luaval_to_object<_OwnMission>(tolua_S, 2, "_OwnMission", &arg0, "CModMission:addDlgCall");
        if(!ok)
            return 0;
        cobj->addDlgCall(arg0);
        return 0;
    }

    gxError("CModMission:addDlgCall has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_addDlgCall'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_onOffline(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_onOffline'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onOffline();
        return 0;
    }

    gxError("CModMission:onOffline has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_onOffline'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_isGuanQia(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_isGuanQia'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isGuanQia();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModMission:isGuanQia has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_isGuanQia'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_onFinishChapter(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_onFinishChapter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CModMission:onFinishChapter");
        if(!ok)
            return 0;
        cobj->onFinishChapter(arg0);
        return 0;
    }

    gxError("CModMission:onFinishChapter has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_onFinishChapter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_onMonsterKill(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_onMonsterKill'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModMission:onMonsterKill");
        if(!ok)
            return 0;
        cobj->onMonsterKill(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        unsigned short arg0;
        int arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CModMission:onMonsterKill");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CModMission:onMonsterKill");
        if(!ok)
            return 0;
        cobj->onMonsterKill(arg0, arg1);
        return 0;
    }

    gxError("CModMission:onMonsterKill has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_onMonsterKill'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_sendUpdateFinish(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_sendUpdateFinish'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _OwnMission* arg0;

        ok &= luaval_to_object<_OwnMission>(tolua_S, 2, "_OwnMission", &arg0, "CModMission:sendUpdateFinish");
        if(!ok)
            return 0;
        cobj->sendUpdateFinish(arg0);
        return 0;
    }

    gxError("CModMission:sendUpdateFinish has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_sendUpdateFinish'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_submitGains(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModMission_submitGains'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMissionConfigTbl* arg0;

        ok &= luaval_to_object<CMissionConfigTbl>(tolua_S, 2, "CMissionConfigTbl", &arg0, "CModMission:submitGains");
        if(!ok)
            return 0;
        cobj->submitGains(arg0);
        return 0;
    }

    gxError("CModMission:submitGains has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModMission_submitGains'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModMission_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CModMission* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CModMission();
        tolua_pushusertype(tolua_S,(void*)cobj,"CModMission");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CModMission:CModMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CModMission_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CModMission)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CModMission",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CModMission* self = (CModMission*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CModMission(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CModMission");
    tolua_cclass(tolua_S,"CModMission","CModMission","CGameRoleModule",lua_mapserver_CModMission_finalize);

    tolua_beginmodule(tolua_S,"CModMission");
        tolua_function(tolua_S,"new",lua_mapserver_CModMission_constructor);
        tolua_function(tolua_S,"getAcceptMissionPtrMap",lua_mapserver_CModMission_getAcceptMissionPtrMap);
        tolua_function(tolua_S,"onNpcDlg",lua_mapserver_CModMission_onNpcDlg);
        tolua_function(tolua_S,"awardExp",lua_mapserver_CModMission_awardExp);
        tolua_function(tolua_S,"addGuanQiaCall",lua_mapserver_CModMission_addGuanQiaCall);
        tolua_function(tolua_S,"isCollectItem",lua_mapserver_CModMission_isCollectItem);
        tolua_function(tolua_S,"isKillMonster",lua_mapserver_CModMission_isKillMonster);
        tolua_function(tolua_S,"deleteFromAcceptMission",lua_mapserver_CModMission_deleteFromAcceptMission);
        tolua_function(tolua_S,"rebuildItemFunc",lua_mapserver_CModMission_rebuildItemFunc);
        tolua_function(tolua_S,"onDesItem",lua_mapserver_CModMission_onDesItem);
        tolua_function(tolua_S,"sendDelMission",lua_mapserver_CModMission_sendDelMission);
        tolua_function(tolua_S,"getTaskItemRemainNum",lua_mapserver_CModMission_getTaskItemRemainNum);
        tolua_function(tolua_S,"isExist",lua_mapserver_CModMission_isExist);
        tolua_function(tolua_S,"sendUpdateParams",lua_mapserver_CModMission_sendUpdateParams);
        tolua_function(tolua_S,"sendAcceptableMission",lua_mapserver_CModMission_sendAcceptableMission);
        tolua_function(tolua_S,"submitMission",lua_mapserver_CModMission_submitMission);
        tolua_function(tolua_S,"setLastFinishMissionID",lua_mapserver_CModMission_setLastFinishMissionID);
        tolua_function(tolua_S,"submitNormalGains",lua_mapserver_CModMission_submitNormalGains);
        tolua_function(tolua_S,"submitConsume",lua_mapserver_CModMission_submitConsume);
        tolua_function(tolua_S,"onSendData",lua_mapserver_CModMission_onSendData);
        tolua_function(tolua_S,"onAddItem",lua_mapserver_CModMission_onAddItem);
        tolua_function(tolua_S,"onSave",lua_mapserver_CModMission_onSave);
        tolua_function(tolua_S,"init",lua_mapserver_CModMission_init);
        tolua_function(tolua_S,"addCall",lua_mapserver_CModMission_addCall);
        tolua_function(tolua_S,"acceptMission",lua_mapserver_CModMission_acceptMission);
        tolua_function(tolua_S,"isDialog",lua_mapserver_CModMission_isDialog);
        tolua_function(tolua_S,"onLoad",lua_mapserver_CModMission_onLoad);
        tolua_function(tolua_S,"checkSubmit",lua_mapserver_CModMission_checkSubmit);
        tolua_function(tolua_S,"isEvent",lua_mapserver_CModMission_isEvent);
        tolua_function(tolua_S,"rebuildCallFunc",lua_mapserver_CModMission_rebuildCallFunc);
        tolua_function(tolua_S,"rebuildKillMonsterFunc",lua_mapserver_CModMission_rebuildKillMonsterFunc);
        tolua_function(tolua_S,"addKillCall",lua_mapserver_CModMission_addKillCall);
        tolua_function(tolua_S,"checkAccept",lua_mapserver_CModMission_checkAccept);
        tolua_function(tolua_S,"rebuildData",lua_mapserver_CModMission_rebuildData);
        tolua_function(tolua_S,"isTaksItem",lua_mapserver_CModMission_isTaksItem);
        tolua_function(tolua_S,"rebuildEvent",lua_mapserver_CModMission_rebuildEvent);
        tolua_function(tolua_S,"addToAcceptMission",lua_mapserver_CModMission_addToAcceptMission);
        tolua_function(tolua_S,"sendUpdateCompleted",lua_mapserver_CModMission_sendUpdateCompleted);
        tolua_function(tolua_S,"afterAccept",lua_mapserver_CModMission_afterAccept);
        tolua_function(tolua_S,"sendAcceptedMission",lua_mapserver_CModMission_sendAcceptedMission);
        tolua_function(tolua_S,"addItemCall",lua_mapserver_CModMission_addItemCall);
        tolua_function(tolua_S,"rebuildNpcDlgFunc",lua_mapserver_CModMission_rebuildNpcDlgFunc);
        tolua_function(tolua_S,"rebuildGuanQiaFunc",lua_mapserver_CModMission_rebuildGuanQiaFunc);
        tolua_function(tolua_S,"sendUpdateMission",lua_mapserver_CModMission_sendUpdateMission);
        tolua_function(tolua_S,"addDlgCall",lua_mapserver_CModMission_addDlgCall);
        tolua_function(tolua_S,"onOffline",lua_mapserver_CModMission_onOffline);
        tolua_function(tolua_S,"isGuanQia",lua_mapserver_CModMission_isGuanQia);
        tolua_function(tolua_S,"onFinishChapter",lua_mapserver_CModMission_onFinishChapter);
        tolua_function(tolua_S,"onMonsterKill",lua_mapserver_CModMission_onMonsterKill);
        tolua_function(tolua_S,"sendUpdateFinish",lua_mapserver_CModMission_sendUpdateFinish);
        tolua_function(tolua_S,"submitGains",lua_mapserver_CModMission_submitGains);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CModMission).name();
    g_luaType[typeName] = "CModMission";
    g_typeCast["CModMission"] = "CModMission";
    return 1;
}

int lua_mapserver_CNewRoleTbl_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CNewRoleTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNewRoleTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNewRoleTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNewRoleTbl_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CNewRoleTbl:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNewRoleTbl_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CNewRoleTbl_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CNewRoleTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNewRoleTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNewRoleTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNewRoleTbl_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CNewRoleTbl:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNewRoleTbl_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CNewRoleTbl_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CNewRoleTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNewRoleTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNewRoleTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNewRoleTbl_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CNewRoleTbl:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNewRoleTbl_getKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CNewRoleTbl_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CNewRoleTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNewRoleTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNewRoleTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNewRoleTbl_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CNewRoleTbl:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CNewRoleTbl:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNewRoleTbl_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CNewRoleTbl_toString(lua_State* tolua_S)
{
    int argc = 0;
    CNewRoleTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNewRoleTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNewRoleTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNewRoleTbl_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CNewRoleTbl:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNewRoleTbl_toString'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CNewRoleTbl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNewRoleTbl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNewRoleTbl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CNewRoleTbl* self = (CNewRoleTbl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CNewRoleTbl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNewRoleTbl");
    tolua_cclass(tolua_S,"CNewRoleTbl","CNewRoleTbl","CConfigTbl",nullptr);

    tolua_beginmodule(tolua_S,"CNewRoleTbl");
        tolua_function(tolua_S,"isKey",lua_mapserver_CNewRoleTbl_isKey);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CNewRoleTbl_keyToString);
        tolua_function(tolua_S,"getKey",lua_mapserver_CNewRoleTbl_getKey);
        tolua_function(tolua_S,"setKey",lua_mapserver_CNewRoleTbl_setKey);
        tolua_function(tolua_S,"toString",lua_mapserver_CNewRoleTbl_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CNewRoleTbl).name();
    g_luaType[typeName] = "CNewRoleTbl";
    g_typeCast["CNewRoleTbl"] = "CNewRoleTbl";
    return 1;
}

int lua_mapserver_CNewRoleTblLoader_getRow(lua_State* tolua_S)
{
    int argc = 0;
    CNewRoleTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNewRoleTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNewRoleTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNewRoleTblLoader_getRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CNewRoleTbl* ret = cobj->getRow();
        object_to_luaval<CNewRoleTbl>(tolua_S, "CNewRoleTbl",(CNewRoleTbl*)ret);
        return 1;
    }

    gxError("CNewRoleTblLoader:getRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNewRoleTblLoader_getRow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CNewRoleTblLoader_readRow(lua_State* tolua_S)
{
    int argc = 0;
    CNewRoleTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNewRoleTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNewRoleTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNewRoleTblLoader_readRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        TiXmlElement* arg0;
        int arg1;
        CNewRoleTbl* arg2;

        ok &= luaval_to_object<TiXmlElement>(tolua_S, 2, "TiXmlElement", &arg0, "CNewRoleTblLoader:readRow");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CNewRoleTblLoader:readRow");

        ok &= luaval_to_object<CNewRoleTbl>(tolua_S, 4, "CNewRoleTbl", &arg2, "CNewRoleTblLoader:readRow");
        if(!ok)
            return 0;
        bool ret = cobj->readRow(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CNewRoleTblLoader:readRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNewRoleTblLoader_readRow'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CNewRoleTblLoader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNewRoleTblLoader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNewRoleTblLoader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CNewRoleTblLoader* self = (CNewRoleTblLoader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CNewRoleTblLoader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNewRoleTblLoader");
    tolua_cclass(tolua_S,"CNewRoleTblLoader","CNewRoleTblLoader","CConfigLoader<CNewRoleTblLoader, CNewRoleTbl>",nullptr);

    tolua_beginmodule(tolua_S,"CNewRoleTblLoader");
        tolua_function(tolua_S,"getRow",lua_mapserver_CNewRoleTblLoader_getRow);
        tolua_function(tolua_S,"readRow",lua_mapserver_CNewRoleTblLoader_readRow);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CNewRoleTblLoader).name();
    g_luaType[typeName] = "CNewRoleTblLoader";
    g_typeCast["CNewRoleTblLoader"] = "CNewRoleTblLoader";
    return 1;
}

int lua_mapserver_CLimitManager_deleteLimitAccount(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_deleteLimitAccount'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLimitManager:deleteLimitAccount");
        if(!ok)
            return 0;
        int ret = (int)cobj->deleteLimitAccount(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLimitManager:deleteLimitAccount has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_deleteLimitAccount'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_addLimitAccount(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_addLimitAccount'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const LimitAccountInfo* arg0;

        ok &= luaval_to_object<const LimitAccountInfo>(tolua_S, 2, "LimitAccountInfo", &arg0, "CLimitManager:addLimitAccount");
        if(!ok)
            return 0;
        int ret = (int)cobj->addLimitAccount(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLimitManager:addLimitAccount has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_addLimitAccount'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_isExistLimitChatInfo(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_isExistLimitChatInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const LimitChatInfo* arg0;

        ok &= luaval_to_object<const LimitChatInfo>(tolua_S, 2, "LimitChatInfo", &arg0, "CLimitManager:isExistLimitChatInfo");
        if(!ok)
            return 0;
        bool ret = cobj->isExistLimitChatInfo(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CLimitManager:isExistLimitChatInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_isExistLimitChatInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_checkLimitChat(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_checkLimitChat'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CLimitManager:checkLimitChat");
        if(!ok)
            return 0;
        bool ret = cobj->checkLimitChat(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CLimitManager:checkLimitChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_checkLimitChat'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_addLimitAccountMap(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_addLimitAccountMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const LimitAccountInfo* arg0;

        ok &= luaval_to_object<const LimitAccountInfo>(tolua_S, 2, "LimitAccountInfo", &arg0, "CLimitManager:addLimitAccountMap");
        if(!ok)
            return 0;
        int ret = (int)cobj->addLimitAccountMap(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLimitManager:addLimitAccountMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_addLimitAccountMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_checkLimitLogin(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CLimitManager_checkLimitLogin'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            std::string arg0;
            ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CLimitManager:checkLimitLogin");

            if (!ok) { break; }
            bool ret = cobj->checkLimitLogin(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            unsigned long long arg0;
            ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CLimitManager:checkLimitLogin");

            if (!ok) { break; }
            bool ret = cobj->checkLimitLogin(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CLimitManager:checkLimitLogin has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_checkLimitLogin'.",&tolua_err);
    return 0;
}
int lua_mapserver_CLimitManager_addLimitChat(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_addLimitChat'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const LimitChatInfo* arg0;

        ok &= luaval_to_object<const LimitChatInfo>(tolua_S, 2, "LimitChatInfo", &arg0, "CLimitManager:addLimitChat");
        if(!ok)
            return 0;
        int ret = (int)cobj->addLimitChat(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLimitManager:addLimitChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_addLimitChat'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_updateLimitChat(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_updateLimitChat'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const LimitChatInfo* arg0;

        ok &= luaval_to_object<const LimitChatInfo>(tolua_S, 2, "LimitChatInfo", &arg0, "CLimitManager:updateLimitChat");
        if(!ok)
            return 0;
        int ret = (int)cobj->updateLimitChat(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLimitManager:updateLimitChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_updateLimitChat'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_initLimitChatList(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_initLimitChatList'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const GXMISC::CArray<LimitChatDB, 50, unsigned char>* arg0;

        ok &= luaval_to_object<const GXMISC::CArray<LimitChatDB, 50, unsigned char>>(tolua_S, 2, "CArray<LimitChatDB, 50, unsigned char>", &arg0, "CLimitManager:initLimitChatList");
        if(!ok)
            return 0;
        cobj->initLimitChatList(arg0);
        return 0;
    }

    gxError("CLimitManager:initLimitChatList has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_initLimitChatList'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_updateLimitRole(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CLimitManager_updateLimitRole'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 4) {
            ERoleLimitType arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLimitManager:updateLimitRole");

            if (!ok) { break; }
            std::string arg1;
            ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CLimitManager:updateLimitRole");

            if (!ok) { break; }
            unsigned char arg2;
            ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CLimitManager:updateLimitRole");

            if (!ok) { break; }
            unsigned int arg3;
            ok &= luaval_to_uint32(tolua_S, 5,(uint32*)&arg3, "CLimitManager:updateLimitRole");

            if (!ok) { break; }
            cobj->updateLimitRole(arg0, arg1, arg2, arg3);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            ERoleLimitType arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLimitManager:updateLimitRole");

            if (!ok) { break; }
            unsigned long long arg1;
            ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CLimitManager:updateLimitRole");

            if (!ok) { break; }
            unsigned char arg2;
            ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CLimitManager:updateLimitRole");

            if (!ok) { break; }
            unsigned int arg3;
            ok &= luaval_to_uint32(tolua_S, 5,(uint32*)&arg3, "CLimitManager:updateLimitRole");

            if (!ok) { break; }
            cobj->updateLimitRole(arg0, arg1, arg2, arg3);
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CLimitManager:updateLimitRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_updateLimitRole'.",&tolua_err);
    return 0;
}
int lua_mapserver_CLimitManager_update(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CLimitManager:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CLimitManager:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_deleteLinitChat(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_deleteLinitChat'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLimitManager:deleteLinitChat");
        if(!ok)
            return 0;
        int ret = (int)cobj->deleteLinitChat(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLimitManager:deleteLinitChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_deleteLinitChat'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_loadLimitInfoFromDB(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_loadLimitInfoFromDB'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const std::vector<LimitAccountInfo, std::allocator<LimitAccountInfo> >* arg0;

        ok &= luaval_to_object<const std::vector<LimitAccountInfo, std::allocator<LimitAccountInfo> >>(tolua_S, 2, "std::vector<LimitAccountInfo, std::allocator<LimitAccountInfo> >*", &arg0, "CLimitManager:loadLimitInfoFromDB");
        if(!ok)
            return 0;
        bool ret = cobj->loadLimitInfoFromDB(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CLimitManager:loadLimitInfoFromDB has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_loadLimitInfoFromDB'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_isExistLimitAccountInfo(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_isExistLimitAccountInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const LimitAccountInfo* arg0;

        ok &= luaval_to_object<const LimitAccountInfo>(tolua_S, 2, "LimitAccountInfo", &arg0, "CLimitManager:isExistLimitAccountInfo");
        if(!ok)
            return 0;
        bool ret = cobj->isExistLimitAccountInfo(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CLimitManager:isExistLimitAccountInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_isExistLimitAccountInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_initLimitAccountIDList(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_initLimitAccountIDList'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const GXMISC::CArray<LimitAccountDB, 50, unsigned char>* arg0;

        ok &= luaval_to_object<const GXMISC::CArray<LimitAccountDB, 50, unsigned char>>(tolua_S, 2, "CArray<LimitAccountDB, 50, unsigned char>", &arg0, "CLimitManager:initLimitAccountIDList");
        if(!ok)
            return 0;
        cobj->initLimitAccountIDList(arg0);
        return 0;
    }

    gxError("CLimitManager:initLimitAccountIDList has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_initLimitAccountIDList'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_isForbbidChat(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_isForbbidChat'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CLimitManager:isForbbidChat");
        if(!ok)
            return 0;
        bool ret = cobj->isForbbidChat(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CLimitManager:isForbbidChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_isForbbidChat'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_findLimitChatPos(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_findLimitChatPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLimitManager:findLimitChatPos");
        if(!ok)
            return 0;
        unsigned int ret = cobj->findLimitChatPos(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLimitManager:findLimitChatPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_findLimitChatPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_updateLimitAccount(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_updateLimitAccount'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const LimitAccountInfo* arg0;

        ok &= luaval_to_object<const LimitAccountInfo>(tolua_S, 2, "LimitAccountInfo", &arg0, "CLimitManager:updateLimitAccount");
        if(!ok)
            return 0;
        int ret = (int)cobj->updateLimitAccount(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLimitManager:updateLimitAccount has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_updateLimitAccount'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_findLimitAccountPos(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_findLimitAccountPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLimitManager:findLimitAccountPos");
        if(!ok)
            return 0;
        unsigned int ret = cobj->findLimitAccountPos(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLimitManager:findLimitAccountPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_findLimitAccountPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_addLimitChatMap(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLimitManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLimitManager_addLimitChatMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const LimitChatInfo* arg0;

        ok &= luaval_to_object<const LimitChatInfo>(tolua_S, 2, "LimitChatInfo", &arg0, "CLimitManager:addLimitChatMap");
        if(!ok)
            return 0;
        int ret = (int)cobj->addLimitChatMap(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLimitManager:addLimitChatMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLimitManager_addLimitChatMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLimitManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CLimitManager* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CLimitManager();
        tolua_pushusertype(tolua_S,(void*)cobj,"CLimitManager");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CLimitManager:CLimitManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CLimitManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLimitManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLimitManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLimitManager* self = (CLimitManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLimitManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLimitManager");
    tolua_cclass(tolua_S,"CLimitManager","CLimitManager","CSingleton<CLimitManager>",lua_mapserver_CLimitManager_finalize);

    tolua_beginmodule(tolua_S,"CLimitManager");
        tolua_function(tolua_S,"new",lua_mapserver_CLimitManager_constructor);
        tolua_function(tolua_S,"deleteLimitAccount",lua_mapserver_CLimitManager_deleteLimitAccount);
        tolua_function(tolua_S,"addLimitAccount",lua_mapserver_CLimitManager_addLimitAccount);
        tolua_function(tolua_S,"isExistLimitChatInfo",lua_mapserver_CLimitManager_isExistLimitChatInfo);
        tolua_function(tolua_S,"checkLimitChat",lua_mapserver_CLimitManager_checkLimitChat);
        tolua_function(tolua_S,"addLimitAccountMap",lua_mapserver_CLimitManager_addLimitAccountMap);
        tolua_function(tolua_S,"checkLimitLogin",lua_mapserver_CLimitManager_checkLimitLogin);
        tolua_function(tolua_S,"addLimitChat",lua_mapserver_CLimitManager_addLimitChat);
        tolua_function(tolua_S,"updateLimitChat",lua_mapserver_CLimitManager_updateLimitChat);
        tolua_function(tolua_S,"initLimitChatList",lua_mapserver_CLimitManager_initLimitChatList);
        tolua_function(tolua_S,"updateLimitRole",lua_mapserver_CLimitManager_updateLimitRole);
        tolua_function(tolua_S,"update",lua_mapserver_CLimitManager_update);
        tolua_function(tolua_S,"deleteLinitChat",lua_mapserver_CLimitManager_deleteLinitChat);
        tolua_function(tolua_S,"loadLimitInfoFromDB",lua_mapserver_CLimitManager_loadLimitInfoFromDB);
        tolua_function(tolua_S,"isExistLimitAccountInfo",lua_mapserver_CLimitManager_isExistLimitAccountInfo);
        tolua_function(tolua_S,"initLimitAccountIDList",lua_mapserver_CLimitManager_initLimitAccountIDList);
        tolua_function(tolua_S,"isForbbidChat",lua_mapserver_CLimitManager_isForbbidChat);
        tolua_function(tolua_S,"findLimitChatPos",lua_mapserver_CLimitManager_findLimitChatPos);
        tolua_function(tolua_S,"updateLimitAccount",lua_mapserver_CLimitManager_updateLimitAccount);
        tolua_function(tolua_S,"findLimitAccountPos",lua_mapserver_CLimitManager_findLimitAccountPos);
        tolua_function(tolua_S,"addLimitChatMap",lua_mapserver_CLimitManager_addLimitChatMap);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLimitManager).name();
    g_luaType[typeName] = "CLimitManager";
    g_typeCast["CLimitManager"] = "CLimitManager";
    return 1;
}

int lua_mapserver_CTimeWaiter_setWaitTime(lua_State* tolua_S)
{
    int argc = 0;
    CTimeWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTimeWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTimeWaiter_setWaitTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimeWaiter:setWaitTime");
        if(!ok)
            return 0;
        cobj->setWaitTime(arg0);
        return 0;
    }

    gxError("CTimeWaiter:setWaitTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTimeWaiter_setWaitTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTimeWaiter_update(lua_State* tolua_S)
{
    int argc = 0;
    CTimeWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTimeWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTimeWaiter_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTimeWaiter:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CTimeWaiter:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTimeWaiter_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTimeWaiter_isTimeout(lua_State* tolua_S)
{
    int argc = 0;
    CTimeWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTimeWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTimeWaiter_isTimeout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isTimeout();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimeWaiter:isTimeout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTimeWaiter_isTimeout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTimeWaiter_setStartTime(lua_State* tolua_S)
{
    int argc = 0;
    CTimeWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTimeWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTimeWaiter_setStartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimeWaiter:setStartTime");
        if(!ok)
            return 0;
        cobj->setStartTime(arg0);
        return 0;
    }

    gxError("CTimeWaiter:setStartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTimeWaiter_setStartTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTimeWaiter_getWaitTime(lua_State* tolua_S)
{
    int argc = 0;
    CTimeWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTimeWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTimeWaiter_getWaitTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getWaitTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeWaiter:getWaitTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTimeWaiter_getWaitTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTimeWaiter_cleanup(lua_State* tolua_S)
{
    int argc = 0;
    CTimeWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTimeWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTimeWaiter_cleanup'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanup();
        return 0;
    }

    gxError("CTimeWaiter:cleanup has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTimeWaiter_cleanup'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTimeWaiter_getStartTime(lua_State* tolua_S)
{
    int argc = 0;
    CTimeWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTimeWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTimeWaiter_getStartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getStartTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeWaiter:getStartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTimeWaiter_getStartTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTimeWaiter_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CTimeWaiter* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CTimeWaiter();
        tolua_pushusertype(tolua_S,(void*)cobj,"CTimeWaiter");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CTimeWaiter:CTimeWaiter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CTimeWaiter_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTimeWaiter)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTimeWaiter",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CTimeWaiter* self = (CTimeWaiter*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CTimeWaiter(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTimeWaiter");
    tolua_cclass(tolua_S,"CTimeWaiter","CTimeWaiter","",lua_mapserver_CTimeWaiter_finalize);

    tolua_beginmodule(tolua_S,"CTimeWaiter");
        tolua_function(tolua_S,"new",lua_mapserver_CTimeWaiter_constructor);
        tolua_function(tolua_S,"setWaitTime",lua_mapserver_CTimeWaiter_setWaitTime);
        tolua_function(tolua_S,"update",lua_mapserver_CTimeWaiter_update);
        tolua_function(tolua_S,"isTimeout",lua_mapserver_CTimeWaiter_isTimeout);
        tolua_function(tolua_S,"setStartTime",lua_mapserver_CTimeWaiter_setStartTime);
        tolua_function(tolua_S,"getWaitTime",lua_mapserver_CTimeWaiter_getWaitTime);
        tolua_function(tolua_S,"cleanup",lua_mapserver_CTimeWaiter_cleanup);
        tolua_function(tolua_S,"getStartTime",lua_mapserver_CTimeWaiter_getStartTime);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CTimeWaiter).name();
    g_luaType[typeName] = "CTimeWaiter";
    g_typeCast["CTimeWaiter"] = "CTimeWaiter";
    return 1;
}

int lua_mapserver_CLoginWaiter_setLoadType(lua_State* tolua_S)
{
    int argc = 0;
    CLoginWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLoginWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLoginWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLoginWaiter_setLoadType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ELoadRoleType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLoginWaiter:setLoadType");
        if(!ok)
            return 0;
        cobj->setLoadType(arg0);
        return 0;
    }

    gxError("CLoginWaiter:setLoadType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLoginWaiter_setLoadType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLoginWaiter_getSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    CLoginWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLoginWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLoginWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLoginWaiter_getSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getSocketIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CLoginWaiter:getSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLoginWaiter_getSocketIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLoginWaiter_getLoadType(lua_State* tolua_S)
{
    int argc = 0;
    CLoginWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLoginWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLoginWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLoginWaiter_getLoadType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getLoadType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLoginWaiter:getLoadType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLoginWaiter_getLoadType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLoginWaiter_setSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    CLoginWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLoginWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLoginWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLoginWaiter_setSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CLoginWaiter:setSocketIndex");
        if(!ok)
            return 0;
        cobj->setSocketIndex(arg0);
        return 0;
    }

    gxError("CLoginWaiter:setSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLoginWaiter_setSocketIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLoginWaiter_cleanup(lua_State* tolua_S)
{
    int argc = 0;
    CLoginWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLoginWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLoginWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLoginWaiter_cleanup'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanup();
        return 0;
    }

    gxError("CLoginWaiter:cleanup has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLoginWaiter_cleanup'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLoginWaiter_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CLoginWaiter* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CLoginWaiter();
        tolua_pushusertype(tolua_S,(void*)cobj,"CLoginWaiter");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CLoginWaiter:CLoginWaiter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CLoginWaiter_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLoginWaiter)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLoginWaiter",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLoginWaiter* self = (CLoginWaiter*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLoginWaiter(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLoginWaiter");
    tolua_cclass(tolua_S,"CLoginWaiter","CLoginWaiter","",lua_mapserver_CLoginWaiter_finalize);

    tolua_beginmodule(tolua_S,"CLoginWaiter");
        tolua_function(tolua_S,"new",lua_mapserver_CLoginWaiter_constructor);
        tolua_function(tolua_S,"setLoadType",lua_mapserver_CLoginWaiter_setLoadType);
        tolua_function(tolua_S,"getSocketIndex",lua_mapserver_CLoginWaiter_getSocketIndex);
        tolua_function(tolua_S,"getLoadType",lua_mapserver_CLoginWaiter_getLoadType);
        tolua_function(tolua_S,"setSocketIndex",lua_mapserver_CLoginWaiter_setSocketIndex);
        tolua_function(tolua_S,"cleanup",lua_mapserver_CLoginWaiter_cleanup);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLoginWaiter).name();
    g_luaType[typeName] = "CLoginWaiter";
    g_typeCast["CLoginWaiter"] = "CLoginWaiter";
    return 1;
}

int lua_mapserver_CLogoutWaiter_setSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    CLogoutWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogoutWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLogoutWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLogoutWaiter_setSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CLogoutWaiter:setSocketIndex");
        if(!ok)
            return 0;
        cobj->setSocketIndex(arg0);
        return 0;
    }

    gxError("CLogoutWaiter:setSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLogoutWaiter_setSocketIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLogoutWaiter_setUnloadType(lua_State* tolua_S)
{
    int argc = 0;
    CLogoutWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogoutWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLogoutWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLogoutWaiter_setUnloadType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EUnloadRoleType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLogoutWaiter:setUnloadType");
        if(!ok)
            return 0;
        cobj->setUnloadType(arg0);
        return 0;
    }

    gxError("CLogoutWaiter:setUnloadType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLogoutWaiter_setUnloadType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLogoutWaiter_getNeedRet(lua_State* tolua_S)
{
    int argc = 0;
    CLogoutWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogoutWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLogoutWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLogoutWaiter_getNeedRet'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getNeedRet();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CLogoutWaiter:getNeedRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLogoutWaiter_getNeedRet'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLogoutWaiter_getUnloadType(lua_State* tolua_S)
{
    int argc = 0;
    CLogoutWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogoutWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLogoutWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLogoutWaiter_getUnloadType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getUnloadType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLogoutWaiter:getUnloadType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLogoutWaiter_getUnloadType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLogoutWaiter_getSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    CLogoutWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogoutWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLogoutWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLogoutWaiter_getSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getSocketIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CLogoutWaiter:getSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLogoutWaiter_getSocketIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLogoutWaiter_cleanup(lua_State* tolua_S)
{
    int argc = 0;
    CLogoutWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogoutWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLogoutWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLogoutWaiter_cleanup'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanup();
        return 0;
    }

    gxError("CLogoutWaiter:cleanup has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLogoutWaiter_cleanup'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLogoutWaiter_setNeedRet(lua_State* tolua_S)
{
    int argc = 0;
    CLogoutWaiter* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogoutWaiter",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLogoutWaiter*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLogoutWaiter_setNeedRet'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CLogoutWaiter:setNeedRet");
        if(!ok)
            return 0;
        cobj->setNeedRet(arg0);
        return 0;
    }

    gxError("CLogoutWaiter:setNeedRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLogoutWaiter_setNeedRet'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLogoutWaiter_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CLogoutWaiter* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CLogoutWaiter();
        tolua_pushusertype(tolua_S,(void*)cobj,"CLogoutWaiter");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CLogoutWaiter:CLogoutWaiter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CLogoutWaiter_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLogoutWaiter)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLogoutWaiter",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLogoutWaiter* self = (CLogoutWaiter*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLogoutWaiter(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLogoutWaiter");
    tolua_cclass(tolua_S,"CLogoutWaiter","CLogoutWaiter","",lua_mapserver_CLogoutWaiter_finalize);

    tolua_beginmodule(tolua_S,"CLogoutWaiter");
        tolua_function(tolua_S,"new",lua_mapserver_CLogoutWaiter_constructor);
        tolua_function(tolua_S,"setSocketIndex",lua_mapserver_CLogoutWaiter_setSocketIndex);
        tolua_function(tolua_S,"setUnloadType",lua_mapserver_CLogoutWaiter_setUnloadType);
        tolua_function(tolua_S,"getNeedRet",lua_mapserver_CLogoutWaiter_getNeedRet);
        tolua_function(tolua_S,"getUnloadType",lua_mapserver_CLogoutWaiter_getUnloadType);
        tolua_function(tolua_S,"getSocketIndex",lua_mapserver_CLogoutWaiter_getSocketIndex);
        tolua_function(tolua_S,"cleanup",lua_mapserver_CLogoutWaiter_cleanup);
        tolua_function(tolua_S,"setNeedRet",lua_mapserver_CLogoutWaiter_setNeedRet);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLogoutWaiter).name();
    g_luaType[typeName] = "CLogoutWaiter";
    g_typeCast["CLogoutWaiter"] = "CLogoutWaiter";
    return 1;
}

int lua_mapserver_CLoginWaiterManager_push(lua_State* tolua_S)
{
    int argc = 0;
    CLoginWaiterManager* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLoginWaiterManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLoginWaiterManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CLoginWaiterManager_push'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            EUnloadRoleType arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLoginWaiterManager:push");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CLoginWaiterManager:push");

            if (!ok) { break; }
            unsigned long long arg2;
            ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CLoginWaiterManager:push");

            if (!ok) { break; }
            cobj->push(arg0, arg1, arg2);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            ELoadRoleType arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLoginWaiterManager:push");

            if (!ok) { break; }
            unsigned long long arg1;
            ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CLoginWaiterManager:push");

            if (!ok) { break; }
            cobj->push(arg0, arg1);
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CLoginWaiterManager:push has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLoginWaiterManager_push'.",&tolua_err);
    return 0;
}
int lua_mapserver_CLoginWaiterManager_isLogin(lua_State* tolua_S)
{
    int argc = 0;
    CLoginWaiterManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLoginWaiterManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLoginWaiterManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLoginWaiterManager_isLogin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isLogin();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CLoginWaiterManager:isLogin has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLoginWaiterManager_isLogin'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLoginWaiterManager_isLogout(lua_State* tolua_S)
{
    int argc = 0;
    CLoginWaiterManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLoginWaiterManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLoginWaiterManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLoginWaiterManager_isLogout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isLogout();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CLoginWaiterManager:isLogout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLoginWaiterManager_isLogout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLoginWaiterManager_onLogin(lua_State* tolua_S)
{
    int argc = 0;
    CLoginWaiterManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLoginWaiterManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLoginWaiterManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLoginWaiterManager_onLogin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ELoadRoleType arg0;
        unsigned long long arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLoginWaiterManager:onLogin");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CLoginWaiterManager:onLogin");
        if(!ok)
            return 0;
        cobj->onLogin(arg0, arg1);
        return 0;
    }

    gxError("CLoginWaiterManager:onLogin has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLoginWaiterManager_onLogin'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLoginWaiterManager_onLogout(lua_State* tolua_S)
{
    int argc = 0;
    CLoginWaiterManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLoginWaiterManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLoginWaiterManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLoginWaiterManager_onLogout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EUnloadRoleType arg0;
        unsigned long long arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLoginWaiterManager:onLogout");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CLoginWaiterManager:onLogout");
        if(!ok)
            return 0;
        cobj->onLogout(arg0, arg1);
        return 0;
    }

    gxError("CLoginWaiterManager:onLogout has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLoginWaiterManager_onLogout'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CLoginWaiterManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLoginWaiterManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLoginWaiterManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLoginWaiterManager* self = (CLoginWaiterManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLoginWaiterManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLoginWaiterManager");
    tolua_cclass(tolua_S,"CLoginWaiterManager","CLoginWaiterManager","",nullptr);

    tolua_beginmodule(tolua_S,"CLoginWaiterManager");
        tolua_function(tolua_S,"push",lua_mapserver_CLoginWaiterManager_push);
        tolua_function(tolua_S,"isLogin",lua_mapserver_CLoginWaiterManager_isLogin);
        tolua_function(tolua_S,"isLogout",lua_mapserver_CLoginWaiterManager_isLogout);
        tolua_function(tolua_S,"onLogin",lua_mapserver_CLoginWaiterManager_onLogin);
        tolua_function(tolua_S,"onLogout",lua_mapserver_CLoginWaiterManager_onLogout);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLoginWaiterManager).name();
    g_luaType[typeName] = "CLoginWaiterManager";
    g_typeCast["CLoginWaiterManager"] = "CLoginWaiterManager";
    return 1;
}

int lua_mapserver_CConstantTbl_key2ToString(lua_State* tolua_S)
{
    int argc = 0;
    CConstantTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConstantTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CConstantTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CConstantTbl_key2ToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->key2ToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CConstantTbl:key2ToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CConstantTbl_key2ToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CConstantTbl_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CConstantTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConstantTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CConstantTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CConstantTbl_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CConstantTbl:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CConstantTbl_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CConstantTbl_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CConstantTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConstantTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CConstantTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CConstantTbl_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CConstantTbl:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CConstantTbl_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CConstantTbl_isKey2(lua_State* tolua_S)
{
    int argc = 0;
    CConstantTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConstantTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CConstantTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CConstantTbl_isKey2'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey2();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CConstantTbl:isKey2 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CConstantTbl_isKey2'.",&tolua_err);
	return 0;
}
int lua_mapserver_CConstantTbl_getKey2(lua_State* tolua_S)
{
    int argc = 0;
    CConstantTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConstantTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CConstantTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CConstantTbl_getKey2'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CCharArray2<250> ret = cobj->getKey2();
        array_string2_to_luaval(tolua_S,ret);
        return 1;
    }

    gxError("CConstantTbl:getKey2 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CConstantTbl_getKey2'.",&tolua_err);
	return 0;
}
int lua_mapserver_CConstantTbl_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CConstantTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConstantTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CConstantTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CConstantTbl_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CConstantTbl:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CConstantTbl_getKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CConstantTbl_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CConstantTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConstantTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CConstantTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CConstantTbl_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CConstantTbl:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CConstantTbl:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CConstantTbl_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CConstantTbl_toString(lua_State* tolua_S)
{
    int argc = 0;
    CConstantTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConstantTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CConstantTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CConstantTbl_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CConstantTbl:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CConstantTbl_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CConstantTbl_setKey2(lua_State* tolua_S)
{
    int argc = 0;
    CConstantTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConstantTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CConstantTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CConstantTbl_setKey2'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharArray2<250> arg0;

        ok &= luaval_to_array_string2(tolua_S, 2,&arg0, "CConstantTbl:setKey2");
        if(!ok)
            return 0;
        cobj->setKey2(arg0);
        return 0;
    }

    gxError("CConstantTbl:setKey2 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CConstantTbl_setKey2'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CConstantTbl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CConstantTbl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CConstantTbl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CConstantTbl* self = (CConstantTbl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CConstantTbl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CConstantTbl");
    tolua_cclass(tolua_S,"CConstantTbl","CConstantTbl","CConfigTbl",nullptr);

    tolua_beginmodule(tolua_S,"CConstantTbl");
        tolua_function(tolua_S,"key2ToString",lua_mapserver_CConstantTbl_key2ToString);
        tolua_function(tolua_S,"isKey",lua_mapserver_CConstantTbl_isKey);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CConstantTbl_keyToString);
        tolua_function(tolua_S,"isKey2",lua_mapserver_CConstantTbl_isKey2);
        tolua_function(tolua_S,"getKey2",lua_mapserver_CConstantTbl_getKey2);
        tolua_function(tolua_S,"getKey",lua_mapserver_CConstantTbl_getKey);
        tolua_function(tolua_S,"setKey",lua_mapserver_CConstantTbl_setKey);
        tolua_function(tolua_S,"toString",lua_mapserver_CConstantTbl_toString);
        tolua_function(tolua_S,"setKey2",lua_mapserver_CConstantTbl_setKey2);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CConstantTbl).name();
    g_luaType[typeName] = "CConstantTbl";
    g_typeCast["CConstantTbl"] = "CConstantTbl";
    return 1;
}

int lua_mapserver_CConstantTblLoader_readRow(lua_State* tolua_S)
{
    int argc = 0;
    CConstantTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConstantTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CConstantTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CConstantTblLoader_readRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        TiXmlElement* arg0;
        int arg1;
        CConstantTbl* arg2;

        ok &= luaval_to_object<TiXmlElement>(tolua_S, 2, "TiXmlElement", &arg0, "CConstantTblLoader:readRow");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CConstantTblLoader:readRow");

        ok &= luaval_to_object<CConstantTbl>(tolua_S, 4, "CConstantTbl", &arg2, "CConstantTblLoader:readRow");
        if(!ok)
            return 0;
        bool ret = cobj->readRow(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CConstantTblLoader:readRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CConstantTblLoader_readRow'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CConstantTblLoader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CConstantTblLoader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CConstantTblLoader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CConstantTblLoader* self = (CConstantTblLoader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CConstantTblLoader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CConstantTblLoader");
    tolua_cclass(tolua_S,"CConstantTblLoader","CConstantTblLoader","CConfigLoader2<CConstantTblLoader, CConstantTbl>",nullptr);

    tolua_beginmodule(tolua_S,"CConstantTblLoader");
        tolua_function(tolua_S,"readRow",lua_mapserver_CConstantTblLoader_readRow);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CConstantTblLoader).name();
    g_luaType[typeName] = "CConstantTblLoader";
    g_typeCast["CConstantTblLoader"] = "CConstantTblLoader";
    return 1;
}

int lua_mapserver_FightRecord_openGuanQiaFight(lua_State* tolua_S)
{
    int argc = 0;
    FightRecord* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"FightRecord",0,&tolua_err)) goto tolua_lerror;
    cobj = (FightRecord*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_FightRecord_openGuanQiaFight'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        unsigned short arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "FightRecord:openGuanQiaFight");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "FightRecord:openGuanQiaFight");
        if(!ok)
            return 0;
        cobj->openGuanQiaFight(arg0, arg1);
        return 0;
    }

    gxError("FightRecord:openGuanQiaFight has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_FightRecord_openGuanQiaFight'.",&tolua_err);
	return 0;
}
int lua_mapserver_FightRecord_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    FightRecord* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"FightRecord",0,&tolua_err)) goto tolua_lerror;
    cobj = (FightRecord*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_FightRecord_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("FightRecord:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_FightRecord_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_FightRecord_isGuanQiaFight(lua_State* tolua_S)
{
    int argc = 0;
    FightRecord* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"FightRecord",0,&tolua_err)) goto tolua_lerror;
    cobj = (FightRecord*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_FightRecord_isGuanQiaFight'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isGuanQiaFight();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("FightRecord:isGuanQiaFight has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_FightRecord_isGuanQiaFight'.",&tolua_err);
	return 0;
}
int lua_mapserver_FightRecord_isFight(lua_State* tolua_S)
{
    int argc = 0;
    FightRecord* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"FightRecord",0,&tolua_err)) goto tolua_lerror;
    cobj = (FightRecord*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_FightRecord_isFight'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isFight();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("FightRecord:isFight has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_FightRecord_isFight'.",&tolua_err);
	return 0;
}
static int lua_mapserver_FightRecord_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (FightRecord)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"FightRecord",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        FightRecord* self = (FightRecord*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_FightRecord(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"FightRecord");
    tolua_cclass(tolua_S,"FightRecord","FightRecord","",nullptr);

    tolua_beginmodule(tolua_S,"FightRecord");
        tolua_function(tolua_S,"openGuanQiaFight",lua_mapserver_FightRecord_openGuanQiaFight);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_FightRecord_cleanUp);
        tolua_function(tolua_S,"isGuanQiaFight",lua_mapserver_FightRecord_isGuanQiaFight);
        tolua_function(tolua_S,"isFight",lua_mapserver_FightRecord_isFight);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(FightRecord).name();
    g_luaType[typeName] = "FightRecord";
    g_typeCast["FightRecord"] = "FightRecord";
    return 1;
}

int lua_mapserver_CModFight_getFightRecrod(lua_State* tolua_S)
{
    int argc = 0;
    CModFight* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModFight",0,&tolua_err)) goto tolua_lerror;
    cobj = (CModFight*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CModFight_getFightRecrod'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        FightRecord* ret = cobj->getFightRecrod();
        object_to_luaval<FightRecord>(tolua_S, "FightRecord",(FightRecord*)ret);
        return 1;
    }

    gxError("CModFight:getFightRecrod has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CModFight_getFightRecrod'.",&tolua_err);
	return 0;
}
int lua_mapserver_CModFight_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CModFight* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CModFight();
        tolua_pushusertype(tolua_S,(void*)cobj,"CModFight");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CModFight:CModFight has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CModFight_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CModFight)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CModFight",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CModFight* self = (CModFight*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CModFight(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CModFight");
    tolua_cclass(tolua_S,"CModFight","CModFight","CGameRoleModule",lua_mapserver_CModFight_finalize);

    tolua_beginmodule(tolua_S,"CModFight");
        tolua_function(tolua_S,"new",lua_mapserver_CModFight_constructor);
        tolua_function(tolua_S,"getFightRecrod",lua_mapserver_CModFight_getFightRecrod);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CModFight).name();
    g_luaType[typeName] = "CModFight";
    g_typeCast["CModFight"] = "CModFight";
    return 1;
}

int lua_mapserver_CTransportConfigTbl_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CTransportConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTransportConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTransportConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTransportConfigTbl_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTransportConfigTbl:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTransportConfigTbl_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTransportConfigTbl_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CTransportConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTransportConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTransportConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTransportConfigTbl_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CTransportConfigTbl:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTransportConfigTbl_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTransportConfigTbl_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CTransportConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTransportConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTransportConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTransportConfigTbl_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTransportConfigTbl:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CTransportConfigTbl:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTransportConfigTbl_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTransportConfigTbl_toString(lua_State* tolua_S)
{
    int argc = 0;
    CTransportConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTransportConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTransportConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTransportConfigTbl_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CTransportConfigTbl:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTransportConfigTbl_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTransportConfigTbl_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CTransportConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTransportConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTransportConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTransportConfigTbl_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTransportConfigTbl:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTransportConfigTbl_getKey'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CTransportConfigTbl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTransportConfigTbl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTransportConfigTbl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CTransportConfigTbl* self = (CTransportConfigTbl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CTransportConfigTbl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTransportConfigTbl");
    tolua_cclass(tolua_S,"CTransportConfigTbl","CTransportConfigTbl","CConfigTbl",nullptr);

    tolua_beginmodule(tolua_S,"CTransportConfigTbl");
        tolua_function(tolua_S,"isKey",lua_mapserver_CTransportConfigTbl_isKey);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CTransportConfigTbl_keyToString);
        tolua_function(tolua_S,"setKey",lua_mapserver_CTransportConfigTbl_setKey);
        tolua_function(tolua_S,"toString",lua_mapserver_CTransportConfigTbl_toString);
        tolua_function(tolua_S,"getKey",lua_mapserver_CTransportConfigTbl_getKey);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CTransportConfigTbl).name();
    g_luaType[typeName] = "CTransportConfigTbl";
    g_typeCast["CTransportConfigTbl"] = "CTransportConfigTbl";
    return 1;
}

int lua_mapserver_CTransportTblLoader_getDestPos(lua_State* tolua_S)
{
    int argc = 0;
    CTransportTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTransportTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTransportTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTransportTblLoader_getDestPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        int arg0;
        unsigned short arg1;
        AxisPos arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTransportTblLoader:getDestPos");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CTransportTblLoader:getDestPos");

        ok &= luaval_to_axispos(tolua_S, 4, "AxisPos", &arg2, "CTransportTblLoader:getDestPos");
        if(!ok)
            return 0;
        bool ret = cobj->getDestPos(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTransportTblLoader:getDestPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTransportTblLoader_getDestPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTransportTblLoader_findByKey(lua_State* tolua_S)
{
    int argc = 0;
    CTransportTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTransportTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTransportTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTransportTblLoader_findByKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTransportTblLoader:findByKey");
        if(!ok)
            return 0;
        CTransportConfigTbl* ret = cobj->findByKey(arg0);
        object_to_luaval<CTransportConfigTbl>(tolua_S, "CTransportConfigTbl",(CTransportConfigTbl*)ret);
        return 1;
    }

    gxError("CTransportTblLoader:findByKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTransportTblLoader_findByKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTransportTblLoader_readRow(lua_State* tolua_S)
{
    int argc = 0;
    CTransportTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTransportTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CTransportTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CTransportTblLoader_readRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        TiXmlElement* arg0;
        int arg1;
        CTransportConfigTbl* arg2;

        ok &= luaval_to_object<TiXmlElement>(tolua_S, 2, "TiXmlElement", &arg0, "CTransportTblLoader:readRow");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CTransportTblLoader:readRow");

        ok &= luaval_to_object<CTransportConfigTbl>(tolua_S, 4, "CTransportConfigTbl", &arg2, "CTransportTblLoader:readRow");
        if(!ok)
            return 0;
        bool ret = cobj->readRow(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTransportTblLoader:readRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTransportTblLoader_readRow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CTransportTblLoader_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTransportTblLoader",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CTransportTblLoader* ret = CTransportTblLoader::GetPtr();
        object_to_luaval<CTransportTblLoader>(tolua_S, "CTransportTblLoader",(CTransportTblLoader*)ret);
        return 1;
    }
    gxError("CTransportTblLoader:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CTransportTblLoader_GetPtr'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CTransportTblLoader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTransportTblLoader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTransportTblLoader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CTransportTblLoader* self = (CTransportTblLoader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CTransportTblLoader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTransportTblLoader");
    tolua_cclass(tolua_S,"CTransportTblLoader","CTransportTblLoader","CConfigLoader<CTransportTblLoader, CTransportConfigTbl>",nullptr);

    tolua_beginmodule(tolua_S,"CTransportTblLoader");
        tolua_function(tolua_S,"getDestPos",lua_mapserver_CTransportTblLoader_getDestPos);
        tolua_function(tolua_S,"findByKey",lua_mapserver_CTransportTblLoader_findByKey);
        tolua_function(tolua_S,"readRow",lua_mapserver_CTransportTblLoader_readRow);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CTransportTblLoader_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CTransportTblLoader).name();
    g_luaType[typeName] = "CTransportTblLoader";
    g_typeCast["CTransportTblLoader"] = "CTransportTblLoader";
    return 1;
}

static int lua_mapserver_CRoleScriptObject_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CRoleScriptObject)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CRoleScriptObject",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CRoleScriptObject* self = (CRoleScriptObject*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CRoleScriptObject(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CRoleScriptObject");
    tolua_cclass(tolua_S,"CRoleScriptObject","CRoleScriptObject","IScriptObject",nullptr);

    tolua_beginmodule(tolua_S,"CRoleScriptObject");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CRoleScriptObject).name();
    g_luaType[typeName] = "CRoleScriptObject";
    g_typeCast["CRoleScriptObject"] = "CRoleScriptObject";
    return 1;
}

int lua_mapserver_CRole_setStrength(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setStrength'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:setStrength");
        if(!ok)
            return 0;
        cobj->setStrength(arg0);
        return 0;
    }

    gxError("CRole:setStrength has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setStrength'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getRmb(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getRmb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getRmb();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getRmb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setGameMoney(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setGameMoney'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:setGameMoney");
        if(!ok)
            return 0;
        cobj->setGameMoney(arg0);
        return 0;
    }

    gxError("CRole:setGameMoney has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setGameMoney'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_sendOtherChangeScene(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_sendOtherChangeScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned int arg0;
        unsigned long long arg1;
        const AxisPos* arg2;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRole:sendOtherChangeScene");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRole:sendOtherChangeScene");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CRole:sendOtherChangeScene");
        if(!ok)
            return 0;
        cobj->sendOtherChangeScene(arg0, arg1, arg2);
        return 0;
    }

    gxError("CRole:sendOtherChangeScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_sendOtherChangeScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_move(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_move'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CArray1<AxisPos, 100>* arg0;

        ok &= luaval_to_object<CArray1<AxisPos, 100>>(tolua_S, 2, "CArray1<AxisPos, 100>", &arg0, "CRole:move");
        if(!ok)
            return 0;
        bool ret = cobj->move(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:move has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_move'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getStrength(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getStrength'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getStrength();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getStrength has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getStrength'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getbagOpenGridNum(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getbagOpenGridNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getbagOpenGridNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getbagOpenGridNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getbagOpenGridNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onMissionSubmit(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onMissionSubmit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned short arg0;
        EMissionType arg1;
        _OwnMission* arg2;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CRole:onMissionSubmit");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:onMissionSubmit");

        ok &= luaval_to_object<_OwnMission>(tolua_S, 4, "_OwnMission", &arg2, "CRole:onMissionSubmit");
        if(!ok)
            return 0;
        cobj->onMissionSubmit(arg0, arg1, arg2);
        return 0;
    }

    gxError("CRole:onMissionSubmit has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onMissionSubmit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getGameMoney(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getGameMoney'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getGameMoney();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getGameMoney has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getGameMoney'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setLocalServerLogin(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setLocalServerLogin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:setLocalServerLogin");
        if(!ok)
            return 0;
        cobj->setLocalServerLogin(arg0);
        return 0;
    }

    gxError("CRole:setLocalServerLogin has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setLocalServerLogin'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_handleGetRoleAttr(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_handleGetRoleAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EAttributes arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:handleGetRoleAttr");
        if(!ok)
            return 0;
        int ret = cobj->handleGetRoleAttr(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:handleGetRoleAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_handleGetRoleAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getScriptHandler(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getScriptHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CRoleScriptObject* ret = cobj->getScriptHandler();
        object_to_luaval<CRoleScriptObject>(tolua_S, "CRoleScriptObject",(CRoleScriptObject*)ret);
        return 1;
    }

    gxError("CRole:getScriptHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getScriptHandler'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isOfflineTime(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CRole_isOfflineTime'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 6) {
            short arg0;
            ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CRole:isOfflineTime");

            if (!ok) { break; }
            char arg1;
            ok &= luaval_to_sint8(tolua_S, 3,(sint8*)&arg1, "CRole:isOfflineTime");

            if (!ok) { break; }
            char arg2;
            ok &= luaval_to_sint8(tolua_S, 4,(sint8*)&arg2, "CRole:isOfflineTime");

            if (!ok) { break; }
            char arg3;
            ok &= luaval_to_sint8(tolua_S, 5,(sint8*)&arg3, "CRole:isOfflineTime");

            if (!ok) { break; }
            char arg4;
            ok &= luaval_to_sint8(tolua_S, 6,(sint8*)&arg4, "CRole:isOfflineTime");

            if (!ok) { break; }
            char arg5;
            ok &= luaval_to_sint8(tolua_S, 7,(sint8*)&arg5, "CRole:isOfflineTime");

            if (!ok) { break; }
            bool ret = cobj->isOfflineTime(arg0, arg1, arg2, arg3, arg4, arg5);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRole:isOfflineTime");

            if (!ok) { break; }
            bool ret = cobj->isOfflineTime(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CRole:isOfflineTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isOfflineTime'.",&tolua_err);
    return 0;
}
int lua_mapserver_CRole_getChangeLineWait(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getChangeLineWait'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        ChangeLineWait* ret = cobj->getChangeLineWait();
        object_to_luaval<ChangeLineWait>(tolua_S, "ChangeLineWait",(ChangeLineWait*)ret);
        return 1;
    }

    gxError("CRole:getChangeLineWait has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getChangeLineWait'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getRoleUserData(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getRoleUserData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CWorldUserData* arg0;

        ok &= luaval_to_object<CWorldUserData>(tolua_S, 2, "CWorldUserData", &arg0, "CRole:getRoleUserData");
        if(!ok)
            return 0;
        cobj->getRoleUserData(arg0);
        return 0;
    }

    gxError("CRole:getRoleUserData has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getRoleUserData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isChangeMap(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isChangeMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isChangeMap();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:isChangeMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isChangeMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setChangePos(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setChangePos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned long long arg0;
        const AxisPos* arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRole:setChangePos");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CRole:setChangePos");
        if(!ok)
            return 0;
        cobj->setChangePos(arg0, arg1);
        return 0;
    }

    gxError("CRole:setChangePos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setChangePos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onChangeMap(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onChangeMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned long long arg0;
        const AxisPos* arg1;
        ETeleportType arg2;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRole:onChangeMap");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CRole:onChangeMap");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CRole:onChangeMap");
        if(!ok)
            return 0;
        bool ret = cobj->onChangeMap(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onChangeMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onChangeMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isFirstLoginInDay(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isFirstLoginInDay'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isFirstLoginInDay();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:isFirstLoginInDay has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isFirstLoginInDay'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onLeaveScene(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onLeaveScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapSceneBase* arg0;

        ok &= luaval_to_object<CMapSceneBase>(tolua_S, 2, "CMapSceneBase", &arg0, "CRole:onLeaveScene");
        if(!ok)
            return 0;
        cobj->onLeaveScene(arg0);
        return 0;
    }

    gxError("CRole:onLeaveScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onLeaveScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onAddToLogout(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onAddToLogout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onAddToLogout();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onAddToLogout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onAddToLogout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getBufferMod(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getBufferMod'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CModBuffer* ret = cobj->getBufferMod();
        object_to_luaval<CModBuffer>(tolua_S, "CModBuffer",(CModBuffer*)ret);
        return 1;
    }

    gxError("CRole:getBufferMod has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getBufferMod'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isChangeLineWait(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isChangeLineWait'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isChangeLineWait();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:isChangeLineWait has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isChangeLineWait'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getOfflineHours(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getOfflineHours'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getOfflineHours();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getOfflineHours has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getOfflineHours'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isDbModBusy(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isDbModBusy'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDbModBusy();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:isDbModBusy has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isDbModBusy'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getBagMod(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getBagMod'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CModBag* ret = cobj->getBagMod();
        object_to_luaval<CModBag>(tolua_S, "CModBag",(CModBag*)ret);
        return 1;
    }

    gxError("CRole:getBagMod has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getBagMod'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getLastSceneID(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getLastSceneID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getLastSceneID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CRole:getLastSceneID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getLastSceneID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_kick(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_kick'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:kick");
        if(!ok)
            return 0;
        cobj->kick(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        bool arg0;
        int arg1;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:kick");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:kick");
        if(!ok)
            return 0;
        cobj->kick(arg0, arg1);
        return 0;
    }
    if (argc == 3) 
    {
        bool arg0;
        int arg1;
        std::string arg2;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:kick");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:kick");

        ok &= luaval_to_std_string(tolua_S, 4,&arg2, "CRole:kick");
        if(!ok)
            return 0;
        cobj->kick(arg0, arg1, arg2);
        return 0;
    }

    gxError("CRole:kick has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_kick'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getScriptObject(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getScriptObject'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        lua_tinker::s_object ret = cobj->getScriptObject();
        lua_tinker::push(tolua_S,ret);
        return 1;
    }

    gxError("CRole:getScriptObject has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getScriptObject'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setLastMapID(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setLastMapID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CRole:setLastMapID");
        if(!ok)
            return 0;
        cobj->setLastMapID(arg0);
        return 0;
    }

    gxError("CRole:setLastMapID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setLastMapID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_randName(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_randName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->randName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CRole:randName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_randName'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isNeedInit(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isNeedInit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNeedInit();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:isNeedInit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isNeedInit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_sendErrorCode(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_sendErrorCode'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EGameRetCode arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:sendErrorCode");
        if(!ok)
            return 0;
        cobj->sendErrorCode(arg0);
        return 0;
    }

    gxError("CRole:sendErrorCode has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_sendErrorCode'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isOfflineDayTime(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isOfflineDayTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CRole:isOfflineDayTime");
        if(!ok)
            return 0;
        bool ret = cobj->isOfflineDayTime(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 2) 
    {
        char arg0;
        char arg1;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CRole:isOfflineDayTime");

        ok &= luaval_to_sint8(tolua_S, 3,(sint8*)&arg1, "CRole:isOfflineDayTime");
        if(!ok)
            return 0;
        bool ret = cobj->isOfflineDayTime(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 3) 
    {
        char arg0;
        char arg1;
        char arg2;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CRole:isOfflineDayTime");

        ok &= luaval_to_sint8(tolua_S, 3,(sint8*)&arg1, "CRole:isOfflineDayTime");

        ok &= luaval_to_sint8(tolua_S, 4,(sint8*)&arg2, "CRole:isOfflineDayTime");
        if(!ok)
            return 0;
        bool ret = cobj->isOfflineDayTime(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:isOfflineDayTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isOfflineDayTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getOnlineMins(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getOnlineMins'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getOnlineMins();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getOnlineMins has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getOnlineMins'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_descAllRmb(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_descAllRmb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:descAllRmb");
        if(!ok)
            return 0;
        int ret = cobj->descAllRmb(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:descAllRmb");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRole:descAllRmb");
        if(!ok)
            return 0;
        int ret = cobj->descAllRmb(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:descAllRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_descAllRmb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onHourTimer(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onHourTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CRole:onHourTimer");
        if(!ok)
            return 0;
        cobj->onHourTimer(arg0);
        return 0;
    }

    gxError("CRole:onHourTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onHourTimer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getMapServerData(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getMapServerData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapServerData* ret = cobj->getMapServerData();
        object_to_luaval<CMapServerData>(tolua_S, "CMapServerData",(CMapServerData*)ret);
        return 1;
    }

    gxError("CRole:getMapServerData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getMapServerData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setSex(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setSex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CRole:setSex");
        if(!ok)
            return 0;
        cobj->setSex(arg0);
        return 0;
    }

    gxError("CRole:setSex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setSex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onAddToReady(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onAddToReady'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onAddToReady();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onAddToReady has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onAddToReady'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getChatMod(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getChatMod'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CModChat* ret = cobj->getChatMod();
        object_to_luaval<CModChat>(tolua_S, "CModChat",(CModChat*)ret);
        return 1;
    }

    gxError("CRole:getChatMod has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getChatMod'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onEnterScene(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onEnterScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapSceneBase* arg0;

        ok &= luaval_to_object<CMapSceneBase>(tolua_S, 2, "CMapSceneBase", &arg0, "CRole:onEnterScene");
        if(!ok)
            return 0;
        cobj->onEnterScene(arg0);
        return 0;
    }

    gxError("CRole:onEnterScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onEnterScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_toWorldKick(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_toWorldKick'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->toWorldKick();
        return 0;
    }

    gxError("CRole:toWorldKick has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_toWorldKick'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onEnter(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onEnter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onEnter();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onEnter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onEnter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onLogin(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onLogin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onLogin();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onLogin has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onLogin'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_handleRoleAttr(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_handleRoleAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EAttributes arg0;
        int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:handleRoleAttr");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:handleRoleAttr");
        if(!ok)
            return 0;
        cobj->handleRoleAttr(arg0, arg1);
        return 0;
    }

    gxError("CRole:handleRoleAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_handleRoleAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getBindRmb(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getBindRmb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getBindRmb();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getBindRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getBindRmb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_enterScene(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CRole_enterScene'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            unsigned long long arg0;
            ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRole:enterScene");

            if (!ok) { break; }
            bool ret = cobj->enterScene(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CRole:enterScene");

            if (!ok) { break; }
            bool ret = cobj->enterScene(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CRole:enterScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_enterScene'.",&tolua_err);
    return 0;
}
int lua_mapserver_CRole_onAfterChangeMap(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onAfterChangeMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        unsigned long long arg0;
        const AxisPos* arg1;
        ELoadRoleType arg2;
        ETeleportType arg3;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRole:onAfterChangeMap");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CRole:onAfterChangeMap");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CRole:onAfterChangeMap");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CRole:onAfterChangeMap");
        if(!ok)
            return 0;
        bool ret = cobj->onAfterChangeMap(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onAfterChangeMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onAfterChangeMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onUnloadRole(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onUnloadRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EUnloadRoleType arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:onUnloadRole");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRole:onUnloadRole");
        if(!ok)
            return 0;
        cobj->onUnloadRole(arg0, arg1);
        return 0;
    }

    gxError("CRole:onUnloadRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onUnloadRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_leaveScene(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_leaveScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:leaveScene");
        if(!ok)
            return 0;
        cobj->leaveScene(arg0);
        return 0;
    }

    gxError("CRole:leaveScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_leaveScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getSex(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getSex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getSex();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getSex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getSex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_handleAddMoneyPort(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_handleAddMoneyPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EAttributes arg0;
        int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:handleAddMoneyPort");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:handleAddMoneyPort");
        if(!ok)
            return 0;
        cobj->handleAddMoneyPort(arg0, arg1);
        return 0;
    }
    if (argc == 3) 
    {
        EAttributes arg0;
        int arg1;
        EMoneyRecordTouchType arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:handleAddMoneyPort");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:handleAddMoneyPort");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CRole:handleAddMoneyPort");
        if(!ok)
            return 0;
        cobj->handleAddMoneyPort(arg0, arg1, arg2);
        return 0;
    }

    gxError("CRole:handleAddMoneyPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_handleAddMoneyPort'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_loadBaseAttr(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_loadBaseAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CAttrBase<int, 49>* arg0;

        ok &= luaval_to_object<CAttrBase<int, 49>>(tolua_S, 2, "CAttrBase<int, 49>", &arg0, "CRole:loadBaseAttr");
        if(!ok)
            return 0;
        cobj->loadBaseAttr(arg0);
        return 0;
    }

    gxError("CRole:loadBaseAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_loadBaseAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getSceneRecord(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getSceneRecord'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        RoleSceneRecord* ret = cobj->getSceneRecord();
        object_to_luaval<RoleSceneRecord>(tolua_S, "RoleSceneRecord",(RoleSceneRecord*)ret);
        return 1;
    }

    gxError("CRole:getSceneRecord has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getSceneRecord'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getOfflineMins(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getOfflineMins'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getOfflineMins();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getOfflineMins has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getOfflineMins'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getMaxLevel(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getMaxLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getMaxLevel();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getMaxLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getMaxLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_sendKickMsg(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_sendKickMsg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EKickType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:sendKickMsg");
        if(!ok)
            return 0;
        cobj->sendKickMsg(arg0);
        return 0;
    }

    gxError("CRole:sendKickMsg has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_sendKickMsg'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onAddItem(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onAddItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        EItemRecordType arg0;
        EPackType arg1;
        unsigned short arg2;
        short arg3;
        unsigned char arg4;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:onAddItem");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:onAddItem");

        ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CRole:onAddItem");

        ok &= luaval_to_sint16(tolua_S, 5,(sint16*)&arg3, "CRole:onAddItem");

        ok &= luaval_to_uint8(tolua_S, 6,(uint8*)&arg4, "CRole:onAddItem");
        if(!ok)
            return 0;
        cobj->onAddItem(arg0, arg1, arg2, arg3, arg4);
        return 0;
    }

    gxError("CRole:onAddItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onAddItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_heartToWorld(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_heartToWorld'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:heartToWorld");
        if(!ok)
            return 0;
        cobj->heartToWorld(arg0);
        return 0;
    }

    gxError("CRole:heartToWorld has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_heartToWorld'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setLoadWaitInfo(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setLoadWaitInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        ELoadRoleType arg0;
        unsigned long long arg1;
        const AxisPos* arg2;
        bool arg3;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:setLoadWaitInfo");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRole:setLoadWaitInfo");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CRole:setLoadWaitInfo");

        ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CRole:setLoadWaitInfo");
        if(!ok)
            return 0;
        cobj->setLoadWaitInfo(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CRole:setLoadWaitInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setLoadWaitInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onQuit(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onQuit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onQuit();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onQuit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onQuit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isChangeLine(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isChangeLine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isChangeLine();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:isChangeLine has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isChangeLine'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_initClient(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_initClient'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->initClient();
        return 0;
    }

    gxError("CRole:initClient has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_initClient'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_initCharacter(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_initCharacter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->initCharacter();
        return 0;
    }

    gxError("CRole:initCharacter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_initCharacter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onNewLogin(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onNewLogin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onNewLogin();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onNewLogin has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onNewLogin'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onLoad(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        RoleManageInfo* arg0;
        CHumanDBBackup* arg1;
        LoadRoleData* arg2;
        ChangeLineTempData* arg3;
        bool arg4;

        ok &= luaval_to_object<RoleManageInfo>(tolua_S, 2, "RoleManageInfo", &arg0, "CRole:onLoad");

        ok &= luaval_to_object<CHumanDBBackup>(tolua_S, 3, "CHumanDBBackup", &arg1, "CRole:onLoad");

        ok &= luaval_to_object<LoadRoleData>(tolua_S, 4, "LoadRoleData", &arg2, "CRole:onLoad");

        ok &= luaval_to_object<ChangeLineTempData>(tolua_S, 5, "ChangeLineTempData", &arg3, "CRole:onLoad");

        ok &= luaval_to_boolean(tolua_S, 6,(bool*)&arg4, "CRole:onLoad");
        if(!ok)
            return 0;
        bool ret = cobj->onLoad(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onLoad'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onFiveSecondTimer(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onFiveSecondTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onFiveSecondTimer();
        return 0;
    }

    gxError("CRole:onFiveSecondTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onFiveSecondTimer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isMaxStrength(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isMaxStrength'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isMaxStrength();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:isMaxStrength has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isMaxStrength'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_roleMove(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_roleMove'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CArray1<AxisPos, 100>* arg0;
        ERoleMoveType arg1;

        ok &= luaval_to_object<CArray1<AxisPos, 100>>(tolua_S, 2, "CArray1<AxisPos, 100>", &arg0, "CRole:roleMove");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:roleMove");
        if(!ok)
            return 0;
        bool ret = cobj->roleMove(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:roleMove has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_roleMove'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_addBindRmb(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_addBindRmb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:addBindRmb");
        if(!ok)
            return 0;
        int ret = cobj->addBindRmb(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:addBindRmb");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRole:addBindRmb");
        if(!ok)
            return 0;
        int ret = cobj->addBindRmb(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:addBindRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_addBindRmb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onLogout(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onLogout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onLogout();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onLogout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onLogout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_sendTimerUpdateData(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_sendTimerUpdateData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        bool arg0;
        ESaveRoleType arg1;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:sendTimerUpdateData");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:sendTimerUpdateData");
        if(!ok)
            return 0;
        cobj->sendTimerUpdateData(arg0, arg1);
        return 0;
    }

    gxError("CRole:sendTimerUpdateData has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_sendTimerUpdateData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onFightFinish(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onFightFinish'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        bool arg0;
        int arg1;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:onFightFinish");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:onFightFinish");
        if(!ok)
            return 0;
        cobj->onFightFinish(arg0, arg1);
        return 0;
    }

    gxError("CRole:onFightFinish has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onFightFinish'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getMissionMod(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getMissionMod'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CModMission* ret = cobj->getMissionMod();
        object_to_luaval<CModMission>(tolua_S, "CModMission",(CModMission*)ret);
        return 1;
    }

    gxError("CRole:getMissionMod has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getMissionMod'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onChangeLineRet(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onChangeLineRet'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onChangeLineRet();
        return 0;
    }

    gxError("CRole:onChangeLineRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onChangeLineRet'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_on12Timer(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_on12Timer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->on12Timer();
        return 0;
    }

    gxError("CRole:on12Timer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_on12Timer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getExp(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getExp();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getScenData(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getScenData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CArray1<unsigned short, 100>* arg0;
        CArray1<unsigned short, 100>* arg1;

        ok &= luaval_to_object<CArray1<unsigned short, 100>>(tolua_S, 2, "CArray1<unsigned short, 100>", &arg0, "CRole:getScenData");

        ok &= luaval_to_object<CArray1<unsigned short, 100>>(tolua_S, 3, "CArray1<unsigned short, 100>", &arg1, "CRole:getScenData");
        if(!ok)
            return 0;
        cobj->getScenData(arg0, arg1);
        return 0;
    }

    gxError("CRole:getScenData has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getScenData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_handleGetTokenOrItem(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_handleGetTokenOrItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CRole:handleGetTokenOrItem");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleGetTokenOrItem(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:handleGetTokenOrItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_handleGetTokenOrItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_changeLine(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_changeLine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        unsigned short arg0;
        unsigned long long arg1;
        const AxisPos* arg2;
        ETeleportType arg3;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CRole:changeLine");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRole:changeLine");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CRole:changeLine");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CRole:changeLine");
        if(!ok)
            return 0;
        int ret = (int)cobj->changeLine(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:changeLine has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_changeLine'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_reLogin(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_reLogin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->reLogin();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:reLogin has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_reLogin'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getLoginManager(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getLoginManager'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CLoginWaiterManager* ret = cobj->getLoginManager();
        object_to_luaval<CLoginWaiterManager>(tolua_S, "CLoginWaiterManager",(CLoginWaiterManager*)ret);
        return 1;
    }

    gxError("CRole:getLoginManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getLoginManager'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getHumanBaseData(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getHumanBaseData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CHumanBaseData* ret = cobj->getHumanBaseData();
        object_to_luaval<CHumanBaseData>(tolua_S, "CHumanBaseData",(CHumanBaseData*)ret);
        return 1;
    }

    gxError("CRole:getHumanBaseData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getHumanBaseData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isForbbidChat(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isForbbidChat'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRole:isForbbidChat");
        if(!ok)
            return 0;
        bool ret = cobj->isForbbidChat(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:isForbbidChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isForbbidChat'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setExp(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:setExp");
        if(!ok)
            return 0;
        cobj->setExp(arg0);
        return 0;
    }

    gxError("CRole:setExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setVipExp(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setVipExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:setVipExp");
        if(!ok)
            return 0;
        cobj->setVipExp(arg0);
        return 0;
    }

    gxError("CRole:setVipExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setVipExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_addVipLevel(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_addVipLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CRole:addVipLevel");
        if(!ok)
            return 0;
        unsigned char ret = cobj->addVipLevel(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned char arg0;
        bool arg1;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CRole:addVipLevel");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRole:addVipLevel");
        if(!ok)
            return 0;
        unsigned char ret = cobj->addVipLevel(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:addVipLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_addVipLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setCreateTime(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setCreateTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRole:setCreateTime");
        if(!ok)
            return 0;
        cobj->setCreateTime(arg0);
        return 0;
    }

    gxError("CRole:setCreateTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setCreateTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getVipLevel(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getVipLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getVipLevel();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getVipLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getVipLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setMapID(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setMapID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CRole:setMapID");
        if(!ok)
            return 0;
        cobj->setMapID(arg0);
        return 0;
    }

    gxError("CRole:setMapID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setMapID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setbagOpenGridNum(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setbagOpenGridNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CRole:setbagOpenGridNum");
        if(!ok)
            return 0;
        cobj->setbagOpenGridNum(arg0);
        return 0;
    }

    gxError("CRole:setbagOpenGridNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setbagOpenGridNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isEnoughWaste(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isEnoughWaste'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EAttributes arg0;
        int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:isEnoughWaste");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:isEnoughWaste");
        if(!ok)
            return 0;
        int ret = (int)cobj->isEnoughWaste(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:isEnoughWaste has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isEnoughWaste'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_sendChat(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_sendChat'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CRole:sendChat");
        if(!ok)
            return 0;
        cobj->sendChat(arg0);
        return 0;
    }

    gxError("CRole:sendChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_sendChat'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onIdle(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onIdle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onIdle();
        return 0;
    }

    gxError("CRole:onIdle has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onIdle'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setHummanDBData(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setHummanDBData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CHumanDBData* arg0;

        ok &= luaval_to_object<CHumanDBData>(tolua_S, 2, "CHumanDBData", &arg0, "CRole:setHummanDBData");
        if(!ok)
            return 0;
        cobj->setHummanDBData(arg0);
        return 0;
    }

    gxError("CRole:setHummanDBData has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setHummanDBData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_addGameMoney(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_addGameMoney'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:addGameMoney");
        if(!ok)
            return 0;
        int ret = cobj->addGameMoney(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:addGameMoney");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRole:addGameMoney");
        if(!ok)
            return 0;
        int ret = cobj->addGameMoney(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:addGameMoney has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_addGameMoney'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_saveRet(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_saveRet'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->saveRet();
        return 0;
    }

    gxError("CRole:saveRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_saveRet'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_loadDataOk(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_loadDataOk'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        LoadRoleData* arg0;

        ok &= luaval_to_object<LoadRoleData>(tolua_S, 2, "LoadRoleData", &arg0, "CRole:loadDataOk");
        if(!ok)
            return 0;
        cobj->loadDataOk(arg0);
        return 0;
    }

    gxError("CRole:loadDataOk has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_loadDataOk'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onOpenDynamicMap(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onOpenDynamicMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        unsigned long long arg0;
        const AxisPos* arg1;
        unsigned short arg2;
        EGameRetCode arg3;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRole:onOpenDynamicMap");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CRole:onOpenDynamicMap");

        ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CRole:onOpenDynamicMap");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CRole:onOpenDynamicMap");
        if(!ok)
            return 0;
        cobj->onOpenDynamicMap(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CRole:onOpenDynamicMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onOpenDynamicMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_waitReconnect(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_waitReconnect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->waitReconnect();
        return 0;
    }

    gxError("CRole:waitReconnect has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_waitReconnect'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isCanViewMe(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isCanViewMe'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const CGameObject* arg0;

        ok &= luaval_to_object<const CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CRole:isCanViewMe");
        if(!ok)
            return 0;
        bool ret = cobj->isCanViewMe(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:isCanViewMe has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isCanViewMe'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_updateLimitManger(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_updateLimitManger'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:updateLimitManger");
        if(!ok)
            return 0;
        cobj->updateLimitManger(arg0);
        return 0;
    }

    gxError("CRole:updateLimitManger has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_updateLimitManger'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setRoleName(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setRoleName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CRole:setRoleName");
        if(!ok)
            return 0;
        cobj->setRoleName(arg0);
        return 0;
    }

    gxError("CRole:setRoleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setRoleName'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getLogoutTime(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CRole_getLogoutTime'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            unsigned int ret = cobj->getLogoutTime();
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            unsigned int ret = cobj->getLogoutTime();
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CRole:getLogoutTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getLogoutTime'.",&tolua_err);
    return 0;
}
int lua_mapserver_CRole_offlineSave(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_offlineSave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        bool arg0;
        ESaveRoleType arg1;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:offlineSave");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:offlineSave");
        if(!ok)
            return 0;
        cobj->offlineSave(arg0, arg1);
        return 0;
    }

    gxError("CRole:offlineSave has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_offlineSave'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_quitGame(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_quitGame'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->quitGame();
        return 0;
    }

    gxError("CRole:quitGame has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_quitGame'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_quit(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_quit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        bool arg0;
        const char* arg1;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:quit");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CRole:quit"); arg1 = (char*)arg1_tmp.buffer;
        if(!ok)
            return 0;
        cobj->quit(arg0, arg1);
        return 0;
    }
    if (argc == 3) 
    {
        bool arg0;
        const char* arg1;
        int arg2;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:quit");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CRole:quit"); arg1 = (char*)arg1_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CRole:quit");
        if(!ok)
            return 0;
        cobj->quit(arg0, arg1, arg2);
        return 0;
    }

    gxError("CRole:quit has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_quit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_toRoleString(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_toRoleString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toRoleString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CRole:toRoleString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_toRoleString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_moveToDynamicMap(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_moveToDynamicMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned long long arg0;
        const AxisPos* arg1;
        unsigned short arg2;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRole:moveToDynamicMap");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CRole:moveToDynamicMap");

        ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CRole:moveToDynamicMap");
        if(!ok)
            return 0;
        int ret = (int)cobj->moveToDynamicMap(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:moveToDynamicMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_moveToDynamicMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onBeforeChangeLine(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onBeforeChangeLine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        ChangeLineTempData* arg0;
        unsigned short arg1;
        const AxisPos* arg2;
        unsigned short arg3;
        ETeleportType arg4;

        ok &= luaval_to_object<ChangeLineTempData>(tolua_S, 2, "ChangeLineTempData", &arg0, "CRole:onBeforeChangeLine");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CRole:onBeforeChangeLine");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CRole:onBeforeChangeLine");

        ok &= luaval_to_uint16(tolua_S, 5, (uint16*)&arg3, "CRole:onBeforeChangeLine");

        ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CRole:onBeforeChangeLine");
        if(!ok)
            return 0;
        bool ret = cobj->onBeforeChangeLine(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onBeforeChangeLine has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onBeforeChangeLine'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onBeforeChangeMap(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onBeforeChangeMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        unsigned long long arg0;
        const AxisPos* arg1;
        ELoadRoleType arg2;
        ETeleportType arg3;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRole:onBeforeChangeMap");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CRole:onBeforeChangeMap");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CRole:onBeforeChangeMap");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CRole:onBeforeChangeMap");
        if(!ok)
            return 0;
        bool ret = cobj->onBeforeChangeMap(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onBeforeChangeMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onBeforeChangeMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_openDynamicMap(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_openDynamicMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CRole:openDynamicMap");
        if(!ok)
            return 0;
        int ret = (int)cobj->openDynamicMap(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:openDynamicMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_openDynamicMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onScene(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapScene* arg0;

        ok &= luaval_to_object<CMapScene>(tolua_S, 2, "CMapScene", &arg0, "CRole:onScene");
        if(!ok)
            return 0;
        bool ret = cobj->onScene(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_sendUnloadRet(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_sendUnloadRet'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EGameRetCode arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:sendUnloadRet");
        if(!ok)
            return 0;
        cobj->sendUnloadRet(arg0);
        return 0;
    }

    gxError("CRole:sendUnloadRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_sendUnloadRet'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getRoleAttrBackup(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getRoleAttrBackup'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const RoleAttrBackup* ret = cobj->getRoleAttrBackup();
        object_to_luaval<RoleAttrBackup>(tolua_S, "RoleAttrBackup",(RoleAttrBackup*)ret);
        return 1;
    }

    gxError("CRole:getRoleAttrBackup has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getRoleAttrBackup'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setAxisPos(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setAxisPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CRole:setAxisPos");
        if(!ok)
            return 0;
        cobj->setAxisPos(arg0);
        return 0;
    }

    gxError("CRole:setAxisPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setAxisPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isWaitOffline(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isWaitOffline'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isWaitOffline();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:isWaitOffline has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isWaitOffline'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onSave(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onSave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:onSave");
        if(!ok)
            return 0;
        bool ret = cobj->onSave(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onSave has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onSave'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_handleDeleteTokenOrItem(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_handleDeleteTokenOrItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const ItemReward* arg0;

        ok &= luaval_to_object<const ItemReward>(tolua_S, 2, "ItemReward", &arg0, "CRole:handleDeleteTokenOrItem");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleDeleteTokenOrItem(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        const ItemReward* arg0;
        int arg1;

        ok &= luaval_to_object<const ItemReward>(tolua_S, 2, "ItemReward", &arg0, "CRole:handleDeleteTokenOrItem");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:handleDeleteTokenOrItem");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleDeleteTokenOrItem(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:handleDeleteTokenOrItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_handleDeleteTokenOrItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_renameName(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_renameName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CRole:renameName");
        if(!ok)
            return 0;
        bool ret = cobj->renameName(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:renameName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_renameName'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onRemoveFromLogout(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onRemoveFromLogout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onRemoveFromLogout();
        return 0;
    }

    gxError("CRole:onRemoveFromLogout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onRemoveFromLogout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_chargeRmb(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_chargeRmb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:chargeRmb");
        if(!ok)
            return 0;
        int ret = cobj->chargeRmb(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:chargeRmb");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRole:chargeRmb");
        if(!ok)
            return 0;
        int ret = cobj->chargeRmb(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:chargeRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_chargeRmb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onDescItem(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onDescItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        EItemRecordType arg0;
        EPackType arg1;
        unsigned short arg2;
        short arg3;
        unsigned char arg4;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:onDescItem");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:onDescItem");

        ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CRole:onDescItem");

        ok &= luaval_to_sint16(tolua_S, 5,(sint16*)&arg3, "CRole:onDescItem");

        ok &= luaval_to_uint8(tolua_S, 6,(uint8*)&arg4, "CRole:onDescItem");
        if(!ok)
            return 0;
        cobj->onDescItem(arg0, arg1, arg2, arg3, arg4);
        return 0;
    }

    gxError("CRole:onDescItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onDescItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onQuitHandle(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onQuitHandle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ESaveRoleType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:onQuitHandle");
        if(!ok)
            return 0;
        cobj->onQuitHandle(arg0);
        return 0;
    }

    gxError("CRole:onQuitHandle has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onQuitHandle'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_directKick(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_directKick'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        bool arg0;
        bool arg1;
        bool arg2;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:directKick");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRole:directKick");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CRole:directKick");
        if(!ok)
            return 0;
        cobj->directKick(arg0, arg1, arg2);
        return 0;
    }
    if (argc == 4) 
    {
        bool arg0;
        bool arg1;
        bool arg2;
        EKickType arg3;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:directKick");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRole:directKick");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CRole:directKick");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CRole:directKick");
        if(!ok)
            return 0;
        cobj->directKick(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CRole:directKick has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_directKick'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onRename(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onRename'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EGameRetCode arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:onRename");
        if(!ok)
            return 0;
        cobj->onRename(arg0);
        return 0;
    }

    gxError("CRole:onRename has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onRename'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setProtypeID(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setProtypeID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CRole:setProtypeID");
        if(!ok)
            return 0;
        cobj->setProtypeID(arg0);
        return 0;
    }

    gxError("CRole:setProtypeID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setProtypeID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setVipLevel(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setVipLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CRole:setVipLevel");
        if(!ok)
            return 0;
        cobj->setVipLevel(arg0);
        return 0;
    }

    gxError("CRole:setVipLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setVipLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getLoginsDay(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getLoginsDay'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getLoginsDay();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getLoginsDay has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getLoginsDay'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_sendEnterScene(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_sendEnterScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ESceneType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:sendEnterScene");
        if(!ok)
            return 0;
        cobj->sendEnterScene(arg0);
        return 0;
    }

    gxError("CRole:sendEnterScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_sendEnterScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getRoleDetailData(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getRoleDetailData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        RoleDetail* arg0;

        ok &= luaval_to_object<RoleDetail>(tolua_S, 2, "RoleDetail", &arg0, "CRole:getRoleDetailData");
        if(!ok)
            return 0;
        cobj->getRoleDetailData(arg0);
        return 0;
    }

    gxError("CRole:getRoleDetailData has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getRoleDetailData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_initScript(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_initScript'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CRole:initScript");
        if(!ok)
            return 0;
        bool ret = cobj->initScript(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:initScript has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_initScript'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getOnlineTime(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getOnlineTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getOnlineTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getOnlineTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getOnlineTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onLogoutTimeout(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onLogoutTimeout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onLogoutTimeout();
        return 0;
    }

    gxError("CRole:onLogoutTimeout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onLogoutTimeout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getHumanDBData(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getHumanDBData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CHumanDBData* ret = cobj->getHumanDBData();
        object_to_luaval<CHumanDBData>(tolua_S, "CHumanDBData",(CHumanDBData*)ret);
        return 1;
    }

    gxError("CRole:getHumanDBData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getHumanDBData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getPlayerHandler(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getPlayerHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapPlayerHandler* ret = cobj->getPlayerHandler();
        object_to_luaval<CMapPlayerHandler>(tolua_S, "CMapPlayerHandler",(CMapPlayerHandler*)ret);
        return 1;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:getPlayerHandler");
        if(!ok)
            return 0;
        CMapPlayerHandler* ret = cobj->getPlayerHandler(arg0);
        object_to_luaval<CMapPlayerHandler>(tolua_S, "CMapPlayerHandler",(CMapPlayerHandler*)ret);
        return 1;
    }

    gxError("CRole:getPlayerHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getPlayerHandler'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_transport(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_transport'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CRole:transport");
        if(!ok)
            return 0;
        int ret = (int)cobj->transport(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:transport has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_transport'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getMaxStrength(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getMaxStrength'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxStrength();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getMaxStrength has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getMaxStrength'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setLogoutTime(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setLogoutTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRole:setLogoutTime");
        if(!ok)
            return 0;
        cobj->setLogoutTime(arg0);
        return 0;
    }

    gxError("CRole:setLogoutTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setLogoutTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_changeMap(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_changeMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned short arg0;
        const AxisPos* arg1;
        ETeleportType arg2;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CRole:changeMap");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CRole:changeMap");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CRole:changeMap");
        if(!ok)
            return 0;
        int ret = (int)cobj->changeMap(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:changeMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_changeMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getVipExp(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getVipExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getVipExp();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getVipExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getVipExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getLevelRow(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getLevelRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CLevelUpTbl* ret = cobj->getLevelRow();
        object_to_luaval<CLevelUpTbl>(tolua_S, "CLevelUpTbl",(CLevelUpTbl*)ret);
        return 1;
    }

    gxError("CRole:getLevelRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getLevelRow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setLoginManager(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setLoginManager'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CLoginWaiterManager* arg0;

        ok &= luaval_to_object<CLoginWaiterManager>(tolua_S, 2, "CLoginWaiterManager", &arg0, "CRole:setLoginManager");
        if(!ok)
            return 0;
        cobj->setLoginManager(arg0);
        return 0;
    }

    gxError("CRole:setLoginManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setLoginManager'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getMaxExp(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getMaxExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxExp();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CRole:getMaxExp");
        if(!ok)
            return 0;
        int ret = cobj->getMaxExp(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getMaxExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getMaxExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setLastSceneID(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setLastSceneID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRole:setLastSceneID");
        if(!ok)
            return 0;
        cobj->setLastSceneID(arg0);
        return 0;
    }

    gxError("CRole:setLastSceneID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setLastSceneID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setLastMapPos(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setLastMapPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        AxisPos* arg0;

        ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CRole:setLastMapPos");
        if(!ok)
            return 0;
        cobj->setLastMapPos(arg0);
        return 0;
    }

    gxError("CRole:setLastMapPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setLastMapPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onMove(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onMove'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CRole:onMove");
        if(!ok)
            return 0;
        cobj->onMove(arg0);
        return 0;
    }

    gxError("CRole:onMove has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onMove'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isFight(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isFight'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isFight();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:isFight has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isFight'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getLoadWaitData(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getLoadWaitData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        LoadWaitEnter* ret = cobj->getLoadWaitData();
        object_to_luaval<LoadWaitEnter>(tolua_S, "LoadWaitEnter",(LoadWaitEnter*)ret);
        return 1;
    }

    gxError("CRole:getLoadWaitData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getLoadWaitData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onAfterChangeLine(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onAfterChangeLine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ChangeLineTempData* arg0;
        ETeleportType arg1;

        ok &= luaval_to_object<ChangeLineTempData>(tolua_S, 2, "ChangeLineTempData", &arg0, "CRole:onAfterChangeLine");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:onAfterChangeLine");
        if(!ok)
            return 0;
        bool ret = cobj->onAfterChangeLine(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onAfterChangeLine has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onAfterChangeLine'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getLastMapID(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getLastMapID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getLastMapID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getLastMapID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getLastMapID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onLevelChanged(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onLevelChanged'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        unsigned int arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRole:onLevelChanged");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CRole:onLevelChanged");
        if(!ok)
            return 0;
        cobj->onLevelChanged(arg0, arg1);
        return 0;
    }

    gxError("CRole:onLevelChanged has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onLevelChanged'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_refreshFast(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_refreshFast'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->refreshFast();
        return 0;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:refreshFast");
        if(!ok)
            return 0;
        cobj->refreshFast(arg0);
        return 0;
    }

    gxError("CRole:refreshFast has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_refreshFast'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getLevel(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getLevel();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getLastMapPos(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getLastMapPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        AxisPos* ret = cobj->getLastMapPos();
        object_to_luaval<AxisPos>(tolua_S, "AxisPos",(AxisPos*)ret);
        return 1;
    }

    gxError("CRole:getLastMapPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getLastMapPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setSceneID(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setSceneID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRole:setSceneID");
        if(!ok)
            return 0;
        cobj->setSceneID(arg0);
        return 0;
    }

    gxError("CRole:setSceneID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setSceneID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onOldLogin(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onOldLogin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onOldLogin();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:onOldLogin has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onOldLogin'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_updateUserData(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_updateUserData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        W2MUserDataUpdate* arg0;

        ok &= luaval_to_object<W2MUserDataUpdate>(tolua_S, 2, "W2MUserDataUpdate", &arg0, "CRole:updateUserData");
        if(!ok)
            return 0;
        cobj->updateUserData(arg0);
        return 0;
    }

    gxError("CRole:updateUserData has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_updateUserData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getScriptObject1(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getScriptObject1'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        lua_tinker::s_object ret = cobj->getScriptObject1();
        lua_tinker::push(tolua_S,ret);
        return 1;
    }

    gxError("CRole:getScriptObject1 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getScriptObject1'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getShapeData(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CRole_getShapeData'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            PackRoleShape* arg0;
            ok &= luaval_to_object<PackRoleShape>(tolua_S, 2, "PackRoleShape", &arg0, "CRole:getShapeData");

            if (!ok) { break; }
            unsigned short ret = cobj->getShapeData(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CRole:getShapeData"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            unsigned int arg1;
            ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CRole:getShapeData");

            if (!ok) { break; }
            unsigned short ret = cobj->getShapeData(arg0, arg1);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CRole:getShapeData has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getShapeData'.",&tolua_err);
    return 0;
}
int lua_mapserver_CRole_cleanAll(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_cleanAll'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:cleanAll");
        if(!ok)
            return 0;
        cobj->cleanAll(arg0);
        return 0;
    }

    gxError("CRole:cleanAll has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_cleanAll'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_handleDescMoneyPort(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_handleDescMoneyPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EAttributes arg0;
        int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:handleDescMoneyPort");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:handleDescMoneyPort");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleDescMoneyPort(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 3) 
    {
        EAttributes arg0;
        int arg1;
        EMoneyRecordTouchType arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:handleDescMoneyPort");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:handleDescMoneyPort");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CRole:handleDescMoneyPort");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleDescMoneyPort(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:handleDescMoneyPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_handleDescMoneyPort'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setLevel(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setLevel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CRole:setLevel");
        if(!ok)
            return 0;
        cobj->setLevel(arg0);
        return 0;
    }

    gxError("CRole:setLevel has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setLevel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_update(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getLoginCountOneDay(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getLoginCountOneDay'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getLoginCountOneDay();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getLoginCountOneDay has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getLoginCountOneDay'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getCreateTime(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getCreateTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getCreateTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getCreateTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getCreateTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_on0Timer(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_on0Timer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->on0Timer();
        return 0;
    }

    gxError("CRole:on0Timer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_on0Timer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onMissionAccept(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onMissionAccept'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned short arg0;
        EMissionType arg1;
        _OwnMission* arg2;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CRole:onMissionAccept");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:onMissionAccept");

        ok &= luaval_to_object<_OwnMission>(tolua_S, 4, "_OwnMission", &arg2, "CRole:onMissionAccept");
        if(!ok)
            return 0;
        cobj->onMissionAccept(arg0, arg1, arg2);
        return 0;
    }

    gxError("CRole:onMissionAccept has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onMissionAccept'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_handleAddTokenOrItem(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_handleAddTokenOrItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const ItemReward* arg0;

        ok &= luaval_to_object<const ItemReward>(tolua_S, 2, "ItemReward", &arg0, "CRole:handleAddTokenOrItem");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleAddTokenOrItem(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        const ItemReward* arg0;
        int arg1;

        ok &= luaval_to_object<const ItemReward>(tolua_S, 2, "ItemReward", &arg0, "CRole:handleAddTokenOrItem");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:handleAddTokenOrItem");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleAddTokenOrItem(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:handleAddTokenOrItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_handleAddTokenOrItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setLoginCountOneDay(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setLoginCountOneDay'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:setLoginCountOneDay");
        if(!ok)
            return 0;
        cobj->setLoginCountOneDay(arg0);
        return 0;
    }

    gxError("CRole:setLoginCountOneDay has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setLoginCountOneDay'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_setHummanDBBuffer(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_setHummanDBBuffer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CRole:setHummanDBBuffer"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:setHummanDBBuffer");
        if(!ok)
            return 0;
        cobj->setHummanDBBuffer(arg0, arg1);
        return 0;
    }

    gxError("CRole:setHummanDBBuffer has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_setHummanDBBuffer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getOfflineOverrunDays(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CRole_getOfflineOverrunDays'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:getOfflineOverrunDays");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:getOfflineOverrunDays");

            if (!ok) { break; }
            unsigned int ret = cobj->getOfflineOverrunDays(arg0, arg1);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:getOfflineOverrunDays");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:getOfflineOverrunDays");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CRole:getOfflineOverrunDays");

            if (!ok) { break; }
            unsigned int ret = cobj->getOfflineOverrunDays(arg0, arg1, arg2);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            unsigned int ret = cobj->getOfflineOverrunDays();
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CRole:getOfflineOverrunDays has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getOfflineOverrunDays'.",&tolua_err);
    return 0;
}
int lua_mapserver_CRole_onDeleteItem(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onDeleteItem'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        EItemRecordType arg0;
        EPackType arg1;
        unsigned short arg2;
        short arg3;
        unsigned char arg4;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:onDeleteItem");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRole:onDeleteItem");

        ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CRole:onDeleteItem");

        ok &= luaval_to_sint16(tolua_S, 5,(sint16*)&arg3, "CRole:onDeleteItem");

        ok &= luaval_to_uint8(tolua_S, 6,(uint8*)&arg4, "CRole:onDeleteItem");
        if(!ok)
            return 0;
        cobj->onDeleteItem(arg0, arg1, arg2, arg3, arg4);
        return 0;
    }

    gxError("CRole:onDeleteItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onDeleteItem'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getDbHandler(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getDbHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapDbPlayerHandler* ret = cobj->getDbHandler();
        object_to_luaval<CMapDbPlayerHandler>(tolua_S, "CMapDbPlayerHandler",(CMapDbPlayerHandler*)ret);
        return 1;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CRole:getDbHandler");
        if(!ok)
            return 0;
        CMapDbPlayerHandler* ret = cobj->getDbHandler(arg0);
        object_to_luaval<CMapDbPlayerHandler>(tolua_S, "CMapDbPlayerHandler",(CMapDbPlayerHandler*)ret);
        return 1;
    }

    gxError("CRole:getDbHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getDbHandler'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_addVipExp(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_addVipExp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:addVipExp");
        if(!ok)
            return 0;
        int ret = cobj->addVipExp(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRole:addVipExp");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRole:addVipExp");
        if(!ok)
            return 0;
        int ret = cobj->addVipExp(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:addVipExp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_addVipExp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getHumanDB(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getHumanDB'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CHumanDB* ret = cobj->getHumanDB();
        object_to_luaval<CHumanDB>(tolua_S, "CHumanDB",(CHumanDB*)ret);
        return 1;
    }

    gxError("CRole:getHumanDB has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getHumanDB'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getLimitManager(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getLimitManager'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CLimitManager* ret = cobj->getLimitManager();
        object_to_luaval<CLimitManager>(tolua_S, "CLimitManager",(CLimitManager*)ret);
        return 1;
    }

    gxError("CRole:getLimitManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getLimitManager'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onOfflineOverrunDays(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onOfflineOverrunDays'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRole:onOfflineOverrunDays");
        if(!ok)
            return 0;
        cobj->onOfflineOverrunDays(arg0);
        return 0;
    }

    gxError("CRole:onOfflineOverrunDays has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onOfflineOverrunDays'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_onLoginTimeout(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_onLoginTimeout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onLoginTimeout();
        return 0;
    }

    gxError("CRole:onLoginTimeout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_onLoginTimeout'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_sendAllData(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_sendAllData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->sendAllData();
        return 0;
    }

    gxError("CRole:sendAllData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_sendAllData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getProtypeID(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getProtypeID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getProtypeID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getProtypeID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getProtypeID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_isNeedUpdateBlock(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_isNeedUpdateBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNeedUpdateBlock();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRole:isNeedUpdateBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_isNeedUpdateBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getAllRmb(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getAllRmb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getAllRmb();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRole:getAllRmb has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getAllRmb'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_getNewRoleRow(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRole*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRole_getNewRoleRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CNewRoleTbl* ret = cobj->getNewRoleRow();
        object_to_luaval<CNewRoleTbl>(tolua_S, "CNewRoleTbl",(CNewRoleTbl*)ret);
        return 1;
    }

    gxError("CRole:getNewRoleRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRole_getNewRoleRow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRole_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CRole* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CRole();
        tolua_pushusertype(tolua_S,(void*)cobj,"CRole");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CRole:CRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CRole_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CRole)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CRole",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CRole* self = (CRole*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CRole(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CRole");
    tolua_cclass(tolua_S,"CRole","CRole","CRoleBase",lua_mapserver_CRole_finalize);

    tolua_beginmodule(tolua_S,"CRole");
        tolua_function(tolua_S,"new",lua_mapserver_CRole_constructor);
        tolua_function(tolua_S,"setStrength",lua_mapserver_CRole_setStrength);
        tolua_function(tolua_S,"getRmb",lua_mapserver_CRole_getRmb);
        tolua_function(tolua_S,"setGameMoney",lua_mapserver_CRole_setGameMoney);
        tolua_function(tolua_S,"sendOtherChangeScene",lua_mapserver_CRole_sendOtherChangeScene);
        tolua_function(tolua_S,"move",lua_mapserver_CRole_move);
        tolua_function(tolua_S,"getStrength",lua_mapserver_CRole_getStrength);
        tolua_function(tolua_S,"getbagOpenGridNum",lua_mapserver_CRole_getbagOpenGridNum);
        tolua_function(tolua_S,"onMissionSubmit",lua_mapserver_CRole_onMissionSubmit);
        tolua_function(tolua_S,"getGameMoney",lua_mapserver_CRole_getGameMoney);
        tolua_function(tolua_S,"setLocalServerLogin",lua_mapserver_CRole_setLocalServerLogin);
        tolua_function(tolua_S,"handleGetRoleAttr",lua_mapserver_CRole_handleGetRoleAttr);
        tolua_function(tolua_S,"getScriptHandler",lua_mapserver_CRole_getScriptHandler);
        tolua_function(tolua_S,"isOfflineTime",lua_mapserver_CRole_isOfflineTime);
        tolua_function(tolua_S,"getChangeLineWait",lua_mapserver_CRole_getChangeLineWait);
        tolua_function(tolua_S,"getRoleUserData",lua_mapserver_CRole_getRoleUserData);
        tolua_function(tolua_S,"isChangeMap",lua_mapserver_CRole_isChangeMap);
        tolua_function(tolua_S,"setChangePos",lua_mapserver_CRole_setChangePos);
        tolua_function(tolua_S,"onChangeMap",lua_mapserver_CRole_onChangeMap);
        tolua_function(tolua_S,"isFirstLoginInDay",lua_mapserver_CRole_isFirstLoginInDay);
        tolua_function(tolua_S,"onLeaveScene",lua_mapserver_CRole_onLeaveScene);
        tolua_function(tolua_S,"onAddToLogout",lua_mapserver_CRole_onAddToLogout);
        tolua_function(tolua_S,"getBufferMod",lua_mapserver_CRole_getBufferMod);
        tolua_function(tolua_S,"isChangeLineWait",lua_mapserver_CRole_isChangeLineWait);
        tolua_function(tolua_S,"getOfflineHours",lua_mapserver_CRole_getOfflineHours);
        tolua_function(tolua_S,"isDbModBusy",lua_mapserver_CRole_isDbModBusy);
        tolua_function(tolua_S,"getBagMod",lua_mapserver_CRole_getBagMod);
        tolua_function(tolua_S,"getLastSceneID",lua_mapserver_CRole_getLastSceneID);
        tolua_function(tolua_S,"kick",lua_mapserver_CRole_kick);
        tolua_function(tolua_S,"getScriptObject",lua_mapserver_CRole_getScriptObject);
        tolua_function(tolua_S,"setLastMapID",lua_mapserver_CRole_setLastMapID);
        tolua_function(tolua_S,"randName",lua_mapserver_CRole_randName);
        tolua_function(tolua_S,"isNeedInit",lua_mapserver_CRole_isNeedInit);
        tolua_function(tolua_S,"sendErrorCode",lua_mapserver_CRole_sendErrorCode);
        tolua_function(tolua_S,"isOfflineDayTime",lua_mapserver_CRole_isOfflineDayTime);
        tolua_function(tolua_S,"getOnlineMins",lua_mapserver_CRole_getOnlineMins);
        tolua_function(tolua_S,"descAllRmb",lua_mapserver_CRole_descAllRmb);
        tolua_function(tolua_S,"onHourTimer",lua_mapserver_CRole_onHourTimer);
        tolua_function(tolua_S,"getMapServerData",lua_mapserver_CRole_getMapServerData);
        tolua_function(tolua_S,"setSex",lua_mapserver_CRole_setSex);
        tolua_function(tolua_S,"onAddToReady",lua_mapserver_CRole_onAddToReady);
        tolua_function(tolua_S,"getChatMod",lua_mapserver_CRole_getChatMod);
        tolua_function(tolua_S,"onEnterScene",lua_mapserver_CRole_onEnterScene);
        tolua_function(tolua_S,"toWorldKick",lua_mapserver_CRole_toWorldKick);
        tolua_function(tolua_S,"onEnter",lua_mapserver_CRole_onEnter);
        tolua_function(tolua_S,"onLogin",lua_mapserver_CRole_onLogin);
        tolua_function(tolua_S,"handleRoleAttr",lua_mapserver_CRole_handleRoleAttr);
        tolua_function(tolua_S,"getBindRmb",lua_mapserver_CRole_getBindRmb);
        tolua_function(tolua_S,"enterScene",lua_mapserver_CRole_enterScene);
        tolua_function(tolua_S,"onAfterChangeMap",lua_mapserver_CRole_onAfterChangeMap);
        tolua_function(tolua_S,"onUnloadRole",lua_mapserver_CRole_onUnloadRole);
        tolua_function(tolua_S,"leaveScene",lua_mapserver_CRole_leaveScene);
        tolua_function(tolua_S,"getSex",lua_mapserver_CRole_getSex);
        tolua_function(tolua_S,"handleAddMoneyPort",lua_mapserver_CRole_handleAddMoneyPort);
        tolua_function(tolua_S,"loadBaseAttr",lua_mapserver_CRole_loadBaseAttr);
        tolua_function(tolua_S,"getSceneRecord",lua_mapserver_CRole_getSceneRecord);
        tolua_function(tolua_S,"getOfflineMins",lua_mapserver_CRole_getOfflineMins);
        tolua_function(tolua_S,"getMaxLevel",lua_mapserver_CRole_getMaxLevel);
        tolua_function(tolua_S,"sendKickMsg",lua_mapserver_CRole_sendKickMsg);
        tolua_function(tolua_S,"onAddItem",lua_mapserver_CRole_onAddItem);
        tolua_function(tolua_S,"heartToWorld",lua_mapserver_CRole_heartToWorld);
        tolua_function(tolua_S,"setLoadWaitInfo",lua_mapserver_CRole_setLoadWaitInfo);
        tolua_function(tolua_S,"onQuit",lua_mapserver_CRole_onQuit);
        tolua_function(tolua_S,"isChangeLine",lua_mapserver_CRole_isChangeLine);
        tolua_function(tolua_S,"initClient",lua_mapserver_CRole_initClient);
        tolua_function(tolua_S,"initCharacter",lua_mapserver_CRole_initCharacter);
        tolua_function(tolua_S,"onNewLogin",lua_mapserver_CRole_onNewLogin);
        tolua_function(tolua_S,"onLoad",lua_mapserver_CRole_onLoad);
        tolua_function(tolua_S,"onFiveSecondTimer",lua_mapserver_CRole_onFiveSecondTimer);
        tolua_function(tolua_S,"isMaxStrength",lua_mapserver_CRole_isMaxStrength);
        tolua_function(tolua_S,"roleMove",lua_mapserver_CRole_roleMove);
        tolua_function(tolua_S,"addBindRmb",lua_mapserver_CRole_addBindRmb);
        tolua_function(tolua_S,"onLogout",lua_mapserver_CRole_onLogout);
        tolua_function(tolua_S,"sendTimerUpdateData",lua_mapserver_CRole_sendTimerUpdateData);
        tolua_function(tolua_S,"onFightFinish",lua_mapserver_CRole_onFightFinish);
        tolua_function(tolua_S,"getMissionMod",lua_mapserver_CRole_getMissionMod);
        tolua_function(tolua_S,"onChangeLineRet",lua_mapserver_CRole_onChangeLineRet);
        tolua_function(tolua_S,"on12Timer",lua_mapserver_CRole_on12Timer);
        tolua_function(tolua_S,"getExp",lua_mapserver_CRole_getExp);
        tolua_function(tolua_S,"getScenData",lua_mapserver_CRole_getScenData);
        tolua_function(tolua_S,"handleGetTokenOrItem",lua_mapserver_CRole_handleGetTokenOrItem);
        tolua_function(tolua_S,"changeLine",lua_mapserver_CRole_changeLine);
        tolua_function(tolua_S,"reLogin",lua_mapserver_CRole_reLogin);
        tolua_function(tolua_S,"getLoginManager",lua_mapserver_CRole_getLoginManager);
        tolua_function(tolua_S,"getHumanBaseData",lua_mapserver_CRole_getHumanBaseData);
        tolua_function(tolua_S,"isForbbidChat",lua_mapserver_CRole_isForbbidChat);
        tolua_function(tolua_S,"setExp",lua_mapserver_CRole_setExp);
        tolua_function(tolua_S,"setVipExp",lua_mapserver_CRole_setVipExp);
        tolua_function(tolua_S,"addVipLevel",lua_mapserver_CRole_addVipLevel);
        tolua_function(tolua_S,"setCreateTime",lua_mapserver_CRole_setCreateTime);
        tolua_function(tolua_S,"getVipLevel",lua_mapserver_CRole_getVipLevel);
        tolua_function(tolua_S,"setMapID",lua_mapserver_CRole_setMapID);
        tolua_function(tolua_S,"setbagOpenGridNum",lua_mapserver_CRole_setbagOpenGridNum);
        tolua_function(tolua_S,"isEnoughWaste",lua_mapserver_CRole_isEnoughWaste);
        tolua_function(tolua_S,"sendChat",lua_mapserver_CRole_sendChat);
        tolua_function(tolua_S,"onIdle",lua_mapserver_CRole_onIdle);
        tolua_function(tolua_S,"setHummanDBData",lua_mapserver_CRole_setHummanDBData);
        tolua_function(tolua_S,"addGameMoney",lua_mapserver_CRole_addGameMoney);
        tolua_function(tolua_S,"saveRet",lua_mapserver_CRole_saveRet);
        tolua_function(tolua_S,"loadDataOk",lua_mapserver_CRole_loadDataOk);
        tolua_function(tolua_S,"onOpenDynamicMap",lua_mapserver_CRole_onOpenDynamicMap);
        tolua_function(tolua_S,"waitReconnect",lua_mapserver_CRole_waitReconnect);
        tolua_function(tolua_S,"isCanViewMe",lua_mapserver_CRole_isCanViewMe);
        tolua_function(tolua_S,"updateLimitManger",lua_mapserver_CRole_updateLimitManger);
        tolua_function(tolua_S,"setRoleName",lua_mapserver_CRole_setRoleName);
        tolua_function(tolua_S,"getLogoutTime",lua_mapserver_CRole_getLogoutTime);
        tolua_function(tolua_S,"offlineSave",lua_mapserver_CRole_offlineSave);
        tolua_function(tolua_S,"quitGame",lua_mapserver_CRole_quitGame);
        tolua_function(tolua_S,"quit",lua_mapserver_CRole_quit);
        tolua_function(tolua_S,"toRoleString",lua_mapserver_CRole_toRoleString);
        tolua_function(tolua_S,"moveToDynamicMap",lua_mapserver_CRole_moveToDynamicMap);
        tolua_function(tolua_S,"onBeforeChangeLine",lua_mapserver_CRole_onBeforeChangeLine);
        tolua_function(tolua_S,"onBeforeChangeMap",lua_mapserver_CRole_onBeforeChangeMap);
        tolua_function(tolua_S,"openDynamicMap",lua_mapserver_CRole_openDynamicMap);
        tolua_function(tolua_S,"onScene",lua_mapserver_CRole_onScene);
        tolua_function(tolua_S,"sendUnloadRet",lua_mapserver_CRole_sendUnloadRet);
        tolua_function(tolua_S,"getRoleAttrBackup",lua_mapserver_CRole_getRoleAttrBackup);
        tolua_function(tolua_S,"setAxisPos",lua_mapserver_CRole_setAxisPos);
        tolua_function(tolua_S,"isWaitOffline",lua_mapserver_CRole_isWaitOffline);
        tolua_function(tolua_S,"onSave",lua_mapserver_CRole_onSave);
        tolua_function(tolua_S,"handleDeleteTokenOrItem",lua_mapserver_CRole_handleDeleteTokenOrItem);
        tolua_function(tolua_S,"renameName",lua_mapserver_CRole_renameName);
        tolua_function(tolua_S,"onRemoveFromLogout",lua_mapserver_CRole_onRemoveFromLogout);
        tolua_function(tolua_S,"chargeRmb",lua_mapserver_CRole_chargeRmb);
        tolua_function(tolua_S,"onDescItem",lua_mapserver_CRole_onDescItem);
        tolua_function(tolua_S,"onQuitHandle",lua_mapserver_CRole_onQuitHandle);
        tolua_function(tolua_S,"directKick",lua_mapserver_CRole_directKick);
        tolua_function(tolua_S,"onRename",lua_mapserver_CRole_onRename);
        tolua_function(tolua_S,"setProtypeID",lua_mapserver_CRole_setProtypeID);
        tolua_function(tolua_S,"setVipLevel",lua_mapserver_CRole_setVipLevel);
        tolua_function(tolua_S,"getLoginsDay",lua_mapserver_CRole_getLoginsDay);
        tolua_function(tolua_S,"sendEnterScene",lua_mapserver_CRole_sendEnterScene);
        tolua_function(tolua_S,"getRoleDetailData",lua_mapserver_CRole_getRoleDetailData);
        tolua_function(tolua_S,"initScript",lua_mapserver_CRole_initScript);
        tolua_function(tolua_S,"getOnlineTime",lua_mapserver_CRole_getOnlineTime);
        tolua_function(tolua_S,"onLogoutTimeout",lua_mapserver_CRole_onLogoutTimeout);
        tolua_function(tolua_S,"getHumanDBData",lua_mapserver_CRole_getHumanDBData);
        tolua_function(tolua_S,"getPlayerHandler",lua_mapserver_CRole_getPlayerHandler);
        tolua_function(tolua_S,"transport",lua_mapserver_CRole_transport);
        tolua_function(tolua_S,"getMaxStrength",lua_mapserver_CRole_getMaxStrength);
        tolua_function(tolua_S,"setLogoutTime",lua_mapserver_CRole_setLogoutTime);
        tolua_function(tolua_S,"changeMap",lua_mapserver_CRole_changeMap);
        tolua_function(tolua_S,"getVipExp",lua_mapserver_CRole_getVipExp);
        tolua_function(tolua_S,"getLevelRow",lua_mapserver_CRole_getLevelRow);
        tolua_function(tolua_S,"setLoginManager",lua_mapserver_CRole_setLoginManager);
        tolua_function(tolua_S,"getMaxExp",lua_mapserver_CRole_getMaxExp);
        tolua_function(tolua_S,"setLastSceneID",lua_mapserver_CRole_setLastSceneID);
        tolua_function(tolua_S,"setLastMapPos",lua_mapserver_CRole_setLastMapPos);
        tolua_function(tolua_S,"onMove",lua_mapserver_CRole_onMove);
        tolua_function(tolua_S,"isFight",lua_mapserver_CRole_isFight);
        tolua_function(tolua_S,"getLoadWaitData",lua_mapserver_CRole_getLoadWaitData);
        tolua_function(tolua_S,"onAfterChangeLine",lua_mapserver_CRole_onAfterChangeLine);
        tolua_function(tolua_S,"getLastMapID",lua_mapserver_CRole_getLastMapID);
        tolua_function(tolua_S,"onLevelChanged",lua_mapserver_CRole_onLevelChanged);
        tolua_function(tolua_S,"refreshFast",lua_mapserver_CRole_refreshFast);
        tolua_function(tolua_S,"getLevel",lua_mapserver_CRole_getLevel);
        tolua_function(tolua_S,"getLastMapPos",lua_mapserver_CRole_getLastMapPos);
        tolua_function(tolua_S,"setSceneID",lua_mapserver_CRole_setSceneID);
        tolua_function(tolua_S,"onOldLogin",lua_mapserver_CRole_onOldLogin);
        tolua_function(tolua_S,"updateUserData",lua_mapserver_CRole_updateUserData);
        tolua_function(tolua_S,"getScriptObject1",lua_mapserver_CRole_getScriptObject1);
        tolua_function(tolua_S,"getShapeData",lua_mapserver_CRole_getShapeData);
        tolua_function(tolua_S,"cleanAll",lua_mapserver_CRole_cleanAll);
        tolua_function(tolua_S,"handleDescMoneyPort",lua_mapserver_CRole_handleDescMoneyPort);
        tolua_function(tolua_S,"setLevel",lua_mapserver_CRole_setLevel);
        tolua_function(tolua_S,"update",lua_mapserver_CRole_update);
        tolua_function(tolua_S,"getLoginCountOneDay",lua_mapserver_CRole_getLoginCountOneDay);
        tolua_function(tolua_S,"getCreateTime",lua_mapserver_CRole_getCreateTime);
        tolua_function(tolua_S,"on0Timer",lua_mapserver_CRole_on0Timer);
        tolua_function(tolua_S,"onMissionAccept",lua_mapserver_CRole_onMissionAccept);
        tolua_function(tolua_S,"handleAddTokenOrItem",lua_mapserver_CRole_handleAddTokenOrItem);
        tolua_function(tolua_S,"setLoginCountOneDay",lua_mapserver_CRole_setLoginCountOneDay);
        tolua_function(tolua_S,"setHummanDBBuffer",lua_mapserver_CRole_setHummanDBBuffer);
        tolua_function(tolua_S,"getOfflineOverrunDays",lua_mapserver_CRole_getOfflineOverrunDays);
        tolua_function(tolua_S,"onDeleteItem",lua_mapserver_CRole_onDeleteItem);
        tolua_function(tolua_S,"getDbHandler",lua_mapserver_CRole_getDbHandler);
        tolua_function(tolua_S,"addVipExp",lua_mapserver_CRole_addVipExp);
        tolua_function(tolua_S,"getHumanDB",lua_mapserver_CRole_getHumanDB);
        tolua_function(tolua_S,"getLimitManager",lua_mapserver_CRole_getLimitManager);
        tolua_function(tolua_S,"onOfflineOverrunDays",lua_mapserver_CRole_onOfflineOverrunDays);
        tolua_function(tolua_S,"onLoginTimeout",lua_mapserver_CRole_onLoginTimeout);
        tolua_function(tolua_S,"sendAllData",lua_mapserver_CRole_sendAllData);
        tolua_function(tolua_S,"getProtypeID",lua_mapserver_CRole_getProtypeID);
        tolua_function(tolua_S,"isNeedUpdateBlock",lua_mapserver_CRole_isNeedUpdateBlock);
        tolua_function(tolua_S,"getAllRmb",lua_mapserver_CRole_getAllRmb);
        tolua_function(tolua_S,"getNewRoleRow",lua_mapserver_CRole_getNewRoleRow);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CRole).name();
    g_luaType[typeName] = "CRole";
    g_typeCast["CRole"] = "CRole";
    return 1;
}

int lua_mapserver_CMapDbResponseTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbResponseTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbResponseTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbResponseTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbResponseTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CMapDbResponseTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbResponseTask_doRun'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbResponseTask_setRetCode(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbResponseTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbResponseTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbResponseTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbResponseTask_setRetCode'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapDbResponseTask:setRetCode");
        if(!ok)
            return 0;
        cobj->setRetCode(arg0);
        return 0;
    }

    gxError("CMapDbResponseTask:setRetCode has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbResponseTask_setRetCode'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbResponseTask_doWork(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbResponseTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbResponseTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbResponseTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbResponseTask_doWork'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CRoleBase* arg0;

        ok &= luaval_to_object<CRoleBase>(tolua_S, 2, "CRoleBase", &arg0, "CMapDbResponseTask:doWork");
        if(!ok)
            return 0;
        cobj->doWork(arg0);
        return 0;
    }

    gxError("CMapDbResponseTask:doWork has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbResponseTask_doWork'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbResponseTask_getRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbResponseTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbResponseTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbResponseTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbResponseTask_getRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getRoleUID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CMapDbResponseTask:getRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbResponseTask_getRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbResponseTask_toString(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbResponseTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbResponseTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbResponseTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbResponseTask_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CMapDbResponseTask:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbResponseTask_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbResponseTask_setErrLogFlag(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbResponseTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbResponseTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbResponseTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbResponseTask_setErrLogFlag'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CMapDbResponseTask:setErrLogFlag");
        if(!ok)
            return 0;
        cobj->setErrLogFlag(arg0);
        return 0;
    }

    gxError("CMapDbResponseTask:setErrLogFlag has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbResponseTask_setErrLogFlag'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbResponseTask_getRole(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbResponseTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbResponseTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbResponseTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbResponseTask_getRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->getRole();
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CMapDbResponseTask:getRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbResponseTask_getRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbResponseTask_setRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbResponseTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbResponseTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbResponseTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbResponseTask_setRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapDbResponseTask:setRoleUID");
        if(!ok)
            return 0;
        cobj->setRoleUID(arg0);
        return 0;
    }

    gxError("CMapDbResponseTask:setRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbResponseTask_setRoleUID'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CMapDbResponseTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapDbResponseTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapDbResponseTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapDbResponseTask* self = (CMapDbResponseTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapDbResponseTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapDbResponseTask");
    tolua_cclass(tolua_S,"CMapDbResponseTask","CMapDbResponseTask","CDbConnTask",nullptr);

    tolua_beginmodule(tolua_S,"CMapDbResponseTask");
        tolua_function(tolua_S,"doRun",lua_mapserver_CMapDbResponseTask_doRun);
        tolua_function(tolua_S,"setRetCode",lua_mapserver_CMapDbResponseTask_setRetCode);
        tolua_function(tolua_S,"doWork",lua_mapserver_CMapDbResponseTask_doWork);
        tolua_function(tolua_S,"getRoleUID",lua_mapserver_CMapDbResponseTask_getRoleUID);
        tolua_function(tolua_S,"toString",lua_mapserver_CMapDbResponseTask_toString);
        tolua_function(tolua_S,"setErrLogFlag",lua_mapserver_CMapDbResponseTask_setErrLogFlag);
        tolua_function(tolua_S,"getRole",lua_mapserver_CMapDbResponseTask_getRole);
        tolua_function(tolua_S,"setRoleUID",lua_mapserver_CMapDbResponseTask_setRoleUID);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapDbResponseTask).name();
    g_luaType[typeName] = "CMapDbResponseTask";
    g_typeCast["CMapDbResponseTask"] = "CMapDbResponseTask";
    return 1;
}

int lua_mapserver_CMapDbRequestTask_freeResponseTask(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbRequestTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbRequestTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbRequestTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbRequestTask_freeResponseTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapDbResponseTask* arg0;

        ok &= luaval_to_object<CMapDbResponseTask>(tolua_S, 2, "CMapDbResponseTask", &arg0, "CMapDbRequestTask:freeResponseTask");
        if(!ok)
            return 0;
        cobj->freeResponseTask(arg0);
        return 0;
    }

    gxError("CMapDbRequestTask:freeResponseTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbRequestTask_freeResponseTask'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbRequestTask_getRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbRequestTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbRequestTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbRequestTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbRequestTask_getRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getRoleUID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CMapDbRequestTask:getRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbRequestTask_getRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbRequestTask_setRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbRequestTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbRequestTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbRequestTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbRequestTask_setRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapDbRequestTask:setRoleUID");
        if(!ok)
            return 0;
        cobj->setRoleUID(arg0);
        return 0;
    }

    gxError("CMapDbRequestTask:setRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbRequestTask_setRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbRequestTask_setErrLogFlag(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbRequestTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbRequestTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbRequestTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbRequestTask_setErrLogFlag'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CMapDbRequestTask:setErrLogFlag");
        if(!ok)
            return 0;
        cobj->setErrLogFlag(arg0);
        return 0;
    }

    gxError("CMapDbRequestTask:setErrLogFlag has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbRequestTask_setErrLogFlag'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CMapDbRequestTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapDbRequestTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapDbRequestTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapDbRequestTask* self = (CMapDbRequestTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapDbRequestTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapDbRequestTask");
    tolua_cclass(tolua_S,"CMapDbRequestTask","CMapDbRequestTask","CDbWrapTask",nullptr);

    tolua_beginmodule(tolua_S,"CMapDbRequestTask");
        tolua_function(tolua_S,"freeResponseTask",lua_mapserver_CMapDbRequestTask_freeResponseTask);
        tolua_function(tolua_S,"getRoleUID",lua_mapserver_CMapDbRequestTask_getRoleUID);
        tolua_function(tolua_S,"setRoleUID",lua_mapserver_CMapDbRequestTask_setRoleUID);
        tolua_function(tolua_S,"setErrLogFlag",lua_mapserver_CMapDbRequestTask_setErrLogFlag);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapDbRequestTask).name();
    g_luaType[typeName] = "CMapDbRequestTask";
    g_typeCast["CMapDbRequestTask"] = "CMapDbRequestTask";
    return 1;
}

int lua_mapserver_CGameDatabaseHandler_breath(lua_State* tolua_S)
{
    int argc = 0;
    CGameDatabaseHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameDatabaseHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameDatabaseHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameDatabaseHandler_breath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGameDatabaseHandler:breath");
        if(!ok)
            return 0;
        cobj->breath(arg0);
        return 0;
    }

    gxError("CGameDatabaseHandler:breath has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameDatabaseHandler_breath'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameDatabaseHandler_getSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    CGameDatabaseHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameDatabaseHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameDatabaseHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameDatabaseHandler_getSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getSocketIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CGameDatabaseHandler:getSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameDatabaseHandler_getSocketIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameDatabaseHandler_setSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    CGameDatabaseHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameDatabaseHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameDatabaseHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameDatabaseHandler_setSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CGameDatabaseHandler:setSocketIndex");
        if(!ok)
            return 0;
        cobj->setSocketIndex(arg0);
        return 0;
    }

    gxError("CGameDatabaseHandler:setSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameDatabaseHandler_setSocketIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameDatabaseHandler_setSocketMgr(lua_State* tolua_S)
{
    int argc = 0;
    CGameDatabaseHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameDatabaseHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameDatabaseHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameDatabaseHandler_setSocketMgr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CNetModule* arg0;

        ok &= luaval_to_object<GXMISC::CNetModule>(tolua_S, 2, "CNetModule", &arg0, "CGameDatabaseHandler:setSocketMgr");
        if(!ok)
            return 0;
        cobj->setSocketMgr(arg0);
        return 0;
    }

    gxError("CGameDatabaseHandler:setSocketMgr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameDatabaseHandler_setSocketMgr'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CGameDatabaseHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGameDatabaseHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGameDatabaseHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CGameDatabaseHandler* self = (CGameDatabaseHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CGameDatabaseHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGameDatabaseHandler");
    tolua_cclass(tolua_S,"CGameDatabaseHandler","CGameDatabaseHandler","CDatabaseHandler",nullptr);

    tolua_beginmodule(tolua_S,"CGameDatabaseHandler");
        tolua_function(tolua_S,"breath",lua_mapserver_CGameDatabaseHandler_breath);
        tolua_function(tolua_S,"getSocketIndex",lua_mapserver_CGameDatabaseHandler_getSocketIndex);
        tolua_function(tolua_S,"setSocketIndex",lua_mapserver_CGameDatabaseHandler_setSocketIndex);
        tolua_function(tolua_S,"setSocketMgr",lua_mapserver_CGameDatabaseHandler_setSocketMgr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CGameDatabaseHandler).name();
    g_luaType[typeName] = "CGameDatabaseHandler";
    g_typeCast["CGameDatabaseHandler"] = "CGameDatabaseHandler";
    return 1;
}

int lua_mapserver_CMapDbPlayerHandlerBase_quit(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_quit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->quit();
        return 0;
    }

    gxError("CMapDbPlayerHandlerBase:quit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_quit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_getRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_getRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getRoleUID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CMapDbPlayerHandlerBase:getRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_getRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_handle(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_handle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char* arg0;
        unsigned int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CMapDbPlayerHandlerBase:handle"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CMapDbPlayerHandlerBase:handle");
        if(!ok)
            return 0;
        int ret = (int)cobj->handle(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapDbPlayerHandlerBase:handle has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_handle'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_getAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_getAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getAccountID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CMapDbPlayerHandlerBase:getAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_getAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_setRequestSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_setRequestSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapDbPlayerHandlerBase:setRequestSocketIndex");
        if(!ok)
            return 0;
        cobj->setRequestSocketIndex(arg0);
        return 0;
    }

    gxError("CMapDbPlayerHandlerBase:setRequestSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_setRequestSocketIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_pushTask(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_pushTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapDbRequestTask* arg0;

        ok &= luaval_to_object<CMapDbRequestTask>(tolua_S, 2, "CMapDbRequestTask", &arg0, "CMapDbPlayerHandlerBase:pushTask");
        if(!ok)
            return 0;
        cobj->pushTask(arg0);
        return 0;
    }

    gxError("CMapDbPlayerHandlerBase:pushTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_pushTask'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_getRequestSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_getRequestSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getRequestSocketIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CMapDbPlayerHandlerBase:getRequestSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_getRequestSocketIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_breath(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_breath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapDbPlayerHandlerBase:breath");
        if(!ok)
            return 0;
        cobj->breath(arg0);
        return 0;
    }

    gxError("CMapDbPlayerHandlerBase:breath has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_breath'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_start(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapDbPlayerHandlerBase:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_start'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_getObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_getObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getObjUID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapDbPlayerHandlerBase:getObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_getObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_setLoginPlayerSockIndex(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_setLoginPlayerSockIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapDbPlayerHandlerBase:setLoginPlayerSockIndex");
        if(!ok)
            return 0;
        cobj->setLoginPlayerSockIndex(arg0);
        return 0;
    }

    gxError("CMapDbPlayerHandlerBase:setLoginPlayerSockIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_setLoginPlayerSockIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_toString(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CMapDbPlayerHandlerBase:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_setObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_setObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CMapDbPlayerHandlerBase:setObjUID");
        if(!ok)
            return 0;
        cobj->setObjUID(arg0);
        return 0;
    }

    gxError("CMapDbPlayerHandlerBase:setObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_setObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_close(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_close'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->close();
        return 0;
    }

    gxError("CMapDbPlayerHandlerBase:close has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_close'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_setAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_setAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapDbPlayerHandlerBase:setAccountID");
        if(!ok)
            return 0;
        cobj->setAccountID(arg0);
        return 0;
    }

    gxError("CMapDbPlayerHandlerBase:setAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_setAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_getRole(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_getRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CMapDbPlayerHandlerBase:getRole");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->getRole(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CMapDbPlayerHandlerBase:getRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_getRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_setRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_setRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapDbPlayerHandlerBase:setRoleUID");
        if(!ok)
            return 0;
        cobj->setRoleUID(arg0);
        return 0;
    }

    gxError("CMapDbPlayerHandlerBase:setRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_setRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_getLoginPlayerSockIndex(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandlerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandlerBase_getLoginPlayerSockIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getLoginPlayerSockIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CMapDbPlayerHandlerBase:getLoginPlayerSockIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandlerBase_getLoginPlayerSockIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandlerBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandlerBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapDbPlayerHandlerBase();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapDbPlayerHandlerBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        GXMISC::CDatabaseConnWrap* arg0;

        ok &= luaval_to_object<GXMISC::CDatabaseConnWrap>(tolua_S, 2, "CDatabaseConnWrap", &arg0, "CMapDbPlayerHandlerBase:CMapDbPlayerHandlerBase");
        if(!ok)
            return 0;
        cobj = new CMapDbPlayerHandlerBase(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapDbPlayerHandlerBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 2) 
    {
        GXMISC::CDatabaseConnWrap* arg0;
        unsigned long long arg1;

        ok &= luaval_to_object<GXMISC::CDatabaseConnWrap>(tolua_S, 2, "CDatabaseConnWrap", &arg0, "CMapDbPlayerHandlerBase:CMapDbPlayerHandlerBase");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CMapDbPlayerHandlerBase:CMapDbPlayerHandlerBase");
        if(!ok)
            return 0;
        cobj = new CMapDbPlayerHandlerBase(arg0, arg1);
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapDbPlayerHandlerBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapDbPlayerHandlerBase:CMapDbPlayerHandlerBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapDbPlayerHandlerBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapDbPlayerHandlerBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapDbPlayerHandlerBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapDbPlayerHandlerBase* self = (CMapDbPlayerHandlerBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapDbPlayerHandlerBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapDbPlayerHandlerBase");
    tolua_cclass(tolua_S,"CMapDbPlayerHandlerBase","CMapDbPlayerHandlerBase","CGameDatabaseHandler",lua_mapserver_CMapDbPlayerHandlerBase_finalize);

    tolua_beginmodule(tolua_S,"CMapDbPlayerHandlerBase");
        tolua_function(tolua_S,"new",lua_mapserver_CMapDbPlayerHandlerBase_constructor);
        tolua_function(tolua_S,"quit",lua_mapserver_CMapDbPlayerHandlerBase_quit);
        tolua_function(tolua_S,"getRoleUID",lua_mapserver_CMapDbPlayerHandlerBase_getRoleUID);
        tolua_function(tolua_S,"handle",lua_mapserver_CMapDbPlayerHandlerBase_handle);
        tolua_function(tolua_S,"getAccountID",lua_mapserver_CMapDbPlayerHandlerBase_getAccountID);
        tolua_function(tolua_S,"setRequestSocketIndex",lua_mapserver_CMapDbPlayerHandlerBase_setRequestSocketIndex);
        tolua_function(tolua_S,"pushTask",lua_mapserver_CMapDbPlayerHandlerBase_pushTask);
        tolua_function(tolua_S,"getRequestSocketIndex",lua_mapserver_CMapDbPlayerHandlerBase_getRequestSocketIndex);
        tolua_function(tolua_S,"breath",lua_mapserver_CMapDbPlayerHandlerBase_breath);
        tolua_function(tolua_S,"start",lua_mapserver_CMapDbPlayerHandlerBase_start);
        tolua_function(tolua_S,"getObjUID",lua_mapserver_CMapDbPlayerHandlerBase_getObjUID);
        tolua_function(tolua_S,"setLoginPlayerSockIndex",lua_mapserver_CMapDbPlayerHandlerBase_setLoginPlayerSockIndex);
        tolua_function(tolua_S,"toString",lua_mapserver_CMapDbPlayerHandlerBase_toString);
        tolua_function(tolua_S,"setObjUID",lua_mapserver_CMapDbPlayerHandlerBase_setObjUID);
        tolua_function(tolua_S,"close",lua_mapserver_CMapDbPlayerHandlerBase_close);
        tolua_function(tolua_S,"setAccountID",lua_mapserver_CMapDbPlayerHandlerBase_setAccountID);
        tolua_function(tolua_S,"getRole",lua_mapserver_CMapDbPlayerHandlerBase_getRole);
        tolua_function(tolua_S,"setRoleUID",lua_mapserver_CMapDbPlayerHandlerBase_setRoleUID);
        tolua_function(tolua_S,"getLoginPlayerSockIndex",lua_mapserver_CMapDbPlayerHandlerBase_getLoginPlayerSockIndex);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapDbPlayerHandlerBase).name();
    g_luaType[typeName] = "CMapDbPlayerHandlerBase";
    g_typeCast["CMapDbPlayerHandlerBase"] = "CMapDbPlayerHandlerBase";
    return 1;
}

static int lua_mapserver__SrvMapTile_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_SrvMapTile)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_SrvMapTile",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _SrvMapTile* self = (_SrvMapTile*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__SrvMapTile(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_SrvMapTile");
    tolua_cclass(tolua_S,"_SrvMapTile","_SrvMapTile","",nullptr);

    tolua_beginmodule(tolua_S,"_SrvMapTile");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_SrvMapTile).name();
    g_luaType[typeName] = "_SrvMapTile";
    g_typeCast["_SrvMapTile"] = "_SrvMapTile";
    return 1;
}

static int lua_mapserver__MapDataHeader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_MapDataHeader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_MapDataHeader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _MapDataHeader* self = (_MapDataHeader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__MapDataHeader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_MapDataHeader");
    tolua_cclass(tolua_S,"_MapDataHeader","_MapDataHeader","",nullptr);

    tolua_beginmodule(tolua_S,"_MapDataHeader");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_MapDataHeader).name();
    g_luaType[typeName] = "_MapDataHeader";
    g_typeCast["_MapDataHeader"] = "_MapDataHeader";
    return 1;
}

static int lua_mapserver__MapData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_MapData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_MapData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _MapData* self = (_MapData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__MapData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_MapData");
    tolua_cclass(tolua_S,"_MapData","_MapData","",nullptr);

    tolua_beginmodule(tolua_S,"_MapData");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_MapData).name();
    g_luaType[typeName] = "_MapData";
    g_typeCast["_MapData"] = "_MapData";
    return 1;
}

int lua_mapserver_CMapBase_load(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_load'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMapBase:load");
        if(!ok)
            return 0;
        bool ret = cobj->load(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapBase:load has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_load'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_randStepPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_randStepPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        std::vector<AxisPos, std::allocator<AxisPos> >* arg0;
        AxisPos* arg1;
        unsigned short arg2;

        ok &= luaval_to_object<std::vector<AxisPos, std::allocator<AxisPos> >>(tolua_S, 2, "std::vector<AxisPos, std::allocator<AxisPos> >*", &arg0, "CMapBase:randStepPos");

        ok &= luaval_to_object<AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapBase:randStepPos");

        ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CMapBase:randStepPos");
        if(!ok)
            return 0;
        cobj->randStepPos(arg0, arg1, arg2);
        return 0;
    }
    if (argc == 4) 
    {
        std::vector<AxisPos, std::allocator<AxisPos> >* arg0;
        AxisPos* arg1;
        unsigned short arg2;
        unsigned int arg3;

        ok &= luaval_to_object<std::vector<AxisPos, std::allocator<AxisPos> >>(tolua_S, 2, "std::vector<AxisPos, std::allocator<AxisPos> >*", &arg0, "CMapBase:randStepPos");

        ok &= luaval_to_object<AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapBase:randStepPos");

        ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CMapBase:randStepPos");

        ok &= luaval_to_uint32(tolua_S, 5,(uint32*)&arg3, "CMapBase:randStepPos");
        if(!ok)
            return 0;
        cobj->randStepPos(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CMapBase:randStepPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_randStepPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_isLineEmpty(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_isLineEmpty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const AxisPos* arg0;
        const AxisPos* arg1;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:isLineEmpty");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapBase:isLineEmpty");
        if(!ok)
            return 0;
        bool ret = cobj->isLineEmpty(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 3) 
    {
        const AxisPos* arg0;
        const AxisPos* arg1;
        unsigned char arg2;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:isLineEmpty");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapBase:isLineEmpty");

        ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CMapBase:isLineEmpty");
        if(!ok)
            return 0;
        bool ret = cobj->isLineEmpty(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapBase:isLineEmpty has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_isLineEmpty'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_setMapID(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_setMapID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapBase:setMapID");
        if(!ok)
            return 0;
        cobj->setMapID(arg0);
        return 0;
    }

    gxError("CMapBase:setMapID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_setMapID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_getMapConfig(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_getMapConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CConfigTbl* ret = cobj->getMapConfig();
        object_to_luaval<CConfigTbl>(tolua_S, "CConfigTbl",(CConfigTbl*)ret);
        return 1;
    }

    gxError("CMapBase:getMapConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_getMapConfig'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_setMapConfig(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_setMapConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CConfigTbl* arg0;

        ok &= luaval_to_object<CConfigTbl>(tolua_S, 2, "CConfigTbl", &arg0, "CMapBase:setMapConfig");
        if(!ok)
            return 0;
        cobj->setMapConfig(arg0);
        return 0;
    }

    gxError("CMapBase:setMapConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_setMapConfig'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapBase:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_getX(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_getX'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        short ret = cobj->getX();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapBase:getX has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_getX'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_getY(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_getY'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        short ret = cobj->getY();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapBase:getY has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_getY'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_verifyPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CMapBase_verifyPos'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            AxisPos* arg0;
            ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:verifyPos");

            if (!ok) { break; }
            AxisPos* arg1;
            ok &= luaval_to_object<AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapBase:verifyPos");

            if (!ok) { break; }
            AxisPos* arg2;
            ok &= luaval_to_object<AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CMapBase:verifyPos");

            if (!ok) { break; }
            cobj->verifyPos(arg0, arg1, arg2);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            AxisPos* arg0;
            ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:verifyPos");

            if (!ok) { break; }
            cobj->verifyPos(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            AxisPos* arg0;
            ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:verifyPos");

            if (!ok) { break; }
            unsigned short arg1;
            ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CMapBase:verifyPos");

            if (!ok) { break; }
            AxisPos* arg2;
            ok &= luaval_to_object<AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CMapBase:verifyPos");

            if (!ok) { break; }
            cobj->verifyPos(arg0, arg1, arg2);
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CMapBase:verifyPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_verifyPos'.",&tolua_err);
    return 0;
}
int lua_mapserver_CMapBase_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CMapBase:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_isSkillLineEmpty(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_isSkillLineEmpty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const AxisPos* arg0;
        const AxisPos* arg1;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:isSkillLineEmpty");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapBase:isSkillLineEmpty");
        if(!ok)
            return 0;
        bool ret = cobj->isSkillLineEmpty(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 3) 
    {
        const AxisPos* arg0;
        const AxisPos* arg1;
        unsigned char arg2;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:isSkillLineEmpty");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapBase:isSkillLineEmpty");

        ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CMapBase:isSkillLineEmpty");
        if(!ok)
            return 0;
        bool ret = cobj->isSkillLineEmpty(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapBase:isSkillLineEmpty has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_isSkillLineEmpty'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_randPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_randPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const AxisPos* arg0;
        const AxisPos* arg1;
        AxisPos* arg2;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:randPos");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapBase:randPos");

        ok &= luaval_to_object<AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CMapBase:randPos");
        if(!ok)
            return 0;
        cobj->randPos(arg0, arg1, arg2);
        return 0;
    }

    gxError("CMapBase:randPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_randPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_getMonsterNum(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_getMonsterNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMonsterNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapBase:getMonsterNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_getMonsterNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_getTransports(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_getTransports'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::vector<unsigned short, std::allocator<unsigned short> >* ret = cobj->getTransports();
        object_to_luaval<std::vector<unsigned short, std::allocator<unsigned short> >>(tolua_S, "std::vector<unsigned short, std::allocator<unsigned short> >*",(std::vector<unsigned short, std::allocator<unsigned short> >*)ret);
        return 1;
    }

    gxError("CMapBase:getTransports has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_getTransports'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_findRandEmptyPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CMapBase_findRandEmptyPos'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            AxisPos* arg0;
            ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:findRandEmptyPos");

            if (!ok) { break; }
            AxisPos* arg1;
            ok &= luaval_to_object<AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapBase:findRandEmptyPos");

            if (!ok) { break; }
            AxisPos* arg2;
            ok &= luaval_to_object<AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CMapBase:findRandEmptyPos");

            if (!ok) { break; }
            bool ret = cobj->findRandEmptyPos(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            AxisPos* arg0;
            ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:findRandEmptyPos");

            if (!ok) { break; }
            unsigned char arg1;
            ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CMapBase:findRandEmptyPos");

            if (!ok) { break; }
            bool ret = cobj->findRandEmptyPos(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CMapBase:findRandEmptyPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_findRandEmptyPos'.",&tolua_err);
    return 0;
}
int lua_mapserver_CMapBase_getMapType(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_getMapType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getMapType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapBase:getMapType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_getMapType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_getMapID(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_getMapID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getMapID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapBase:getMapID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_getMapID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapBase:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CMapBase:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_toString(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CMapBase:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_pushMonster(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_pushMonster'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapBase:pushMonster");
        if(!ok)
            return 0;
        cobj->pushMonster(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        unsigned short arg0;
        int arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapBase:pushMonster");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapBase:pushMonster");
        if(!ok)
            return 0;
        cobj->pushMonster(arg0, arg1);
        return 0;
    }

    gxError("CMapBase:pushMonster has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_pushMonster'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_getNpcs(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_getNpcs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::vector<unsigned short, std::allocator<unsigned short> >* ret = cobj->getNpcs();
        object_to_luaval<std::vector<unsigned short, std::allocator<unsigned short> >>(tolua_S, "std::vector<unsigned short, std::allocator<unsigned short> >*",(std::vector<unsigned short, std::allocator<unsigned short> >*)ret);
        return 1;
    }

    gxError("CMapBase:getNpcs has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_getNpcs'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_isCanWalk(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CMapBase_isCanWalk'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            short arg0;
            ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CMapBase:isCanWalk");

            if (!ok) { break; }
            short arg1;
            ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CMapBase:isCanWalk");

            if (!ok) { break; }
            bool ret = cobj->isCanWalk(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            short arg0;
            ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CMapBase:isCanWalk");

            if (!ok) { break; }
            short arg1;
            ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CMapBase:isCanWalk");

            if (!ok) { break; }
            unsigned char arg2;
            ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CMapBase:isCanWalk");

            if (!ok) { break; }
            bool ret = cobj->isCanWalk(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            const AxisPos* arg0;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:isCanWalk");

            if (!ok) { break; }
            bool ret = cobj->isCanWalk(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            const AxisPos* arg0;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:isCanWalk");

            if (!ok) { break; }
            unsigned char arg1;
            ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CMapBase:isCanWalk");

            if (!ok) { break; }
            bool ret = cobj->isCanWalk(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CMapBase:isCanWalk has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_isCanWalk'.",&tolua_err);
    return 0;
}
int lua_mapserver_CMapBase_setEmptyPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_setEmptyPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:setEmptyPos");
        if(!ok)
            return 0;
        cobj->setEmptyPos(arg0);
        return 0;
    }

    gxError("CMapBase:setEmptyPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_setEmptyPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_getEmptyPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_getEmptyPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        AxisPos* ret = cobj->getEmptyPos();
        object_to_luaval<AxisPos>(tolua_S, "AxisPos",(AxisPos*)ret);
        return 1;
    }

    gxError("CMapBase:getEmptyPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_getEmptyPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_getMonsters(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_getMonsters'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::vector<unsigned short, std::allocator<unsigned short> >* ret = cobj->getMonsters();
        object_to_luaval<std::vector<unsigned short, std::allocator<unsigned short> >>(tolua_S, "std::vector<unsigned short, std::allocator<unsigned short> >*",(std::vector<unsigned short, std::allocator<unsigned short> >*)ret);
        return 1;
    }

    gxError("CMapBase:getMonsters has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_getMonsters'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_getNpcNum(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_getNpcNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getNpcNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapBase:getNpcNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_getNpcNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_pushTransport(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_pushTransport'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapBase:pushTransport");
        if(!ok)
            return 0;
        cobj->pushTransport(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        unsigned short arg0;
        int arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapBase:pushTransport");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapBase:pushTransport");
        if(!ok)
            return 0;
        cobj->pushTransport(arg0, arg1);
        return 0;
    }

    gxError("CMapBase:pushTransport has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_pushTransport'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_findRobotPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_findRobotPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        std::vector<AxisPos, std::allocator<AxisPos> >* arg0;
        AxisPos* arg1;
        AxisPos* arg2;

        ok &= luaval_to_object<std::vector<AxisPos, std::allocator<AxisPos> >>(tolua_S, 2, "std::vector<AxisPos, std::allocator<AxisPos> >*", &arg0, "CMapBase:findRobotPos");

        ok &= luaval_to_object<AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapBase:findRobotPos");

        ok &= luaval_to_object<AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CMapBase:findRobotPos");
        if(!ok)
            return 0;
        cobj->findRobotPos(arg0, arg1, arg2);
        return 0;
    }

    gxError("CMapBase:findRobotPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_findRobotPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_getLineEmptyPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_getLineEmptyPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const AxisPos* arg0;
        const AxisPos* arg1;
        AxisPos* arg2;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:getLineEmptyPos");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapBase:getLineEmptyPos");

        ok &= luaval_to_object<AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CMapBase:getLineEmptyPos");
        if(!ok)
            return 0;
        bool ret = cobj->getLineEmptyPos(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 4) 
    {
        const AxisPos* arg0;
        const AxisPos* arg1;
        AxisPos* arg2;
        unsigned char arg3;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:getLineEmptyPos");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapBase:getLineEmptyPos");

        ok &= luaval_to_object<AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CMapBase:getLineEmptyPos");

        ok &= luaval_to_uint8(tolua_S, 5,(uint8*)&arg3, "CMapBase:getLineEmptyPos");
        if(!ok)
            return 0;
        bool ret = cobj->getLineEmptyPos(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapBase:getLineEmptyPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_getLineEmptyPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapBase:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapBase:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_getKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_findEmptyPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CMapBase_findEmptyPos'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            AxisPos* arg0;
            ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:findEmptyPos");

            if (!ok) { break; }
            AxisPos* arg1;
            ok &= luaval_to_object<AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapBase:findEmptyPos");

            if (!ok) { break; }
            AxisPos* arg2;
            ok &= luaval_to_object<AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CMapBase:findEmptyPos");

            if (!ok) { break; }
            bool ret = cobj->findEmptyPos(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            AxisPos* arg0;
            ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapBase:findEmptyPos");

            if (!ok) { break; }
            unsigned short arg1;
            ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CMapBase:findEmptyPos");

            if (!ok) { break; }
            bool ret = cobj->findEmptyPos(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CMapBase:findEmptyPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_findEmptyPos'.",&tolua_err);
    return 0;
}
int lua_mapserver_CMapBase_pushNpc(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapBase_pushNpc'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapBase:pushNpc");
        if(!ok)
            return 0;
        cobj->pushNpc(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        unsigned short arg0;
        int arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapBase:pushNpc");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapBase:pushNpc");
        if(!ok)
            return 0;
        cobj->pushNpc(arg0, arg1);
        return 0;
    }

    gxError("CMapBase:pushNpc has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapBase_pushNpc'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapBase();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapBase:CMapBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapBase* self = (CMapBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapBase");
    tolua_cclass(tolua_S,"CMapBase","CMapBase","",lua_mapserver_CMapBase_finalize);

    tolua_beginmodule(tolua_S,"CMapBase");
        tolua_function(tolua_S,"new",lua_mapserver_CMapBase_constructor);
        tolua_function(tolua_S,"load",lua_mapserver_CMapBase_load);
        tolua_function(tolua_S,"randStepPos",lua_mapserver_CMapBase_randStepPos);
        tolua_function(tolua_S,"isLineEmpty",lua_mapserver_CMapBase_isLineEmpty);
        tolua_function(tolua_S,"setMapID",lua_mapserver_CMapBase_setMapID);
        tolua_function(tolua_S,"getMapConfig",lua_mapserver_CMapBase_getMapConfig);
        tolua_function(tolua_S,"setMapConfig",lua_mapserver_CMapBase_setMapConfig);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CMapBase_keyToString);
        tolua_function(tolua_S,"getX",lua_mapserver_CMapBase_getX);
        tolua_function(tolua_S,"getY",lua_mapserver_CMapBase_getY);
        tolua_function(tolua_S,"verifyPos",lua_mapserver_CMapBase_verifyPos);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CMapBase_cleanUp);
        tolua_function(tolua_S,"isSkillLineEmpty",lua_mapserver_CMapBase_isSkillLineEmpty);
        tolua_function(tolua_S,"randPos",lua_mapserver_CMapBase_randPos);
        tolua_function(tolua_S,"getMonsterNum",lua_mapserver_CMapBase_getMonsterNum);
        tolua_function(tolua_S,"getTransports",lua_mapserver_CMapBase_getTransports);
        tolua_function(tolua_S,"findRandEmptyPos",lua_mapserver_CMapBase_findRandEmptyPos);
        tolua_function(tolua_S,"getMapType",lua_mapserver_CMapBase_getMapType);
        tolua_function(tolua_S,"getMapID",lua_mapserver_CMapBase_getMapID);
        tolua_function(tolua_S,"setKey",lua_mapserver_CMapBase_setKey);
        tolua_function(tolua_S,"toString",lua_mapserver_CMapBase_toString);
        tolua_function(tolua_S,"pushMonster",lua_mapserver_CMapBase_pushMonster);
        tolua_function(tolua_S,"getNpcs",lua_mapserver_CMapBase_getNpcs);
        tolua_function(tolua_S,"isCanWalk",lua_mapserver_CMapBase_isCanWalk);
        tolua_function(tolua_S,"setEmptyPos",lua_mapserver_CMapBase_setEmptyPos);
        tolua_function(tolua_S,"getEmptyPos",lua_mapserver_CMapBase_getEmptyPos);
        tolua_function(tolua_S,"getMonsters",lua_mapserver_CMapBase_getMonsters);
        tolua_function(tolua_S,"getNpcNum",lua_mapserver_CMapBase_getNpcNum);
        tolua_function(tolua_S,"pushTransport",lua_mapserver_CMapBase_pushTransport);
        tolua_function(tolua_S,"findRobotPos",lua_mapserver_CMapBase_findRobotPos);
        tolua_function(tolua_S,"getLineEmptyPos",lua_mapserver_CMapBase_getLineEmptyPos);
        tolua_function(tolua_S,"isKey",lua_mapserver_CMapBase_isKey);
        tolua_function(tolua_S,"getKey",lua_mapserver_CMapBase_getKey);
        tolua_function(tolua_S,"findEmptyPos",lua_mapserver_CMapBase_findEmptyPos);
        tolua_function(tolua_S,"pushNpc",lua_mapserver_CMapBase_pushNpc);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapBase).name();
    g_luaType[typeName] = "CMapBase";
    g_typeCast["CMapBase"] = "CMapBase";
    return 1;
}

static int lua_mapserver__ObjManagerInit_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (_ObjManagerInit)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"_ObjManagerInit",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        _ObjManagerInit* self = (_ObjManagerInit*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver__ObjManagerInit(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"_ObjManagerInit");
    tolua_cclass(tolua_S,"_ObjManagerInit","_ObjManagerInit","",nullptr);

    tolua_beginmodule(tolua_S,"_ObjManagerInit");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(_ObjManagerInit).name();
    g_luaType[typeName] = "_ObjManagerInit";
    g_typeCast["_ObjManagerInit"] = "_ObjManagerInit";
    return 1;
}

int lua_mapserver_CObjectManager_getNext(lua_State* tolua_S)
{
    int argc = 0;
    CObjectManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjectManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjectManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjectManager_getNext'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CGameObject* ret = cobj->getNext();
        object_to_luaval<CGameObject>(tolua_S, "CGameObject",(CGameObject*)ret);
        return 1;
    }

    gxError("CObjectManager:getNext has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjectManager_getNext'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjectManager_genObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CObjectManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjectManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjectManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjectManager_genObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->genObjUID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CObjectManager:genObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjectManager_genObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjectManager_getBegin(lua_State* tolua_S)
{
    int argc = 0;
    CObjectManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjectManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjectManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjectManager_getBegin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CGameObject* ret = cobj->getBegin();
        object_to_luaval<CGameObject>(tolua_S, "CGameObject",(CGameObject*)ret);
        return 1;
    }

    gxError("CObjectManager:getBegin has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjectManager_getBegin'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjectManager_findObj(lua_State* tolua_S)
{
    int argc = 0;
    CObjectManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjectManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjectManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjectManager_findObj'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CObjectManager:findObj");
        if(!ok)
            return 0;
        CGameObject* ret = cobj->findObj(arg0);
        object_to_luaval<CGameObject>(tolua_S, "CGameObject",(CGameObject*)ret);
        return 1;
    }

    gxError("CObjectManager:findObj has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjectManager_findObj'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjectManager_update(lua_State* tolua_S)
{
    int argc = 0;
    CObjectManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjectManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjectManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjectManager_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CObjectManager:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CObjectManager:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjectManager_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjectManager_addObj(lua_State* tolua_S)
{
    int argc = 0;
    CObjectManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjectManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjectManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjectManager_addObj'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CGameObject* arg0;

        ok &= luaval_to_object<CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CObjectManager:addObj");
        if(!ok)
            return 0;
        cobj->addObj(arg0);
        return 0;
    }

    gxError("CObjectManager:addObj has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjectManager_addObj'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjectManager_init(lua_State* tolua_S)
{
    int argc = 0;
    CObjectManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjectManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjectManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjectManager_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        _ObjManagerInit* arg0;

        ok &= luaval_to_object<_ObjManagerInit>(tolua_S, 2, "_ObjManagerInit", &arg0, "CObjectManager:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CObjectManager:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjectManager_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjectManager_isObjExist(lua_State* tolua_S)
{
    int argc = 0;
    CObjectManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjectManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjectManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjectManager_isObjExist'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CObjectManager:isObjExist");
        if(!ok)
            return 0;
        bool ret = cobj->isObjExist(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CObjectManager:isObjExist has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjectManager_isObjExist'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjectManager_delObj(lua_State* tolua_S)
{
    int argc = 0;
    CObjectManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CObjectManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CObjectManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CObjectManager_delObj'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CObjectManager:delObj");
        if(!ok)
            return 0;
        cobj->delObj(arg0);
        return 0;
    }

    gxError("CObjectManager:delObj has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CObjectManager_delObj'.",&tolua_err);
	return 0;
}
int lua_mapserver_CObjectManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CObjectManager* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CObjectManager();
        tolua_pushusertype(tolua_S,(void*)cobj,"CObjectManager");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CObjectManager:CObjectManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CObjectManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CObjectManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CObjectManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CObjectManager* self = (CObjectManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CObjectManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CObjectManager");
    tolua_cclass(tolua_S,"CObjectManager","CObjectManager","CHashMultiIndex<CGameObject, false, 4294967295>",lua_mapserver_CObjectManager_finalize);

    tolua_beginmodule(tolua_S,"CObjectManager");
        tolua_function(tolua_S,"new",lua_mapserver_CObjectManager_constructor);
        tolua_function(tolua_S,"getNext",lua_mapserver_CObjectManager_getNext);
        tolua_function(tolua_S,"genObjUID",lua_mapserver_CObjectManager_genObjUID);
        tolua_function(tolua_S,"getBegin",lua_mapserver_CObjectManager_getBegin);
        tolua_function(tolua_S,"findObj",lua_mapserver_CObjectManager_findObj);
        tolua_function(tolua_S,"update",lua_mapserver_CObjectManager_update);
        tolua_function(tolua_S,"addObj",lua_mapserver_CObjectManager_addObj);
        tolua_function(tolua_S,"init",lua_mapserver_CObjectManager_init);
        tolua_function(tolua_S,"isObjExist",lua_mapserver_CObjectManager_isObjExist);
        tolua_function(tolua_S,"delObj",lua_mapserver_CObjectManager_delObj);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CObjectManager).name();
    g_luaType[typeName] = "CObjectManager";
    g_typeCast["CObjectManager"] = "CObjectManager";
    return 1;
}

int lua_mapserver_CSceneObjectManager_setScene(lua_State* tolua_S)
{
    int argc = 0;
    CSceneObjectManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneObjectManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneObjectManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneObjectManager_setScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapSceneBase* arg0;

        ok &= luaval_to_object<CMapSceneBase>(tolua_S, 2, "CMapSceneBase", &arg0, "CSceneObjectManager:setScene");
        if(!ok)
            return 0;
        cobj->setScene(arg0);
        return 0;
    }

    gxError("CSceneObjectManager:setScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneObjectManager_setScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneObjectManager_init(lua_State* tolua_S)
{
    int argc = 0;
    CSceneObjectManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneObjectManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneObjectManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneObjectManager_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapSceneBase* arg0;

        ok &= luaval_to_object<CMapSceneBase>(tolua_S, 2, "CMapSceneBase", &arg0, "CSceneObjectManager:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSceneObjectManager:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneObjectManager_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneObjectManager_getScene(lua_State* tolua_S)
{
    int argc = 0;
    CSceneObjectManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneObjectManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneObjectManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneObjectManager_getScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapSceneBase* ret = cobj->getScene();
        object_to_luaval<CMapSceneBase>(tolua_S, "CMapSceneBase",(CMapSceneBase*)ret);
        return 1;
    }

    gxError("CSceneObjectManager:getScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneObjectManager_getScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneObjectManager_update(lua_State* tolua_S)
{
    int argc = 0;
    CSceneObjectManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneObjectManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneObjectManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneObjectManager_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSceneObjectManager:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CSceneObjectManager:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneObjectManager_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneObjectManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CSceneObjectManager* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CSceneObjectManager();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSceneObjectManager");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSceneObjectManager:CSceneObjectManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CSceneObjectManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSceneObjectManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSceneObjectManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CSceneObjectManager* self = (CSceneObjectManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CSceneObjectManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSceneObjectManager");
    tolua_cclass(tolua_S,"CSceneObjectManager","CSceneObjectManager","CObjectManager",lua_mapserver_CSceneObjectManager_finalize);

    tolua_beginmodule(tolua_S,"CSceneObjectManager");
        tolua_function(tolua_S,"new",lua_mapserver_CSceneObjectManager_constructor);
        tolua_function(tolua_S,"setScene",lua_mapserver_CSceneObjectManager_setScene);
        tolua_function(tolua_S,"init",lua_mapserver_CSceneObjectManager_init);
        tolua_function(tolua_S,"getScene",lua_mapserver_CSceneObjectManager_getScene);
        tolua_function(tolua_S,"update",lua_mapserver_CSceneObjectManager_update);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CSceneObjectManager).name();
    g_luaType[typeName] = "CSceneObjectManager";
    g_typeCast["CSceneObjectManager"] = "CSceneObjectManager";
    return 1;
}

int lua_mapserver_CSceneRoleManager_getAllRole(lua_State* tolua_S)
{
    int argc = 0;
    CSceneRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneRoleManager_getAllRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::vector<CRoleBase *, std::allocator<CRoleBase *> > arg0;

        ok &= luaval_to_vector(tolua_S, 2, "std::vector<CRoleBase *, std::allocator<CRoleBase *> >", &arg0, "CSceneRoleManager:getAllRole");
        if(!ok)
            return 0;
        cobj->getAllRole(arg0);
        return 0;
    }

    gxError("CSceneRoleManager:getAllRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneRoleManager_getAllRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneRoleManager_getRole(lua_State* tolua_S)
{
    int argc = 0;
    CSceneRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneRoleManager_getRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CSceneRoleManager:getRole");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->getRole(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CSceneRoleManager:getRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneRoleManager_getRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneRoleManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CSceneRoleManager* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CSceneRoleManager();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSceneRoleManager");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSceneRoleManager:CSceneRoleManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CSceneRoleManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSceneRoleManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSceneRoleManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CSceneRoleManager* self = (CSceneRoleManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CSceneRoleManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSceneRoleManager");
    tolua_cclass(tolua_S,"CSceneRoleManager","CSceneRoleManager","CSceneObjectManager",lua_mapserver_CSceneRoleManager_finalize);

    tolua_beginmodule(tolua_S,"CSceneRoleManager");
        tolua_function(tolua_S,"new",lua_mapserver_CSceneRoleManager_constructor);
        tolua_function(tolua_S,"getAllRole",lua_mapserver_CSceneRoleManager_getAllRole);
        tolua_function(tolua_S,"getRole",lua_mapserver_CSceneRoleManager_getRole);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CSceneRoleManager).name();
    g_luaType[typeName] = "CSceneRoleManager";
    g_typeCast["CSceneRoleManager"] = "CSceneRoleManager";
    return 1;
}

int lua_mapserver_CMapSceneBase_isFull(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_isFull'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isFull();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:isFull has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_isFull'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_initRoleInfo(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_initRoleInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:initRoleInfo");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapSceneBase:initRoleInfo");
        if(!ok)
            return 0;
        cobj->initRoleInfo(arg0, arg1);
        return 0;
    }

    gxError("CMapSceneBase:initRoleInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_initRoleInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_proInit(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_proInit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapSceneBase:proInit");
        if(!ok)
            return 0;
        bool ret = cobj->proInit(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:proInit has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_proInit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getRoleMgr(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getRoleMgr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CSceneRoleManager* ret = cobj->getRoleMgr();
        object_to_luaval<CSceneRoleManager>(tolua_S, "CSceneRoleManager",(CSceneRoleManager*)ret);
        return 1;
    }

    gxError("CMapSceneBase:getRoleMgr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getRoleMgr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getRelivePos(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getRelivePos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CRoleBase* arg0;
        EReliveType arg1;
        MapIDRangePos* arg2;

        ok &= luaval_to_object<CRoleBase>(tolua_S, 2, "CRoleBase", &arg0, "CMapSceneBase:getRelivePos");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapSceneBase:getRelivePos");

        ok &= luaval_to_object<MapIDRangePos>(tolua_S, 4, "MapIDRangePos", &arg2, "CMapSceneBase:getRelivePos");
        if(!ok)
            return 0;
        int ret = (int)cobj->getRelivePos(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapSceneBase:getRelivePos has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getRelivePos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_calcBlockID(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_calcBlockID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:calcBlockID");
        if(!ok)
            return 0;
        int ret = cobj->calcBlockID(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapSceneBase:calcBlockID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_calcBlockID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_putEmptyGourpID(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_putEmptyGourpID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:putEmptyGourpID");
        if(!ok)
            return 0;
        cobj->putEmptyGourpID(arg0);
        return 0;
    }

    gxError("CMapSceneBase:putEmptyGourpID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_putEmptyGourpID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_findRandEmptyPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CMapSceneBase_findRandEmptyPos'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            AxisPos* arg0;
            ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:findRandEmptyPos");

            if (!ok) { break; }
            AxisPos* arg1;
            ok &= luaval_to_object<AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapSceneBase:findRandEmptyPos");

            if (!ok) { break; }
            AxisPos* arg2;
            ok &= luaval_to_object<AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CMapSceneBase:findRandEmptyPos");

            if (!ok) { break; }
            bool ret = cobj->findRandEmptyPos(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            AxisPos* arg0;
            ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:findRandEmptyPos");

            if (!ok) { break; }
            unsigned short arg1;
            ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CMapSceneBase:findRandEmptyPos");

            if (!ok) { break; }
            bool ret = cobj->findRandEmptyPos(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CMapSceneBase:findRandEmptyPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_findRandEmptyPos'.",&tolua_err);
    return 0;
}
int lua_mapserver_CMapSceneBase_init(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapBase* arg0;

        ok &= luaval_to_object<CMapBase>(tolua_S, 2, "CMapBase", &arg0, "CMapSceneBase:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_scanObject(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_scanObject'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        int arg0;
        unsigned char arg1;
        std::vector<CGameObject *, std::allocator<CGameObject *> > arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:scanObject");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CMapSceneBase:scanObject");

        ok &= luaval_to_vector(tolua_S, 4, "std::vector<CGameObject *, std::allocator<CGameObject *> >", &arg2, "CMapSceneBase:scanObject");
        if(!ok)
            return 0;
        bool ret = cobj->scanObject(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:scanObject has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_scanObject'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getIsNeedClose(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getIsNeedClose'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getIsNeedClose();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:getIsNeedClose has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getIsNeedClose'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_onRoleLeave(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_onRoleLeave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CRoleBase* arg0;
        bool arg1;

        ok &= luaval_to_object<CRoleBase>(tolua_S, 2, "CRoleBase", &arg0, "CMapSceneBase:onRoleLeave");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CMapSceneBase:onRoleLeave");
        if(!ok)
            return 0;
        cobj->onRoleLeave(arg0, arg1);
        return 0;
    }

    gxError("CMapSceneBase:onRoleLeave has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_onRoleLeave'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_clearBlock(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CMapSceneBase_clearBlock'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            const AxisPos* arg0;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:clearBlock");

            if (!ok) { break; }
            cobj->clearBlock(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            const AxisPos* arg0;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:clearBlock");

            if (!ok) { break; }
            char arg1;
            ok &= luaval_to_sint8(tolua_S, 3,(sint8*)&arg1, "CMapSceneBase:clearBlock");

            if (!ok) { break; }
            cobj->clearBlock(arg0, arg1);
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CMapSceneBase:clearBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_clearBlock'.",&tolua_err);
    return 0;
}
int lua_mapserver_CMapSceneBase_isMaxRoleNum(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_isMaxRoleNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isMaxRoleNum();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:isMaxRoleNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_isMaxRoleNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_leave(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_leave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CGameObject* arg0;
        bool arg1;

        ok &= luaval_to_object<CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CMapSceneBase:leave");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CMapSceneBase:leave");
        if(!ok)
            return 0;
        cobj->leave(arg0, arg1);
        return 0;
    }

    gxError("CMapSceneBase:leave has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_leave'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_onRoleEnter(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_onRoleEnter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CRoleBase* arg0;

        ok &= luaval_to_object<CRoleBase>(tolua_S, 2, "CRoleBase", &arg0, "CMapSceneBase:onRoleEnter");
        if(!ok)
            return 0;
        cobj->onRoleEnter(arg0);
        return 0;
    }

    gxError("CMapSceneBase:onRoleEnter has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_onRoleEnter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_findRandPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_findRandPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        AxisPos* arg0;
        unsigned short arg1;

        ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:findRandPos");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CMapSceneBase:findRandPos");
        if(!ok)
            return 0;
        bool ret = cobj->findRandPos(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:findRandPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_findRandPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_findEmptyPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CMapSceneBase_findEmptyPos'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            AxisPos* arg0;
            ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:findEmptyPos");

            if (!ok) { break; }
            unsigned short arg1;
            ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CMapSceneBase:findEmptyPos");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CMapSceneBase:findEmptyPos");

            if (!ok) { break; }
            bool ret = cobj->findEmptyPos(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            AxisPos* arg0;
            ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:findEmptyPos");

            if (!ok) { break; }
            unsigned short arg1;
            ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CMapSceneBase:findEmptyPos");

            if (!ok) { break; }
            bool ret = cobj->findEmptyPos(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            AxisPos* arg0;
            ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:findEmptyPos");

            if (!ok) { break; }
            AxisPos* arg1;
            ok &= luaval_to_object<AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapSceneBase:findEmptyPos");

            if (!ok) { break; }
            AxisPos* arg2;
            ok &= luaval_to_object<AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CMapSceneBase:findEmptyPos");

            if (!ok) { break; }
            bool ret = cobj->findEmptyPos(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CMapSceneBase:findEmptyPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_findEmptyPos'.",&tolua_err);
    return 0;
}
int lua_mapserver_CMapSceneBase_getMaxNumInGroup(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getMaxNumInGroup'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxNumInGroup();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapSceneBase:getMaxNumInGroup has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getMaxNumInGroup'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_randStepPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_randStepPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        std::vector<AxisPos, std::allocator<AxisPos> >* arg0;
        AxisPos* arg1;
        unsigned short arg2;

        ok &= luaval_to_object<std::vector<AxisPos, std::allocator<AxisPos> >>(tolua_S, 2, "std::vector<AxisPos, std::allocator<AxisPos> >*", &arg0, "CMapSceneBase:randStepPos");

        ok &= luaval_to_object<AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapSceneBase:randStepPos");

        ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CMapSceneBase:randStepPos");
        if(!ok)
            return 0;
        cobj->randStepPos(arg0, arg1, arg2);
        return 0;
    }
    if (argc == 4) 
    {
        std::vector<AxisPos, std::allocator<AxisPos> >* arg0;
        AxisPos* arg1;
        unsigned short arg2;
        unsigned int arg3;

        ok &= luaval_to_object<std::vector<AxisPos, std::allocator<AxisPos> >>(tolua_S, 2, "std::vector<AxisPos, std::allocator<AxisPos> >*", &arg0, "CMapSceneBase:randStepPos");

        ok &= luaval_to_object<AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapSceneBase:randStepPos");

        ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CMapSceneBase:randStepPos");

        ok &= luaval_to_uint32(tolua_S, 5,(uint32*)&arg3, "CMapSceneBase:randStepPos");
        if(!ok)
            return 0;
        cobj->randStepPos(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CMapSceneBase:randStepPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_randStepPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_proMonsterLeaveScene(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_proMonsterLeaveScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned int arg0;
        unsigned short arg1;
        unsigned int arg2;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CMapSceneBase:proMonsterLeaveScene");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CMapSceneBase:proMonsterLeaveScene");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CMapSceneBase:proMonsterLeaveScene");
        if(!ok)
            return 0;
        cobj->proMonsterLeaveScene(arg0, arg1, arg2);
        return 0;
    }

    gxError("CMapSceneBase:proMonsterLeaveScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_proMonsterLeaveScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_posValidate(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_posValidate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:posValidate");
        if(!ok)
            return 0;
        const bool ret = cobj->posValidate(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:posValidate has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_posValidate'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_leaveBlock(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_leaveBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CGameObject* arg0;

        ok &= luaval_to_object<CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CMapSceneBase:leaveBlock");
        if(!ok)
            return 0;
        cobj->leaveBlock(arg0);
        return 0;
    }

    gxError("CMapSceneBase:leaveBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_leaveBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getBlocksInRange(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getBlocksInRange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        std::vector<int, std::allocator<int> >* arg0;
        unsigned short arg1;
        int arg2;
        bool arg3;

        ok &= luaval_to_object<std::vector<int, std::allocator<int> >>(tolua_S, 2, "std::vector<int, std::allocator<int> >*", &arg0, "CMapSceneBase:getBlocksInRange");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CMapSceneBase:getBlocksInRange");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CMapSceneBase:getBlocksInRange");

        ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CMapSceneBase:getBlocksInRange");
        if(!ok)
            return 0;
        cobj->getBlocksInRange(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CMapSceneBase:getBlocksInRange has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getBlocksInRange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_proRoleEnterScene(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_proRoleEnterScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CRoleBase* arg0;

        ok &= luaval_to_object<CRoleBase>(tolua_S, 2, "CRoleBase", &arg0, "CMapSceneBase:proRoleEnterScene");
        if(!ok)
            return 0;
        cobj->proRoleEnterScene(arg0);
        return 0;
    }

    gxError("CMapSceneBase:proRoleEnterScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_proRoleEnterScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_objBlockRegister(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_objBlockRegister'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CGameObject* arg0;
        int arg1;

        ok &= luaval_to_object<CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CMapSceneBase:objBlockRegister");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapSceneBase:objBlockRegister");
        if(!ok)
            return 0;
        bool ret = cobj->objBlockRegister(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:objBlockRegister has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_objBlockRegister'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getKickPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getKickPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        MapIDRangePos* arg0;
        CRoleBase* arg1;

        ok &= luaval_to_object<MapIDRangePos>(tolua_S, 2, "MapIDRangePos", &arg0, "CMapSceneBase:getKickPos");

        ok &= luaval_to_object<CRoleBase>(tolua_S, 3, "CRoleBase", &arg1, "CMapSceneBase:getKickPos");
        if(!ok)
            return 0;
        bool ret = cobj->getKickPos(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:getKickPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getKickPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getCharacterByUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getCharacterByUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CMapSceneBase:getCharacterByUID");
        if(!ok)
            return 0;
        CCharacterObject* ret = cobj->getCharacterByUID(arg0);
        object_to_luaval<CCharacterObject>(tolua_S, "CCharacterObject",(CCharacterObject*)ret);
        return 1;
    }

    gxError("CMapSceneBase:getCharacterByUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getCharacterByUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getObjectMgr(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getObjectMgr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CSceneObjectManager* ret = cobj->getObjectMgr();
        object_to_luaval<CSceneObjectManager>(tolua_S, "CSceneObjectManager",(CSceneObjectManager*)ret);
        return 1;
    }

    gxError("CMapSceneBase:getObjectMgr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getObjectMgr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_kickSingleRole(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_kickSingleRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CRoleBase* arg0;

        ok &= luaval_to_object<CRoleBase>(tolua_S, 2, "CRoleBase", &arg0, "CMapSceneBase:kickSingleRole");
        if(!ok)
            return 0;
        cobj->kickSingleRole(arg0);
        return 0;
    }

    gxError("CMapSceneBase:kickSingleRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_kickSingleRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_clearObjectBlock(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_clearObjectBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:clearObjectBlock");
        if(!ok)
            return 0;
        cobj->clearObjectBlock(arg0);
        return 0;
    }

    gxError("CMapSceneBase:clearObjectBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_clearObjectBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_toString(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CMapSceneBase:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_isForceUpdateAllBlock(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_isForceUpdateAllBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isForceUpdateAllBlock();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:isForceUpdateAllBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_isForceUpdateAllBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getTile(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getTile'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:getTile");
        if(!ok)
            return 0;
        const _SrvMapTile* ret = cobj->getTile(arg0);
        object_to_luaval<_SrvMapTile>(tolua_S, "_SrvMapTile",(_SrvMapTile*)ret);
        return 1;
    }

    gxError("CMapSceneBase:getTile has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getTile'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_objBlockUnregister(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_objBlockUnregister'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CGameObject* arg0;
        int arg1;

        ok &= luaval_to_object<CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CMapSceneBase:objBlockUnregister");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapSceneBase:objBlockUnregister");
        if(!ok)
            return 0;
        bool ret = cobj->objBlockUnregister(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:objBlockUnregister has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_objBlockUnregister'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_isNormalScene(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_isNormalScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNormalScene();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:isNormalScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_isNormalScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_kickAllRole(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_kickAllRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->kickAllRole();
        return 0;
    }

    gxError("CMapSceneBase:kickAllRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_kickAllRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getAllRoleSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getAllRoleSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CArray<unsigned long long, 10, unsigned char>* arg0;

        ok &= luaval_to_object<GXMISC::CArray<unsigned long long, 10, unsigned char>>(tolua_S, 2, "CArray<unsigned long long, 10, unsigned char>", &arg0, "CMapSceneBase:getAllRoleSocketIndex");
        if(!ok)
            return 0;
        cobj->getAllRoleSocketIndex(arg0);
        return 0;
    }

    gxError("CMapSceneBase:getAllRoleSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getAllRoleSocketIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_setOwnerObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_setOwnerObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CMapSceneBase:setOwnerObjUID");
        if(!ok)
            return 0;
        cobj->setOwnerObjUID(arg0);
        return 0;
    }

    gxError("CMapSceneBase:setOwnerObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_setOwnerObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getMapData(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getMapData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapBase* ret = cobj->getMapData();
        object_to_luaval<CMapBase>(tolua_S, "CMapBase",(CMapBase*)ret);
        return 1;
    }

    gxError("CMapSceneBase:getMapData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getMapData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_objBlockChanged(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_objBlockChanged'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CGameObject* arg0;
        int arg1;
        int arg2;

        ok &= luaval_to_object<CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CMapSceneBase:objBlockChanged");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapSceneBase:objBlockChanged");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CMapSceneBase:objBlockChanged");
        if(!ok)
            return 0;
        bool ret = cobj->objBlockChanged(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:objBlockChanged has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_objBlockChanged'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getKey();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CMapSceneBase:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_axisRange2BlockRange(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_axisRange2BlockRange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const AxisPos* arg0;
        unsigned char arg1;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:axisRange2BlockRange");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CMapSceneBase:axisRange2BlockRange");
        if(!ok)
            return 0;
        unsigned char ret = cobj->axisRange2BlockRange(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapSceneBase:axisRange2BlockRange has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_axisRange2BlockRange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_load(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_load'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->load();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:load has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_load'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_onUnload(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_onUnload'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onUnload();
        return 0;
    }

    gxError("CMapSceneBase:onUnload has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_onUnload'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapSceneBase:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getRectInRange(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getRectInRange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        _BlockRect* arg0;
        char arg1;
        int arg2;

        ok &= luaval_to_object<_BlockRect>(tolua_S, 2, "_BlockRect", &arg0, "CMapSceneBase:getRectInRange");

        ok &= luaval_to_sint8(tolua_S, 3,(sint8*)&arg1, "CMapSceneBase:getRectInRange");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CMapSceneBase:getRectInRange");
        if(!ok)
            return 0;
        cobj->getRectInRange(arg0, arg1, arg2);
        return 0;
    }

    gxError("CMapSceneBase:getRectInRange has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getRectInRange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CMapSceneBase:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_blockRangeInTwo(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_blockRangeInTwo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:blockRangeInTwo");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapSceneBase:blockRangeInTwo");
        if(!ok)
            return 0;
        unsigned char ret = cobj->blockRangeInTwo(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapSceneBase:blockRangeInTwo has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_blockRangeInTwo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getObjByUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getObjByUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CMapSceneBase:getObjByUID");
        if(!ok)
            return 0;
        CGameObject* ret = cobj->getObjByUID(arg0);
        object_to_luaval<CGameObject>(tolua_S, "CGameObject",(CGameObject*)ret);
        return 1;
    }

    gxError("CMapSceneBase:getObjByUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getObjByUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_checkObjectBlock(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_checkObjectBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:checkObjectBlock");
        if(!ok)
            return 0;
        const bool ret = cobj->checkObjectBlock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:checkObjectBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_checkObjectBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getOwnerObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getOwnerObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getOwnerObjUID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapSceneBase:getOwnerObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getOwnerObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getMapID(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getMapID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getMapID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapSceneBase:getMapID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getMapID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_scanObjSub(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_scanObjSub'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        int arg0;
        int arg1;
        unsigned char arg2;
        std::vector<CGameObject *, std::allocator<CGameObject *> > arg3;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:scanObjSub");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapSceneBase:scanObjSub");

        ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CMapSceneBase:scanObjSub");

        ok &= luaval_to_vector(tolua_S, 5, "std::vector<CGameObject *, std::allocator<CGameObject *> >", &arg3, "CMapSceneBase:scanObjSub");
        if(!ok)
            return 0;
        bool ret = cobj->scanObjSub(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:scanObjSub has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_scanObjSub'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_scanRole(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CMapSceneBase_scanRole'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:scanRole");

            if (!ok) { break; }
            unsigned char arg1;
            ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CMapSceneBase:scanRole");

            if (!ok) { break; }
            std::vector<CRoleBase *, std::allocator<CRoleBase *> > arg2;
            ok &= luaval_to_vector(tolua_S, 4, "std::vector<CRoleBase *, std::allocator<CRoleBase *> >", &arg2, "CMapSceneBase:scanRole");

            if (!ok) { break; }
            bool ret = cobj->scanRole(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            AxisPos* arg0;
            ok &= luaval_to_object<AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:scanRole");

            if (!ok) { break; }
            unsigned char arg1;
            ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CMapSceneBase:scanRole");

            if (!ok) { break; }
            std::vector<CRoleBase *, std::allocator<CRoleBase *> > arg2;
            ok &= luaval_to_vector(tolua_S, 4, "std::vector<CRoleBase *, std::allocator<CRoleBase *> >", &arg2, "CMapSceneBase:scanRole");

            if (!ok) { break; }
            bool ret = cobj->scanRole(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CMapSceneBase:scanRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_scanRole'.",&tolua_err);
    return 0;
}
int lua_mapserver_CMapSceneBase_setObjectBlock(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_setObjectBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const AxisPos* arg0;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:setObjectBlock");
        if(!ok)
            return 0;
        cobj->setObjectBlock(arg0);
        return 0;
    }

    gxError("CMapSceneBase:setObjectBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_setObjectBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getEmptyGroupID(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getEmptyGroupID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getEmptyGroupID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapSceneBase:getEmptyGroupID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getEmptyGroupID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_setIsNeedClose(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_setIsNeedClose'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CMapSceneBase:setIsNeedClose");
        if(!ok)
            return 0;
        cobj->setIsNeedClose(arg0);
        return 0;
    }

    gxError("CMapSceneBase:setIsNeedClose has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_setIsNeedClose'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_isDynamicScene(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_isDynamicScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDynamicScene();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:isDynamicScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_isDynamicScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_proUpdate(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_proUpdate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:proUpdate");
        if(!ok)
            return 0;
        bool ret = cobj->proUpdate(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:proUpdate has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_proUpdate'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_setSceneID(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_setSceneID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapSceneBase:setSceneID");
        if(!ok)
            return 0;
        cobj->setSceneID(arg0);
        return 0;
    }

    gxError("CMapSceneBase:setSceneID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_setSceneID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getLineEmptyPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CMapSceneBase_getLineEmptyPos'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 4) {
            const AxisPos* arg0;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:getLineEmptyPos");

            if (!ok) { break; }
            const AxisPos* arg1;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapSceneBase:getLineEmptyPos");

            if (!ok) { break; }
            unsigned short arg2;
            ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CMapSceneBase:getLineEmptyPos");

            if (!ok) { break; }
            AxisPos* arg3;
            ok &= luaval_to_object<AxisPos>(tolua_S, 5, "AxisPos", &arg3, "CMapSceneBase:getLineEmptyPos");

            if (!ok) { break; }
            bool ret = cobj->getLineEmptyPos(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            const AxisPos* arg0;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:getLineEmptyPos");

            if (!ok) { break; }
            const AxisPos* arg1;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapSceneBase:getLineEmptyPos");

            if (!ok) { break; }
            AxisPos* arg2;
            ok &= luaval_to_object<AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CMapSceneBase:getLineEmptyPos");

            if (!ok) { break; }
            bool ret = cobj->getLineEmptyPos(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CMapSceneBase:getLineEmptyPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getLineEmptyPos'.",&tolua_err);
    return 0;
}
int lua_mapserver_CMapSceneBase_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_checkBlock(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CMapSceneBase_checkBlock'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            short arg0;
            ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CMapSceneBase:checkBlock");

            if (!ok) { break; }
            short arg1;
            ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CMapSceneBase:checkBlock");

            if (!ok) { break; }
            char arg2;
            ok &= luaval_to_sint8(tolua_S, 4,(sint8*)&arg2, "CMapSceneBase:checkBlock");

            if (!ok) { break; }
            const bool ret = cobj->checkBlock(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            const AxisPos* arg0;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:checkBlock");

            if (!ok) { break; }
            char arg1;
            ok &= luaval_to_sint8(tolua_S, 3,(sint8*)&arg1, "CMapSceneBase:checkBlock");

            if (!ok) { break; }
            const bool ret = cobj->checkBlock(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            short arg0;
            ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CMapSceneBase:checkBlock");

            if (!ok) { break; }
            short arg1;
            ok &= luaval_to_sint16(tolua_S, 3,(sint16*)&arg1, "CMapSceneBase:checkBlock");

            if (!ok) { break; }
            const bool ret = cobj->checkBlock(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            const AxisPos* arg0;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:checkBlock");

            if (!ok) { break; }
            const bool ret = cobj->checkBlock(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CMapSceneBase:checkBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_checkBlock'.",&tolua_err);
    return 0;
}
int lua_mapserver_CMapSceneBase_onInit(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_onInit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onInit();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:onInit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_onInit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_scanRoleSub(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_scanRoleSub'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        int arg0;
        int arg1;
        unsigned char arg2;
        std::vector<CRoleBase *, std::allocator<CRoleBase *> > arg3;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:scanRoleSub");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapSceneBase:scanRoleSub");

        ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CMapSceneBase:scanRoleSub");

        ok &= luaval_to_vector(tolua_S, 5, "std::vector<CRoleBase *, std::allocator<CRoleBase *> >", &arg3, "CMapSceneBase:scanRoleSub");
        if(!ok)
            return 0;
        bool ret = cobj->scanRoleSub(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:scanRoleSub has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_scanRoleSub'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_isCanEnter(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_isCanEnter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isCanEnter();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:isCanEnter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_isCanEnter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_isBlockDirty(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_isBlockDirty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:isBlockDirty");
        if(!ok)
            return 0;
        bool ret = cobj->isBlockDirty(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:isBlockDirty has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_isBlockDirty'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_isLineEmpty(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_isLineEmpty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const AxisPos* arg0;
        const AxisPos* arg1;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:isLineEmpty");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapSceneBase:isLineEmpty");
        if(!ok)
            return 0;
        bool ret = cobj->isLineEmpty(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:isLineEmpty has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_isLineEmpty'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_scan(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_scan'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CScanOperator* arg0;
        bool arg1;

        ok &= luaval_to_object<CScanOperator>(tolua_S, 2, "CScanOperator", &arg0, "CMapSceneBase:scan");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CMapSceneBase:scan");
        if(!ok)
            return 0;
        bool ret = cobj->scan(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:scan has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_scan'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getSceneData(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getSceneData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        SceneData* arg0;

        ok &= luaval_to_object<SceneData>(tolua_S, 2, "SceneData", &arg0, "CMapSceneBase:getSceneData");
        if(!ok)
            return 0;
        cobj->getSceneData(arg0);
        return 0;
    }

    gxError("CMapSceneBase:getSceneData has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getSceneData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getMaxRoleNum(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getMaxRoleNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getMaxRoleNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapSceneBase:getMaxRoleNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getMaxRoleNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_randPos(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_randPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const AxisPos* arg0;
        const AxisPos* arg1;
        AxisPos* arg2;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:randPos");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapSceneBase:randPos");

        ok &= luaval_to_object<AxisPos>(tolua_S, 4, "AxisPos", &arg2, "CMapSceneBase:randPos");
        if(!ok)
            return 0;
        cobj->randPos(arg0, arg1, arg2);
        return 0;
    }

    gxError("CMapSceneBase:randPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_randPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_proRoleLeaveScene(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_proRoleLeaveScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CRoleBase* arg0;
        bool arg1;

        ok &= luaval_to_object<CRoleBase>(tolua_S, 2, "CRoleBase", &arg0, "CMapSceneBase:proRoleLeaveScene");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CMapSceneBase:proRoleLeaveScene");
        if(!ok)
            return 0;
        cobj->proRoleLeaveScene(arg0, arg1);
        return 0;
    }

    gxError("CMapSceneBase:proRoleLeaveScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_proRoleLeaveScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapSceneBase:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CMapSceneBase:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_checkBlockID(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_checkBlockID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:checkBlockID");
        if(!ok)
            return 0;
        bool ret = cobj->checkBlockID(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:checkBlockID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_checkBlockID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getSceneID(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getSceneID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getSceneID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CMapSceneBase:getSceneID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getSceneID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_setSceneType(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_setSceneType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ESceneType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:setSceneType");
        if(!ok)
            return 0;
        cobj->setSceneType(arg0);
        return 0;
    }

    gxError("CMapSceneBase:setSceneType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_setSceneType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_isInCurBlock(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_isInCurBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        int arg0;
        AxisPos* arg1;
        unsigned char arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:isInCurBlock");

        ok &= luaval_to_object<AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CMapSceneBase:isInCurBlock");

        ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CMapSceneBase:isInCurBlock");
        if(!ok)
            return 0;
        bool ret = cobj->isInCurBlock(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:isInCurBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_isInCurBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_update(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getSceneType(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getSceneType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getSceneType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapSceneBase:getSceneType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getSceneType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_canEnter(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_canEnter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canEnter();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:canEnter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_canEnter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_getBlock(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_getBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:getBlock");
        if(!ok)
            return 0;
        CBlock* ret = cobj->getBlock(arg0);
        object_to_luaval<CBlock>(tolua_S, "CBlock",(CBlock*)ret);
        return 1;
    }

    gxError("CMapSceneBase:getBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_getBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_unload(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_unload'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->unload();
        return 0;
    }

    gxError("CMapSceneBase:unload has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_unload'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_setBlock(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CMapSceneBase_setBlock'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            const AxisPos* arg0;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:setBlock");

            if (!ok) { break; }
            cobj->setBlock(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            const AxisPos* arg0;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:setBlock");

            if (!ok) { break; }
            char arg1;
            ok &= luaval_to_sint8(tolua_S, 3,(sint8*)&arg1, "CMapSceneBase:setBlock");

            if (!ok) { break; }
            cobj->setBlock(arg0, arg1);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            const AxisPos* arg0;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CMapSceneBase:setBlock");

            if (!ok) { break; }
            unsigned short arg1;
            ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CMapSceneBase:setBlock");

            if (!ok) { break; }
            char arg2;
            ok &= luaval_to_sint8(tolua_S, 4,(sint8*)&arg2, "CMapSceneBase:setBlock");

            if (!ok) { break; }
            cobj->setBlock(arg0, arg1, arg2);
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CMapSceneBase:setBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_setBlock'.",&tolua_err);
    return 0;
}
int lua_mapserver_CMapSceneBase_enter(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_enter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CGameObject* arg0;

        ok &= luaval_to_object<CGameObject>(tolua_S, 2, "CGameObject", &arg0, "CMapSceneBase:enter");
        if(!ok)
            return 0;
        bool ret = cobj->enter(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapSceneBase:enter has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_enter'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_signUpdateBlock(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapSceneBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapSceneBase_signUpdateBlock'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapSceneBase:signUpdateBlock");
        if(!ok)
            return 0;
        cobj->signUpdateBlock(arg0);
        return 0;
    }

    gxError("CMapSceneBase:signUpdateBlock has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapSceneBase_signUpdateBlock'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapSceneBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapSceneBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapSceneBase();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapSceneBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapSceneBase:CMapSceneBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapSceneBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapSceneBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapSceneBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapSceneBase* self = (CMapSceneBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapSceneBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapSceneBase");
    tolua_cclass(tolua_S,"CMapSceneBase","CMapSceneBase","",lua_mapserver_CMapSceneBase_finalize);

    tolua_beginmodule(tolua_S,"CMapSceneBase");
        tolua_function(tolua_S,"new",lua_mapserver_CMapSceneBase_constructor);
        tolua_function(tolua_S,"isFull",lua_mapserver_CMapSceneBase_isFull);
        tolua_function(tolua_S,"initRoleInfo",lua_mapserver_CMapSceneBase_initRoleInfo);
        tolua_function(tolua_S,"proInit",lua_mapserver_CMapSceneBase_proInit);
        tolua_function(tolua_S,"getRoleMgr",lua_mapserver_CMapSceneBase_getRoleMgr);
        tolua_function(tolua_S,"getRelivePos",lua_mapserver_CMapSceneBase_getRelivePos);
        tolua_function(tolua_S,"calcBlockID",lua_mapserver_CMapSceneBase_calcBlockID);
        tolua_function(tolua_S,"putEmptyGourpID",lua_mapserver_CMapSceneBase_putEmptyGourpID);
        tolua_function(tolua_S,"findRandEmptyPos",lua_mapserver_CMapSceneBase_findRandEmptyPos);
        tolua_function(tolua_S,"init",lua_mapserver_CMapSceneBase_init);
        tolua_function(tolua_S,"scanObject",lua_mapserver_CMapSceneBase_scanObject);
        tolua_function(tolua_S,"getIsNeedClose",lua_mapserver_CMapSceneBase_getIsNeedClose);
        tolua_function(tolua_S,"onRoleLeave",lua_mapserver_CMapSceneBase_onRoleLeave);
        tolua_function(tolua_S,"clearBlock",lua_mapserver_CMapSceneBase_clearBlock);
        tolua_function(tolua_S,"isMaxRoleNum",lua_mapserver_CMapSceneBase_isMaxRoleNum);
        tolua_function(tolua_S,"leave",lua_mapserver_CMapSceneBase_leave);
        tolua_function(tolua_S,"onRoleEnter",lua_mapserver_CMapSceneBase_onRoleEnter);
        tolua_function(tolua_S,"findRandPos",lua_mapserver_CMapSceneBase_findRandPos);
        tolua_function(tolua_S,"findEmptyPos",lua_mapserver_CMapSceneBase_findEmptyPos);
        tolua_function(tolua_S,"getMaxNumInGroup",lua_mapserver_CMapSceneBase_getMaxNumInGroup);
        tolua_function(tolua_S,"randStepPos",lua_mapserver_CMapSceneBase_randStepPos);
        tolua_function(tolua_S,"proMonsterLeaveScene",lua_mapserver_CMapSceneBase_proMonsterLeaveScene);
        tolua_function(tolua_S,"posValidate",lua_mapserver_CMapSceneBase_posValidate);
        tolua_function(tolua_S,"leaveBlock",lua_mapserver_CMapSceneBase_leaveBlock);
        tolua_function(tolua_S,"getBlocksInRange",lua_mapserver_CMapSceneBase_getBlocksInRange);
        tolua_function(tolua_S,"proRoleEnterScene",lua_mapserver_CMapSceneBase_proRoleEnterScene);
        tolua_function(tolua_S,"objBlockRegister",lua_mapserver_CMapSceneBase_objBlockRegister);
        tolua_function(tolua_S,"getKickPos",lua_mapserver_CMapSceneBase_getKickPos);
        tolua_function(tolua_S,"getCharacterByUID",lua_mapserver_CMapSceneBase_getCharacterByUID);
        tolua_function(tolua_S,"getObjectMgr",lua_mapserver_CMapSceneBase_getObjectMgr);
        tolua_function(tolua_S,"kickSingleRole",lua_mapserver_CMapSceneBase_kickSingleRole);
        tolua_function(tolua_S,"clearObjectBlock",lua_mapserver_CMapSceneBase_clearObjectBlock);
        tolua_function(tolua_S,"toString",lua_mapserver_CMapSceneBase_toString);
        tolua_function(tolua_S,"isForceUpdateAllBlock",lua_mapserver_CMapSceneBase_isForceUpdateAllBlock);
        tolua_function(tolua_S,"getTile",lua_mapserver_CMapSceneBase_getTile);
        tolua_function(tolua_S,"objBlockUnregister",lua_mapserver_CMapSceneBase_objBlockUnregister);
        tolua_function(tolua_S,"isNormalScene",lua_mapserver_CMapSceneBase_isNormalScene);
        tolua_function(tolua_S,"kickAllRole",lua_mapserver_CMapSceneBase_kickAllRole);
        tolua_function(tolua_S,"getAllRoleSocketIndex",lua_mapserver_CMapSceneBase_getAllRoleSocketIndex);
        tolua_function(tolua_S,"setOwnerObjUID",lua_mapserver_CMapSceneBase_setOwnerObjUID);
        tolua_function(tolua_S,"getMapData",lua_mapserver_CMapSceneBase_getMapData);
        tolua_function(tolua_S,"objBlockChanged",lua_mapserver_CMapSceneBase_objBlockChanged);
        tolua_function(tolua_S,"getKey",lua_mapserver_CMapSceneBase_getKey);
        tolua_function(tolua_S,"axisRange2BlockRange",lua_mapserver_CMapSceneBase_axisRange2BlockRange);
        tolua_function(tolua_S,"load",lua_mapserver_CMapSceneBase_load);
        tolua_function(tolua_S,"onUnload",lua_mapserver_CMapSceneBase_onUnload);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CMapSceneBase_keyToString);
        tolua_function(tolua_S,"getRectInRange",lua_mapserver_CMapSceneBase_getRectInRange);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_CMapSceneBase_cleanUp);
        tolua_function(tolua_S,"blockRangeInTwo",lua_mapserver_CMapSceneBase_blockRangeInTwo);
        tolua_function(tolua_S,"getObjByUID",lua_mapserver_CMapSceneBase_getObjByUID);
        tolua_function(tolua_S,"checkObjectBlock",lua_mapserver_CMapSceneBase_checkObjectBlock);
        tolua_function(tolua_S,"getOwnerObjUID",lua_mapserver_CMapSceneBase_getOwnerObjUID);
        tolua_function(tolua_S,"getMapID",lua_mapserver_CMapSceneBase_getMapID);
        tolua_function(tolua_S,"scanObjSub",lua_mapserver_CMapSceneBase_scanObjSub);
        tolua_function(tolua_S,"scanRole",lua_mapserver_CMapSceneBase_scanRole);
        tolua_function(tolua_S,"setObjectBlock",lua_mapserver_CMapSceneBase_setObjectBlock);
        tolua_function(tolua_S,"getEmptyGroupID",lua_mapserver_CMapSceneBase_getEmptyGroupID);
        tolua_function(tolua_S,"setIsNeedClose",lua_mapserver_CMapSceneBase_setIsNeedClose);
        tolua_function(tolua_S,"isDynamicScene",lua_mapserver_CMapSceneBase_isDynamicScene);
        tolua_function(tolua_S,"proUpdate",lua_mapserver_CMapSceneBase_proUpdate);
        tolua_function(tolua_S,"setSceneID",lua_mapserver_CMapSceneBase_setSceneID);
        tolua_function(tolua_S,"getLineEmptyPos",lua_mapserver_CMapSceneBase_getLineEmptyPos);
        tolua_function(tolua_S,"isKey",lua_mapserver_CMapSceneBase_isKey);
        tolua_function(tolua_S,"checkBlock",lua_mapserver_CMapSceneBase_checkBlock);
        tolua_function(tolua_S,"onInit",lua_mapserver_CMapSceneBase_onInit);
        tolua_function(tolua_S,"scanRoleSub",lua_mapserver_CMapSceneBase_scanRoleSub);
        tolua_function(tolua_S,"isCanEnter",lua_mapserver_CMapSceneBase_isCanEnter);
        tolua_function(tolua_S,"isBlockDirty",lua_mapserver_CMapSceneBase_isBlockDirty);
        tolua_function(tolua_S,"isLineEmpty",lua_mapserver_CMapSceneBase_isLineEmpty);
        tolua_function(tolua_S,"scan",lua_mapserver_CMapSceneBase_scan);
        tolua_function(tolua_S,"getSceneData",lua_mapserver_CMapSceneBase_getSceneData);
        tolua_function(tolua_S,"getMaxRoleNum",lua_mapserver_CMapSceneBase_getMaxRoleNum);
        tolua_function(tolua_S,"randPos",lua_mapserver_CMapSceneBase_randPos);
        tolua_function(tolua_S,"proRoleLeaveScene",lua_mapserver_CMapSceneBase_proRoleLeaveScene);
        tolua_function(tolua_S,"setKey",lua_mapserver_CMapSceneBase_setKey);
        tolua_function(tolua_S,"checkBlockID",lua_mapserver_CMapSceneBase_checkBlockID);
        tolua_function(tolua_S,"getSceneID",lua_mapserver_CMapSceneBase_getSceneID);
        tolua_function(tolua_S,"setSceneType",lua_mapserver_CMapSceneBase_setSceneType);
        tolua_function(tolua_S,"isInCurBlock",lua_mapserver_CMapSceneBase_isInCurBlock);
        tolua_function(tolua_S,"update",lua_mapserver_CMapSceneBase_update);
        tolua_function(tolua_S,"getSceneType",lua_mapserver_CMapSceneBase_getSceneType);
        tolua_function(tolua_S,"canEnter",lua_mapserver_CMapSceneBase_canEnter);
        tolua_function(tolua_S,"getBlock",lua_mapserver_CMapSceneBase_getBlock);
        tolua_function(tolua_S,"unload",lua_mapserver_CMapSceneBase_unload);
        tolua_function(tolua_S,"setBlock",lua_mapserver_CMapSceneBase_setBlock);
        tolua_function(tolua_S,"enter",lua_mapserver_CMapSceneBase_enter);
        tolua_function(tolua_S,"signUpdateBlock",lua_mapserver_CMapSceneBase_signUpdateBlock);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapSceneBase).name();
    g_luaType[typeName] = "CMapSceneBase";
    g_typeCast["CMapSceneBase"] = "CMapSceneBase";
    return 1;
}

int lua_mapserver_CAvoidOverlap_getIndex(lua_State* tolua_S)
{
    int argc = 0;
    CAvoidOverlap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAvoidOverlap",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAvoidOverlap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAvoidOverlap_getIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const AxisPos* arg0;
        const AxisPos* arg1;

        ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CAvoidOverlap:getIndex");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CAvoidOverlap:getIndex");
        if(!ok)
            return 0;
        short ret = cobj->getIndex(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CAvoidOverlap:getIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAvoidOverlap_getIndex'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAvoidOverlap_resetUsedDir(lua_State* tolua_S)
{
    int argc = 0;
    CAvoidOverlap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAvoidOverlap",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAvoidOverlap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAvoidOverlap_resetUsedDir'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->resetUsedDir();
        return 0;
    }

    gxError("CAvoidOverlap:resetUsedDir has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAvoidOverlap_resetUsedDir'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAvoidOverlap_setSitPos(lua_State* tolua_S)
{
    int argc = 0;
    CAvoidOverlap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAvoidOverlap",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAvoidOverlap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAvoidOverlap_setSitPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        short arg0;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CAvoidOverlap:setSitPos");
        if(!ok)
            return 0;
        cobj->setSitPos(arg0);
        return 0;
    }

    gxError("CAvoidOverlap:setSitPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAvoidOverlap_setSitPos'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAvoidOverlap_isEmpty(lua_State* tolua_S)
{
    int argc = 0;
    CAvoidOverlap* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAvoidOverlap",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAvoidOverlap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CAvoidOverlap_isEmpty'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            short arg0;
            ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CAvoidOverlap:isEmpty");

            if (!ok) { break; }
            bool ret = cobj->isEmpty(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            const AxisPos* arg0;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 2, "AxisPos", &arg0, "CAvoidOverlap:isEmpty");

            if (!ok) { break; }
            const AxisPos* arg1;
            ok &= luaval_to_object<const AxisPos>(tolua_S, 3, "AxisPos", &arg1, "CAvoidOverlap:isEmpty");

            if (!ok) { break; }
            bool ret = cobj->isEmpty(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CAvoidOverlap:isEmpty has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAvoidOverlap_isEmpty'.",&tolua_err);
    return 0;
}
int lua_mapserver_CAvoidOverlap_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CAvoidOverlap* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CAvoidOverlap();
        tolua_pushusertype(tolua_S,(void*)cobj,"CAvoidOverlap");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CAvoidOverlap:CAvoidOverlap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CAvoidOverlap_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CAvoidOverlap)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CAvoidOverlap",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CAvoidOverlap* self = (CAvoidOverlap*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CAvoidOverlap(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CAvoidOverlap");
    tolua_cclass(tolua_S,"CAvoidOverlap","CAvoidOverlap","",lua_mapserver_CAvoidOverlap_finalize);

    tolua_beginmodule(tolua_S,"CAvoidOverlap");
        tolua_function(tolua_S,"new",lua_mapserver_CAvoidOverlap_constructor);
        tolua_function(tolua_S,"getIndex",lua_mapserver_CAvoidOverlap_getIndex);
        tolua_function(tolua_S,"resetUsedDir",lua_mapserver_CAvoidOverlap_resetUsedDir);
        tolua_function(tolua_S,"setSitPos",lua_mapserver_CAvoidOverlap_setSitPos);
        tolua_function(tolua_S,"isEmpty",lua_mapserver_CAvoidOverlap_isEmpty);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CAvoidOverlap).name();
    g_luaType[typeName] = "CAvoidOverlap";
    g_typeCast["CAvoidOverlap"] = "CAvoidOverlap";
    return 1;
}

int lua_mapserver_CMapScene_load(lua_State* tolua_S)
{
    int argc = 0;
    CMapScene* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapScene",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapScene*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapScene_load'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->load();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapScene:load has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapScene_load'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CMapScene_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapScene)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapScene",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapScene* self = (CMapScene*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapScene(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapScene");
    tolua_cclass(tolua_S,"CMapScene","CMapScene","CMapSceneBase",nullptr);

    tolua_beginmodule(tolua_S,"CMapScene");
        tolua_function(tolua_S,"load",lua_mapserver_CMapScene_load);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapScene).name();
    g_luaType[typeName] = "CMapScene";
    g_typeCast["CMapScene"] = "CMapScene";
    return 1;
}

int lua_mapserver_MCUpdateMissionList_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCUpdateMissionList* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCUpdateMissionList",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCUpdateMissionList*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCUpdateMissionList_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCUpdateMissionList:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCUpdateMissionList_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCUpdateMissionList_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCUpdateMissionList",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCUpdateMissionList::Setup();
        return 0;
    }
    gxError("MCUpdateMissionList:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCUpdateMissionList_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCUpdateMissionList_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCUpdateMissionList",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCUpdateMissionList::Unsetup();
        return 0;
    }
    gxError("MCUpdateMissionList:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCUpdateMissionList_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCUpdateMissionList_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCUpdateMissionList",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCUpdateMissionList* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCUpdateMissionList>(tolua_S, 2, "MCUpdateMissionList", &arg0, "MCUpdateMissionList:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCUpdateMissionList:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCUpdateMissionList:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCUpdateMissionList::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCUpdateMissionList:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCUpdateMissionList_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCUpdateMissionList_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCUpdateMissionList* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCUpdateMissionList();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCUpdateMissionList");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCUpdateMissionList:MCUpdateMissionList has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCUpdateMissionList_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCUpdateMissionList)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCUpdateMissionList",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCUpdateMissionList* self = (MCUpdateMissionList*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCUpdateMissionList(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCUpdateMissionList");
    tolua_cclass(tolua_S,"MCUpdateMissionList","MCUpdateMissionList","CServerPacket",lua_mapserver_MCUpdateMissionList_finalize);

    tolua_beginmodule(tolua_S,"MCUpdateMissionList");
        tolua_function(tolua_S,"new",lua_mapserver_MCUpdateMissionList_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCUpdateMissionList_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCUpdateMissionList_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCUpdateMissionList_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCUpdateMissionList_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCUpdateMissionList).name();
    g_luaType[typeName] = "MCUpdateMissionList";
    g_typeCast["MCUpdateMissionList"] = "MCUpdateMissionList";
    return 1;
}

int lua_mapserver_MCUpdateMissionParam_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCUpdateMissionParam* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCUpdateMissionParam",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCUpdateMissionParam*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCUpdateMissionParam_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCUpdateMissionParam:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCUpdateMissionParam_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCUpdateMissionParam_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCUpdateMissionParam",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCUpdateMissionParam::Setup();
        return 0;
    }
    gxError("MCUpdateMissionParam:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCUpdateMissionParam_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCUpdateMissionParam_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCUpdateMissionParam",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCUpdateMissionParam::Unsetup();
        return 0;
    }
    gxError("MCUpdateMissionParam:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCUpdateMissionParam_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCUpdateMissionParam_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCUpdateMissionParam",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCUpdateMissionParam* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCUpdateMissionParam>(tolua_S, 2, "MCUpdateMissionParam", &arg0, "MCUpdateMissionParam:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCUpdateMissionParam:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCUpdateMissionParam:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCUpdateMissionParam::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCUpdateMissionParam:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCUpdateMissionParam_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCUpdateMissionParam_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCUpdateMissionParam* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCUpdateMissionParam();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCUpdateMissionParam");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCUpdateMissionParam:MCUpdateMissionParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCUpdateMissionParam_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCUpdateMissionParam)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCUpdateMissionParam",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCUpdateMissionParam* self = (MCUpdateMissionParam*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCUpdateMissionParam(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCUpdateMissionParam");
    tolua_cclass(tolua_S,"MCUpdateMissionParam","MCUpdateMissionParam","CServerPacket",lua_mapserver_MCUpdateMissionParam_finalize);

    tolua_beginmodule(tolua_S,"MCUpdateMissionParam");
        tolua_function(tolua_S,"new",lua_mapserver_MCUpdateMissionParam_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCUpdateMissionParam_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCUpdateMissionParam_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCUpdateMissionParam_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCUpdateMissionParam_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCUpdateMissionParam).name();
    g_luaType[typeName] = "MCUpdateMissionParam";
    g_typeCast["MCUpdateMissionParam"] = "MCUpdateMissionParam";
    return 1;
}

int lua_mapserver_MCDeleteMission_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCDeleteMission* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCDeleteMission",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCDeleteMission*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCDeleteMission_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCDeleteMission:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCDeleteMission_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCDeleteMission_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCDeleteMission* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCDeleteMission();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCDeleteMission");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCDeleteMission:MCDeleteMission has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCDeleteMission_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCDeleteMission)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCDeleteMission",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCDeleteMission* self = (MCDeleteMission*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCDeleteMission(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCDeleteMission");
    tolua_cclass(tolua_S,"MCDeleteMission","MCDeleteMission","CServerPacket",lua_mapserver_MCDeleteMission_finalize);

    tolua_beginmodule(tolua_S,"MCDeleteMission");
        tolua_function(tolua_S,"new",lua_mapserver_MCDeleteMission_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCDeleteMission_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCDeleteMission).name();
    g_luaType[typeName] = "MCDeleteMission";
    g_typeCast["MCDeleteMission"] = "MCDeleteMission";
    return 1;
}

int lua_mapserver_CMMissionOperate_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMMissionOperate* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMMissionOperate",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMMissionOperate*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMMissionOperate_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMMissionOperate:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMMissionOperate_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMMissionOperate_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMMissionOperate* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMMissionOperate();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMMissionOperate");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMMissionOperate:CMMissionOperate has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMMissionOperate_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMMissionOperate)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMMissionOperate",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMMissionOperate* self = (CMMissionOperate*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMMissionOperate(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMMissionOperate");
    tolua_cclass(tolua_S,"CMMissionOperate","CMMissionOperate","CRequestPacket",lua_mapserver_CMMissionOperate_finalize);

    tolua_beginmodule(tolua_S,"CMMissionOperate");
        tolua_function(tolua_S,"new",lua_mapserver_CMMissionOperate_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMMissionOperate_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMMissionOperate).name();
    g_luaType[typeName] = "CMMissionOperate";
    g_typeCast["CMMissionOperate"] = "CMMissionOperate";
    return 1;
}

int lua_mapserver_MCMissionOperateRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCMissionOperateRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCMissionOperateRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCMissionOperateRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCMissionOperateRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCMissionOperateRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCMissionOperateRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCMissionOperateRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCMissionOperateRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCMissionOperateRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCMissionOperateRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCMissionOperateRet:MCMissionOperateRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCMissionOperateRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCMissionOperateRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCMissionOperateRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCMissionOperateRet* self = (MCMissionOperateRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCMissionOperateRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCMissionOperateRet");
    tolua_cclass(tolua_S,"MCMissionOperateRet","MCMissionOperateRet","CResponsePacket",lua_mapserver_MCMissionOperateRet_finalize);

    tolua_beginmodule(tolua_S,"MCMissionOperateRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCMissionOperateRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCMissionOperateRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCMissionOperateRet).name();
    g_luaType[typeName] = "MCMissionOperateRet";
    g_typeCast["MCMissionOperateRet"] = "MCMissionOperateRet";
    return 1;
}

int lua_mapserver_MCAddItems_toString(lua_State* tolua_S)
{
    int argc = 0;
    MCAddItems* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCAddItems",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCAddItems*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCAddItems_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("MCAddItems:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCAddItems_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCAddItems_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCAddItems* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCAddItems",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCAddItems*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCAddItems_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCAddItems:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCAddItems_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCAddItems_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCAddItems",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCAddItems::Setup();
        return 0;
    }
    gxError("MCAddItems:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCAddItems_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCAddItems_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCAddItems",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCAddItems::Unsetup();
        return 0;
    }
    gxError("MCAddItems:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCAddItems_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCAddItems_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCAddItems",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCAddItems* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCAddItems>(tolua_S, 2, "MCAddItems", &arg0, "MCAddItems:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCAddItems:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCAddItems:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCAddItems::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCAddItems:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCAddItems_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCAddItems_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCAddItems* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCAddItems();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCAddItems");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCAddItems:MCAddItems has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCAddItems_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCAddItems)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCAddItems",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCAddItems* self = (MCAddItems*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCAddItems(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCAddItems");
    tolua_cclass(tolua_S,"MCAddItems","MCAddItems","CServerPacket",lua_mapserver_MCAddItems_finalize);

    tolua_beginmodule(tolua_S,"MCAddItems");
        tolua_function(tolua_S,"new",lua_mapserver_MCAddItems_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_MCAddItems_toString);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCAddItems_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCAddItems_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCAddItems_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCAddItems_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCAddItems).name();
    g_luaType[typeName] = "MCAddItems";
    g_typeCast["MCAddItems"] = "MCAddItems";
    return 1;
}

int lua_mapserver_MCDelItems_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCDelItems* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCDelItems",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCDelItems*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCDelItems_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCDelItems:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCDelItems_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCDelItems_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCDelItems",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCDelItems::Setup();
        return 0;
    }
    gxError("MCDelItems:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCDelItems_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCDelItems_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCDelItems",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCDelItems::Unsetup();
        return 0;
    }
    gxError("MCDelItems:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCDelItems_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCDelItems_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCDelItems",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCDelItems* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCDelItems>(tolua_S, 2, "MCDelItems", &arg0, "MCDelItems:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCDelItems:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCDelItems:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCDelItems::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCDelItems:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCDelItems_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCDelItems_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCDelItems* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCDelItems();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCDelItems");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCDelItems:MCDelItems has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCDelItems_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCDelItems)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCDelItems",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCDelItems* self = (MCDelItems*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCDelItems(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCDelItems");
    tolua_cclass(tolua_S,"MCDelItems","MCDelItems","CServerPacket",lua_mapserver_MCDelItems_finalize);

    tolua_beginmodule(tolua_S,"MCDelItems");
        tolua_function(tolua_S,"new",lua_mapserver_MCDelItems_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCDelItems_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCDelItems_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCDelItems_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCDelItems_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCDelItems).name();
    g_luaType[typeName] = "MCDelItems";
    g_typeCast["MCDelItems"] = "MCDelItems";
    return 1;
}

int lua_mapserver_MCUpdateItems_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCUpdateItems* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCUpdateItems",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCUpdateItems*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCUpdateItems_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCUpdateItems:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCUpdateItems_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCUpdateItems_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCUpdateItems",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCUpdateItems::Setup();
        return 0;
    }
    gxError("MCUpdateItems:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCUpdateItems_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCUpdateItems_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCUpdateItems",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCUpdateItems::Unsetup();
        return 0;
    }
    gxError("MCUpdateItems:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCUpdateItems_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCUpdateItems_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCUpdateItems",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCUpdateItems* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCUpdateItems>(tolua_S, 2, "MCUpdateItems", &arg0, "MCUpdateItems:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCUpdateItems:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCUpdateItems:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCUpdateItems::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCUpdateItems:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCUpdateItems_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCUpdateItems_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCUpdateItems* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCUpdateItems();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCUpdateItems");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCUpdateItems:MCUpdateItems has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCUpdateItems_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCUpdateItems)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCUpdateItems",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCUpdateItems* self = (MCUpdateItems*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCUpdateItems(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCUpdateItems");
    tolua_cclass(tolua_S,"MCUpdateItems","MCUpdateItems","CServerPacket",lua_mapserver_MCUpdateItems_finalize);

    tolua_beginmodule(tolua_S,"MCUpdateItems");
        tolua_function(tolua_S,"new",lua_mapserver_MCUpdateItems_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCUpdateItems_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCUpdateItems_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCUpdateItems_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCUpdateItems_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCUpdateItems).name();
    g_luaType[typeName] = "MCUpdateItems";
    g_typeCast["MCUpdateItems"] = "MCUpdateItems";
    return 1;
}

int lua_mapserver_MCMoveItems_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCMoveItems* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCMoveItems",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCMoveItems*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCMoveItems_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCMoveItems:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCMoveItems_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCMoveItems_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCMoveItems",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCMoveItems::Setup();
        return 0;
    }
    gxError("MCMoveItems:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCMoveItems_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCMoveItems_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCMoveItems",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        MCMoveItems::Unsetup();
        return 0;
    }
    gxError("MCMoveItems:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCMoveItems_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCMoveItems_Unpacket(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"MCMoveItems",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        MCMoveItems* arg0;
        const char* arg1;
        int arg2;
        ok &= luaval_to_object<MCMoveItems>(tolua_S, 2, "MCMoveItems", &arg0, "MCMoveItems:Unpacket");
        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "MCMoveItems:Unpacket"); arg1 = (char*)arg1_tmp.buffer;
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "MCMoveItems:Unpacket");
        if(!ok)
            return 0;
        bool ret = MCMoveItems::Unpacket(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("MCMoveItems:Unpacket has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCMoveItems_Unpacket'.", &tolua_err);
    return 0;
}
int lua_mapserver_MCMoveItems_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCMoveItems* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCMoveItems();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCMoveItems");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCMoveItems:MCMoveItems has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCMoveItems_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCMoveItems)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCMoveItems",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCMoveItems* self = (MCMoveItems*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCMoveItems(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCMoveItems");
    tolua_cclass(tolua_S,"MCMoveItems","MCMoveItems","CServerPacket",lua_mapserver_MCMoveItems_finalize);

    tolua_beginmodule(tolua_S,"MCMoveItems");
        tolua_function(tolua_S,"new",lua_mapserver_MCMoveItems_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCMoveItems_getPackLen);
        tolua_function(tolua_S,"Setup", lua_mapserver_MCMoveItems_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_MCMoveItems_Unsetup);
        tolua_function(tolua_S,"Unpacket", lua_mapserver_MCMoveItems_Unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCMoveItems).name();
    g_luaType[typeName] = "MCMoveItems";
    g_typeCast["MCMoveItems"] = "MCMoveItems";
    return 1;
}

int lua_mapserver_MCExchangeItem_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCExchangeItem* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCExchangeItem",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCExchangeItem*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCExchangeItem_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCExchangeItem:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCExchangeItem_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCExchangeItem_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCExchangeItem* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCExchangeItem();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCExchangeItem");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCExchangeItem:MCExchangeItem has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCExchangeItem_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCExchangeItem)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCExchangeItem",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCExchangeItem* self = (MCExchangeItem*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCExchangeItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCExchangeItem");
    tolua_cclass(tolua_S,"MCExchangeItem","MCExchangeItem","CServerPacket",lua_mapserver_MCExchangeItem_finalize);

    tolua_beginmodule(tolua_S,"MCExchangeItem");
        tolua_function(tolua_S,"new",lua_mapserver_MCExchangeItem_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCExchangeItem_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCExchangeItem).name();
    g_luaType[typeName] = "MCExchangeItem";
    g_typeCast["MCExchangeItem"] = "MCExchangeItem";
    return 1;
}

int lua_mapserver_CMBagOperate_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMBagOperate* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMBagOperate",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMBagOperate*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMBagOperate_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMBagOperate:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMBagOperate_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMBagOperate_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMBagOperate* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMBagOperate();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMBagOperate");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMBagOperate:CMBagOperate has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMBagOperate_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMBagOperate)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMBagOperate",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMBagOperate* self = (CMBagOperate*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMBagOperate(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMBagOperate");
    tolua_cclass(tolua_S,"CMBagOperate","CMBagOperate","CRequestPacket",lua_mapserver_CMBagOperate_finalize);

    tolua_beginmodule(tolua_S,"CMBagOperate");
        tolua_function(tolua_S,"new",lua_mapserver_CMBagOperate_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMBagOperate_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMBagOperate).name();
    g_luaType[typeName] = "CMBagOperate";
    g_typeCast["CMBagOperate"] = "CMBagOperate";
    return 1;
}

int lua_mapserver_MCBagOperateRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCBagOperateRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCBagOperateRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCBagOperateRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCBagOperateRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCBagOperateRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCBagOperateRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCBagOperateRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCBagOperateRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCBagOperateRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCBagOperateRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCBagOperateRet:MCBagOperateRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCBagOperateRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCBagOperateRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCBagOperateRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCBagOperateRet* self = (MCBagOperateRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCBagOperateRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCBagOperateRet");
    tolua_cclass(tolua_S,"MCBagOperateRet","MCBagOperateRet","CResponsePacket",lua_mapserver_MCBagOperateRet_finalize);

    tolua_beginmodule(tolua_S,"MCBagOperateRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCBagOperateRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCBagOperateRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCBagOperateRet).name();
    g_luaType[typeName] = "MCBagOperateRet";
    g_typeCast["MCBagOperateRet"] = "MCBagOperateRet";
    return 1;
}

int lua_mapserver_CMBagExtend_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMBagExtend* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMBagExtend",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMBagExtend*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMBagExtend_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMBagExtend:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMBagExtend_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMBagExtend_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMBagExtend* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMBagExtend();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMBagExtend");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMBagExtend:CMBagExtend has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMBagExtend_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMBagExtend)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMBagExtend",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMBagExtend* self = (CMBagExtend*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMBagExtend(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMBagExtend");
    tolua_cclass(tolua_S,"CMBagExtend","CMBagExtend","CRequestPacket",lua_mapserver_CMBagExtend_finalize);

    tolua_beginmodule(tolua_S,"CMBagExtend");
        tolua_function(tolua_S,"new",lua_mapserver_CMBagExtend_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMBagExtend_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMBagExtend).name();
    g_luaType[typeName] = "CMBagExtend";
    g_typeCast["CMBagExtend"] = "CMBagExtend";
    return 1;
}

int lua_mapserver_MCBagExtendRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCBagExtendRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCBagExtendRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCBagExtendRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCBagExtendRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCBagExtendRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCBagExtendRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCBagExtendRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCBagExtendRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCBagExtendRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCBagExtendRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCBagExtendRet:MCBagExtendRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCBagExtendRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCBagExtendRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCBagExtendRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCBagExtendRet* self = (MCBagExtendRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCBagExtendRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCBagExtendRet");
    tolua_cclass(tolua_S,"MCBagExtendRet","MCBagExtendRet","CResponsePacket",lua_mapserver_MCBagExtendRet_finalize);

    tolua_beginmodule(tolua_S,"MCBagExtendRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCBagExtendRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCBagExtendRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCBagExtendRet).name();
    g_luaType[typeName] = "MCBagExtendRet";
    g_typeCast["MCBagExtendRet"] = "MCBagExtendRet";
    return 1;
}

int lua_mapserver_MCBagExtend_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCBagExtend* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCBagExtend",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCBagExtend*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCBagExtend_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCBagExtend:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCBagExtend_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCBagExtend_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCBagExtend* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCBagExtend();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCBagExtend");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCBagExtend:MCBagExtend has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCBagExtend_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCBagExtend)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCBagExtend",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCBagExtend* self = (MCBagExtend*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCBagExtend(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCBagExtend");
    tolua_cclass(tolua_S,"MCBagExtend","MCBagExtend","CServerPacket",lua_mapserver_MCBagExtend_finalize);

    tolua_beginmodule(tolua_S,"MCBagExtend");
        tolua_function(tolua_S,"new",lua_mapserver_MCBagExtend_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCBagExtend_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCBagExtend).name();
    g_luaType[typeName] = "MCBagExtend";
    g_typeCast["MCBagExtend"] = "MCBagExtend";
    return 1;
}

int lua_mapserver_CMExchangeGiftReq_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CMExchangeGiftReq* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMExchangeGiftReq",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMExchangeGiftReq*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMExchangeGiftReq_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMExchangeGiftReq:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMExchangeGiftReq_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMExchangeGiftReq_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMExchangeGiftReq* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMExchangeGiftReq();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMExchangeGiftReq");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMExchangeGiftReq:CMExchangeGiftReq has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMExchangeGiftReq_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMExchangeGiftReq)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMExchangeGiftReq",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMExchangeGiftReq* self = (CMExchangeGiftReq*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMExchangeGiftReq(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMExchangeGiftReq");
    tolua_cclass(tolua_S,"CMExchangeGiftReq","CMExchangeGiftReq","CRequestPacket",lua_mapserver_CMExchangeGiftReq_finalize);

    tolua_beginmodule(tolua_S,"CMExchangeGiftReq");
        tolua_function(tolua_S,"new",lua_mapserver_CMExchangeGiftReq_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CMExchangeGiftReq_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMExchangeGiftReq).name();
    g_luaType[typeName] = "CMExchangeGiftReq";
    g_typeCast["CMExchangeGiftReq"] = "CMExchangeGiftReq";
    return 1;
}

int lua_mapserver_MCExchangeGiftRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    MCExchangeGiftRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"MCExchangeGiftRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (MCExchangeGiftRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_MCExchangeGiftRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("MCExchangeGiftRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_MCExchangeGiftRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_MCExchangeGiftRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    MCExchangeGiftRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new MCExchangeGiftRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"MCExchangeGiftRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("MCExchangeGiftRet:MCExchangeGiftRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_MCExchangeGiftRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (MCExchangeGiftRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"MCExchangeGiftRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        MCExchangeGiftRet* self = (MCExchangeGiftRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_MCExchangeGiftRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"MCExchangeGiftRet");
    tolua_cclass(tolua_S,"MCExchangeGiftRet","MCExchangeGiftRet","CResponsePacket",lua_mapserver_MCExchangeGiftRet_finalize);

    tolua_beginmodule(tolua_S,"MCExchangeGiftRet");
        tolua_function(tolua_S,"new",lua_mapserver_MCExchangeGiftRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_MCExchangeGiftRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(MCExchangeGiftRet).name();
    g_luaType[typeName] = "MCExchangeGiftRet";
    g_typeCast["MCExchangeGiftRet"] = "MCExchangeGiftRet";
    return 1;
}

int lua_mapserver_CMapPlayerHandler_handleLocalLoginAccount(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_handleLocalLoginAccount'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMLocalLoginGameAccount* arg0;

        ok &= luaval_to_object<CMLocalLoginGameAccount>(tolua_S, 2, "CMLocalLoginGameAccount", &arg0, "CMapPlayerHandler:handleLocalLoginAccount");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleLocalLoginAccount(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:handleLocalLoginAccount has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_handleLocalLoginAccount'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_handleJump(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_handleJump'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMJump* arg0;

        ok &= luaval_to_object<CMJump>(tolua_S, 2, "CMJump", &arg0, "CMapPlayerHandler:handleJump");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleJump(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:handleJump has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_handleJump'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_initScriptObject(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_initScriptObject'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CLuaVM* arg0;

        ok &= luaval_to_object<GXMISC::CLuaVM>(tolua_S, 2, "CLuaVM", &arg0, "CMapPlayerHandler:initScriptObject");
        if(!ok)
            return 0;
        bool ret = cobj->initScriptObject(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:initScriptObject has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_initScriptObject'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_handleDrop(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_handleDrop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMDrop* arg0;

        ok &= luaval_to_object<CMDrop>(tolua_S, 2, "CMDrop", &arg0, "CMapPlayerHandler:handleDrop");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleDrop(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:handleDrop has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_handleDrop'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_handleTransmite(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_handleTransmite'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMTransmite* arg0;

        ok &= luaval_to_object<CMTransmite>(tolua_S, 2, "CMTransmite", &arg0, "CMapPlayerHandler:handleTransmite");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleTransmite(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:handleTransmite has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_handleTransmite'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_handleLand(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_handleLand'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMLand* arg0;

        ok &= luaval_to_object<CMLand>(tolua_S, 2, "CMLand", &arg0, "CMapPlayerHandler:handleLand");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleLand(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:handleLand has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_handleLand'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_handleRandRoleName(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_handleRandRoleName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMRandRoleName* arg0;

        ok &= luaval_to_object<CMRandRoleName>(tolua_S, 2, "CMRandRoleName", &arg0, "CMapPlayerHandler:handleRandRoleName");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleRandRoleName(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:handleRandRoleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_handleRandRoleName'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_handleChat(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_handleChat'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMChat* arg0;

        ok &= luaval_to_object<CMChat>(tolua_S, 2, "CMChat", &arg0, "CMapPlayerHandler:handleChat");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleChat(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:handleChat has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_handleChat'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_handleLocalLogin(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_handleLocalLogin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMLocalLoginGame* arg0;

        ok &= luaval_to_object<CMLocalLoginGame>(tolua_S, 2, "CMLocalLoginGame", &arg0, "CMapPlayerHandler:handleLocalLogin");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleLocalLogin(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:handleLocalLogin has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_handleLocalLogin'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_start(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_start'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_handleEnterScene(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_handleEnterScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMEnterScene* arg0;

        ok &= luaval_to_object<CMEnterScene>(tolua_S, 2, "CMEnterScene", &arg0, "CMapPlayerHandler:handleEnterScene");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleEnterScene(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:handleEnterScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_handleEnterScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_handleEnterGame(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_handleEnterGame'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMEnterGame* arg0;

        ok &= luaval_to_object<CMEnterGame>(tolua_S, 2, "CMEnterGame", &arg0, "CMapPlayerHandler:handleEnterGame");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleEnterGame(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:handleEnterGame has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_handleEnterGame'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_handleMissionOperate(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_handleMissionOperate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMMissionOperate* arg0;

        ok &= luaval_to_object<CMMissionOperate>(tolua_S, 2, "CMMissionOperate", &arg0, "CMapPlayerHandler:handleMissionOperate");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleMissionOperate(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:handleMissionOperate has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_handleMissionOperate'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_handleMove(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_handleMove'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMMove* arg0;

        ok &= luaval_to_object<CMMove>(tolua_S, 2, "CMMove", &arg0, "CMapPlayerHandler:handleMove");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleMove(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:handleMove has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_handleMove'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_handleRename(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapPlayerHandler_handleRename'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMRenameRoleName* arg0;

        ok &= luaval_to_object<CMRenameRoleName>(tolua_S, 2, "CMRenameRoleName", &arg0, "CMapPlayerHandler:handleRename");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleRename(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapPlayerHandler:handleRename has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_handleRename'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapPlayerHandler_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMapPlayerHandler::Setup();
        return 0;
    }
    gxError("CMapPlayerHandler:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMapPlayerHandler_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMapPlayerHandler",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMapPlayerHandler::Unsetup();
        return 0;
    }
    gxError("CMapPlayerHandler:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapPlayerHandler_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMapPlayerHandler_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapPlayerHandler* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapPlayerHandler();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapPlayerHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapPlayerHandler:CMapPlayerHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapPlayerHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapPlayerHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapPlayerHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapPlayerHandler* self = (CMapPlayerHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapPlayerHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapPlayerHandler");
    tolua_cclass(tolua_S,"CMapPlayerHandler","CMapPlayerHandler","CMapPlayerHandlerBase",lua_mapserver_CMapPlayerHandler_finalize);

    tolua_beginmodule(tolua_S,"CMapPlayerHandler");
        tolua_function(tolua_S,"new",lua_mapserver_CMapPlayerHandler_constructor);
        tolua_function(tolua_S,"handleLocalLoginAccount",lua_mapserver_CMapPlayerHandler_handleLocalLoginAccount);
        tolua_function(tolua_S,"handleJump",lua_mapserver_CMapPlayerHandler_handleJump);
        tolua_function(tolua_S,"initScriptObject",lua_mapserver_CMapPlayerHandler_initScriptObject);
        tolua_function(tolua_S,"handleDrop",lua_mapserver_CMapPlayerHandler_handleDrop);
        tolua_function(tolua_S,"handleTransmite",lua_mapserver_CMapPlayerHandler_handleTransmite);
        tolua_function(tolua_S,"handleLand",lua_mapserver_CMapPlayerHandler_handleLand);
        tolua_function(tolua_S,"handleRandRoleName",lua_mapserver_CMapPlayerHandler_handleRandRoleName);
        tolua_function(tolua_S,"handleChat",lua_mapserver_CMapPlayerHandler_handleChat);
        tolua_function(tolua_S,"handleLocalLogin",lua_mapserver_CMapPlayerHandler_handleLocalLogin);
        tolua_function(tolua_S,"start",lua_mapserver_CMapPlayerHandler_start);
        tolua_function(tolua_S,"handleEnterScene",lua_mapserver_CMapPlayerHandler_handleEnterScene);
        tolua_function(tolua_S,"handleEnterGame",lua_mapserver_CMapPlayerHandler_handleEnterGame);
        tolua_function(tolua_S,"handleMissionOperate",lua_mapserver_CMapPlayerHandler_handleMissionOperate);
        tolua_function(tolua_S,"handleMove",lua_mapserver_CMapPlayerHandler_handleMove);
        tolua_function(tolua_S,"handleRename",lua_mapserver_CMapPlayerHandler_handleRename);
        tolua_function(tolua_S,"Setup", lua_mapserver_CMapPlayerHandler_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_CMapPlayerHandler_Unsetup);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapPlayerHandler).name();
    g_luaType[typeName] = "CMapPlayerHandler";
    g_typeCast["CMapPlayerHandler"] = "CMapPlayerHandler";
    return 1;
}

int lua_mapserver_CMapDbPlayerHandler_sendLoadDataTask(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandler_sendLoadDataTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        LoadRoleData* arg0;
        ChangeLineTempData* arg1;
        unsigned long long arg2;
        unsigned long long arg3;
        bool arg4;

        ok &= luaval_to_object<LoadRoleData>(tolua_S, 2, "LoadRoleData", &arg0, "CMapDbPlayerHandler:sendLoadDataTask");

        ok &= luaval_to_object<ChangeLineTempData>(tolua_S, 3, "ChangeLineTempData", &arg1, "CMapDbPlayerHandler:sendLoadDataTask");

        ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CMapDbPlayerHandler:sendLoadDataTask");

        ok &= luaval_to_uint64(tolua_S, 5, (uint64*)&arg3, "CMapDbPlayerHandler:sendLoadDataTask");

        ok &= luaval_to_boolean(tolua_S, 6,(bool*)&arg4, "CMapDbPlayerHandler:sendLoadDataTask");
        if(!ok)
            return 0;
        bool ret = cobj->sendLoadDataTask(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapDbPlayerHandler:sendLoadDataTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandler_sendLoadDataTask'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandler_sendUpdateRoleData(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandler_sendUpdateRoleData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CHumanDB* arg0;
        ESaveRoleType arg1;

        ok &= luaval_to_object<CHumanDB>(tolua_S, 2, "CHumanDB", &arg0, "CMapDbPlayerHandler:sendUpdateRoleData");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapDbPlayerHandler:sendUpdateRoleData");
        if(!ok)
            return 0;
        cobj->sendUpdateRoleData(arg0, arg1);
        return 0;
    }

    gxError("CMapDbPlayerHandler:sendUpdateRoleData has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandler_sendUpdateRoleData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandler_sendSaveRoleData(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbPlayerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbPlayerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbPlayerHandler_sendSaveRoleData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        CHumanDB* arg0;
        unsigned long long arg1;
        bool arg2;
        ESaveRoleType arg3;

        ok &= luaval_to_object<CHumanDB>(tolua_S, 2, "CHumanDB", &arg0, "CMapDbPlayerHandler:sendSaveRoleData");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CMapDbPlayerHandler:sendSaveRoleData");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CMapDbPlayerHandler:sendSaveRoleData");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CMapDbPlayerHandler:sendSaveRoleData");
        if(!ok)
            return 0;
        bool ret = cobj->sendSaveRoleData(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapDbPlayerHandler:sendSaveRoleData has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbPlayerHandler_sendSaveRoleData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbPlayerHandler_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbPlayerHandler* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapDbPlayerHandler();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapDbPlayerHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        GXMISC::CDatabaseConnWrap* arg0;

        ok &= luaval_to_object<GXMISC::CDatabaseConnWrap>(tolua_S, 2, "CDatabaseConnWrap", &arg0, "CMapDbPlayerHandler:CMapDbPlayerHandler");
        if(!ok)
            return 0;
        cobj = new CMapDbPlayerHandler(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapDbPlayerHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 2) 
    {
        GXMISC::CDatabaseConnWrap* arg0;
        unsigned long long arg1;

        ok &= luaval_to_object<GXMISC::CDatabaseConnWrap>(tolua_S, 2, "CDatabaseConnWrap", &arg0, "CMapDbPlayerHandler:CMapDbPlayerHandler");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CMapDbPlayerHandler:CMapDbPlayerHandler");
        if(!ok)
            return 0;
        cobj = new CMapDbPlayerHandler(arg0, arg1);
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapDbPlayerHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapDbPlayerHandler:CMapDbPlayerHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapDbPlayerHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapDbPlayerHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapDbPlayerHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapDbPlayerHandler* self = (CMapDbPlayerHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapDbPlayerHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapDbPlayerHandler");
    tolua_cclass(tolua_S,"CMapDbPlayerHandler","CMapDbPlayerHandler","CMapDbPlayerHandlerBase",lua_mapserver_CMapDbPlayerHandler_finalize);

    tolua_beginmodule(tolua_S,"CMapDbPlayerHandler");
        tolua_function(tolua_S,"new",lua_mapserver_CMapDbPlayerHandler_constructor);
        tolua_function(tolua_S,"sendLoadDataTask",lua_mapserver_CMapDbPlayerHandler_sendLoadDataTask);
        tolua_function(tolua_S,"sendUpdateRoleData",lua_mapserver_CMapDbPlayerHandler_sendUpdateRoleData);
        tolua_function(tolua_S,"sendSaveRoleData",lua_mapserver_CMapDbPlayerHandler_sendSaveRoleData);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapDbPlayerHandler).name();
    g_luaType[typeName] = "CMapDbPlayerHandler";
    g_typeCast["CMapDbPlayerHandler"] = "CMapDbPlayerHandler";
    return 1;
}

int lua_mapserver_CRoleManagerBase_findInEnterByAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findInEnterByAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findInEnterByAccountID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInEnterByAccountID(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findInEnterByAccountID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManagerBase:findInEnterByAccountID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInEnterByAccountID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findInEnterByAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findInEnterByAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findInQueTypeByObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findInQueTypeByObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EManagerQueType arg0;
        unsigned int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManagerBase:findInQueTypeByObjUID");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CRoleManagerBase:findInQueTypeByObjUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInQueTypeByObjUID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 3) 
    {
        EManagerQueType arg0;
        unsigned int arg1;
        bool arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManagerBase:findInQueTypeByObjUID");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CRoleManagerBase:findInQueTypeByObjUID");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CRoleManagerBase:findInQueTypeByObjUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInQueTypeByObjUID(arg0, arg1, arg2);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findInQueTypeByObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findInQueTypeByObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findInEnterByRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findInEnterByRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findInEnterByRoleUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInEnterByRoleUID(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findInEnterByRoleUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManagerBase:findInEnterByRoleUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInEnterByRoleUID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findInEnterByRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findInEnterByRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findInQueTypeByRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findInQueTypeByRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EManagerQueType arg0;
        unsigned long long arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManagerBase:findInQueTypeByRoleUID");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRoleManagerBase:findInQueTypeByRoleUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInQueTypeByRoleUID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 3) 
    {
        EManagerQueType arg0;
        unsigned long long arg1;
        bool arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManagerBase:findInQueTypeByRoleUID");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRoleManagerBase:findInQueTypeByRoleUID");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CRoleManagerBase:findInQueTypeByRoleUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInQueTypeByRoleUID(arg0, arg1, arg2);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findInQueTypeByRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findInQueTypeByRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findInLogoutByRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findInLogoutByRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findInLogoutByRoleUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInLogoutByRoleUID(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findInLogoutByRoleUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManagerBase:findInLogoutByRoleUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInLogoutByRoleUID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findInLogoutByRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findInLogoutByRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findByRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findByRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findByRoleUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findByRoleUID(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findByRoleUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManagerBase:findByRoleUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findByRoleUID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findByRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findByRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findByAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findByAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findByAccountID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findByAccountID(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findByAccountID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManagerBase:findByAccountID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findByAccountID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findByAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findByAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findInReadyByAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findInReadyByAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findInReadyByAccountID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInReadyByAccountID(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findInReadyByAccountID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManagerBase:findInReadyByAccountID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInReadyByAccountID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findInReadyByAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findInReadyByAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findInLogoutByObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findInLogoutByObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManagerBase:findInLogoutByObjUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInLogoutByObjUID(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned int arg0;
        bool arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManagerBase:findInLogoutByObjUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManagerBase:findInLogoutByObjUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInLogoutByObjUID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findInLogoutByObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findInLogoutByObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_updateTimer(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_updateTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManagerBase:updateTimer");
        if(!ok)
            return 0;
        cobj->updateTimer(arg0);
        return 0;
    }

    gxError("CRoleManagerBase:updateTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_updateTimer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_getSaveSec(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_getSaveSec'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getSaveSec();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleManagerBase:getSaveSec has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_getSaveSec'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findByObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findByObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManagerBase:findByObjUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findByObjUID(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned int arg0;
        bool arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManagerBase:findByObjUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManagerBase:findByObjUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findByObjUID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findByObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findByObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_renameRole(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_renameRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned long long arg0;
        std::string arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:renameRole");

        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CRoleManagerBase:renameRole");
        if(!ok)
            return 0;
        bool ret = cobj->renameRole(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleManagerBase:renameRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_renameRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_update(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManagerBase:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CRoleManagerBase:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findInLogoutByAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findInLogoutByAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findInLogoutByAccountID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInLogoutByAccountID(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findInLogoutByAccountID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManagerBase:findInLogoutByAccountID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInLogoutByAccountID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findInLogoutByAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findInLogoutByAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_doProfile(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_doProfile'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doProfile();
        return 0;
    }

    gxError("CRoleManagerBase:doProfile has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_doProfile'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_kickAllRole(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_kickAllRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->kickAllRole();
        return 0;
    }

    gxError("CRoleManagerBase:kickAllRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_kickAllRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findInEnterByObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findInEnterByObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManagerBase:findInEnterByObjUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInEnterByObjUID(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned int arg0;
        bool arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManagerBase:findInEnterByObjUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManagerBase:findInEnterByObjUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInEnterByObjUID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findInEnterByObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findInEnterByObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findInQueTypeByAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findInQueTypeByAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EManagerQueType arg0;
        unsigned long long arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManagerBase:findInQueTypeByAccountID");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRoleManagerBase:findInQueTypeByAccountID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInQueTypeByAccountID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 3) 
    {
        EManagerQueType arg0;
        unsigned long long arg1;
        bool arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManagerBase:findInQueTypeByAccountID");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRoleManagerBase:findInQueTypeByAccountID");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CRoleManagerBase:findInQueTypeByAccountID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInQueTypeByAccountID(arg0, arg1, arg2);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findInQueTypeByAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findInQueTypeByAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_updateRoleIdle(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_updateRoleIdle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->updateRoleIdle();
        return 0;
    }

    gxError("CRoleManagerBase:updateRoleIdle has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_updateRoleIdle'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findInReadyByObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findInReadyByObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManagerBase:findInReadyByObjUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInReadyByObjUID(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned int arg0;
        bool arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManagerBase:findInReadyByObjUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManagerBase:findInReadyByObjUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInReadyByObjUID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findInReadyByObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findInReadyByObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManagerBase_findInReadyByRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManagerBase_findInReadyByRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findInReadyByRoleUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInReadyByRoleUID(arg0);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManagerBase:findInReadyByRoleUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManagerBase:findInReadyByRoleUID");
        if(!ok)
            return 0;
        CRoleBase* ret = cobj->findInReadyByRoleUID(arg0, arg1);
        object_to_luaval<CRoleBase>(tolua_S, "CRoleBase",(CRoleBase*)ret);
        return 1;
    }

    gxError("CRoleManagerBase:findInReadyByRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManagerBase_findInReadyByRoleUID'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CRoleManagerBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CRoleManagerBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CRoleManagerBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CRoleManagerBase* self = (CRoleManagerBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CRoleManagerBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CRoleManagerBase");
    tolua_cclass(tolua_S,"CRoleManagerBase","CRoleManagerBase","CGamePlayerMgr3<CRoleBase>",nullptr);

    tolua_beginmodule(tolua_S,"CRoleManagerBase");
        tolua_function(tolua_S,"findInEnterByAccountID",lua_mapserver_CRoleManagerBase_findInEnterByAccountID);
        tolua_function(tolua_S,"findInQueTypeByObjUID",lua_mapserver_CRoleManagerBase_findInQueTypeByObjUID);
        tolua_function(tolua_S,"findInEnterByRoleUID",lua_mapserver_CRoleManagerBase_findInEnterByRoleUID);
        tolua_function(tolua_S,"findInQueTypeByRoleUID",lua_mapserver_CRoleManagerBase_findInQueTypeByRoleUID);
        tolua_function(tolua_S,"findInLogoutByRoleUID",lua_mapserver_CRoleManagerBase_findInLogoutByRoleUID);
        tolua_function(tolua_S,"findByRoleUID",lua_mapserver_CRoleManagerBase_findByRoleUID);
        tolua_function(tolua_S,"findByAccountID",lua_mapserver_CRoleManagerBase_findByAccountID);
        tolua_function(tolua_S,"findInReadyByAccountID",lua_mapserver_CRoleManagerBase_findInReadyByAccountID);
        tolua_function(tolua_S,"findInLogoutByObjUID",lua_mapserver_CRoleManagerBase_findInLogoutByObjUID);
        tolua_function(tolua_S,"updateTimer",lua_mapserver_CRoleManagerBase_updateTimer);
        tolua_function(tolua_S,"getSaveSec",lua_mapserver_CRoleManagerBase_getSaveSec);
        tolua_function(tolua_S,"findByObjUID",lua_mapserver_CRoleManagerBase_findByObjUID);
        tolua_function(tolua_S,"renameRole",lua_mapserver_CRoleManagerBase_renameRole);
        tolua_function(tolua_S,"update",lua_mapserver_CRoleManagerBase_update);
        tolua_function(tolua_S,"findInLogoutByAccountID",lua_mapserver_CRoleManagerBase_findInLogoutByAccountID);
        tolua_function(tolua_S,"doProfile",lua_mapserver_CRoleManagerBase_doProfile);
        tolua_function(tolua_S,"kickAllRole",lua_mapserver_CRoleManagerBase_kickAllRole);
        tolua_function(tolua_S,"findInEnterByObjUID",lua_mapserver_CRoleManagerBase_findInEnterByObjUID);
        tolua_function(tolua_S,"findInQueTypeByAccountID",lua_mapserver_CRoleManagerBase_findInQueTypeByAccountID);
        tolua_function(tolua_S,"updateRoleIdle",lua_mapserver_CRoleManagerBase_updateRoleIdle);
        tolua_function(tolua_S,"findInReadyByObjUID",lua_mapserver_CRoleManagerBase_findInReadyByObjUID);
        tolua_function(tolua_S,"findInReadyByRoleUID",lua_mapserver_CRoleManagerBase_findInReadyByRoleUID);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CRoleManagerBase).name();
    g_luaType[typeName] = "CRoleManagerBase";
    g_typeCast["CRoleManagerBase"] = "CRoleManagerBase";
    return 1;
}

int lua_mapserver_CRoleManager_findInEnterByAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findInEnterByAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findInEnterByAccountID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInEnterByAccountID(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findInEnterByAccountID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManager:findInEnterByAccountID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInEnterByAccountID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findInEnterByAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findInEnterByAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findInQueTypeByObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findInQueTypeByObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EManagerQueType arg0;
        unsigned int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManager:findInQueTypeByObjUID");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CRoleManager:findInQueTypeByObjUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInQueTypeByObjUID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 3) 
    {
        EManagerQueType arg0;
        unsigned int arg1;
        bool arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManager:findInQueTypeByObjUID");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CRoleManager:findInQueTypeByObjUID");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CRoleManager:findInQueTypeByObjUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInQueTypeByObjUID(arg0, arg1, arg2);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findInQueTypeByObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findInQueTypeByObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_initRolePool(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_initRolePool'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManager:initRolePool");
        if(!ok)
            return 0;
        bool ret = cobj->initRolePool(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleManager:initRolePool has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_initRolePool'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_getSize(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_getSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleManager:getSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_getSize'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findInEnterByRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findInEnterByRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findInEnterByRoleUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInEnterByRoleUID(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findInEnterByRoleUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManager:findInEnterByRoleUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInEnterByRoleUID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findInEnterByRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findInEnterByRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findInQueTypeByRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findInQueTypeByRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EManagerQueType arg0;
        unsigned long long arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManager:findInQueTypeByRoleUID");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRoleManager:findInQueTypeByRoleUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInQueTypeByRoleUID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 3) 
    {
        EManagerQueType arg0;
        unsigned long long arg1;
        bool arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManager:findInQueTypeByRoleUID");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRoleManager:findInQueTypeByRoleUID");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CRoleManager:findInQueTypeByRoleUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInQueTypeByRoleUID(arg0, arg1, arg2);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findInQueTypeByRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findInQueTypeByRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_loadRoleData(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_loadRoleData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        LoadRoleData* arg0;
        unsigned long long arg1;
        unsigned long long arg2;
        ChangeLineTempData* arg3;
        bool arg4;

        ok &= luaval_to_object<LoadRoleData>(tolua_S, 2, "LoadRoleData", &arg0, "CRoleManager:loadRoleData");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRoleManager:loadRoleData");

        ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CRoleManager:loadRoleData");

        ok &= luaval_to_object<ChangeLineTempData>(tolua_S, 5, "ChangeLineTempData", &arg3, "CRoleManager:loadRoleData");

        ok &= luaval_to_boolean(tolua_S, 6,(bool*)&arg4, "CRoleManager:loadRoleData");
        if(!ok)
            return 0;
        int ret = (int)cobj->loadRoleData(arg0, arg1, arg2, arg3, arg4);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleManager:loadRoleData has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_loadRoleData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findInLogoutByRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findInLogoutByRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findInLogoutByRoleUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInLogoutByRoleUID(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findInLogoutByRoleUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManager:findInLogoutByRoleUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInLogoutByRoleUID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findInLogoutByRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findInLogoutByRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findByRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findByRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findByRoleUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findByRoleUID(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findByRoleUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManager:findByRoleUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findByRoleUID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findByRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findByRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findByAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findByAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findByAccountID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findByAccountID(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findByAccountID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManager:findByAccountID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findByAccountID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findByAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findByAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_init(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManager:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRoleManager:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_getRoleHummanDBPool(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_getRoleHummanDBPool'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CFixEmptyObjPool<CHumanDBData, unsigned long long, 1000>* ret = cobj->getRoleHummanDBPool();
        object_to_luaval<GXMISC::CFixEmptyObjPool<CHumanDBData, unsigned long long, 1000>>(tolua_S, "CFixEmptyObjPool<CHumanDBData, unsigned long long, 1000>",(GXMISC::CFixEmptyObjPool<CHumanDBData, unsigned long long, 1000>*)ret);
        return 1;
    }

    gxError("CRoleManager:getRoleHummanDBPool has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_getRoleHummanDBPool'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findInReadyByAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findInReadyByAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findInReadyByAccountID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInReadyByAccountID(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findInReadyByAccountID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManager:findInReadyByAccountID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInReadyByAccountID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findInReadyByAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findInReadyByAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_delPlayer(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_delPlayer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:delPlayer");
        if(!ok)
            return 0;
        cobj->delPlayer(arg0);
        return 0;
    }

    gxError("CRoleManager:delPlayer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_delPlayer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_roleHeart(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_roleHeart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManager:roleHeart");
        if(!ok)
            return 0;
        cobj->roleHeart(arg0);
        return 0;
    }

    gxError("CRoleManager:roleHeart has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_roleHeart'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findInLogoutByObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findInLogoutByObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManager:findInLogoutByObjUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInLogoutByObjUID(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned int arg0;
        bool arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManager:findInLogoutByObjUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManager:findInLogoutByObjUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInLogoutByObjUID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findInLogoutByObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findInLogoutByObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findByObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findByObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManager:findByObjUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findByObjUID(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned int arg0;
        bool arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManager:findByObjUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManager:findByObjUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findByObjUID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findByObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findByObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_update(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManager:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CRoleManager:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findInLogoutByAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findInLogoutByAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findInLogoutByAccountID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInLogoutByAccountID(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findInLogoutByAccountID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManager:findInLogoutByAccountID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInLogoutByAccountID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findInLogoutByAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findInLogoutByAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_newRole(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_newRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        unsigned long long arg0;
        unsigned int arg1;
        unsigned long long arg2;
        bool arg3;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:newRole");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CRoleManager:newRole");

        ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CRoleManager:newRole");

        ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CRoleManager:newRole");
        if(!ok)
            return 0;
        CRole* ret = cobj->newRole(arg0, arg1, arg2, arg3);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:newRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_newRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_addNewPlayer(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_addNewPlayer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned long long arg0;
        unsigned int arg1;
        unsigned long long arg2;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:addNewPlayer");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CRoleManager:addNewPlayer");

        ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CRoleManager:addNewPlayer");
        if(!ok)
            return 0;
        CRole* ret = cobj->addNewPlayer(arg0, arg1, arg2);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 4) 
    {
        unsigned long long arg0;
        unsigned int arg1;
        unsigned long long arg2;
        bool arg3;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:addNewPlayer");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CRoleManager:addNewPlayer");

        ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CRoleManager:addNewPlayer");

        ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CRoleManager:addNewPlayer");
        if(!ok)
            return 0;
        CRole* ret = cobj->addNewPlayer(arg0, arg1, arg2, arg3);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:addNewPlayer has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_addNewPlayer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findInEnterByObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findInEnterByObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManager:findInEnterByObjUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInEnterByObjUID(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned int arg0;
        bool arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManager:findInEnterByObjUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManager:findInEnterByObjUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInEnterByObjUID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findInEnterByObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findInEnterByObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_loadRoleDataRet(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_loadRoleDataRet'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 10) 
    {
        LoadRoleData* arg0;
        unsigned long long arg1;
        unsigned long long arg2;
        ChangeLineTempData* arg3;
        unsigned long long arg4;
        RoleManageInfo* arg5;
        CHumanDBBackup* arg6;
        bool arg7;
        bool arg8;
        CRole* arg9;

        ok &= luaval_to_object<LoadRoleData>(tolua_S, 2, "LoadRoleData", &arg0, "CRoleManager:loadRoleDataRet");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRoleManager:loadRoleDataRet");

        ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CRoleManager:loadRoleDataRet");

        ok &= luaval_to_object<ChangeLineTempData>(tolua_S, 5, "ChangeLineTempData", &arg3, "CRoleManager:loadRoleDataRet");

        ok &= luaval_to_uint64(tolua_S, 6, (uint64*)&arg4, "CRoleManager:loadRoleDataRet");

        ok &= luaval_to_object<RoleManageInfo>(tolua_S, 7, "RoleManageInfo", &arg5, "CRoleManager:loadRoleDataRet");

        ok &= luaval_to_object<CHumanDBBackup>(tolua_S, 8, "CHumanDBBackup", &arg6, "CRoleManager:loadRoleDataRet");

        ok &= luaval_to_boolean(tolua_S, 9,(bool*)&arg7, "CRoleManager:loadRoleDataRet");

        ok &= luaval_to_boolean(tolua_S, 10,(bool*)&arg8, "CRoleManager:loadRoleDataRet");

        ok &= luaval_to_object<CRole>(tolua_S, 11, "CRole", &arg9, "CRoleManager:loadRoleDataRet");
        if(!ok)
            return 0;
        int ret = (int)cobj->loadRoleDataRet(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleManager:loadRoleDataRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 10);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_loadRoleDataRet'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findInQueTypeByAccountID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findInQueTypeByAccountID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        EManagerQueType arg0;
        unsigned long long arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManager:findInQueTypeByAccountID");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRoleManager:findInQueTypeByAccountID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInQueTypeByAccountID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 3) 
    {
        EManagerQueType arg0;
        unsigned long long arg1;
        bool arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CRoleManager:findInQueTypeByAccountID");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRoleManager:findInQueTypeByAccountID");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CRoleManager:findInQueTypeByAccountID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInQueTypeByAccountID(arg0, arg1, arg2);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findInQueTypeByAccountID has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findInQueTypeByAccountID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_unLoadRoleData(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_unLoadRoleData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        unsigned long long arg0;
        unsigned long long arg1;
        bool arg2;
        EUnloadRoleType arg3;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:unLoadRoleData");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CRoleManager:unLoadRoleData");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CRoleManager:unLoadRoleData");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CRoleManager:unLoadRoleData");
        if(!ok)
            return 0;
        int ret = (int)cobj->unLoadRoleData(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRoleManager:unLoadRoleData has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_unLoadRoleData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_freeNewPlayer(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_freeNewPlayer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CRole* arg0;

        ok &= luaval_to_object<CRole>(tolua_S, 2, "CRole", &arg0, "CRoleManager:freeNewPlayer");
        if(!ok)
            return 0;
        cobj->freeNewPlayer(arg0);
        return 0;
    }

    gxError("CRoleManager:freeNewPlayer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_freeNewPlayer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_delRole(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_delRole'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:delRole");
        if(!ok)
            return 0;
        cobj->delRole(arg0);
        return 0;
    }

    gxError("CRoleManager:delRole has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_delRole'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findInReadyByObjUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findInReadyByObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManager:findInReadyByObjUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInReadyByObjUID(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned int arg0;
        bool arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRoleManager:findInReadyByObjUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManager:findInReadyByObjUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInReadyByObjUID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findInReadyByObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findInReadyByObjUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_findInReadyByRoleUID(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_findInReadyByRoleUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findInReadyByRoleUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInReadyByRoleUID(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CRoleManager:findInReadyByRoleUID");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CRoleManager:findInReadyByRoleUID");
        if(!ok)
            return 0;
        CRole* ret = cobj->findInReadyByRoleUID(arg0, arg1);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }

    gxError("CRoleManager:findInReadyByRoleUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_findInReadyByRoleUID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_setNewRoleScriptFunctionName(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRoleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRoleManager_setNewRoleScriptFunctionName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CRoleManager:setNewRoleScriptFunctionName");
        if(!ok)
            return 0;
        cobj->setNewRoleScriptFunctionName(arg0);
        return 0;
    }

    gxError("CRoleManager:setNewRoleScriptFunctionName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_setNewRoleScriptFunctionName'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRoleManager_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CRoleManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CRoleManager* ret = CRoleManager::GetPtr();
        object_to_luaval<CRoleManager>(tolua_S, "CRoleManager",(CRoleManager*)ret);
        return 1;
    }
    gxError("CRoleManager:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRoleManager_GetPtr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CRoleManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CRoleManager* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CRoleManager();
        tolua_pushusertype(tolua_S,(void*)cobj,"CRoleManager");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CRoleManager:CRoleManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CRoleManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CRoleManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CRoleManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CRoleManager* self = (CRoleManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CRoleManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CRoleManager");
    tolua_cclass(tolua_S,"CRoleManager","CRoleManager","CRoleManagerBase",lua_mapserver_CRoleManager_finalize);

    tolua_beginmodule(tolua_S,"CRoleManager");
        tolua_function(tolua_S,"new",lua_mapserver_CRoleManager_constructor);
        tolua_function(tolua_S,"findInEnterByAccountID",lua_mapserver_CRoleManager_findInEnterByAccountID);
        tolua_function(tolua_S,"findInQueTypeByObjUID",lua_mapserver_CRoleManager_findInQueTypeByObjUID);
        tolua_function(tolua_S,"initRolePool",lua_mapserver_CRoleManager_initRolePool);
        tolua_function(tolua_S,"getSize",lua_mapserver_CRoleManager_getSize);
        tolua_function(tolua_S,"findInEnterByRoleUID",lua_mapserver_CRoleManager_findInEnterByRoleUID);
        tolua_function(tolua_S,"findInQueTypeByRoleUID",lua_mapserver_CRoleManager_findInQueTypeByRoleUID);
        tolua_function(tolua_S,"loadRoleData",lua_mapserver_CRoleManager_loadRoleData);
        tolua_function(tolua_S,"findInLogoutByRoleUID",lua_mapserver_CRoleManager_findInLogoutByRoleUID);
        tolua_function(tolua_S,"findByRoleUID",lua_mapserver_CRoleManager_findByRoleUID);
        tolua_function(tolua_S,"findByAccountID",lua_mapserver_CRoleManager_findByAccountID);
        tolua_function(tolua_S,"init",lua_mapserver_CRoleManager_init);
        tolua_function(tolua_S,"getRoleHummanDBPool",lua_mapserver_CRoleManager_getRoleHummanDBPool);
        tolua_function(tolua_S,"findInReadyByAccountID",lua_mapserver_CRoleManager_findInReadyByAccountID);
        tolua_function(tolua_S,"delPlayer",lua_mapserver_CRoleManager_delPlayer);
        tolua_function(tolua_S,"roleHeart",lua_mapserver_CRoleManager_roleHeart);
        tolua_function(tolua_S,"findInLogoutByObjUID",lua_mapserver_CRoleManager_findInLogoutByObjUID);
        tolua_function(tolua_S,"findByObjUID",lua_mapserver_CRoleManager_findByObjUID);
        tolua_function(tolua_S,"update",lua_mapserver_CRoleManager_update);
        tolua_function(tolua_S,"findInLogoutByAccountID",lua_mapserver_CRoleManager_findInLogoutByAccountID);
        tolua_function(tolua_S,"newRole",lua_mapserver_CRoleManager_newRole);
        tolua_function(tolua_S,"addNewPlayer",lua_mapserver_CRoleManager_addNewPlayer);
        tolua_function(tolua_S,"findInEnterByObjUID",lua_mapserver_CRoleManager_findInEnterByObjUID);
        tolua_function(tolua_S,"loadRoleDataRet",lua_mapserver_CRoleManager_loadRoleDataRet);
        tolua_function(tolua_S,"findInQueTypeByAccountID",lua_mapserver_CRoleManager_findInQueTypeByAccountID);
        tolua_function(tolua_S,"unLoadRoleData",lua_mapserver_CRoleManager_unLoadRoleData);
        tolua_function(tolua_S,"freeNewPlayer",lua_mapserver_CRoleManager_freeNewPlayer);
        tolua_function(tolua_S,"delRole",lua_mapserver_CRoleManager_delRole);
        tolua_function(tolua_S,"findInReadyByObjUID",lua_mapserver_CRoleManager_findInReadyByObjUID);
        tolua_function(tolua_S,"findInReadyByRoleUID",lua_mapserver_CRoleManager_findInReadyByRoleUID);
        tolua_function(tolua_S,"setNewRoleScriptFunctionName",lua_mapserver_CRoleManager_setNewRoleScriptFunctionName);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CRoleManager_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CRoleManager).name();
    g_luaType[typeName] = "CRoleManager";
    g_typeCast["CRoleManager"] = "CRoleManager";
    return 1;
}

int lua_mapserver_CMapDbServerHandler_handle(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbServerHandler_handle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char* arg0;
        unsigned int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CMapDbServerHandler:handle"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CMapDbServerHandler:handle");
        if(!ok)
            return 0;
        int ret = (int)cobj->handle(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapDbServerHandler:handle has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbServerHandler_handle'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbServerHandler_breath(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbServerHandler_breath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapDbServerHandler:breath");
        if(!ok)
            return 0;
        cobj->breath(arg0);
        return 0;
    }

    gxError("CMapDbServerHandler:breath has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbServerHandler_breath'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbServerHandler_start(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbServerHandler_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapDbServerHandler:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbServerHandler_start'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbServerHandler_sendPlayerRegiste(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbServerHandler_sendPlayerRegiste'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        std::string arg0;
        std::string arg1;
        unsigned long long arg2;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMapDbServerHandler:sendPlayerRegiste");

        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CMapDbServerHandler:sendPlayerRegiste");

        ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CMapDbServerHandler:sendPlayerRegiste");
        if(!ok)
            return 0;
        cobj->sendPlayerRegiste(arg0, arg1, arg2);
        return 0;
    }

    gxError("CMapDbServerHandler:sendPlayerRegiste has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbServerHandler_sendPlayerRegiste'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbServerHandler_close(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbServerHandler_close'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->close();
        return 0;
    }

    gxError("CMapDbServerHandler:close has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbServerHandler_close'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbServerHandler_sendSaveMapServerDataTask(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDbServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDbServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDbServerHandler_sendSaveMapServerDataTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->sendSaveMapServerDataTask();
        return 0;
    }

    gxError("CMapDbServerHandler:sendSaveMapServerDataTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDbServerHandler_sendSaveMapServerDataTask'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDbServerHandler_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapDbServerHandler* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapDbServerHandler();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapDbServerHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        GXMISC::CDatabaseConnWrap* arg0;

        ok &= luaval_to_object<GXMISC::CDatabaseConnWrap>(tolua_S, 2, "CDatabaseConnWrap", &arg0, "CMapDbServerHandler:CMapDbServerHandler");
        if(!ok)
            return 0;
        cobj = new CMapDbServerHandler(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapDbServerHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 2) 
    {
        GXMISC::CDatabaseConnWrap* arg0;
        unsigned long long arg1;

        ok &= luaval_to_object<GXMISC::CDatabaseConnWrap>(tolua_S, 2, "CDatabaseConnWrap", &arg0, "CMapDbServerHandler:CMapDbServerHandler");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CMapDbServerHandler:CMapDbServerHandler");
        if(!ok)
            return 0;
        cobj = new CMapDbServerHandler(arg0, arg1);
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapDbServerHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapDbServerHandler:CMapDbServerHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapDbServerHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapDbServerHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapDbServerHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapDbServerHandler* self = (CMapDbServerHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapDbServerHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapDbServerHandler");
    tolua_cclass(tolua_S,"CMapDbServerHandler","CMapDbServerHandler","CGameDatabaseHandler",lua_mapserver_CMapDbServerHandler_finalize);

    tolua_beginmodule(tolua_S,"CMapDbServerHandler");
        tolua_function(tolua_S,"new",lua_mapserver_CMapDbServerHandler_constructor);
        tolua_function(tolua_S,"handle",lua_mapserver_CMapDbServerHandler_handle);
        tolua_function(tolua_S,"breath",lua_mapserver_CMapDbServerHandler_breath);
        tolua_function(tolua_S,"start",lua_mapserver_CMapDbServerHandler_start);
        tolua_function(tolua_S,"sendPlayerRegiste",lua_mapserver_CMapDbServerHandler_sendPlayerRegiste);
        tolua_function(tolua_S,"close",lua_mapserver_CMapDbServerHandler_close);
        tolua_function(tolua_S,"sendSaveMapServerDataTask",lua_mapserver_CMapDbServerHandler_sendSaveMapServerDataTask);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapDbServerHandler).name();
    g_luaType[typeName] = "CMapDbServerHandler";
    g_typeCast["CMapDbServerHandler"] = "CMapDbServerHandler";
    return 1;
}

int lua_mapserver_CMapConfigTbl_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CMapConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapConfigTbl_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapConfigTbl:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapConfigTbl_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapConfigTbl_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CMapConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapConfigTbl_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapConfigTbl:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapConfigTbl_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapConfigTbl_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CMapConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapConfigTbl_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapConfigTbl:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapConfigTbl_getKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapConfigTbl_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CMapConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapConfigTbl_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapConfigTbl:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CMapConfigTbl:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapConfigTbl_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapConfigTbl_toString(lua_State* tolua_S)
{
    int argc = 0;
    CMapConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapConfigTbl_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CMapConfigTbl:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapConfigTbl_toString'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CMapConfigTbl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapConfigTbl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapConfigTbl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapConfigTbl* self = (CMapConfigTbl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapConfigTbl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapConfigTbl");
    tolua_cclass(tolua_S,"CMapConfigTbl","CMapConfigTbl","CConfigTbl",nullptr);

    tolua_beginmodule(tolua_S,"CMapConfigTbl");
        tolua_function(tolua_S,"isKey",lua_mapserver_CMapConfigTbl_isKey);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CMapConfigTbl_keyToString);
        tolua_function(tolua_S,"getKey",lua_mapserver_CMapConfigTbl_getKey);
        tolua_function(tolua_S,"setKey",lua_mapserver_CMapConfigTbl_setKey);
        tolua_function(tolua_S,"toString",lua_mapserver_CMapConfigTbl_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapConfigTbl).name();
    g_luaType[typeName] = "CMapConfigTbl";
    g_typeCast["CMapConfigTbl"] = "CMapConfigTbl";
    return 1;
}

int lua_mapserver_CMapTblLoader_findByKey(lua_State* tolua_S)
{
    int argc = 0;
    CMapTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapTblLoader_findByKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapTblLoader:findByKey");
        if(!ok)
            return 0;
        CMapConfigTbl* ret = cobj->findByKey(arg0);
        object_to_luaval<CMapConfigTbl>(tolua_S, "CMapConfigTbl",(CMapConfigTbl*)ret);
        return 1;
    }

    gxError("CMapTblLoader:findByKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapTblLoader_findByKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapTblLoader_readRow(lua_State* tolua_S)
{
    int argc = 0;
    CMapTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapTblLoader_readRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        TiXmlElement* arg0;
        int arg1;
        CMapConfigTbl* arg2;

        ok &= luaval_to_object<TiXmlElement>(tolua_S, 2, "TiXmlElement", &arg0, "CMapTblLoader:readRow");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapTblLoader:readRow");

        ok &= luaval_to_object<CMapConfigTbl>(tolua_S, 4, "CMapConfigTbl", &arg2, "CMapTblLoader:readRow");
        if(!ok)
            return 0;
        bool ret = cobj->readRow(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapTblLoader:readRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapTblLoader_readRow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapTblLoader_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMapTblLoader",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMapTblLoader* ret = CMapTblLoader::GetPtr();
        object_to_luaval<CMapTblLoader>(tolua_S, "CMapTblLoader",(CMapTblLoader*)ret);
        return 1;
    }
    gxError("CMapTblLoader:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapTblLoader_GetPtr'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CMapTblLoader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapTblLoader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapTblLoader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapTblLoader* self = (CMapTblLoader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapTblLoader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapTblLoader");
    tolua_cclass(tolua_S,"CMapTblLoader","CMapTblLoader","CConfigLoader<CMapTblLoader, CMapConfigTbl>",nullptr);

    tolua_beginmodule(tolua_S,"CMapTblLoader");
        tolua_function(tolua_S,"findByKey",lua_mapserver_CMapTblLoader_findByKey);
        tolua_function(tolua_S,"readRow",lua_mapserver_CMapTblLoader_readRow);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CMapTblLoader_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapTblLoader).name();
    g_luaType[typeName] = "CMapTblLoader";
    g_typeCast["CMapTblLoader"] = "CMapTblLoader";
    return 1;
}

int lua_mapserver_CBufferConfigTbl_getParamAry(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CBufferConfigTbl_getParamAry'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CBufferConfigTbl:getParamAry");

            if (!ok) { break; }
            GXMISC::CArray<int, 10, unsigned char>* arg1;
            ok &= luaval_to_object<GXMISC::CArray<int, 10, unsigned char>>(tolua_S, 3, "CArray<int, 10, unsigned char>", &arg1, "CBufferConfigTbl:getParamAry");

            if (!ok) { break; }
            cobj->getParamAry(arg0, arg1);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CBufferConfigTbl:getParamAry");

            if (!ok) { break; }
            std::vector<int, std::allocator<int> >* arg1;
            ok &= luaval_to_object<std::vector<int, std::allocator<int> >>(tolua_S, 3, "std::vector<int, std::allocator<int> >*", &arg1, "CBufferConfigTbl:getParamAry");

            if (!ok) { break; }
            cobj->getParamAry(arg0, arg1);
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CBufferConfigTbl:getParamAry has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_getParamAry'.",&tolua_err);
    return 0;
}
int lua_mapserver_CBufferConfigTbl_isParamOverlap(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_isParamOverlap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isParamOverlap();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:isParamOverlap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_isParamOverlap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_getAttrAry(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_getAttrAry'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CBufferConfigTbl:getAttrAry");
        if(!ok)
            return 0;
        std::vector<ExtendAttr, std::allocator<ExtendAttr> >* ret = cobj->getAttrAry(arg0);
        object_to_luaval<std::vector<ExtendAttr, std::allocator<ExtendAttr> >>(tolua_S, "std::vector<ExtendAttr, std::allocator<ExtendAttr> >*",(std::vector<ExtendAttr, std::allocator<ExtendAttr> >*)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:getAttrAry has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_getAttrAry'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_isPermanence(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_isPermanence'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isPermanence();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:isPermanence has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_isPermanence'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_isInterval(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_isInterval'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isInterval();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:isInterval has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_isInterval'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_isTimeOverlap(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_isTimeOverlap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isTimeOverlap();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:isTimeOverlap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_isTimeOverlap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CBufferConfigTbl:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_getIntervalTime(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CBufferConfigTbl_getIntervalTime'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            char arg0;
            ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CBufferConfigTbl:getIntervalTime");

            if (!ok) { break; }
            unsigned int ret = cobj->getIntervalTime(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            std::vector<unsigned int, std::allocator<unsigned int> >* ret = cobj->getIntervalTime();
            object_to_luaval<std::vector<unsigned int, std::allocator<unsigned int> >>(tolua_S, "std::vector<unsigned int, std::allocator<unsigned int> >*",(std::vector<unsigned int, std::allocator<unsigned int> >*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CBufferConfigTbl:getIntervalTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_getIntervalTime'.",&tolua_err);
    return 0;
}
int lua_mapserver_CBufferConfigTbl_isShow(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_isShow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isShow();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:isShow has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_isShow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_getID(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_getID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:getID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_getID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_getKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_getTotalTime(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CBufferConfigTbl_getTotalTime'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            char arg0;
            ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CBufferConfigTbl:getTotalTime");

            if (!ok) { break; }
            unsigned int ret = cobj->getTotalTime(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            std::vector<unsigned int, std::allocator<unsigned int> >* ret = cobj->getTotalTime();
            object_to_luaval<std::vector<unsigned int, std::allocator<unsigned int> >>(tolua_S, "std::vector<unsigned int, std::allocator<unsigned int> >*",(std::vector<unsigned int, std::allocator<unsigned int> >*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CBufferConfigTbl:getTotalTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_getTotalTime'.",&tolua_err);
    return 0;
}
int lua_mapserver_CBufferConfigTbl_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CBufferConfigTbl:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CBufferConfigTbl:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_toString(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_getParam(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_getParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CBufferConfigTbl:getParam");
        if(!ok)
            return 0;
        std::vector<int>* ret = cobj->getParam(arg0);
        object_to_luaval<std::vector<int>>(tolua_S, "std::vector<int, std::allocator<int> >*",(std::vector<int>*)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:getParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_getParam'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_isOfflineCountTime(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_isOfflineCountTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isOfflineCountTime();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:isOfflineCountTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_isOfflineCountTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_getAttrArySize(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_getAttrArySize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getAttrArySize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:getAttrArySize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_getAttrArySize'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_isOfflineDisa(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_isOfflineDisa'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isOfflineDisa();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:isOfflineDisa has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_isOfflineDisa'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBufferConfigTbl_getParamArySize(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTbl_getParamArySize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getParamArySize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBufferConfigTbl:getParamArySize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTbl_getParamArySize'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CBufferConfigTbl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBufferConfigTbl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBufferConfigTbl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CBufferConfigTbl* self = (CBufferConfigTbl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CBufferConfigTbl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBufferConfigTbl");
    tolua_cclass(tolua_S,"CBufferConfigTbl","CBufferConfigTbl","CConfigTbl",nullptr);

    tolua_beginmodule(tolua_S,"CBufferConfigTbl");
        tolua_function(tolua_S,"getParamAry",lua_mapserver_CBufferConfigTbl_getParamAry);
        tolua_function(tolua_S,"isParamOverlap",lua_mapserver_CBufferConfigTbl_isParamOverlap);
        tolua_function(tolua_S,"getAttrAry",lua_mapserver_CBufferConfigTbl_getAttrAry);
        tolua_function(tolua_S,"isPermanence",lua_mapserver_CBufferConfigTbl_isPermanence);
        tolua_function(tolua_S,"isInterval",lua_mapserver_CBufferConfigTbl_isInterval);
        tolua_function(tolua_S,"isKey",lua_mapserver_CBufferConfigTbl_isKey);
        tolua_function(tolua_S,"isTimeOverlap",lua_mapserver_CBufferConfigTbl_isTimeOverlap);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CBufferConfigTbl_keyToString);
        tolua_function(tolua_S,"getIntervalTime",lua_mapserver_CBufferConfigTbl_getIntervalTime);
        tolua_function(tolua_S,"isShow",lua_mapserver_CBufferConfigTbl_isShow);
        tolua_function(tolua_S,"getID",lua_mapserver_CBufferConfigTbl_getID);
        tolua_function(tolua_S,"getKey",lua_mapserver_CBufferConfigTbl_getKey);
        tolua_function(tolua_S,"getTotalTime",lua_mapserver_CBufferConfigTbl_getTotalTime);
        tolua_function(tolua_S,"setKey",lua_mapserver_CBufferConfigTbl_setKey);
        tolua_function(tolua_S,"toString",lua_mapserver_CBufferConfigTbl_toString);
        tolua_function(tolua_S,"getParam",lua_mapserver_CBufferConfigTbl_getParam);
        tolua_function(tolua_S,"isOfflineCountTime",lua_mapserver_CBufferConfigTbl_isOfflineCountTime);
        tolua_function(tolua_S,"getAttrArySize",lua_mapserver_CBufferConfigTbl_getAttrArySize);
        tolua_function(tolua_S,"isOfflineDisa",lua_mapserver_CBufferConfigTbl_isOfflineDisa);
        tolua_function(tolua_S,"getParamArySize",lua_mapserver_CBufferConfigTbl_getParamArySize);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CBufferConfigTbl).name();
    g_luaType[typeName] = "CBufferConfigTbl";
    g_typeCast["CBufferConfigTbl"] = "CBufferConfigTbl";
    return 1;
}

int lua_mapserver_CBufferConfigTblLoader_readRow(lua_State* tolua_S)
{
    int argc = 0;
    CBufferConfigTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBufferConfigTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBufferConfigTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBufferConfigTblLoader_readRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        TiXmlElement* arg0;
        int arg1;
        CBufferConfigTbl* arg2;

        ok &= luaval_to_object<TiXmlElement>(tolua_S, 2, "TiXmlElement", &arg0, "CBufferConfigTblLoader:readRow");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CBufferConfigTblLoader:readRow");

        ok &= luaval_to_object<CBufferConfigTbl>(tolua_S, 4, "CBufferConfigTbl", &arg2, "CBufferConfigTblLoader:readRow");
        if(!ok)
            return 0;
        bool ret = cobj->readRow(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBufferConfigTblLoader:readRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBufferConfigTblLoader_readRow'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CBufferConfigTblLoader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBufferConfigTblLoader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBufferConfigTblLoader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CBufferConfigTblLoader* self = (CBufferConfigTblLoader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CBufferConfigTblLoader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBufferConfigTblLoader");
    tolua_cclass(tolua_S,"CBufferConfigTblLoader","CBufferConfigTblLoader","CConfigLoader<CBufferConfigTblLoader, CBufferConfigTbl>",nullptr);

    tolua_beginmodule(tolua_S,"CBufferConfigTblLoader");
        tolua_function(tolua_S,"readRow",lua_mapserver_CBufferConfigTblLoader_readRow);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CBufferConfigTblLoader).name();
    g_luaType[typeName] = "CBufferConfigTblLoader";
    g_typeCast["CBufferConfigTblLoader"] = "CBufferConfigTblLoader";
    return 1;
}

int lua_mapserver_CMapServerBase_getServerType(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_getServerType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getServerType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerBase:getServerType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_getServerType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_onBreath(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_onBreath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapServerBase:onBreath");
        if(!ok)
            return 0;
        cobj->onBreath(arg0);
        return 0;
    }

    gxError("CMapServerBase:onBreath has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_onBreath'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_onRegisteToWorld(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_onRegisteToWorld'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapServerBase:onRegisteToWorld");
        if(!ok)
            return 0;
        cobj->onRegisteToWorld(arg0);
        return 0;
    }

    gxError("CMapServerBase:onRegisteToWorld has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_onRegisteToWorld'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_isDynamicServer(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_isDynamicServer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDynamicServer();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerBase:isDynamicServer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_isDynamicServer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_onLoad(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_onLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::CIni* arg0;
        std::string arg1;

        ok &= luaval_to_object<GXMISC::CIni>(tolua_S, 2, "CIni", &arg0, "CMapServerBase:onLoad");

        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CMapServerBase:onLoad");
        if(!ok)
            return 0;
        bool ret = cobj->onLoad(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerBase:onLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_onLoad'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_isConfigRemotePath(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_isConfigRemotePath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isConfigRemotePath();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerBase:isConfigRemotePath has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_isConfigRemotePath'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_getToClientListenPort(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_getToClientListenPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getToClientListenPort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerBase:getToClientListenPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_getToClientListenPort'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_canOpenDynamicMap(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_canOpenDynamicMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canOpenDynamicMap();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerBase:canOpenDynamicMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_canOpenDynamicMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_getServerID(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_getServerID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getServerID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerBase:getServerID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_getServerID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_onAfterStart(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_onAfterStart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onAfterStart();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerBase:onAfterStart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_onAfterStart'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_init(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerBase:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_getToClientListenIP(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_getToClientListenIP'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getToClientListenIP();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapServerBase:getToClientListenIP has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_getToClientListenIP'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_getScenePoolNum(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_getScenePoolNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getScenePoolNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerBase:getScenePoolNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_getScenePoolNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_getMaxRoleNum(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_getMaxRoleNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxRoleNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerBase:getMaxRoleNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_getMaxRoleNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_onWorldServerInfo(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerBase_onWorldServerInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        WMServerInfo* arg0;

        ok &= luaval_to_object<WMServerInfo>(tolua_S, 2, "WMServerInfo", &arg0, "CMapServerBase:onWorldServerInfo");
        if(!ok)
            return 0;
        cobj->onWorldServerInfo(arg0);
        return 0;
    }

    gxError("CMapServerBase:onWorldServerInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerBase_onWorldServerInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapServerBase();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapServerBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMapServerBase:CMapServerBase");
        if(!ok)
            return 0;
        cobj = new CMapServerBase(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapServerBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 2) 
    {
        std::string arg0;
        GXMISC::CGxServiceConfig* arg1;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMapServerBase:CMapServerBase");

        ok &= luaval_to_object<GXMISC::CGxServiceConfig>(tolua_S, 3, "CGxServiceConfig", &arg1, "CMapServerBase:CMapServerBase");
        if(!ok)
            return 0;
        cobj = new CMapServerBase(arg0, arg1);
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapServerBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapServerBase:CMapServerBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapServerBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapServerBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapServerBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapServerBase* self = (CMapServerBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapServerBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapServerBase");
    tolua_cclass(tolua_S,"CMapServerBase","CMapServerBase","GxService",lua_mapserver_CMapServerBase_finalize);

    tolua_beginmodule(tolua_S,"CMapServerBase");
        tolua_function(tolua_S,"new",lua_mapserver_CMapServerBase_constructor);
        tolua_function(tolua_S,"getServerType",lua_mapserver_CMapServerBase_getServerType);
        tolua_function(tolua_S,"onBreath",lua_mapserver_CMapServerBase_onBreath);
        tolua_function(tolua_S,"onRegisteToWorld",lua_mapserver_CMapServerBase_onRegisteToWorld);
        tolua_function(tolua_S,"isDynamicServer",lua_mapserver_CMapServerBase_isDynamicServer);
        tolua_function(tolua_S,"onLoad",lua_mapserver_CMapServerBase_onLoad);
        tolua_function(tolua_S,"isConfigRemotePath",lua_mapserver_CMapServerBase_isConfigRemotePath);
        tolua_function(tolua_S,"getToClientListenPort",lua_mapserver_CMapServerBase_getToClientListenPort);
        tolua_function(tolua_S,"canOpenDynamicMap",lua_mapserver_CMapServerBase_canOpenDynamicMap);
        tolua_function(tolua_S,"getServerID",lua_mapserver_CMapServerBase_getServerID);
        tolua_function(tolua_S,"onAfterStart",lua_mapserver_CMapServerBase_onAfterStart);
        tolua_function(tolua_S,"init",lua_mapserver_CMapServerBase_init);
        tolua_function(tolua_S,"getToClientListenIP",lua_mapserver_CMapServerBase_getToClientListenIP);
        tolua_function(tolua_S,"getScenePoolNum",lua_mapserver_CMapServerBase_getScenePoolNum);
        tolua_function(tolua_S,"getMaxRoleNum",lua_mapserver_CMapServerBase_getMaxRoleNum);
        tolua_function(tolua_S,"onWorldServerInfo",lua_mapserver_CMapServerBase_onWorldServerInfo);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapServerBase).name();
    g_luaType[typeName] = "CMapServerBase";
    g_typeCast["CMapServerBase"] = "CMapServerBase";
    return 1;
}

int lua_mapserver_CGameConfig_setBroadcastRange(lua_State* tolua_S)
{
    int argc = 0;
    CGameConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameConfig_setBroadcastRange'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameConfig:setBroadcastRange");
        if(!ok)
            return 0;
        cobj->setBroadcastRange(arg0);
        return 0;
    }

    gxError("CGameConfig:setBroadcastRange has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameConfig_setBroadcastRange'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameConfig_setBlockSize(lua_State* tolua_S)
{
    int argc = 0;
    CGameConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameConfig_setBlockSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameConfig:setBlockSize");
        if(!ok)
            return 0;
        cobj->setBlockSize(arg0);
        return 0;
    }

    gxError("CGameConfig:setBlockSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameConfig_setBlockSize'.",&tolua_err);
	return 0;
}
int lua_mapserver_CGameConfig_getSameScreenRadius(lua_State* tolua_S)
{
    int argc = 0;
    CGameConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CGameConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CGameConfig_getSameScreenRadius'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getSameScreenRadius();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameConfig:getSameScreenRadius has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CGameConfig_getSameScreenRadius'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CGameConfig_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGameConfig)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGameConfig",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CGameConfig* self = (CGameConfig*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CGameConfig(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGameConfig");
    tolua_cclass(tolua_S,"CGameConfig","CGameConfig","",nullptr);

    tolua_beginmodule(tolua_S,"CGameConfig");
        tolua_function(tolua_S,"setBroadcastRange",lua_mapserver_CGameConfig_setBroadcastRange);
        tolua_function(tolua_S,"setBlockSize",lua_mapserver_CGameConfig_setBlockSize);
        tolua_function(tolua_S,"getSameScreenRadius",lua_mapserver_CGameConfig_getSameScreenRadius);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CGameConfig).name();
    g_luaType[typeName] = "CGameConfig";
    g_typeCast["CGameConfig"] = "CGameConfig";
    return 1;
}

int lua_mapserver_CMapServerConfig_getProfileFrame(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getProfileFrame'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getProfileFrame();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getProfileFrame has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getProfileFrame'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getRecordeSvrSocketAttr(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getRecordeSvrSocketAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const SockAttr* ret = cobj->getRecordeSvrSocketAttr();
        object_to_luaval<SockAttr>(tolua_S, "SockAttr",(SockAttr*)ret);
        return 1;
    }

    gxError("CMapServerConfig:getRecordeSvrSocketAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getRecordeSvrSocketAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getMapDataPath(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getMapDataPath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getMapDataPath();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapServerConfig:getMapDataPath has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getMapDataPath'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getManagerServerPort(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getManagerServerPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getManagerServerPort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getManagerServerPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getManagerServerPort'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getGmListenIP(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getGmListenIP'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getGmListenIP();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapServerConfig:getGmListenIP has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getGmListenIP'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_onAfterLoad(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_onAfterLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onAfterLoad();
        return 0;
    }

    gxError("CMapServerConfig:onAfterLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_onAfterLoad'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_setFrameNum(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_setFrameNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapServerConfig:setFrameNum");
        if(!ok)
            return 0;
        cobj->setFrameNum(arg0);
        return 0;
    }

    gxError("CMapServerConfig:setFrameNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_setFrameNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getRecordeServerPort(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getRecordeServerPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getRecordeServerPort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getRecordeServerPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getRecordeServerPort'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getCheckTextFileName(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getCheckTextFileName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getCheckTextFileName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapServerConfig:getCheckTextFileName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getCheckTextFileName'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getWorldServerPort(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getWorldServerPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getWorldServerPort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getWorldServerPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getWorldServerPort'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getConfigTblPath(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getConfigTblPath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getConfigTblPath();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapServerConfig:getConfigTblPath has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getConfigTblPath'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_check(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_check'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->check();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerConfig:check has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_check'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getResourceSvrSocketAttr(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getResourceSvrSocketAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const SockAttr* ret = cobj->getResourceSvrSocketAttr();
        object_to_luaval<SockAttr>(tolua_S, "SockAttr",(SockAttr*)ret);
        return 1;
    }

    gxError("CMapServerConfig:getResourceSvrSocketAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getResourceSvrSocketAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_isConfigRemotePath(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_isConfigRemotePath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isConfigRemotePath();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerConfig:isConfigRemotePath has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_isConfigRemotePath'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getClientListenIP(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getClientListenIP'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getClientListenIP();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapServerConfig:getClientListenIP has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getClientListenIP'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getResourceServerPort(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getResourceServerPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getResourceServerPort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getResourceServerPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getResourceServerPort'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getToClientListenPort(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getToClientListenPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getToClientListenPort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getToClientListenPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getToClientListenPort'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getOpenGmLog(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getOpenGmLog'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getOpenGmLog();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerConfig:getOpenGmLog has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getOpenGmLog'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getClientListenSocketAttr(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getClientListenSocketAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const SockAttr* ret = cobj->getClientListenSocketAttr();
        object_to_luaval<SockAttr>(tolua_S, "SockAttr",(SockAttr*)ret);
        return 1;
    }

    gxError("CMapServerConfig:getClientListenSocketAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getClientListenSocketAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getHttpListenIP(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getHttpListenIP'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getHttpListenIP();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapServerConfig:getHttpListenIP has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getHttpListenIP'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getRolePoolNum(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getRolePoolNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getRolePoolNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getRolePoolNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getRolePoolNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getManagerServerIP(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getManagerServerIP'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getManagerServerIP();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapServerConfig:getManagerServerIP has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getManagerServerIP'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getOpenGmCheck(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getOpenGmCheck'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getOpenGmCheck();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerConfig:getOpenGmCheck has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getOpenGmCheck'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getWorldServerIP(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getWorldServerIP'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getWorldServerIP();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapServerConfig:getWorldServerIP has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getWorldServerIP'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getResourceServerIP(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getResourceServerIP'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getResourceServerIP();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapServerConfig:getResourceServerIP has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getResourceServerIP'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getHttpListenPort(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getHttpListenPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getHttpListenPort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getHttpListenPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getHttpListenPort'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getGmListenSocketAttr(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getGmListenSocketAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const SockAttr* ret = cobj->getGmListenSocketAttr();
        object_to_luaval<SockAttr>(tolua_S, "SockAttr",(SockAttr*)ret);
        return 1;
    }

    gxError("CMapServerConfig:getGmListenSocketAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getGmListenSocketAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_isDynamicMapServer(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_isDynamicMapServer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDynamicMapServer();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerConfig:isDynamicMapServer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_isDynamicMapServer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getManagerSvrSocketAttr(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getManagerSvrSocketAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const SockAttr* ret = cobj->getManagerSvrSocketAttr();
        object_to_luaval<SockAttr>(tolua_S, "SockAttr",(SockAttr*)ret);
        return 1;
    }

    gxError("CMapServerConfig:getManagerSvrSocketAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getManagerSvrSocketAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getClientListenPort(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getClientListenPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getClientListenPort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getClientListenPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getClientListenPort'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getMapServerID(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getMapServerID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getMapServerID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getMapServerID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getMapServerID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_setHttpCheck(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_setHttpCheck'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CMapServerConfig:setHttpCheck");
        if(!ok)
            return 0;
        cobj->setHttpCheck(arg0);
        return 0;
    }

    gxError("CMapServerConfig:setHttpCheck has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_setHttpCheck'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_setRecordeSize(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_setRecordeSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setRecordeSize();
        return 0;
    }

    gxError("CMapServerConfig:setRecordeSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_setRecordeSize'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getGmListenPort(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getGmListenPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getGmListenPort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getGmListenPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getGmListenPort'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getMapServerType(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getMapServerType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getMapServerType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getMapServerType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getMapServerType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getHttpCheck(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getHttpCheck'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getHttpCheck();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerConfig:getHttpCheck has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getHttpCheck'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getRiskSceneNum(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getRiskSceneNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getRiskSceneNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getRiskSceneNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getRiskSceneNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getOpenRecordeServer(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getOpenRecordeServer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getOpenRecordeServer();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getOpenRecordeServer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getOpenRecordeServer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getWorldSvrSocketAttr(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getWorldSvrSocketAttr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const SockAttr* ret = cobj->getWorldSvrSocketAttr();
        object_to_luaval<SockAttr>(tolua_S, "SockAttr",(SockAttr*)ret);
        return 1;
    }

    gxError("CMapServerConfig:getWorldSvrSocketAttr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getWorldSvrSocketAttr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getToClientListenIP(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getToClientListenIP'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getToClientListenIP();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapServerConfig:getToClientListenIP has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getToClientListenIP'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getRecordeServerIP(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getRecordeServerIP'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getRecordeServerIP();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CMapServerConfig:getRecordeServerIP has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getRecordeServerIP'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getScenePoolNum(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getScenePoolNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getScenePoolNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapServerConfig:getScenePoolNum");
        if(!ok)
            return 0;
        unsigned int ret = cobj->getScenePoolNum(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapServerConfig:getScenePoolNum");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapServerConfig:getScenePoolNum");
        if(!ok)
            return 0;
        unsigned int ret = cobj->getScenePoolNum(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerConfig:getScenePoolNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getScenePoolNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_getMapIDs(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerConfig_getMapIDs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::vector<unsigned short, std::allocator<unsigned short> > ret = cobj->getMapIDs();
        vector_to_luaval(tolua_S, "std::vector<unsigned short, std::allocator<unsigned short> >", ret);
        return 1;
    }

    gxError("CMapServerConfig:getMapIDs has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerConfig_getMapIDs'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerConfig_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerConfig* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMapServerConfig:CMapServerConfig");
        if(!ok)
            return 0;
        cobj = new CMapServerConfig(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapServerConfig");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapServerConfig:CMapServerConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_mapserver_CMapServerConfig_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapServerConfig)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapServerConfig",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapServerConfig* self = (CMapServerConfig*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapServerConfig(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapServerConfig");
    tolua_cclass(tolua_S,"CMapServerConfig","CMapServerConfig","CGxServiceConfig",lua_mapserver_CMapServerConfig_finalize);

    tolua_beginmodule(tolua_S,"CMapServerConfig");
        tolua_function(tolua_S,"new",lua_mapserver_CMapServerConfig_constructor);
        tolua_function(tolua_S,"getProfileFrame",lua_mapserver_CMapServerConfig_getProfileFrame);
        tolua_function(tolua_S,"getRecordeSvrSocketAttr",lua_mapserver_CMapServerConfig_getRecordeSvrSocketAttr);
        tolua_function(tolua_S,"getMapDataPath",lua_mapserver_CMapServerConfig_getMapDataPath);
        tolua_function(tolua_S,"getManagerServerPort",lua_mapserver_CMapServerConfig_getManagerServerPort);
        tolua_function(tolua_S,"getGmListenIP",lua_mapserver_CMapServerConfig_getGmListenIP);
        tolua_function(tolua_S,"onAfterLoad",lua_mapserver_CMapServerConfig_onAfterLoad);
        tolua_function(tolua_S,"setFrameNum",lua_mapserver_CMapServerConfig_setFrameNum);
        tolua_function(tolua_S,"getRecordeServerPort",lua_mapserver_CMapServerConfig_getRecordeServerPort);
        tolua_function(tolua_S,"getCheckTextFileName",lua_mapserver_CMapServerConfig_getCheckTextFileName);
        tolua_function(tolua_S,"getWorldServerPort",lua_mapserver_CMapServerConfig_getWorldServerPort);
        tolua_function(tolua_S,"getConfigTblPath",lua_mapserver_CMapServerConfig_getConfigTblPath);
        tolua_function(tolua_S,"check",lua_mapserver_CMapServerConfig_check);
        tolua_function(tolua_S,"getResourceSvrSocketAttr",lua_mapserver_CMapServerConfig_getResourceSvrSocketAttr);
        tolua_function(tolua_S,"isConfigRemotePath",lua_mapserver_CMapServerConfig_isConfigRemotePath);
        tolua_function(tolua_S,"getClientListenIP",lua_mapserver_CMapServerConfig_getClientListenIP);
        tolua_function(tolua_S,"getResourceServerPort",lua_mapserver_CMapServerConfig_getResourceServerPort);
        tolua_function(tolua_S,"getToClientListenPort",lua_mapserver_CMapServerConfig_getToClientListenPort);
        tolua_function(tolua_S,"getOpenGmLog",lua_mapserver_CMapServerConfig_getOpenGmLog);
        tolua_function(tolua_S,"getClientListenSocketAttr",lua_mapserver_CMapServerConfig_getClientListenSocketAttr);
        tolua_function(tolua_S,"getHttpListenIP",lua_mapserver_CMapServerConfig_getHttpListenIP);
        tolua_function(tolua_S,"getRolePoolNum",lua_mapserver_CMapServerConfig_getRolePoolNum);
        tolua_function(tolua_S,"getManagerServerIP",lua_mapserver_CMapServerConfig_getManagerServerIP);
        tolua_function(tolua_S,"getOpenGmCheck",lua_mapserver_CMapServerConfig_getOpenGmCheck);
        tolua_function(tolua_S,"getWorldServerIP",lua_mapserver_CMapServerConfig_getWorldServerIP);
        tolua_function(tolua_S,"getResourceServerIP",lua_mapserver_CMapServerConfig_getResourceServerIP);
        tolua_function(tolua_S,"getHttpListenPort",lua_mapserver_CMapServerConfig_getHttpListenPort);
        tolua_function(tolua_S,"getGmListenSocketAttr",lua_mapserver_CMapServerConfig_getGmListenSocketAttr);
        tolua_function(tolua_S,"isDynamicMapServer",lua_mapserver_CMapServerConfig_isDynamicMapServer);
        tolua_function(tolua_S,"getManagerSvrSocketAttr",lua_mapserver_CMapServerConfig_getManagerSvrSocketAttr);
        tolua_function(tolua_S,"getClientListenPort",lua_mapserver_CMapServerConfig_getClientListenPort);
        tolua_function(tolua_S,"getMapServerID",lua_mapserver_CMapServerConfig_getMapServerID);
        tolua_function(tolua_S,"setHttpCheck",lua_mapserver_CMapServerConfig_setHttpCheck);
        tolua_function(tolua_S,"setRecordeSize",lua_mapserver_CMapServerConfig_setRecordeSize);
        tolua_function(tolua_S,"getGmListenPort",lua_mapserver_CMapServerConfig_getGmListenPort);
        tolua_function(tolua_S,"getMapServerType",lua_mapserver_CMapServerConfig_getMapServerType);
        tolua_function(tolua_S,"getHttpCheck",lua_mapserver_CMapServerConfig_getHttpCheck);
        tolua_function(tolua_S,"getRiskSceneNum",lua_mapserver_CMapServerConfig_getRiskSceneNum);
        tolua_function(tolua_S,"getOpenRecordeServer",lua_mapserver_CMapServerConfig_getOpenRecordeServer);
        tolua_function(tolua_S,"getWorldSvrSocketAttr",lua_mapserver_CMapServerConfig_getWorldSvrSocketAttr);
        tolua_function(tolua_S,"getToClientListenIP",lua_mapserver_CMapServerConfig_getToClientListenIP);
        tolua_function(tolua_S,"getRecordeServerIP",lua_mapserver_CMapServerConfig_getRecordeServerIP);
        tolua_function(tolua_S,"getScenePoolNum",lua_mapserver_CMapServerConfig_getScenePoolNum);
        tolua_function(tolua_S,"getMapIDs",lua_mapserver_CMapServerConfig_getMapIDs);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapServerConfig).name();
    g_luaType[typeName] = "CMapServerConfig";
    g_typeCast["CMapServerConfig"] = "CMapServerConfig";
    return 1;
}

int lua_mapserver_BroadInfo_setChatStr(lua_State* tolua_S)
{
    int argc = 0;
    BroadInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"BroadInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (BroadInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_BroadInfo_setChatStr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CCharArray2<250> arg0;

        ok &= luaval_to_array_string2(tolua_S, 2,&arg0, "BroadInfo:setChatStr");
        if(!ok)
            return 0;
        cobj->setChatStr(arg0);
        return 0;
    }

    gxError("BroadInfo:setChatStr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_BroadInfo_setChatStr'.",&tolua_err);
	return 0;
}
int lua_mapserver_BroadInfo_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    BroadInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"BroadInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (BroadInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_BroadInfo_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("BroadInfo:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_BroadInfo_cleanUp'.",&tolua_err);
	return 0;
}
int lua_mapserver_BroadInfo_getChatStr(lua_State* tolua_S)
{
    int argc = 0;
    BroadInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"BroadInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (BroadInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_BroadInfo_getChatStr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CCharArray2<250> ret = cobj->getChatStr();
        array_string2_to_luaval(tolua_S,ret);
        return 1;
    }

    gxError("BroadInfo:getChatStr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_BroadInfo_getChatStr'.",&tolua_err);
	return 0;
}
int lua_mapserver_BroadInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    BroadInfo* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new BroadInfo();
        tolua_pushusertype(tolua_S,(void*)cobj,"BroadInfo");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("BroadInfo:BroadInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_BroadInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (BroadInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"BroadInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        BroadInfo* self = (BroadInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_BroadInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"BroadInfo");
    tolua_cclass(tolua_S,"BroadInfo","BroadInfo","",lua_mapserver_BroadInfo_finalize);

    tolua_beginmodule(tolua_S,"BroadInfo");
        tolua_function(tolua_S,"new",lua_mapserver_BroadInfo_constructor);
        tolua_function(tolua_S,"setChatStr",lua_mapserver_BroadInfo_setChatStr);
        tolua_function(tolua_S,"cleanUp",lua_mapserver_BroadInfo_cleanUp);
        tolua_function(tolua_S,"getChatStr",lua_mapserver_BroadInfo_getChatStr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(BroadInfo).name();
    g_luaType[typeName] = "BroadInfo";
    g_typeCast["BroadInfo"] = "BroadInfo";
    return 1;
}

int lua_mapserver_CBroadTimer_isNeedDel(lua_State* tolua_S)
{
    int argc = 0;
    CBroadTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBroadTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBroadTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBroadTimer_isNeedDel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNeedDel();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBroadTimer:isNeedDel has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBroadTimer_isNeedDel'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBroadTimer_update(lua_State* tolua_S)
{
    int argc = 0;
    CBroadTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBroadTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBroadTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBroadTimer_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CBroadTimer:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBroadTimer:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBroadTimer_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBroadTimer_getID(lua_State* tolua_S)
{
    int argc = 0;
    CBroadTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBroadTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBroadTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBroadTimer_getID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBroadTimer:getID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBroadTimer_getID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBroadTimer_getMsg(lua_State* tolua_S)
{
    int argc = 0;
    CBroadTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBroadTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBroadTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBroadTimer_getMsg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getMsg();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CBroadTimer:getMsg has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBroadTimer_getMsg'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBroadTimer_init(lua_State* tolua_S)
{
    int argc = 0;
    CBroadTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBroadTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBroadTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBroadTimer_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned short arg0;
        const BroadInfo* arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CBroadTimer:init");

        ok &= luaval_to_object<const BroadInfo>(tolua_S, 3, "BroadInfo", &arg1, "CBroadTimer:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CBroadTimer:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBroadTimer_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBroadTimer_setID(lua_State* tolua_S)
{
    int argc = 0;
    CBroadTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBroadTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CBroadTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CBroadTimer_setID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CBroadTimer:setID");
        if(!ok)
            return 0;
        cobj->setID(arg0);
        return 0;
    }

    gxError("CBroadTimer:setID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CBroadTimer_setID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CBroadTimer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CBroadTimer* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CBroadTimer();
        tolua_pushusertype(tolua_S,(void*)cobj,"CBroadTimer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CBroadTimer:CBroadTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CBroadTimer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBroadTimer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBroadTimer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CBroadTimer* self = (CBroadTimer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CBroadTimer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBroadTimer");
    tolua_cclass(tolua_S,"CBroadTimer","CBroadTimer","",lua_mapserver_CBroadTimer_finalize);

    tolua_beginmodule(tolua_S,"CBroadTimer");
        tolua_function(tolua_S,"new",lua_mapserver_CBroadTimer_constructor);
        tolua_function(tolua_S,"isNeedDel",lua_mapserver_CBroadTimer_isNeedDel);
        tolua_function(tolua_S,"update",lua_mapserver_CBroadTimer_update);
        tolua_function(tolua_S,"getID",lua_mapserver_CBroadTimer_getID);
        tolua_function(tolua_S,"getMsg",lua_mapserver_CBroadTimer_getMsg);
        tolua_function(tolua_S,"init",lua_mapserver_CBroadTimer_init);
        tolua_function(tolua_S,"setID",lua_mapserver_CBroadTimer_setID);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CBroadTimer).name();
    g_luaType[typeName] = "CBroadTimer";
    g_typeCast["CBroadTimer"] = "CBroadTimer";
    return 1;
}

int lua_mapserver_CAnnouncementSysManager_addBroad(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementSysManager* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAnnouncementSysManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAnnouncementSysManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CAnnouncementSysManager_addBroad'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CAnnouncementSysManager:addBroad");

            if (!ok) { break; }
            const BroadInfo* arg1;
            ok &= luaval_to_object<const BroadInfo>(tolua_S, 3, "BroadInfo", &arg1, "CAnnouncementSysManager:addBroad");

            if (!ok) { break; }
            bool ret = cobj->addBroad(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            const BroadInfo* arg0;
            ok &= luaval_to_object<const BroadInfo>(tolua_S, 2, "BroadInfo", &arg0, "CAnnouncementSysManager:addBroad");

            if (!ok) { break; }
            bool ret = cobj->addBroad(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CAnnouncementSysManager:addBroad has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementSysManager_addBroad'.",&tolua_err);
    return 0;
}
int lua_mapserver_CAnnouncementSysManager_delBroad(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementSysManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAnnouncementSysManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAnnouncementSysManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAnnouncementSysManager_delBroad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->delBroad();
        return 0;
    }

    gxError("CAnnouncementSysManager:delBroad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementSysManager_delBroad'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAnnouncementSysManager_addAnnouncement(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementSysManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAnnouncementSysManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAnnouncementSysManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAnnouncementSysManager_addAnnouncement'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const std::vector<BroadInfo, std::allocator<BroadInfo> >* arg0;

        ok &= luaval_to_object<const std::vector<BroadInfo, std::allocator<BroadInfo> >>(tolua_S, 2, "std::vector<BroadInfo, std::allocator<BroadInfo> >*", &arg0, "CAnnouncementSysManager:addAnnouncement");
        if(!ok)
            return 0;
        cobj->addAnnouncement(arg0);
        return 0;
    }

    gxError("CAnnouncementSysManager:addAnnouncement has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementSysManager_addAnnouncement'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAnnouncementSysManager_update(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementSysManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CAnnouncementSysManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CAnnouncementSysManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CAnnouncementSysManager_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        std::map<unsigned short, std::basic_string<char>, std::less<unsigned short>, std::allocator<std::pair<const unsigned short, std::basic_string<char> > > > arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CAnnouncementSysManager:update");

        ok &= luaval_to_map(tolua_S, 3, "std::map<unsigned short, std::basic_string<char>, std::less<unsigned short>, std::allocator<std::pair<const unsigned short, std::basic_string<char> > > >", &arg1, "CAnnouncementSysManager:update");
        if(!ok)
            return 0;
        cobj->update(arg0, arg1);
        return 0;
    }

    gxError("CAnnouncementSysManager:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementSysManager_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CAnnouncementSysManager_IsSystemID(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CAnnouncementSysManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned short arg0;
        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CAnnouncementSysManager:IsSystemID");
        if(!ok)
            return 0;
        bool ret = CAnnouncementSysManager::IsSystemID(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CAnnouncementSysManager:IsSystemID has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CAnnouncementSysManager_IsSystemID'.", &tolua_err);
    return 0;
}
int lua_mapserver_CAnnouncementSysManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CAnnouncementSysManager* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CAnnouncementSysManager();
        tolua_pushusertype(tolua_S,(void*)cobj,"CAnnouncementSysManager");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CAnnouncementSysManager:CAnnouncementSysManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CAnnouncementSysManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CAnnouncementSysManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CAnnouncementSysManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CAnnouncementSysManager* self = (CAnnouncementSysManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CAnnouncementSysManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CAnnouncementSysManager");
    tolua_cclass(tolua_S,"CAnnouncementSysManager","CAnnouncementSysManager","",lua_mapserver_CAnnouncementSysManager_finalize);

    tolua_beginmodule(tolua_S,"CAnnouncementSysManager");
        tolua_function(tolua_S,"new",lua_mapserver_CAnnouncementSysManager_constructor);
        tolua_function(tolua_S,"addBroad",lua_mapserver_CAnnouncementSysManager_addBroad);
        tolua_function(tolua_S,"delBroad",lua_mapserver_CAnnouncementSysManager_delBroad);
        tolua_function(tolua_S,"addAnnouncement",lua_mapserver_CAnnouncementSysManager_addAnnouncement);
        tolua_function(tolua_S,"update",lua_mapserver_CAnnouncementSysManager_update);
        tolua_function(tolua_S,"IsSystemID", lua_mapserver_CAnnouncementSysManager_IsSystemID);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CAnnouncementSysManager).name();
    g_luaType[typeName] = "CAnnouncementSysManager";
    g_typeCast["CAnnouncementSysManager"] = "CAnnouncementSysManager";
    return 1;
}

int lua_mapserver_CStopTimer_setService(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_setService'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::GxService* arg0;

        ok &= luaval_to_object<GXMISC::GxService>(tolua_S, 2, "GxService", &arg0, "CStopTimer:setService");
        if(!ok)
            return 0;
        cobj->setService(arg0);
        return 0;
    }

    gxError("CStopTimer:setService has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_setService'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_setStopLastTime(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_setStopLastTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CStopTimer:setStopLastTime");
        if(!ok)
            return 0;
        cobj->setStopLastTime(arg0);
        return 0;
    }

    gxError("CStopTimer:setStopLastTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_setStopLastTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_isStop(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_isStop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isStop();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CStopTimer:isStop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_isStop'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_setStopStartTime(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_setStopStartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CStopTimer:setStopStartTime");
        if(!ok)
            return 0;
        cobj->setStopStartTime(arg0);
        return 0;
    }

    gxError("CStopTimer:setStopStartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_setStopStartTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_getStopLastTime(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_getStopLastTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getStopLastTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CStopTimer:getStopLastTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_getStopLastTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_getStopSaveTime(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_getStopSaveTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getStopSaveTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CStopTimer:getStopSaveTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_getStopSaveTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_getScriptEngine(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_getScriptEngine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CScriptEngineCommon* ret = cobj->getScriptEngine();
        object_to_luaval<CScriptEngineCommon>(tolua_S, "CScriptEngineCommon",(CScriptEngineCommon*)ret);
        return 1;
    }

    gxError("CStopTimer:getScriptEngine has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_getScriptEngine'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_update(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CStopTimer:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CStopTimer:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_doStopSave(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_doStopSave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doStopSave();
        return 0;
    }

    gxError("CStopTimer:doStopSave has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_doStopSave'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_getService(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_getService'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::GxService* ret = cobj->getService();
        object_to_luaval<GXMISC::GxService>(tolua_S, "GxService",(GXMISC::GxService*)ret);
        return 1;
    }

    gxError("CStopTimer:getService has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_getService'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_setScriptEngine(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_setScriptEngine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CScriptEngineCommon* arg0;

        ok &= luaval_to_object<CScriptEngineCommon>(tolua_S, 2, "CScriptEngineCommon", &arg0, "CStopTimer:setScriptEngine");
        if(!ok)
            return 0;
        cobj->setScriptEngine(arg0);
        return 0;
    }

    gxError("CStopTimer:setScriptEngine has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_setScriptEngine'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_setStopSaveTime(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_setStopSaveTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CStopTimer:setStopSaveTime");
        if(!ok)
            return 0;
        cobj->setStopSaveTime(arg0);
        return 0;
    }

    gxError("CStopTimer:setStopSaveTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_setStopSaveTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_initData(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_initData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->initData();
        return 0;
    }

    gxError("CStopTimer:initData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_initData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_doStop(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_doStop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doStop();
        return 0;
    }

    gxError("CStopTimer:doStop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_doStop'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_isSaveTime(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_isSaveTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isSaveTime();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CStopTimer:isSaveTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_isSaveTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_isStopTime(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_isStopTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isStopTime();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CStopTimer:isStopTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_isStopTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_getStopStartTime(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_getStopStartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getStopStartTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CStopTimer:getStopStartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_getStopStartTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_onStop(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CStopTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CStopTimer_onStop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CStopTimer:onStop");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CStopTimer:onStop");
        if(!ok)
            return 0;
        cobj->onStop(arg0, arg1);
        return 0;
    }

    gxError("CStopTimer:onStop has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CStopTimer_onStop'.",&tolua_err);
	return 0;
}
int lua_mapserver_CStopTimer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CStopTimer* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CStopTimer();
        tolua_pushusertype(tolua_S,(void*)cobj,"CStopTimer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CStopTimer:CStopTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CStopTimer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CStopTimer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CStopTimer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CStopTimer* self = (CStopTimer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CStopTimer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CStopTimer");
    tolua_cclass(tolua_S,"CStopTimer","CStopTimer","",lua_mapserver_CStopTimer_finalize);

    tolua_beginmodule(tolua_S,"CStopTimer");
        tolua_function(tolua_S,"new",lua_mapserver_CStopTimer_constructor);
        tolua_function(tolua_S,"setService",lua_mapserver_CStopTimer_setService);
        tolua_function(tolua_S,"setStopLastTime",lua_mapserver_CStopTimer_setStopLastTime);
        tolua_function(tolua_S,"isStop",lua_mapserver_CStopTimer_isStop);
        tolua_function(tolua_S,"setStopStartTime",lua_mapserver_CStopTimer_setStopStartTime);
        tolua_function(tolua_S,"getStopLastTime",lua_mapserver_CStopTimer_getStopLastTime);
        tolua_function(tolua_S,"getStopSaveTime",lua_mapserver_CStopTimer_getStopSaveTime);
        tolua_function(tolua_S,"getScriptEngine",lua_mapserver_CStopTimer_getScriptEngine);
        tolua_function(tolua_S,"update",lua_mapserver_CStopTimer_update);
        tolua_function(tolua_S,"doStopSave",lua_mapserver_CStopTimer_doStopSave);
        tolua_function(tolua_S,"getService",lua_mapserver_CStopTimer_getService);
        tolua_function(tolua_S,"setScriptEngine",lua_mapserver_CStopTimer_setScriptEngine);
        tolua_function(tolua_S,"setStopSaveTime",lua_mapserver_CStopTimer_setStopSaveTime);
        tolua_function(tolua_S,"initData",lua_mapserver_CStopTimer_initData);
        tolua_function(tolua_S,"doStop",lua_mapserver_CStopTimer_doStop);
        tolua_function(tolua_S,"isSaveTime",lua_mapserver_CStopTimer_isSaveTime);
        tolua_function(tolua_S,"isStopTime",lua_mapserver_CStopTimer_isStopTime);
        tolua_function(tolua_S,"getStopStartTime",lua_mapserver_CStopTimer_getStopStartTime);
        tolua_function(tolua_S,"onStop",lua_mapserver_CStopTimer_onStop);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CStopTimer).name();
    g_luaType[typeName] = "CStopTimer";
    g_typeCast["CStopTimer"] = "CStopTimer";
    return 1;
}

int lua_mapserver_CMapServer_getServerConfig(lua_State* tolua_S)
{
    int argc = 0;
    CMapServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServer_getServerConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const CMapServerConfig* ret = cobj->getServerConfig();
        object_to_luaval<CMapServerConfig>(tolua_S, "CMapServerConfig",(CMapServerConfig*)ret);
        return 1;
    }

    gxError("CMapServer:getServerConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServer_getServerConfig'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServer_onRegisteToWorld(lua_State* tolua_S)
{
    int argc = 0;
    CMapServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServer_onRegisteToWorld'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapServer:onRegisteToWorld");
        if(!ok)
            return 0;
        cobj->onRegisteToWorld(arg0);
        return 0;
    }

    gxError("CMapServer:onRegisteToWorld has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServer_onRegisteToWorld'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServer_getOpenTime(lua_State* tolua_S)
{
    int argc = 0;
    CMapServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServer_getOpenTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getOpenTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServer:getOpenTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServer_getOpenTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServer_isDynamicServer(lua_State* tolua_S)
{
    int argc = 0;
    CMapServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServer_isDynamicServer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isDynamicServer();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServer:isDynamicServer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServer_isDynamicServer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServer_addManagerBoard(lua_State* tolua_S)
{
    int argc = 0;
    CMapServer* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_mapserver_CMapServer_addManagerBoard'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            std::string arg0;
            ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMapServer:addManagerBoard");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapServer:addManagerBoard");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CMapServer:addManagerBoard");

            if (!ok) { break; }
            cobj->addManagerBoard(arg0, arg1, arg2);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::string arg0;
            ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMapServer:addManagerBoard");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMapServer:addManagerBoard");

            if (!ok) { break; }
            cobj->addManagerBoard(arg0, arg1);
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CMapServer:addManagerBoard has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServer_addManagerBoard'.",&tolua_err);
    return 0;
}
int lua_mapserver_CMapServer_canOpenDynamicMap(lua_State* tolua_S)
{
    int argc = 0;
    CMapServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServer_canOpenDynamicMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canOpenDynamicMap();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServer:canOpenDynamicMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServer_canOpenDynamicMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServer_isGmLog(lua_State* tolua_S)
{
    int argc = 0;
    CMapServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServer_isGmLog'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isGmLog();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServer:isGmLog has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServer_isGmLog'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServer_isConfigRemotePath(lua_State* tolua_S)
{
    int argc = 0;
    CMapServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServer_isConfigRemotePath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isConfigRemotePath();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServer:isConfigRemotePath has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServer_isConfigRemotePath'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServer_getFirstStartTime(lua_State* tolua_S)
{
    int argc = 0;
    CMapServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServer_getFirstStartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getFirstStartTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServer:getFirstStartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServer_getFirstStartTime'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServer_onWorldServerInfo(lua_State* tolua_S)
{
    int argc = 0;
    CMapServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServer_onWorldServerInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        WMServerInfo* arg0;

        ok &= luaval_to_object<WMServerInfo>(tolua_S, 2, "WMServerInfo", &arg0, "CMapServer:onWorldServerInfo");
        if(!ok)
            return 0;
        cobj->onWorldServerInfo(arg0);
        return 0;
    }

    gxError("CMapServer:onWorldServerInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServer_onWorldServerInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServer_getStopTimer(lua_State* tolua_S)
{
    int argc = 0;
    CMapServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServer_getStopTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CStopTimer* ret = cobj->getStopTimer();
        object_to_luaval<CStopTimer>(tolua_S, "CStopTimer",(CStopTimer*)ret);
        return 1;
    }

    gxError("CMapServer:getStopTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServer_getStopTimer'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServer_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMapServer",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMapServerBase* ret = CMapServer::GetPtr();
        object_to_luaval<CMapServerBase>(tolua_S, "CMapServerBase",(CMapServerBase*)ret);
        return 1;
    }
    gxError("CMapServer:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServer_GetPtr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMapServer_InitStaticInstanace(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMapServer",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMapServer::InitStaticInstanace();
        return 0;
    }
    if (argc == 1)
    {
        lua_State* arg0;
        ok &= luaval_to_object<lua_State>(tolua_S, 2, "lua_State", &arg0, "CMapServer:InitStaticInstanace");
        if(!ok)
            return 0;
        CMapServer::InitStaticInstanace(arg0);
        return 0;
    }
    gxError("CMapServer:InitStaticInstanace has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServer_InitStaticInstanace'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMapServer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapServer* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapServer();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapServer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMapServer:CMapServer");
        if(!ok)
            return 0;
        cobj = new CMapServer(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapServer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapServer:CMapServer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapServer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapServer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapServer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapServer* self = (CMapServer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapServer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapServer");
    tolua_cclass(tolua_S,"CMapServer","CMapServer","CMapServerBase",lua_mapserver_CMapServer_finalize);

    tolua_beginmodule(tolua_S,"CMapServer");
        tolua_function(tolua_S,"new",lua_mapserver_CMapServer_constructor);
        tolua_function(tolua_S,"getServerConfig",lua_mapserver_CMapServer_getServerConfig);
        tolua_function(tolua_S,"onRegisteToWorld",lua_mapserver_CMapServer_onRegisteToWorld);
        tolua_function(tolua_S,"getOpenTime",lua_mapserver_CMapServer_getOpenTime);
        tolua_function(tolua_S,"isDynamicServer",lua_mapserver_CMapServer_isDynamicServer);
        tolua_function(tolua_S,"addManagerBoard",lua_mapserver_CMapServer_addManagerBoard);
        tolua_function(tolua_S,"canOpenDynamicMap",lua_mapserver_CMapServer_canOpenDynamicMap);
        tolua_function(tolua_S,"isGmLog",lua_mapserver_CMapServer_isGmLog);
        tolua_function(tolua_S,"isConfigRemotePath",lua_mapserver_CMapServer_isConfigRemotePath);
        tolua_function(tolua_S,"getFirstStartTime",lua_mapserver_CMapServer_getFirstStartTime);
        tolua_function(tolua_S,"onWorldServerInfo",lua_mapserver_CMapServer_onWorldServerInfo);
        tolua_function(tolua_S,"getStopTimer",lua_mapserver_CMapServer_getStopTimer);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CMapServer_GetPtr);
        tolua_function(tolua_S,"InitStaticInstanace", lua_mapserver_CMapServer_InitStaticInstanace);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapServer).name();
    g_luaType[typeName] = "CMapServer";
    g_typeCast["CMapServer"] = "CMapServer";
    return 1;
}

int lua_mapserver_CMap_getMapType(lua_State* tolua_S)
{
    int argc = 0;
    CMap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMap",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMap_getMapType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getMapType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMap:getMapType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMap_getMapType'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMap_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMap* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMap();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMap");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMap:CMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMap_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMap)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMap",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMap* self = (CMap*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMap(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMap");
    tolua_cclass(tolua_S,"CMap","CMap","CMapBase",lua_mapserver_CMap_finalize);

    tolua_beginmodule(tolua_S,"CMap");
        tolua_function(tolua_S,"new",lua_mapserver_CMap_constructor);
        tolua_function(tolua_S,"getMapType",lua_mapserver_CMap_getMapType);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMap).name();
    g_luaType[typeName] = "CMap";
    g_typeCast["CMap"] = "CMap";
    return 1;
}

int lua_mapserver_CMapDataManagerBase_getNext(lua_State* tolua_S)
{
    int argc = 0;
    CMapDataManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDataManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDataManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDataManagerBase_getNext'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapBase* ret = cobj->getNext();
        object_to_luaval<CMapBase>(tolua_S, "CMapBase",(CMapBase*)ret);
        return 1;
    }

    gxError("CMapDataManagerBase:getNext has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDataManagerBase_getNext'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDataManagerBase_getBegin(lua_State* tolua_S)
{
    int argc = 0;
    CMapDataManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDataManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDataManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDataManagerBase_getBegin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapBase* ret = cobj->getBegin();
        object_to_luaval<CMapBase>(tolua_S, "CMapBase",(CMapBase*)ret);
        return 1;
    }

    gxError("CMapDataManagerBase:getBegin has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDataManagerBase_getBegin'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDataManagerBase_isMapExist(lua_State* tolua_S)
{
    int argc = 0;
    CMapDataManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDataManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDataManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDataManagerBase_isMapExist'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapDataManagerBase:isMapExist");
        if(!ok)
            return 0;
        bool ret = cobj->isMapExist(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapDataManagerBase:isMapExist has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDataManagerBase_isMapExist'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDataManagerBase_findMap(lua_State* tolua_S)
{
    int argc = 0;
    CMapDataManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDataManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDataManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDataManagerBase_findMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapDataManagerBase:findMap");
        if(!ok)
            return 0;
        CMapBase* ret = cobj->findMap(arg0);
        object_to_luaval<CMapBase>(tolua_S, "CMapBase",(CMapBase*)ret);
        return 1;
    }

    gxError("CMapDataManagerBase:findMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDataManagerBase_findMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDataManagerBase_getNormalMaps(lua_State* tolua_S)
{
    int argc = 0;
    CMapDataManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDataManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDataManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDataManagerBase_getNormalMaps'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::vector<unsigned short, std::allocator<unsigned short> > ret = cobj->getNormalMaps();
        vector_to_luaval(tolua_S, "std::vector<unsigned short, std::allocator<unsigned short> >", ret);
        return 1;
    }

    gxError("CMapDataManagerBase:getNormalMaps has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDataManagerBase_getNormalMaps'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDataManagerBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapDataManagerBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapDataManagerBase();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapDataManagerBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapDataManagerBase:CMapDataManagerBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapDataManagerBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapDataManagerBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapDataManagerBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapDataManagerBase* self = (CMapDataManagerBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapDataManagerBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapDataManagerBase");
    tolua_cclass(tolua_S,"CMapDataManagerBase","CMapDataManagerBase","CHashMultiIndex<CMapBase, false, 0>",lua_mapserver_CMapDataManagerBase_finalize);

    tolua_beginmodule(tolua_S,"CMapDataManagerBase");
        tolua_function(tolua_S,"new",lua_mapserver_CMapDataManagerBase_constructor);
        tolua_function(tolua_S,"getNext",lua_mapserver_CMapDataManagerBase_getNext);
        tolua_function(tolua_S,"getBegin",lua_mapserver_CMapDataManagerBase_getBegin);
        tolua_function(tolua_S,"isMapExist",lua_mapserver_CMapDataManagerBase_isMapExist);
        tolua_function(tolua_S,"findMap",lua_mapserver_CMapDataManagerBase_findMap);
        tolua_function(tolua_S,"getNormalMaps",lua_mapserver_CMapDataManagerBase_getNormalMaps);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapDataManagerBase).name();
    g_luaType[typeName] = "CMapDataManagerBase";
    g_typeCast["CMapDataManagerBase"] = "CMapDataManagerBase";
    return 1;
}

int lua_mapserver_CMapDataManager_addNewMap(lua_State* tolua_S)
{
    int argc = 0;
    CMapDataManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDataManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDataManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDataManager_addNewMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned short arg0;
        std::string arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapDataManager:addNewMap");

        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CMapDataManager:addNewMap");
        if(!ok)
            return 0;
        CMap* ret = cobj->addNewMap(arg0, arg1);
        object_to_luaval<CMap>(tolua_S, "CMap",(CMap*)ret);
        return 1;
    }

    gxError("CMapDataManager:addNewMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDataManager_addNewMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDataManager_init(lua_State* tolua_S)
{
    int argc = 0;
    CMapDataManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDataManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDataManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDataManager_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMapDataManager:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapDataManager:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDataManager_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDataManager_delMap(lua_State* tolua_S)
{
    int argc = 0;
    CMapDataManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDataManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDataManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDataManager_delMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapDataManager:delMap");
        if(!ok)
            return 0;
        cobj->delMap(arg0);
        return 0;
    }

    gxError("CMapDataManager:delMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDataManager_delMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDataManager_findMap(lua_State* tolua_S)
{
    int argc = 0;
    CMapDataManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapDataManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapDataManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapDataManager_findMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapDataManager:findMap");
        if(!ok)
            return 0;
        CMap* ret = cobj->findMap(arg0);
        object_to_luaval<CMap>(tolua_S, "CMap",(CMap*)ret);
        return 1;
    }

    gxError("CMapDataManager:findMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDataManager_findMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapDataManager_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMapDataManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMapDataManager* ret = CMapDataManager::GetPtr();
        object_to_luaval<CMapDataManager>(tolua_S, "CMapDataManager",(CMapDataManager*)ret);
        return 1;
    }
    gxError("CMapDataManager:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapDataManager_GetPtr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMapDataManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapDataManager* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapDataManager();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapDataManager");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapDataManager:CMapDataManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapDataManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapDataManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapDataManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapDataManager* self = (CMapDataManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapDataManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapDataManager");
    tolua_cclass(tolua_S,"CMapDataManager","CMapDataManager","CMapDataManagerBase",lua_mapserver_CMapDataManager_finalize);

    tolua_beginmodule(tolua_S,"CMapDataManager");
        tolua_function(tolua_S,"new",lua_mapserver_CMapDataManager_constructor);
        tolua_function(tolua_S,"addNewMap",lua_mapserver_CMapDataManager_addNewMap);
        tolua_function(tolua_S,"init",lua_mapserver_CMapDataManager_init);
        tolua_function(tolua_S,"delMap",lua_mapserver_CMapDataManager_delMap);
        tolua_function(tolua_S,"findMap",lua_mapserver_CMapDataManager_findMap);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CMapDataManager_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapDataManager).name();
    g_luaType[typeName] = "CMapDataManager";
    g_typeCast["CMapDataManager"] = "CMapDataManager";
    return 1;
}

int lua_mapserver_CLoadRoleDataTask_toString(lua_State* tolua_S)
{
    int argc = 0;
    CLoadRoleDataTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLoadRoleDataTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLoadRoleDataTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLoadRoleDataTask_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CLoadRoleDataTask:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLoadRoleDataTask_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLoadRoleDataTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CLoadRoleDataTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CLoadRoleDataTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CLoadRoleDataTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CLoadRoleDataTask:CLoadRoleDataTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CLoadRoleDataTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLoadRoleDataTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLoadRoleDataTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLoadRoleDataTask* self = (CLoadRoleDataTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLoadRoleDataTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLoadRoleDataTask");
    tolua_cclass(tolua_S,"CLoadRoleDataTask","CLoadRoleDataTask","CDbWrapTask",lua_mapserver_CLoadRoleDataTask_finalize);

    tolua_beginmodule(tolua_S,"CLoadRoleDataTask");
        tolua_function(tolua_S,"new",lua_mapserver_CLoadRoleDataTask_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_CLoadRoleDataTask_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLoadRoleDataTask).name();
    g_luaType[typeName] = "CLoadRoleDataTask";
    g_typeCast["CLoadRoleDataTask"] = "CLoadRoleDataTask";
    return 1;
}

int lua_mapserver_CLoadRoleDataRetTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    CLoadRoleDataRetTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLoadRoleDataRetTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLoadRoleDataRetTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLoadRoleDataRetTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CLoadRoleDataRetTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLoadRoleDataRetTask_doRun'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLoadRoleDataRetTask_toString(lua_State* tolua_S)
{
    int argc = 0;
    CLoadRoleDataRetTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLoadRoleDataRetTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLoadRoleDataRetTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLoadRoleDataRetTask_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CLoadRoleDataRetTask:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLoadRoleDataRetTask_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLoadRoleDataRetTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CLoadRoleDataRetTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CLoadRoleDataRetTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CLoadRoleDataRetTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CLoadRoleDataRetTask:CLoadRoleDataRetTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CLoadRoleDataRetTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLoadRoleDataRetTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLoadRoleDataRetTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLoadRoleDataRetTask* self = (CLoadRoleDataRetTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLoadRoleDataRetTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLoadRoleDataRetTask");
    tolua_cclass(tolua_S,"CLoadRoleDataRetTask","CLoadRoleDataRetTask","CDbConnTask",lua_mapserver_CLoadRoleDataRetTask_finalize);

    tolua_beginmodule(tolua_S,"CLoadRoleDataRetTask");
        tolua_function(tolua_S,"new",lua_mapserver_CLoadRoleDataRetTask_constructor);
        tolua_function(tolua_S,"doRun",lua_mapserver_CLoadRoleDataRetTask_doRun);
        tolua_function(tolua_S,"toString",lua_mapserver_CLoadRoleDataRetTask_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLoadRoleDataRetTask).name();
    g_luaType[typeName] = "CLoadRoleDataRetTask";
    g_typeCast["CLoadRoleDataRetTask"] = "CLoadRoleDataRetTask";
    return 1;
}

static int lua_mapserver_CPlayerRegisteTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CPlayerRegisteTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CPlayerRegisteTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CPlayerRegisteTask* self = (CPlayerRegisteTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CPlayerRegisteTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CPlayerRegisteTask");
    tolua_cclass(tolua_S,"CPlayerRegisteTask","CPlayerRegisteTask","CDbWrapTask",nullptr);

    tolua_beginmodule(tolua_S,"CPlayerRegisteTask");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CPlayerRegisteTask).name();
    g_luaType[typeName] = "CPlayerRegisteTask";
    g_typeCast["CPlayerRegisteTask"] = "CPlayerRegisteTask";
    return 1;
}

int lua_mapserver_CPlayerRegisteRetTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    CPlayerRegisteRetTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CPlayerRegisteRetTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CPlayerRegisteRetTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CPlayerRegisteRetTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CPlayerRegisteRetTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CPlayerRegisteRetTask_doRun'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CPlayerRegisteRetTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CPlayerRegisteRetTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CPlayerRegisteRetTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CPlayerRegisteRetTask* self = (CPlayerRegisteRetTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CPlayerRegisteRetTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CPlayerRegisteRetTask");
    tolua_cclass(tolua_S,"CPlayerRegisteRetTask","CPlayerRegisteRetTask","CDbConnTask",nullptr);

    tolua_beginmodule(tolua_S,"CPlayerRegisteRetTask");
        tolua_function(tolua_S,"doRun",lua_mapserver_CPlayerRegisteRetTask_doRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CPlayerRegisteRetTask).name();
    g_luaType[typeName] = "CPlayerRegisteRetTask";
    g_typeCast["CPlayerRegisteRetTask"] = "CPlayerRegisteRetTask";
    return 1;
}

int lua_mapserver_CSaveRoleDataTask_toString(lua_State* tolua_S)
{
    int argc = 0;
    CSaveRoleDataTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSaveRoleDataTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSaveRoleDataTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSaveRoleDataTask_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CSaveRoleDataTask:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSaveRoleDataTask_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSaveRoleDataTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CSaveRoleDataTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CSaveRoleDataTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSaveRoleDataTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSaveRoleDataTask:CSaveRoleDataTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CSaveRoleDataTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSaveRoleDataTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSaveRoleDataTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CSaveRoleDataTask* self = (CSaveRoleDataTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CSaveRoleDataTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSaveRoleDataTask");
    tolua_cclass(tolua_S,"CSaveRoleDataTask","CSaveRoleDataTask","CMapDbRequestTask",lua_mapserver_CSaveRoleDataTask_finalize);

    tolua_beginmodule(tolua_S,"CSaveRoleDataTask");
        tolua_function(tolua_S,"new",lua_mapserver_CSaveRoleDataTask_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_CSaveRoleDataTask_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CSaveRoleDataTask).name();
    g_luaType[typeName] = "CSaveRoleDataTask";
    g_typeCast["CSaveRoleDataTask"] = "CSaveRoleDataTask";
    return 1;
}

int lua_mapserver_CSaveRoleDataRetTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CSaveRoleDataRetTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CSaveRoleDataRetTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSaveRoleDataRetTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSaveRoleDataRetTask:CSaveRoleDataRetTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CSaveRoleDataRetTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSaveRoleDataRetTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSaveRoleDataRetTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CSaveRoleDataRetTask* self = (CSaveRoleDataRetTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CSaveRoleDataRetTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSaveRoleDataRetTask");
    tolua_cclass(tolua_S,"CSaveRoleDataRetTask","CSaveRoleDataRetTask","CMapDbResponseTask",lua_mapserver_CSaveRoleDataRetTask_finalize);

    tolua_beginmodule(tolua_S,"CSaveRoleDataRetTask");
        tolua_function(tolua_S,"new",lua_mapserver_CSaveRoleDataRetTask_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CSaveRoleDataRetTask).name();
    g_luaType[typeName] = "CSaveRoleDataRetTask";
    g_typeCast["CSaveRoleDataRetTask"] = "CSaveRoleDataRetTask";
    return 1;
}

int lua_mapserver_CUpdateRoleDataTimerTask_toString(lua_State* tolua_S)
{
    int argc = 0;
    CUpdateRoleDataTimerTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CUpdateRoleDataTimerTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (CUpdateRoleDataTimerTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CUpdateRoleDataTimerTask_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CUpdateRoleDataTimerTask:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CUpdateRoleDataTimerTask_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CUpdateRoleDataTimerTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CUpdateRoleDataTimerTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CUpdateRoleDataTimerTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CUpdateRoleDataTimerTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CUpdateRoleDataTimerTask:CUpdateRoleDataTimerTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CUpdateRoleDataTimerTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CUpdateRoleDataTimerTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CUpdateRoleDataTimerTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CUpdateRoleDataTimerTask* self = (CUpdateRoleDataTimerTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CUpdateRoleDataTimerTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CUpdateRoleDataTimerTask");
    tolua_cclass(tolua_S,"CUpdateRoleDataTimerTask","CUpdateRoleDataTimerTask","CMapDbRequestTask",lua_mapserver_CUpdateRoleDataTimerTask_finalize);

    tolua_beginmodule(tolua_S,"CUpdateRoleDataTimerTask");
        tolua_function(tolua_S,"new",lua_mapserver_CUpdateRoleDataTimerTask_constructor);
        tolua_function(tolua_S,"toString",lua_mapserver_CUpdateRoleDataTimerTask_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CUpdateRoleDataTimerTask).name();
    g_luaType[typeName] = "CUpdateRoleDataTimerTask";
    g_typeCast["CUpdateRoleDataTimerTask"] = "CUpdateRoleDataTimerTask";
    return 1;
}

int lua_mapserver_CMapServerData_setMapServerID(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerData_setMapServerID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapServerData:setMapServerID");
        if(!ok)
            return 0;
        cobj->setMapServerID(arg0);
        return 0;
    }

    gxError("CMapServerData:setMapServerID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_setMapServerID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerData_getDbHandler(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerData_getDbHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapDbServerHandler* ret = cobj->getDbHandler();
        object_to_luaval<CMapDbServerHandler>(tolua_S, "CMapDbServerHandler",(CMapDbServerHandler*)ret);
        return 1;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CMapServerData:getDbHandler");
        if(!ok)
            return 0;
        CMapDbServerHandler* ret = cobj->getDbHandler(arg0);
        object_to_luaval<CMapDbServerHandler>(tolua_S, "CMapDbServerHandler",(CMapDbServerHandler*)ret);
        return 1;
    }

    gxError("CMapServerData:getDbHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_getDbHandler'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerData_initWorldServerInfo(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerData_initWorldServerInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::CGameTime arg0;
        GXMISC::CGameTime arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(GXMISC::TGameTime_t*)&arg0, "CMapServerData:initWorldServerInfo");

        ok &= luaval_to_uint32(tolua_S, 3,(GXMISC::TGameTime_t*)&arg1, "CMapServerData:initWorldServerInfo");
        if(!ok)
            return 0;
        cobj->initWorldServerInfo(arg0, arg1);
        return 0;
    }

    gxError("CMapServerData:initWorldServerInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_initWorldServerInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerData_getWorldServerID(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerData_getWorldServerID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getWorldServerID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerData:getWorldServerID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_getWorldServerID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerData_update(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerData_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapServerData:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CMapServerData:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerData_getMapServerID(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerData_getMapServerID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getMapServerID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerData:getMapServerID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_getMapServerID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerData_setPlatformID(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerData_setPlatformID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CMapServerData:setPlatformID");
        if(!ok)
            return 0;
        cobj->setPlatformID(arg0);
        return 0;
    }

    gxError("CMapServerData:setPlatformID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_setPlatformID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerData_setCDKeyStr(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerData_setCDKeyStr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CFixString<50> arg0;

        ok &= luaval_to_fixstring(tolua_S, 2,&arg0, "CMapServerData:setCDKeyStr");
        if(!ok)
            return 0;
        cobj->setCDKeyStr(arg0);
        return 0;
    }

    gxError("CMapServerData:setCDKeyStr has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_setCDKeyStr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerData_setMapDbHandlerID(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerData_setMapDbHandlerID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapServerData:setMapDbHandlerID");
        if(!ok)
            return 0;
        cobj->setMapDbHandlerID(arg0);
        return 0;
    }

    gxError("CMapServerData:setMapDbHandlerID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_setMapDbHandlerID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerData_getPlatformID(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerData_getPlatformID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getPlatformID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerData:getPlatformID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_getPlatformID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerData_getCDKeyStr(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerData_getCDKeyStr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const GXMISC::CFixString<50>& ret = cobj->getCDKeyStr();
        fixstring_to_luaval(tolua_S,ret);
        return 1;
    }

    gxError("CMapServerData:getCDKeyStr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_getCDKeyStr'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerData_setWorldServerID(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerData_setWorldServerID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMapServerData:setWorldServerID");
        if(!ok)
            return 0;
        cobj->setWorldServerID(arg0);
        return 0;
    }

    gxError("CMapServerData:setWorldServerID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_setWorldServerID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerData_getServerOpenDay(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerData*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerData_getServerOpenDay'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getServerOpenDay();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapServerData:getServerOpenDay has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_getServerOpenDay'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerData_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMapServerData",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMapServerData* ret = CMapServerData::GetPtr();
        object_to_luaval<CMapServerData>(tolua_S, "CMapServerData",(CMapServerData*)ret);
        return 1;
    }
    gxError("CMapServerData:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerData_GetPtr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMapServerData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerData* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapServerData();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapServerData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapServerData:CMapServerData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapServerData_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapServerData)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapServerData",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapServerData* self = (CMapServerData*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapServerData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapServerData");
    tolua_cclass(tolua_S,"CMapServerData","CMapServerData","CManualSingleton<CMapServerData>",lua_mapserver_CMapServerData_finalize);

    tolua_beginmodule(tolua_S,"CMapServerData");
        tolua_function(tolua_S,"new",lua_mapserver_CMapServerData_constructor);
        tolua_function(tolua_S,"setMapServerID",lua_mapserver_CMapServerData_setMapServerID);
        tolua_function(tolua_S,"getDbHandler",lua_mapserver_CMapServerData_getDbHandler);
        tolua_function(tolua_S,"initWorldServerInfo",lua_mapserver_CMapServerData_initWorldServerInfo);
        tolua_function(tolua_S,"getWorldServerID",lua_mapserver_CMapServerData_getWorldServerID);
        tolua_function(tolua_S,"update",lua_mapserver_CMapServerData_update);
        tolua_function(tolua_S,"getMapServerID",lua_mapserver_CMapServerData_getMapServerID);
        tolua_function(tolua_S,"setPlatformID",lua_mapserver_CMapServerData_setPlatformID);
        tolua_function(tolua_S,"setCDKeyStr",lua_mapserver_CMapServerData_setCDKeyStr);
        tolua_function(tolua_S,"setMapDbHandlerID",lua_mapserver_CMapServerData_setMapDbHandlerID);
        tolua_function(tolua_S,"getPlatformID",lua_mapserver_CMapServerData_getPlatformID);
        tolua_function(tolua_S,"getCDKeyStr",lua_mapserver_CMapServerData_getCDKeyStr);
        tolua_function(tolua_S,"setWorldServerID",lua_mapserver_CMapServerData_setWorldServerID);
        tolua_function(tolua_S,"getServerOpenDay",lua_mapserver_CMapServerData_getServerOpenDay);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CMapServerData_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapServerData).name();
    g_luaType[typeName] = "CMapServerData";
    g_typeCast["CMapServerData"] = "CMapServerData";
    return 1;
}

int lua_mapserver_CMapServerEvent_onDump(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerEvent* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerEvent",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerEvent*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerEvent_onDump'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMapServerEvent:onDump");
        if(!ok)
            return 0;
        cobj->onDump(arg0);
        return 0;
    }

    gxError("CMapServerEvent:onDump has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerEvent_onDump'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CMapServerEvent_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapServerEvent)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapServerEvent",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapServerEvent* self = (CMapServerEvent*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapServerEvent(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapServerEvent");
    tolua_cclass(tolua_S,"CMapServerEvent","CMapServerEvent","IDumpHandler",nullptr);

    tolua_beginmodule(tolua_S,"CMapServerEvent");
        tolua_function(tolua_S,"onDump",lua_mapserver_CMapServerEvent_onDump);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapServerEvent).name();
    g_luaType[typeName] = "CMapServerEvent";
    g_typeCast["CMapServerEvent"] = "CMapServerEvent";
    return 1;
}

int lua_mapserver_CMapServerInitFlag_setWorldRegiste(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerInitFlag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerInitFlag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerInitFlag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerInitFlag_setWorldRegiste'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CMapServerInitFlag:setWorldRegiste");
        if(!ok)
            return 0;
        cobj->setWorldRegiste(arg0);
        return 0;
    }

    gxError("CMapServerInitFlag:setWorldRegiste has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerInitFlag_setWorldRegiste'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerInitFlag_setServiceStart(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerInitFlag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerInitFlag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerInitFlag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerInitFlag_setServiceStart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CMapServerInitFlag:setServiceStart");
        if(!ok)
            return 0;
        cobj->setServiceStart(arg0);
        return 0;
    }

    gxError("CMapServerInitFlag:setServiceStart has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerInitFlag_setServiceStart'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerInitFlag_setDbInit(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerInitFlag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerInitFlag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerInitFlag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerInitFlag_setDbInit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CMapServerInitFlag:setDbInit");
        if(!ok)
            return 0;
        cobj->setDbInit(arg0);
        return 0;
    }

    gxError("CMapServerInitFlag:setDbInit has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerInitFlag_setDbInit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerInitFlag_clearInitSuccess(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerInitFlag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerInitFlag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerInitFlag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerInitFlag_clearInitSuccess'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->clearInitSuccess();
        return 0;
    }

    gxError("CMapServerInitFlag:clearInitSuccess has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerInitFlag_clearInitSuccess'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerInitFlag_isServiceStart(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerInitFlag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerInitFlag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerInitFlag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerInitFlag_isServiceStart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isServiceStart();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerInitFlag:isServiceStart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerInitFlag_isServiceStart'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerInitFlag_isInitSuccess(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerInitFlag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerInitFlag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerInitFlag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerInitFlag_isInitSuccess'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isInitSuccess();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerInitFlag:isInitSuccess has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerInitFlag_isInitSuccess'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerInitFlag_isInitFaild(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerInitFlag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerInitFlag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerInitFlag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerInitFlag_isInitFaild'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isInitFaild();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMapServerInitFlag:isInitFaild has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerInitFlag_isInitFaild'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerInitFlag_clean(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerInitFlag* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapServerInitFlag",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapServerInitFlag*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapServerInitFlag_clean'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->clean();
        return 0;
    }

    gxError("CMapServerInitFlag:clean has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapServerInitFlag_clean'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapServerInitFlag_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapServerInitFlag* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapServerInitFlag();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapServerInitFlag");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapServerInitFlag:CMapServerInitFlag has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapServerInitFlag_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapServerInitFlag)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapServerInitFlag",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapServerInitFlag* self = (CMapServerInitFlag*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapServerInitFlag(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapServerInitFlag");
    tolua_cclass(tolua_S,"CMapServerInitFlag","CMapServerInitFlag","",lua_mapserver_CMapServerInitFlag_finalize);

    tolua_beginmodule(tolua_S,"CMapServerInitFlag");
        tolua_function(tolua_S,"new",lua_mapserver_CMapServerInitFlag_constructor);
        tolua_function(tolua_S,"setWorldRegiste",lua_mapserver_CMapServerInitFlag_setWorldRegiste);
        tolua_function(tolua_S,"setServiceStart",lua_mapserver_CMapServerInitFlag_setServiceStart);
        tolua_function(tolua_S,"setDbInit",lua_mapserver_CMapServerInitFlag_setDbInit);
        tolua_function(tolua_S,"clearInitSuccess",lua_mapserver_CMapServerInitFlag_clearInitSuccess);
        tolua_function(tolua_S,"isServiceStart",lua_mapserver_CMapServerInitFlag_isServiceStart);
        tolua_function(tolua_S,"isInitSuccess",lua_mapserver_CMapServerInitFlag_isInitSuccess);
        tolua_function(tolua_S,"isInitFaild",lua_mapserver_CMapServerInitFlag_isInitFaild);
        tolua_function(tolua_S,"clean",lua_mapserver_CMapServerInitFlag_clean);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapServerInitFlag).name();
    g_luaType[typeName] = "CMapServerInitFlag";
    g_typeCast["CMapServerInitFlag"] = "CMapServerInitFlag";
    return 1;
}

int lua_mapserver_COpenDynamicScene_setParam(lua_State* tolua_S)
{
    int argc = 0;
    COpenDynamicScene* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"COpenDynamicScene",0,&tolua_err)) goto tolua_lerror;
    cobj = (COpenDynamicScene*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_COpenDynamicScene_setParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        unsigned int arg0;
        unsigned short arg1;
        const AxisPos* arg2;
        ESceneType arg3;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "COpenDynamicScene:setParam");

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "COpenDynamicScene:setParam");

        ok &= luaval_to_object<const AxisPos>(tolua_S, 4, "AxisPos", &arg2, "COpenDynamicScene:setParam");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "COpenDynamicScene:setParam");
        if(!ok)
            return 0;
        cobj->setParam(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("COpenDynamicScene:setParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_COpenDynamicScene_setParam'.",&tolua_err);
	return 0;
}
int lua_mapserver_COpenDynamicScene_constructor(lua_State* tolua_S)
{
    int argc = 0;
    COpenDynamicScene* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new COpenDynamicScene();
        tolua_pushusertype(tolua_S,(void*)cobj,"COpenDynamicScene");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("COpenDynamicScene:COpenDynamicScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_COpenDynamicScene_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (COpenDynamicScene)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"COpenDynamicScene",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        COpenDynamicScene* self = (COpenDynamicScene*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_COpenDynamicScene(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"COpenDynamicScene");
    tolua_cclass(tolua_S,"COpenDynamicScene","COpenDynamicScene","CServiceTask",lua_mapserver_COpenDynamicScene_finalize);

    tolua_beginmodule(tolua_S,"COpenDynamicScene");
        tolua_function(tolua_S,"new",lua_mapserver_COpenDynamicScene_constructor);
        tolua_function(tolua_S,"setParam",lua_mapserver_COpenDynamicScene_setParam);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(COpenDynamicScene).name();
    g_luaType[typeName] = "COpenDynamicScene";
    g_typeCast["COpenDynamicScene"] = "COpenDynamicScene";
    return 1;
}

int lua_mapserver_CWLRegiste_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CWLRegiste* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CWLRegiste",0,&tolua_err)) goto tolua_lerror;
    cobj = (CWLRegiste*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CWLRegiste_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CWLRegiste:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CWLRegiste_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CWLRegiste_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CWLRegiste* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CWLRegiste();
        tolua_pushusertype(tolua_S,(void*)cobj,"CWLRegiste");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CWLRegiste:CWLRegiste has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CWLRegiste_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CWLRegiste)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CWLRegiste",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CWLRegiste* self = (CWLRegiste*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CWLRegiste(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CWLRegiste");
    tolua_cclass(tolua_S,"CWLRegiste","CWLRegiste","CRequestPacket",lua_mapserver_CWLRegiste_finalize);

    tolua_beginmodule(tolua_S,"CWLRegiste");
        tolua_function(tolua_S,"new",lua_mapserver_CWLRegiste_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CWLRegiste_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CWLRegiste).name();
    g_luaType[typeName] = "CWLRegiste";
    g_typeCast["CWLRegiste"] = "CWLRegiste";
    return 1;
}

int lua_mapserver_CLWRegisteRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CLWRegisteRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLWRegisteRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLWRegisteRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLWRegisteRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLWRegisteRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLWRegisteRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLWRegisteRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CLWRegisteRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CLWRegisteRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"CLWRegisteRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CLWRegisteRet:CLWRegisteRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CLWRegisteRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLWRegisteRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLWRegisteRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLWRegisteRet* self = (CLWRegisteRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLWRegisteRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLWRegisteRet");
    tolua_cclass(tolua_S,"CLWRegisteRet","CLWRegisteRet","CResponsePacket",lua_mapserver_CLWRegisteRet_finalize);

    tolua_beginmodule(tolua_S,"CLWRegisteRet");
        tolua_function(tolua_S,"new",lua_mapserver_CLWRegisteRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CLWRegisteRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLWRegisteRet).name();
    g_luaType[typeName] = "CLWRegisteRet";
    g_typeCast["CLWRegisteRet"] = "CLWRegisteRet";
    return 1;
}

int lua_mapserver_CWLRoleLogin_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CWLRoleLogin* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CWLRoleLogin",0,&tolua_err)) goto tolua_lerror;
    cobj = (CWLRoleLogin*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CWLRoleLogin_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CWLRoleLogin:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CWLRoleLogin_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CWLRoleLogin_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CWLRoleLogin* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CWLRoleLogin();
        tolua_pushusertype(tolua_S,(void*)cobj,"CWLRoleLogin");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CWLRoleLogin:CWLRoleLogin has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CWLRoleLogin_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CWLRoleLogin)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CWLRoleLogin",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CWLRoleLogin* self = (CWLRoleLogin*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CWLRoleLogin(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CWLRoleLogin");
    tolua_cclass(tolua_S,"CWLRoleLogin","CWLRoleLogin","CRequestPacket",lua_mapserver_CWLRoleLogin_finalize);

    tolua_beginmodule(tolua_S,"CWLRoleLogin");
        tolua_function(tolua_S,"new",lua_mapserver_CWLRoleLogin_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CWLRoleLogin_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CWLRoleLogin).name();
    g_luaType[typeName] = "CWLRoleLogin";
    g_typeCast["CWLRoleLogin"] = "CWLRoleLogin";
    return 1;
}

int lua_mapserver_CLWRoleLoginRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CLWRoleLoginRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLWRoleLoginRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLWRoleLoginRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLWRoleLoginRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLWRoleLoginRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLWRoleLoginRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLWRoleLoginRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CLWRoleLoginRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CLWRoleLoginRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"CLWRoleLoginRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CLWRoleLoginRet:CLWRoleLoginRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CLWRoleLoginRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLWRoleLoginRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLWRoleLoginRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLWRoleLoginRet* self = (CLWRoleLoginRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLWRoleLoginRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLWRoleLoginRet");
    tolua_cclass(tolua_S,"CLWRoleLoginRet","CLWRoleLoginRet","CResponsePacket",lua_mapserver_CLWRoleLoginRet_finalize);

    tolua_beginmodule(tolua_S,"CLWRoleLoginRet");
        tolua_function(tolua_S,"new",lua_mapserver_CLWRoleLoginRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CLWRoleLoginRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLWRoleLoginRet).name();
    g_luaType[typeName] = "CLWRoleLoginRet";
    g_typeCast["CLWRoleLoginRet"] = "CLWRoleLoginRet";
    return 1;
}

int lua_mapserver_CWLRoleCreate_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CWLRoleCreate* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CWLRoleCreate",0,&tolua_err)) goto tolua_lerror;
    cobj = (CWLRoleCreate*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CWLRoleCreate_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CWLRoleCreate:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CWLRoleCreate_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CWLRoleCreate_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CWLRoleCreate* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CWLRoleCreate();
        tolua_pushusertype(tolua_S,(void*)cobj,"CWLRoleCreate");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CWLRoleCreate:CWLRoleCreate has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CWLRoleCreate_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CWLRoleCreate)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CWLRoleCreate",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CWLRoleCreate* self = (CWLRoleCreate*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CWLRoleCreate(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CWLRoleCreate");
    tolua_cclass(tolua_S,"CWLRoleCreate","CWLRoleCreate","CRequestPacket",lua_mapserver_CWLRoleCreate_finalize);

    tolua_beginmodule(tolua_S,"CWLRoleCreate");
        tolua_function(tolua_S,"new",lua_mapserver_CWLRoleCreate_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CWLRoleCreate_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CWLRoleCreate).name();
    g_luaType[typeName] = "CWLRoleCreate";
    g_typeCast["CWLRoleCreate"] = "CWLRoleCreate";
    return 1;
}

int lua_mapserver_CLWRoleCreateRet_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CLWRoleCreateRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLWRoleCreateRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLWRoleCreateRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLWRoleCreateRet_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLWRoleCreateRet:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLWRoleCreateRet_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLWRoleCreateRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CLWRoleCreateRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CLWRoleCreateRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"CLWRoleCreateRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CLWRoleCreateRet:CLWRoleCreateRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CLWRoleCreateRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLWRoleCreateRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLWRoleCreateRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLWRoleCreateRet* self = (CLWRoleCreateRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLWRoleCreateRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLWRoleCreateRet");
    tolua_cclass(tolua_S,"CLWRoleCreateRet","CLWRoleCreateRet","CResponsePacket",lua_mapserver_CLWRoleCreateRet_finalize);

    tolua_beginmodule(tolua_S,"CLWRoleCreateRet");
        tolua_function(tolua_S,"new",lua_mapserver_CLWRoleCreateRet_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CLWRoleCreateRet_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLWRoleCreateRet).name();
    g_luaType[typeName] = "CLWRoleCreateRet";
    g_typeCast["CLWRoleCreateRet"] = "CLWRoleCreateRet";
    return 1;
}

int lua_mapserver_CWLDataUpdate_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CWLDataUpdate* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CWLDataUpdate",0,&tolua_err)) goto tolua_lerror;
    cobj = (CWLDataUpdate*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CWLDataUpdate_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CWLDataUpdate:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CWLDataUpdate_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CWLDataUpdate_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CWLDataUpdate* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CWLDataUpdate();
        tolua_pushusertype(tolua_S,(void*)cobj,"CWLDataUpdate");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CWLDataUpdate:CWLDataUpdate has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CWLDataUpdate_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CWLDataUpdate)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CWLDataUpdate",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CWLDataUpdate* self = (CWLDataUpdate*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CWLDataUpdate(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CWLDataUpdate");
    tolua_cclass(tolua_S,"CWLDataUpdate","CWLDataUpdate","CRequestPacket",lua_mapserver_CWLDataUpdate_finalize);

    tolua_beginmodule(tolua_S,"CWLDataUpdate");
        tolua_function(tolua_S,"new",lua_mapserver_CWLDataUpdate_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CWLDataUpdate_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CWLDataUpdate).name();
    g_luaType[typeName] = "CWLDataUpdate";
    g_typeCast["CWLDataUpdate"] = "CWLDataUpdate";
    return 1;
}

int lua_mapserver_CLWLimitInfoUpdate_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CLWLimitInfoUpdate* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLWLimitInfoUpdate",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLWLimitInfoUpdate*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLWLimitInfoUpdate_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLWLimitInfoUpdate:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLWLimitInfoUpdate_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLWLimitInfoUpdate_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CLWLimitInfoUpdate* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CLWLimitInfoUpdate();
        tolua_pushusertype(tolua_S,(void*)cobj,"CLWLimitInfoUpdate");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CLWLimitInfoUpdate:CLWLimitInfoUpdate has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CLWLimitInfoUpdate_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLWLimitInfoUpdate)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLWLimitInfoUpdate",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLWLimitInfoUpdate* self = (CLWLimitInfoUpdate*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLWLimitInfoUpdate(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLWLimitInfoUpdate");
    tolua_cclass(tolua_S,"CLWLimitInfoUpdate","CLWLimitInfoUpdate","CServerPacket",lua_mapserver_CLWLimitInfoUpdate_finalize);

    tolua_beginmodule(tolua_S,"CLWLimitInfoUpdate");
        tolua_function(tolua_S,"new",lua_mapserver_CLWLimitInfoUpdate_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CLWLimitInfoUpdate_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLWLimitInfoUpdate).name();
    g_luaType[typeName] = "CLWLimitInfoUpdate";
    g_typeCast["CLWLimitInfoUpdate"] = "CLWLimitInfoUpdate";
    return 1;
}

int lua_mapserver_CLWLimitAccountInfo_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CLWLimitAccountInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLWLimitAccountInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLWLimitAccountInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLWLimitAccountInfo_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLWLimitAccountInfo:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLWLimitAccountInfo_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLWLimitAccountInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CLWLimitAccountInfo* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CLWLimitAccountInfo();
        tolua_pushusertype(tolua_S,(void*)cobj,"CLWLimitAccountInfo");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CLWLimitAccountInfo:CLWLimitAccountInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CLWLimitAccountInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLWLimitAccountInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLWLimitAccountInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLWLimitAccountInfo* self = (CLWLimitAccountInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLWLimitAccountInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLWLimitAccountInfo");
    tolua_cclass(tolua_S,"CLWLimitAccountInfo","CLWLimitAccountInfo","CServerPacket",lua_mapserver_CLWLimitAccountInfo_finalize);

    tolua_beginmodule(tolua_S,"CLWLimitAccountInfo");
        tolua_function(tolua_S,"new",lua_mapserver_CLWLimitAccountInfo_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CLWLimitAccountInfo_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLWLimitAccountInfo).name();
    g_luaType[typeName] = "CLWLimitAccountInfo";
    g_typeCast["CLWLimitAccountInfo"] = "CLWLimitAccountInfo";
    return 1;
}

int lua_mapserver_CLWLimitChatInfo_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CLWLimitChatInfo* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLWLimitChatInfo",0,&tolua_err)) goto tolua_lerror;
    cobj = (CLWLimitChatInfo*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CLWLimitChatInfo_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLWLimitChatInfo:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CLWLimitChatInfo_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CLWLimitChatInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CLWLimitChatInfo* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CLWLimitChatInfo();
        tolua_pushusertype(tolua_S,(void*)cobj,"CLWLimitChatInfo");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CLWLimitChatInfo:CLWLimitChatInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CLWLimitChatInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLWLimitChatInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLWLimitChatInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CLWLimitChatInfo* self = (CLWLimitChatInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CLWLimitChatInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLWLimitChatInfo");
    tolua_cclass(tolua_S,"CLWLimitChatInfo","CLWLimitChatInfo","CServerPacket",lua_mapserver_CLWLimitChatInfo_finalize);

    tolua_beginmodule(tolua_S,"CLWLimitChatInfo");
        tolua_function(tolua_S,"new",lua_mapserver_CLWLimitChatInfo_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CLWLimitChatInfo_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CLWLimitChatInfo).name();
    g_luaType[typeName] = "CLWLimitChatInfo";
    g_typeCast["CLWLimitChatInfo"] = "CLWLimitChatInfo";
    return 1;
}

static int lua_mapserver_WLChargeRmb_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (WLChargeRmb)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"WLChargeRmb",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        WLChargeRmb* self = (WLChargeRmb*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_WLChargeRmb(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"WLChargeRmb");
    tolua_cclass(tolua_S,"WLChargeRmb","WLChargeRmb","CServerPacket",nullptr);

    tolua_beginmodule(tolua_S,"WLChargeRmb");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(WLChargeRmb).name();
    g_luaType[typeName] = "WLChargeRmb";
    g_typeCast["WLChargeRmb"] = "WLChargeRmb";
    return 1;
}

int lua_mapserver_CWLLimitInfoReq_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    CWLLimitInfoReq* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CWLLimitInfoReq",0,&tolua_err)) goto tolua_lerror;
    cobj = (CWLLimitInfoReq*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CWLLimitInfoReq_getPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getPackLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CWLLimitInfoReq:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CWLLimitInfoReq_getPackLen'.",&tolua_err);
	return 0;
}
int lua_mapserver_CWLLimitInfoReq_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CWLLimitInfoReq* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CWLLimitInfoReq();
        tolua_pushusertype(tolua_S,(void*)cobj,"CWLLimitInfoReq");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CWLLimitInfoReq:CWLLimitInfoReq has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CWLLimitInfoReq_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CWLLimitInfoReq)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CWLLimitInfoReq",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CWLLimitInfoReq* self = (CWLLimitInfoReq*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CWLLimitInfoReq(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CWLLimitInfoReq");
    tolua_cclass(tolua_S,"CWLLimitInfoReq","CWLLimitInfoReq","CServerPacket",lua_mapserver_CWLLimitInfoReq_finalize);

    tolua_beginmodule(tolua_S,"CWLLimitInfoReq");
        tolua_function(tolua_S,"new",lua_mapserver_CWLLimitInfoReq_constructor);
        tolua_function(tolua_S,"getPackLen",lua_mapserver_CWLLimitInfoReq_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CWLLimitInfoReq).name();
    g_luaType[typeName] = "CWLLimitInfoReq";
    g_typeCast["CWLLimitInfoReq"] = "CWLLimitInfoReq";
    return 1;
}

int lua_mapserver_CMapWorldServerHandler_sendUnloadDataRet(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandler_sendUnloadDataRet'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        EUnloadRoleType arg0;
        unsigned long long arg1;
        unsigned long long arg2;
        unsigned long long arg3;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMapWorldServerHandler:sendUnloadDataRet");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CMapWorldServerHandler:sendUnloadDataRet");

        ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CMapWorldServerHandler:sendUnloadDataRet");

        ok &= luaval_to_uint64(tolua_S, 5, (uint64*)&arg3, "CMapWorldServerHandler:sendUnloadDataRet");
        if(!ok)
            return 0;
        cobj->sendUnloadDataRet(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CMapWorldServerHandler:sendUnloadDataRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandler_sendUnloadDataRet'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandler_doBroadCast(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandler_doBroadCast'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        CBasePacket* arg0;
        unsigned int arg1;

        ok &= luaval_to_object<CBasePacket>(tolua_S, 2, "CBasePacket", &arg0, "CMapWorldServerHandler:doBroadCast");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CMapWorldServerHandler:doBroadCast");
        if(!ok)
            return 0;
        int ret = (int)cobj->doBroadCast(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandler:doBroadCast has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandler_doBroadCast'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandler_handleUnloadRoleData(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandler_handleUnloadRoleData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        WMUnloadRoleData* arg0;

        ok &= luaval_to_object<WMUnloadRoleData>(tolua_S, 2, "WMUnloadRoleData", &arg0, "CMapWorldServerHandler:handleUnloadRoleData");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleUnloadRoleData(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandler:handleUnloadRoleData has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandler_handleUnloadRoleData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandler_handleRecharge(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandler_handleRecharge'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        WMRecharge* arg0;

        ok &= luaval_to_object<WMRecharge>(tolua_S, 2, "WMRecharge", &arg0, "CMapWorldServerHandler:handleRecharge");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleRecharge(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandler:handleRecharge has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandler_handleRecharge'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandler_handleUpdateUserata(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandler_handleUpdateUserata'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        WMUpdateUserData* arg0;

        ok &= luaval_to_object<WMUpdateUserData>(tolua_S, 2, "WMUpdateUserData", &arg0, "CMapWorldServerHandler:handleUpdateUserata");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleUpdateUserata(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandler:handleUpdateUserata has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandler_handleUpdateUserata'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandler_handleLoadRoleData(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandler_handleLoadRoleData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        WMLoadRoleData* arg0;

        ok &= luaval_to_object<WMLoadRoleData>(tolua_S, 2, "WMLoadRoleData", &arg0, "CMapWorldServerHandler:handleLoadRoleData");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleLoadRoleData(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandler:handleLoadRoleData has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandler_handleLoadRoleData'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandler_sendRoleQuit(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandler_sendRoleQuit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        unsigned long long arg0;
        unsigned int arg1;
        unsigned long long arg2;
        unsigned long long arg3;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMapWorldServerHandler:sendRoleQuit");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CMapWorldServerHandler:sendRoleQuit");

        ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CMapWorldServerHandler:sendRoleQuit");

        ok &= luaval_to_uint64(tolua_S, 5, (uint64*)&arg3, "CMapWorldServerHandler:sendRoleQuit");
        if(!ok)
            return 0;
        cobj->sendRoleQuit(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CMapWorldServerHandler:sendRoleQuit has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandler_sendRoleQuit'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandler_handleLimitChatInfo(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandler_handleLimitChatInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CWMLimitChatInfo* arg0;

        ok &= luaval_to_object<CWMLimitChatInfo>(tolua_S, 2, "CWMLimitChatInfo", &arg0, "CMapWorldServerHandler:handleLimitChatInfo");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleLimitChatInfo(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandler:handleLimitChatInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandler_handleLimitChatInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandler_handleLimitAccountInfo(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandler_handleLimitAccountInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CWMLimitAccountInfo* arg0;

        ok &= luaval_to_object<CWMLimitAccountInfo>(tolua_S, 2, "CWMLimitAccountInfo", &arg0, "CMapWorldServerHandler:handleLimitAccountInfo");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleLimitAccountInfo(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandler:handleLimitAccountInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandler_handleLimitAccountInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandler_doTrans(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandler_doTrans'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        CBasePacket* arg0;
        unsigned int arg1;
        unsigned int arg2;

        ok &= luaval_to_object<CBasePacket>(tolua_S, 2, "CBasePacket", &arg0, "CMapWorldServerHandler:doTrans");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CMapWorldServerHandler:doTrans");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CMapWorldServerHandler:doTrans");
        if(!ok)
            return 0;
        int ret = (int)cobj->doTrans(arg0, arg1, arg2);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandler:doTrans has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandler_doTrans'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandler_handleLimitInfo(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (CMapWorldServerHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CMapWorldServerHandler_handleLimitInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CLWLimitInfoUpdate* arg0;

        ok &= luaval_to_object<CLWLimitInfoUpdate>(tolua_S, 2, "CLWLimitInfoUpdate", &arg0, "CMapWorldServerHandler:handleLimitInfo");
        if(!ok)
            return 0;
        int ret = (int)cobj->handleLimitInfo(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMapWorldServerHandler:handleLimitInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandler_handleLimitInfo'.",&tolua_err);
	return 0;
}
int lua_mapserver_CMapWorldServerHandler_Setup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMapWorldServerHandler::Setup();
        return 0;
    }
    gxError("CMapWorldServerHandler:Setup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandler_Setup'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMapWorldServerHandler_Unsetup(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMapWorldServerHandler::Unsetup();
        return 0;
    }
    gxError("CMapWorldServerHandler:Unsetup has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMapWorldServerHandler_Unsetup'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMapWorldServerHandler_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CMapWorldServerHandler* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CMapWorldServerHandler();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMapWorldServerHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMapWorldServerHandler:CMapWorldServerHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CMapWorldServerHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMapWorldServerHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMapWorldServerHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMapWorldServerHandler* self = (CMapWorldServerHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMapWorldServerHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMapWorldServerHandler");
    tolua_cclass(tolua_S,"CMapWorldServerHandler","CMapWorldServerHandler","CMapWorldServerHandlerBase",lua_mapserver_CMapWorldServerHandler_finalize);

    tolua_beginmodule(tolua_S,"CMapWorldServerHandler");
        tolua_function(tolua_S,"new",lua_mapserver_CMapWorldServerHandler_constructor);
        tolua_function(tolua_S,"sendUnloadDataRet",lua_mapserver_CMapWorldServerHandler_sendUnloadDataRet);
        tolua_function(tolua_S,"doBroadCast",lua_mapserver_CMapWorldServerHandler_doBroadCast);
        tolua_function(tolua_S,"handleUnloadRoleData",lua_mapserver_CMapWorldServerHandler_handleUnloadRoleData);
        tolua_function(tolua_S,"handleRecharge",lua_mapserver_CMapWorldServerHandler_handleRecharge);
        tolua_function(tolua_S,"handleUpdateUserata",lua_mapserver_CMapWorldServerHandler_handleUpdateUserata);
        tolua_function(tolua_S,"handleLoadRoleData",lua_mapserver_CMapWorldServerHandler_handleLoadRoleData);
        tolua_function(tolua_S,"sendRoleQuit",lua_mapserver_CMapWorldServerHandler_sendRoleQuit);
        tolua_function(tolua_S,"handleLimitChatInfo",lua_mapserver_CMapWorldServerHandler_handleLimitChatInfo);
        tolua_function(tolua_S,"handleLimitAccountInfo",lua_mapserver_CMapWorldServerHandler_handleLimitAccountInfo);
        tolua_function(tolua_S,"doTrans",lua_mapserver_CMapWorldServerHandler_doTrans);
        tolua_function(tolua_S,"handleLimitInfo",lua_mapserver_CMapWorldServerHandler_handleLimitInfo);
        tolua_function(tolua_S,"Setup", lua_mapserver_CMapWorldServerHandler_Setup);
        tolua_function(tolua_S,"Unsetup", lua_mapserver_CMapWorldServerHandler_Unsetup);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMapWorldServerHandler).name();
    g_luaType[typeName] = "CMapWorldServerHandler";
    g_typeCast["CMapWorldServerHandler"] = "CMapWorldServerHandler";
    return 1;
}

int lua_mapserver_CNpcConfigTbl_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CNpcConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNpcConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNpcConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNpcConfigTbl_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CNpcConfigTbl:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNpcConfigTbl_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CNpcConfigTbl_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CNpcConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNpcConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNpcConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNpcConfigTbl_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CNpcConfigTbl:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNpcConfigTbl_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CNpcConfigTbl_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CNpcConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNpcConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNpcConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNpcConfigTbl_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CNpcConfigTbl:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CNpcConfigTbl:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNpcConfigTbl_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CNpcConfigTbl_toString(lua_State* tolua_S)
{
    int argc = 0;
    CNpcConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNpcConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNpcConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNpcConfigTbl_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CNpcConfigTbl:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNpcConfigTbl_toString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CNpcConfigTbl_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CNpcConfigTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNpcConfigTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNpcConfigTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNpcConfigTbl_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CNpcConfigTbl:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNpcConfigTbl_getKey'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CNpcConfigTbl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNpcConfigTbl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNpcConfigTbl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CNpcConfigTbl* self = (CNpcConfigTbl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CNpcConfigTbl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNpcConfigTbl");
    tolua_cclass(tolua_S,"CNpcConfigTbl","CNpcConfigTbl","CConfigTbl",nullptr);

    tolua_beginmodule(tolua_S,"CNpcConfigTbl");
        tolua_function(tolua_S,"isKey",lua_mapserver_CNpcConfigTbl_isKey);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CNpcConfigTbl_keyToString);
        tolua_function(tolua_S,"setKey",lua_mapserver_CNpcConfigTbl_setKey);
        tolua_function(tolua_S,"toString",lua_mapserver_CNpcConfigTbl_toString);
        tolua_function(tolua_S,"getKey",lua_mapserver_CNpcConfigTbl_getKey);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CNpcConfigTbl).name();
    g_luaType[typeName] = "CNpcConfigTbl";
    g_typeCast["CNpcConfigTbl"] = "CNpcConfigTbl";
    return 1;
}

int lua_mapserver_CNpcTblLoader_findByKey(lua_State* tolua_S)
{
    int argc = 0;
    CNpcTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNpcTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNpcTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNpcTblLoader_findByKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CNpcTblLoader:findByKey");
        if(!ok)
            return 0;
        CNpcConfigTbl* ret = cobj->findByKey(arg0);
        object_to_luaval<CNpcConfigTbl>(tolua_S, "CNpcConfigTbl",(CNpcConfigTbl*)ret);
        return 1;
    }

    gxError("CNpcTblLoader:findByKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNpcTblLoader_findByKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CNpcTblLoader_readRow(lua_State* tolua_S)
{
    int argc = 0;
    CNpcTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNpcTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CNpcTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CNpcTblLoader_readRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        TiXmlElement* arg0;
        int arg1;
        CNpcConfigTbl* arg2;

        ok &= luaval_to_object<TiXmlElement>(tolua_S, 2, "TiXmlElement", &arg0, "CNpcTblLoader:readRow");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CNpcTblLoader:readRow");

        ok &= luaval_to_object<CNpcConfigTbl>(tolua_S, 4, "CNpcConfigTbl", &arg2, "CNpcTblLoader:readRow");
        if(!ok)
            return 0;
        bool ret = cobj->readRow(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CNpcTblLoader:readRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNpcTblLoader_readRow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CNpcTblLoader_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CNpcTblLoader",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CNpcTblLoader* ret = CNpcTblLoader::GetPtr();
        object_to_luaval<CNpcTblLoader>(tolua_S, "CNpcTblLoader",(CNpcTblLoader*)ret);
        return 1;
    }
    gxError("CNpcTblLoader:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CNpcTblLoader_GetPtr'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CNpcTblLoader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNpcTblLoader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNpcTblLoader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CNpcTblLoader* self = (CNpcTblLoader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CNpcTblLoader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNpcTblLoader");
    tolua_cclass(tolua_S,"CNpcTblLoader","CNpcTblLoader","CConfigLoader<CNpcTblLoader, CNpcConfigTbl>",nullptr);

    tolua_beginmodule(tolua_S,"CNpcTblLoader");
        tolua_function(tolua_S,"findByKey",lua_mapserver_CNpcTblLoader_findByKey);
        tolua_function(tolua_S,"readRow",lua_mapserver_CNpcTblLoader_readRow);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CNpcTblLoader_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CNpcTblLoader).name();
    g_luaType[typeName] = "CNpcTblLoader";
    g_typeCast["CNpcTblLoader"] = "CNpcTblLoader";
    return 1;
}

static int lua_mapserver_RandDropComInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (RandDropComInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"RandDropComInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        RandDropComInfo* self = (RandDropComInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_RandDropComInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"RandDropComInfo");
    tolua_cclass(tolua_S,"RandDropComInfo","RandDropComInfo","",nullptr);

    tolua_beginmodule(tolua_S,"RandDropComInfo");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(RandDropComInfo).name();
    g_luaType[typeName] = "RandDropComInfo";
    g_typeCast["RandDropComInfo"] = "RandDropComInfo";
    return 1;
}

static int lua_mapserver_RandDropConfigInfo_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (RandDropConfigInfo)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"RandDropConfigInfo",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        RandDropConfigInfo* self = (RandDropConfigInfo*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_RandDropConfigInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"RandDropConfigInfo");
    tolua_cclass(tolua_S,"RandDropConfigInfo","RandDropConfigInfo","",nullptr);

    tolua_beginmodule(tolua_S,"RandDropConfigInfo");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(RandDropConfigInfo).name();
    g_luaType[typeName] = "RandDropConfigInfo";
    g_typeCast["RandDropConfigInfo"] = "RandDropConfigInfo";
    return 1;
}

static int lua_mapserver_RandDropComInfoEx_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (RandDropComInfoEx)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"RandDropComInfoEx",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        RandDropComInfoEx* self = (RandDropComInfoEx*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_RandDropComInfoEx(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"RandDropComInfoEx");
    tolua_cclass(tolua_S,"RandDropComInfoEx","RandDropComInfoEx","",nullptr);

    tolua_beginmodule(tolua_S,"RandDropComInfoEx");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(RandDropComInfoEx).name();
    g_luaType[typeName] = "RandDropComInfoEx";
    g_typeCast["RandDropComInfoEx"] = "RandDropComInfoEx";
    return 1;
}

static int lua_mapserver_RandDropConfigInfoEx_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (RandDropConfigInfoEx)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"RandDropConfigInfoEx",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        RandDropConfigInfoEx* self = (RandDropConfigInfoEx*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_RandDropConfigInfoEx(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"RandDropConfigInfoEx");
    tolua_cclass(tolua_S,"RandDropConfigInfoEx","RandDropConfigInfoEx","",nullptr);

    tolua_beginmodule(tolua_S,"RandDropConfigInfoEx");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(RandDropConfigInfoEx).name();
    g_luaType[typeName] = "RandDropConfigInfoEx";
    g_typeCast["RandDropConfigInfoEx"] = "RandDropConfigInfoEx";
    return 1;
}

int lua_mapserver_CRandDropTbl_isKey(lua_State* tolua_S)
{
    int argc = 0;
    CRandDropTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandDropTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandDropTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandDropTbl_isKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isKey();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRandDropTbl:isKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandDropTbl_isKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandDropTbl_keyToString(lua_State* tolua_S)
{
    int argc = 0;
    CRandDropTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandDropTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandDropTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandDropTbl_keyToString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->keyToString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CRandDropTbl:keyToString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandDropTbl_keyToString'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandDropTbl_getKey(lua_State* tolua_S)
{
    int argc = 0;
    CRandDropTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandDropTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandDropTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandDropTbl_getKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getKey();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CRandDropTbl:getKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandDropTbl_getKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandDropTbl_setKey(lua_State* tolua_S)
{
    int argc = 0;
    CRandDropTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandDropTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandDropTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandDropTbl_setKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRandDropTbl:setKey");
        if(!ok)
            return 0;
        cobj->setKey(arg0);
        return 0;
    }

    gxError("CRandDropTbl:setKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandDropTbl_setKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandDropTbl_toString(lua_State* tolua_S)
{
    int argc = 0;
    CRandDropTbl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandDropTbl",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandDropTbl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandDropTbl_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CRandDropTbl:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandDropTbl_toString'.",&tolua_err);
	return 0;
}
static int lua_mapserver_CRandDropTbl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CRandDropTbl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CRandDropTbl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CRandDropTbl* self = (CRandDropTbl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CRandDropTbl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CRandDropTbl");
    tolua_cclass(tolua_S,"CRandDropTbl","CRandDropTbl","CConfigTbl",nullptr);

    tolua_beginmodule(tolua_S,"CRandDropTbl");
        tolua_function(tolua_S,"isKey",lua_mapserver_CRandDropTbl_isKey);
        tolua_function(tolua_S,"keyToString",lua_mapserver_CRandDropTbl_keyToString);
        tolua_function(tolua_S,"getKey",lua_mapserver_CRandDropTbl_getKey);
        tolua_function(tolua_S,"setKey",lua_mapserver_CRandDropTbl_setKey);
        tolua_function(tolua_S,"toString",lua_mapserver_CRandDropTbl_toString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CRandDropTbl).name();
    g_luaType[typeName] = "CRandDropTbl";
    g_typeCast["CRandDropTbl"] = "CRandDropTbl";
    return 1;
}

int lua_mapserver_CRandDropTblLoader_HandleConvert(lua_State* tolua_S)
{
    int argc = 0;
    CRandDropTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandDropTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandDropTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandDropTblLoader_HandleConvert'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        std::string arg0;
        int arg1;
        const CRandDropTbl* arg2;
        const TiXmlElement* arg3;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CRandDropTblLoader:HandleConvert");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRandDropTblLoader:HandleConvert");

        ok &= luaval_to_object<const CRandDropTbl>(tolua_S, 4, "CRandDropTbl", &arg2, "CRandDropTblLoader:HandleConvert");

        ok &= luaval_to_object<const TiXmlElement>(tolua_S, 5, "TiXmlElement", &arg3, "CRandDropTblLoader:HandleConvert");
        if(!ok)
            return 0;
        bool ret = cobj->HandleConvert(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRandDropTblLoader:HandleConvert has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandDropTblLoader_HandleConvert'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandDropTblLoader_findByKey(lua_State* tolua_S)
{
    int argc = 0;
    CRandDropTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandDropTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandDropTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandDropTblLoader_findByKey'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CRandDropTblLoader:findByKey");
        if(!ok)
            return 0;
        CRandDropTbl* ret = cobj->findByKey(arg0);
        object_to_luaval<CRandDropTbl>(tolua_S, "CRandDropTbl",(CRandDropTbl*)ret);
        return 1;
    }

    gxError("CRandDropTblLoader:findByKey has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandDropTblLoader_findByKey'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandDropTblLoader_getRow(lua_State* tolua_S)
{
    int argc = 0;
    CRandDropTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandDropTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandDropTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandDropTblLoader_getRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CRandDropTbl* ret = cobj->getRow();
        object_to_luaval<CRandDropTbl>(tolua_S, "CRandDropTbl",(CRandDropTbl*)ret);
        return 1;
    }

    gxError("CRandDropTblLoader:getRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandDropTblLoader_getRow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandDropTblLoader_readRow(lua_State* tolua_S)
{
    int argc = 0;
    CRandDropTblLoader* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CRandDropTblLoader",0,&tolua_err)) goto tolua_lerror;
    cobj = (CRandDropTblLoader*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CRandDropTblLoader_readRow'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        TiXmlElement* arg0;
        int arg1;
        CRandDropTbl* arg2;

        ok &= luaval_to_object<TiXmlElement>(tolua_S, 2, "TiXmlElement", &arg0, "CRandDropTblLoader:readRow");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CRandDropTblLoader:readRow");

        ok &= luaval_to_object<CRandDropTbl>(tolua_S, 4, "CRandDropTbl", &arg2, "CRandDropTblLoader:readRow");
        if(!ok)
            return 0;
        bool ret = cobj->readRow(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CRandDropTblLoader:readRow has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandDropTblLoader_readRow'.",&tolua_err);
	return 0;
}
int lua_mapserver_CRandDropTblLoader_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CRandDropTblLoader",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CRandDropTblLoader* ret = CRandDropTblLoader::GetPtr();
        object_to_luaval<CRandDropTblLoader>(tolua_S, "CRandDropTblLoader",(CRandDropTblLoader*)ret);
        return 1;
    }
    gxError("CRandDropTblLoader:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CRandDropTblLoader_GetPtr'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CRandDropTblLoader_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CRandDropTblLoader)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CRandDropTblLoader",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CRandDropTblLoader* self = (CRandDropTblLoader*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CRandDropTblLoader(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CRandDropTblLoader");
    tolua_cclass(tolua_S,"CRandDropTblLoader","CRandDropTblLoader","CConfigLoader<CRandDropTblLoader, CRandDropTbl>",nullptr);

    tolua_beginmodule(tolua_S,"CRandDropTblLoader");
        tolua_function(tolua_S,"HandleConvert",lua_mapserver_CRandDropTblLoader_HandleConvert);
        tolua_function(tolua_S,"findByKey",lua_mapserver_CRandDropTblLoader_findByKey);
        tolua_function(tolua_S,"getRow",lua_mapserver_CRandDropTblLoader_getRow);
        tolua_function(tolua_S,"readRow",lua_mapserver_CRandDropTblLoader_readRow);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CRandDropTblLoader_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CRandDropTblLoader).name();
    g_luaType[typeName] = "CRandDropTblLoader";
    g_typeCast["CRandDropTblLoader"] = "CRandDropTblLoader";
    return 1;
}

int lua_mapserver_CranddropItemMgr_randItemByDropId(lua_State* tolua_S)
{
    int argc = 0;
    CranddropItemMgr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CranddropItemMgr",0,&tolua_err)) goto tolua_lerror;
    cobj = (CranddropItemMgr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CranddropItemMgr_randItemByDropId'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        std::vector<ItemReward, std::allocator<ItemReward> >* arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CranddropItemMgr:randItemByDropId");

        ok &= luaval_to_object<std::vector<ItemReward, std::allocator<ItemReward> >>(tolua_S, 3, "std::vector<ItemReward, std::allocator<ItemReward> >*", &arg1, "CranddropItemMgr:randItemByDropId");
        if(!ok)
            return 0;
        cobj->randItemByDropId(arg0, arg1);
        return 0;
    }

    gxError("CranddropItemMgr:randItemByDropId has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CranddropItemMgr_randItemByDropId'.",&tolua_err);
	return 0;
}
int lua_mapserver_CranddropItemMgr_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CranddropItemMgr",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CranddropItemMgr* ret = CranddropItemMgr::GetPtr();
        object_to_luaval<CranddropItemMgr>(tolua_S, "CranddropItemMgr",(CranddropItemMgr*)ret);
        return 1;
    }
    gxError("CranddropItemMgr:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CranddropItemMgr_GetPtr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CranddropItemMgr_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CranddropItemMgr* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CranddropItemMgr();
        tolua_pushusertype(tolua_S,(void*)cobj,"CranddropItemMgr");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CranddropItemMgr:CranddropItemMgr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CranddropItemMgr_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CranddropItemMgr)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CranddropItemMgr",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CranddropItemMgr* self = (CranddropItemMgr*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CranddropItemMgr(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CranddropItemMgr");
    tolua_cclass(tolua_S,"CranddropItemMgr","CranddropItemMgr","CManualSingleton<CranddropItemMgr>",lua_mapserver_CranddropItemMgr_finalize);

    tolua_beginmodule(tolua_S,"CranddropItemMgr");
        tolua_function(tolua_S,"new",lua_mapserver_CranddropItemMgr_constructor);
        tolua_function(tolua_S,"randItemByDropId",lua_mapserver_CranddropItemMgr_randItemByDropId);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CranddropItemMgr_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CranddropItemMgr).name();
    g_luaType[typeName] = "CranddropItemMgr";
    g_typeCast["CranddropItemMgr"] = "CranddropItemMgr";
    return 1;
}

int lua_mapserver_CSceneManagerBase_getNext(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_getNext'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapSceneBase* ret = cobj->getNext();
        object_to_luaval<CMapSceneBase>(tolua_S, "CMapSceneBase",(CMapSceneBase*)ret);
        return 1;
    }

    gxError("CSceneManagerBase:getNext has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_getNext'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_addNewScene(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_addNewScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned long long arg0;
        unsigned char arg1;
        bool arg2;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSceneManagerBase:addNewScene");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CSceneManagerBase:addNewScene");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CSceneManagerBase:addNewScene");
        if(!ok)
            return 0;
        CMapSceneBase* ret = cobj->addNewScene(arg0, arg1, arg2);
        object_to_luaval<CMapSceneBase>(tolua_S, "CMapSceneBase",(CMapSceneBase*)ret);
        return 1;
    }

    gxError("CSceneManagerBase:addNewScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_addNewScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_getBegin(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_getBegin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CMapSceneBase* ret = cobj->getBegin();
        object_to_luaval<CMapSceneBase>(tolua_S, "CMapSceneBase",(CMapSceneBase*)ret);
        return 1;
    }

    gxError("CSceneManagerBase:getBegin has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_getBegin'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_getDynamicMapNum(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_getDynamicMapNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getDynamicMapNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSceneManagerBase:getDynamicMapNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_getDynamicMapNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_openDynamicScene(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_openDynamicScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        unsigned short arg0;
        ESceneType arg1;
        unsigned int arg2;
        bool arg3;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CSceneManagerBase:openDynamicScene");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSceneManagerBase:openDynamicScene");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CSceneManagerBase:openDynamicScene");

        ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CSceneManagerBase:openDynamicScene");
        if(!ok)
            return 0;
        CMapSceneBase* ret = cobj->openDynamicScene(arg0, arg1, arg2, arg3);
        object_to_luaval<CMapSceneBase>(tolua_S, "CMapSceneBase",(CMapSceneBase*)ret);
        return 1;
    }

    gxError("CSceneManagerBase:openDynamicScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_openDynamicScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_sendOpenDynamicToWorld(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_sendOpenDynamicToWorld'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapSceneBase* arg0;

        ok &= luaval_to_object<CMapSceneBase>(tolua_S, 2, "CMapSceneBase", &arg0, "CSceneManagerBase:sendOpenDynamicToWorld");
        if(!ok)
            return 0;
        cobj->sendOpenDynamicToWorld(arg0);
        return 0;
    }

    gxError("CSceneManagerBase:sendOpenDynamicToWorld has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_sendOpenDynamicToWorld'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_findScene(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_findScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSceneManagerBase:findScene");
        if(!ok)
            return 0;
        CMapSceneBase* ret = cobj->findScene(arg0);
        object_to_luaval<CMapSceneBase>(tolua_S, "CMapSceneBase",(CMapSceneBase*)ret);
        return 1;
    }

    gxError("CSceneManagerBase:findScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_findScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_genSceneID(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_genSceneID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned short arg0;
        unsigned char arg1;
        unsigned short arg2;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CSceneManagerBase:genSceneID");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CSceneManagerBase:genSceneID");

        ok &= luaval_to_uint16(tolua_S, 4, (uint16*)&arg2, "CSceneManagerBase:genSceneID");
        if(!ok)
            return 0;
        unsigned long long ret = cobj->genSceneID(arg0, arg1, arg2);
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CSceneManagerBase:genSceneID has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_genSceneID'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_update(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSceneManagerBase:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CSceneManagerBase:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_update'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_isSceneExist(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_isSceneExist'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSceneManagerBase:isSceneExist");
        if(!ok)
            return 0;
        bool ret = cobj->isSceneExist(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSceneManagerBase:isSceneExist has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_isSceneExist'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_closeDynamicScene(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_closeDynamicScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned long long arg0;
        bool arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSceneManagerBase:closeDynamicScene");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CSceneManagerBase:closeDynamicScene");
        if(!ok)
            return 0;
        cobj->closeDynamicScene(arg0, arg1);
        return 0;
    }

    gxError("CSceneManagerBase:closeDynamicScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_closeDynamicScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_statDynamicSceneNum(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_statDynamicSceneNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->statDynamicSceneNum();
        return 0;
    }

    gxError("CSceneManagerBase:statDynamicSceneNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_statDynamicSceneNum'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_getLeastScene(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_getLeastScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CSceneManagerBase:getLeastScene");
        if(!ok)
            return 0;
        CMapSceneBase* ret = cobj->getLeastScene(arg0);
        object_to_luaval<CMapSceneBase>(tolua_S, "CMapSceneBase",(CMapSceneBase*)ret);
        return 1;
    }

    gxError("CSceneManagerBase:getLeastScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_getLeastScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_sendCloseDynamicToWorld(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_sendCloseDynamicToWorld'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSceneManagerBase:sendCloseDynamicToWorld");
        if(!ok)
            return 0;
        cobj->sendCloseDynamicToWorld(arg0);
        return 0;
    }

    gxError("CSceneManagerBase:sendCloseDynamicToWorld has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_sendCloseDynamicToWorld'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_delScene(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_delScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSceneManagerBase:delScene");
        if(!ok)
            return 0;
        cobj->delScene(arg0);
        return 0;
    }

    gxError("CSceneManagerBase:delScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_delScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_initAllMap(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManagerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManagerBase_initAllMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->initAllMap();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSceneManagerBase:initAllMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManagerBase_initAllMap'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManagerBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManagerBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CSceneManagerBase();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSceneManagerBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSceneManagerBase:CSceneManagerBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CSceneManagerBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSceneManagerBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSceneManagerBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CSceneManagerBase* self = (CSceneManagerBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CSceneManagerBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSceneManagerBase");
    tolua_cclass(tolua_S,"CSceneManagerBase","CSceneManagerBase","CHashMultiIndex<CMapSceneBase, false, 18446744073709551615>",lua_mapserver_CSceneManagerBase_finalize);

    tolua_beginmodule(tolua_S,"CSceneManagerBase");
        tolua_function(tolua_S,"new",lua_mapserver_CSceneManagerBase_constructor);
        tolua_function(tolua_S,"getNext",lua_mapserver_CSceneManagerBase_getNext);
        tolua_function(tolua_S,"addNewScene",lua_mapserver_CSceneManagerBase_addNewScene);
        tolua_function(tolua_S,"getBegin",lua_mapserver_CSceneManagerBase_getBegin);
        tolua_function(tolua_S,"getDynamicMapNum",lua_mapserver_CSceneManagerBase_getDynamicMapNum);
        tolua_function(tolua_S,"openDynamicScene",lua_mapserver_CSceneManagerBase_openDynamicScene);
        tolua_function(tolua_S,"sendOpenDynamicToWorld",lua_mapserver_CSceneManagerBase_sendOpenDynamicToWorld);
        tolua_function(tolua_S,"findScene",lua_mapserver_CSceneManagerBase_findScene);
        tolua_function(tolua_S,"genSceneID",lua_mapserver_CSceneManagerBase_genSceneID);
        tolua_function(tolua_S,"update",lua_mapserver_CSceneManagerBase_update);
        tolua_function(tolua_S,"isSceneExist",lua_mapserver_CSceneManagerBase_isSceneExist);
        tolua_function(tolua_S,"closeDynamicScene",lua_mapserver_CSceneManagerBase_closeDynamicScene);
        tolua_function(tolua_S,"statDynamicSceneNum",lua_mapserver_CSceneManagerBase_statDynamicSceneNum);
        tolua_function(tolua_S,"getLeastScene",lua_mapserver_CSceneManagerBase_getLeastScene);
        tolua_function(tolua_S,"sendCloseDynamicToWorld",lua_mapserver_CSceneManagerBase_sendCloseDynamicToWorld);
        tolua_function(tolua_S,"delScene",lua_mapserver_CSceneManagerBase_delScene);
        tolua_function(tolua_S,"initAllMap",lua_mapserver_CSceneManagerBase_initAllMap);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CSceneManagerBase).name();
    g_luaType[typeName] = "CSceneManagerBase";
    g_typeCast["CSceneManagerBase"] = "CSceneManagerBase";
    return 1;
}

int lua_mapserver_CSceneManager_addNewScene(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManager_addNewScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned long long arg0;
        unsigned char arg1;
        bool arg2;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSceneManager:addNewScene");

        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CSceneManager:addNewScene");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CSceneManager:addNewScene");
        if(!ok)
            return 0;
        CMapSceneBase* ret = cobj->addNewScene(arg0, arg1, arg2);
        object_to_luaval<CMapSceneBase>(tolua_S, "CMapSceneBase",(CMapSceneBase*)ret);
        return 1;
    }

    gxError("CSceneManager:addNewScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManager_addNewScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManager_delScene(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManager_delScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSceneManager:delScene");
        if(!ok)
            return 0;
        cobj->delScene(arg0);
        return 0;
    }

    gxError("CSceneManager:delScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManager_delScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManager_init(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManager_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CMapServerConfig* arg0;

        ok &= luaval_to_object<CMapServerConfig>(tolua_S, 2, "CMapServerConfig", &arg0, "CSceneManager:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSceneManager:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManager_init'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManager_findScene(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSceneManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (CSceneManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_mapserver_CSceneManager_findScene'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSceneManager:findScene");
        if(!ok)
            return 0;
        CMapScene* ret = cobj->findScene(arg0);
        object_to_luaval<CMapScene>(tolua_S, "CMapScene",(CMapScene*)ret);
        return 1;
    }

    gxError("CSceneManager:findScene has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManager_findScene'.",&tolua_err);
	return 0;
}
int lua_mapserver_CSceneManager_GetPtr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CSceneManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CSceneManager* ret = CSceneManager::GetPtr();
        object_to_luaval<CSceneManager>(tolua_S, "CSceneManager",(CSceneManager*)ret);
        return 1;
    }
    gxError("CSceneManager:GetPtr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CSceneManager_GetPtr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CSceneManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    CSceneManager* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new CSceneManager();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSceneManager");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSceneManager:CSceneManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_mapserver_CSceneManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSceneManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSceneManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CSceneManager* self = (CSceneManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CSceneManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSceneManager");
    tolua_cclass(tolua_S,"CSceneManager","CSceneManager","CSceneManagerBase",lua_mapserver_CSceneManager_finalize);

    tolua_beginmodule(tolua_S,"CSceneManager");
        tolua_function(tolua_S,"new",lua_mapserver_CSceneManager_constructor);
        tolua_function(tolua_S,"addNewScene",lua_mapserver_CSceneManager_addNewScene);
        tolua_function(tolua_S,"delScene",lua_mapserver_CSceneManager_delScene);
        tolua_function(tolua_S,"init",lua_mapserver_CSceneManager_init);
        tolua_function(tolua_S,"findScene",lua_mapserver_CSceneManager_findScene);
        tolua_function(tolua_S,"GetPtr", lua_mapserver_CSceneManager_GetPtr);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CSceneManager).name();
    g_luaType[typeName] = "CSceneManager";
    g_typeCast["CSceneManager"] = "CSceneManager";
    return 1;
}

int lua_mapserver_CMServerHelper_LuaGetRoleByName(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string arg0;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMServerHelper:LuaGetRoleByName");
        if(!ok)
            return 0;
        CRole* ret = CMServerHelper::LuaGetRoleByName(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    gxError("CMServerHelper:LuaGetRoleByName has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaGetRoleByName'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaWorldChatBroad(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        std::string arg0;
        std::string arg1;
        unsigned char arg2;
        std::string arg3;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMServerHelper:LuaWorldChatBroad");
        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CMServerHelper:LuaWorldChatBroad");
        ok &= luaval_to_uint8(tolua_S, 4,(uint8*)&arg2, "CMServerHelper:LuaWorldChatBroad");
        ok &= luaval_to_std_string(tolua_S, 5,&arg3, "CMServerHelper:LuaWorldChatBroad");
        if(!ok)
            return 0;
        CMServerHelper::LuaWorldChatBroad(arg0, arg1, arg2, arg3);
        return 0;
    }
    gxError("CMServerHelper:LuaWorldChatBroad has wrong number of arguments: {0}, was expecting {1}\n ", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaWorldChatBroad'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaGetAnnouncementEventType(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned short arg0;
        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMServerHelper:LuaGetAnnouncementEventType");
        if(!ok)
            return 0;
        int ret = CMServerHelper::LuaGetAnnouncementEventType(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CMServerHelper:LuaGetAnnouncementEventType has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaGetAnnouncementEventType'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaKickRole(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string arg0;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMServerHelper:LuaKickRole");
        if(!ok)
            return 0;
        CMServerHelper::LuaKickRole(arg0);
        return 0;
    }
    gxError("CMServerHelper:LuaKickRole has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaKickRole'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaToNum64(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string arg0;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMServerHelper:LuaToNum64");
        if(!ok)
            return 0;
        uint64 ret = CMServerHelper::LuaToNum64(arg0);
        lua_tinker::push(tolua_S,ret);
        return 1;
    }
    gxError("CMServerHelper:LuaToNum64 has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaToNum64'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaGetRoleMgr(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CRoleManager* ret = CMServerHelper::LuaGetRoleMgr();
        object_to_luaval<CRoleManager>(tolua_S, "CRoleManager",(CRoleManager*)ret);
        return 1;
    }
    gxError("CMServerHelper:LuaGetRoleMgr has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaGetRoleMgr'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaAllAnnouncement(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        std::string arg0;
        int arg1;
        int arg2;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMServerHelper:LuaAllAnnouncement");
        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMServerHelper:LuaAllAnnouncement");
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CMServerHelper:LuaAllAnnouncement");
        if(!ok)
            return 0;
        CMServerHelper::LuaAllAnnouncement(arg0, arg1, arg2);
        return 0;
    }
    gxError("CMServerHelper:LuaAllAnnouncement has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaAllAnnouncement'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaGetAllRole(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        std::vector<CRole *, std::allocator<CRole *> > ret = CMServerHelper::LuaGetAllRole();
        vector_to_luaval(tolua_S, "std::vector<CRole *, std::allocator<CRole *> >", ret);
        return 1;
    }
    gxError("CMServerHelper:LuaGetAllRole has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaGetAllRole'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaGetSpRole(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned long long arg0;
        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMServerHelper:LuaGetSpRole");
        if(!ok)
            return 0;
        lua_tinker::s_object ret = CMServerHelper::LuaGetSpRole(arg0);
        lua_tinker::push(tolua_S,ret);
        return 1;
    }
    gxError("CMServerHelper:LuaGetSpRole has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaGetSpRole'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_Md5String(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string arg0;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMServerHelper:Md5String");
        if(!ok)
            return 0;
        std::string ret = CMServerHelper::Md5String(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }
    gxError("CMServerHelper:Md5String has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_Md5String'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaGetAnnouncementSysType(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned short arg0;
        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMServerHelper:LuaGetAnnouncementSysType");
        if(!ok)
            return 0;
        char ret = CMServerHelper::LuaGetAnnouncementSysType(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CMServerHelper:LuaGetAnnouncementSysType has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaGetAnnouncementSysType'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaGetServerData(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMapServerData* ret = CMServerHelper::LuaGetServerData();
        object_to_luaval<CMapServerData>(tolua_S, "CMapServerData",(CMapServerData*)ret);
        return 1;
    }
    gxError("CMServerHelper:LuaGetServerData has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaGetServerData'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaCrc32(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string arg0;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMServerHelper:LuaCrc32");
        if(!ok)
            return 0;
        unsigned int ret = CMServerHelper::LuaCrc32(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CMServerHelper:LuaCrc32 has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaCrc32'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaSystemChatBroad(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        std::string arg0;
        unsigned char arg1;
        int arg2;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMServerHelper:LuaSystemChatBroad");
        ok &= luaval_to_uint8(tolua_S, 3,(uint8*)&arg1, "CMServerHelper:LuaSystemChatBroad");
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CMServerHelper:LuaSystemChatBroad");
        if(!ok)
            return 0;
        CMServerHelper::LuaSystemChatBroad(arg0, arg1, arg2);
        return 0;
    }
    gxError("CMServerHelper:LuaSystemChatBroad has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaSystemChatBroad'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaGetRole(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned long long arg0;
        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMServerHelper:LuaGetRole");
        if(!ok)
            return 0;
        CRole* ret = CMServerHelper::LuaGetRole(arg0);
        object_to_luaval<CRole>(tolua_S, "CRole",(CRole*)ret);
        return 1;
    }
    gxError("CMServerHelper:LuaGetRole has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaGetRole'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaGetMapServer(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        CMapServer* ret = CMServerHelper::LuaGetMapServer();
        object_to_luaval<CMapServer>(tolua_S, "CMapServer",(CMapServer*)ret);
        return 1;
    }
    gxError("CMServerHelper:LuaGetMapServer has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaGetMapServer'.", &tolua_err);
    return 0;
}
int lua_mapserver_CMServerHelper_LuaChat(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMServerHelper",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        CRole* arg0;
        std::string arg1;
        ok &= luaval_to_object<CRole>(tolua_S, 2, "CRole", &arg0, "CMServerHelper:LuaChat");
        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CMServerHelper:LuaChat");
        if(!ok)
            return 0;
        CMServerHelper::LuaChat(arg0, arg1);
        return 0;
    }
    gxError("CMServerHelper:LuaChat has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_mapserver_CMServerHelper_LuaChat'.", &tolua_err);
    return 0;
}
static int lua_mapserver_CMServerHelper_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMServerHelper)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMServerHelper",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CMServerHelper* self = (CMServerHelper*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_mapserver_CMServerHelper(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMServerHelper");
    tolua_cclass(tolua_S,"CMServerHelper","CMServerHelper","",nullptr);

    tolua_beginmodule(tolua_S,"CMServerHelper");
        tolua_function(tolua_S,"LuaGetRoleByName", lua_mapserver_CMServerHelper_LuaGetRoleByName);
        tolua_function(tolua_S,"LuaWorldChatBroad", lua_mapserver_CMServerHelper_LuaWorldChatBroad);
        tolua_function(tolua_S,"LuaGetAnnouncementEventType", lua_mapserver_CMServerHelper_LuaGetAnnouncementEventType);
        tolua_function(tolua_S,"LuaKickRole", lua_mapserver_CMServerHelper_LuaKickRole);
        tolua_function(tolua_S,"LuaToNum64", lua_mapserver_CMServerHelper_LuaToNum64);
        tolua_function(tolua_S,"LuaGetRoleMgr", lua_mapserver_CMServerHelper_LuaGetRoleMgr);
        tolua_function(tolua_S,"LuaAllAnnouncement", lua_mapserver_CMServerHelper_LuaAllAnnouncement);
        tolua_function(tolua_S,"LuaGetAllRole", lua_mapserver_CMServerHelper_LuaGetAllRole);
        tolua_function(tolua_S,"LuaGetSpRole", lua_mapserver_CMServerHelper_LuaGetSpRole);
        tolua_function(tolua_S,"Md5String", lua_mapserver_CMServerHelper_Md5String);
        tolua_function(tolua_S,"LuaGetAnnouncementSysType", lua_mapserver_CMServerHelper_LuaGetAnnouncementSysType);
        tolua_function(tolua_S,"LuaGetServerData", lua_mapserver_CMServerHelper_LuaGetServerData);
        tolua_function(tolua_S,"LuaCrc32", lua_mapserver_CMServerHelper_LuaCrc32);
        tolua_function(tolua_S,"LuaSystemChatBroad", lua_mapserver_CMServerHelper_LuaSystemChatBroad);
        tolua_function(tolua_S,"LuaGetRole", lua_mapserver_CMServerHelper_LuaGetRole);
        tolua_function(tolua_S,"LuaGetMapServer", lua_mapserver_CMServerHelper_LuaGetMapServer);
        tolua_function(tolua_S,"LuaChat", lua_mapserver_CMServerHelper_LuaChat);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CMServerHelper).name();
    g_luaType[typeName] = "CMServerHelper";
    g_typeCast["CMServerHelper"] = "CMServerHelper";
    return 1;
}
int register_all_mapserver(lua_State* tolua_S)
{
	tolua_open(tolua_S);
	
	tolua_module(tolua_S,nullptr,0);
	tolua_beginmodule(tolua_S,nullptr);

	lua_register_mapserver_CMapPlayerHandlerBase(tolua_S);
	lua_register_mapserver__SrvMapTile(tolua_S);
	lua_register_mapserver__DbBaseItem(tolua_S);
	lua_register_mapserver_CGmCmdFunc(tolua_S);
	lua_register_mapserver_PacketCreateBrforeInfo(tolua_S);
	lua_register_mapserver_PacketGameCollectInfo(tolua_S);
	lua_register_mapserver_CScanOperator(tolua_S);
	lua_register_mapserver_CSkillTargetScan(tolua_S);
	lua_register_mapserver_CBasePacket(tolua_S);
	lua_register_mapserver_CRequestPacket(tolua_S);
	lua_register_mapserver_MWRoleQuit(tolua_S);
	lua_register_mapserver_CBlock(tolua_S);
	lua_register_mapserver_CResponsePacket(tolua_S);
	lua_register_mapserver_CServerPacket(tolua_S);
	lua_register_mapserver_CWMLimitAccountInfo(tolua_S);
	lua_register_mapserver_MCBagExtend(tolua_S);
	lua_register_mapserver_MWUpdateRoleData(tolua_S);
	lua_register_mapserver_CMapServerConfig(tolua_S);
	lua_register_mapserver_CNewRoleTblLoader(tolua_S);
	lua_register_mapserver_CSkillBuff(tolua_S);
	lua_register_mapserver__PackBuffer(tolua_S);
	lua_register_mapserver_CMMissionOperate(tolua_S);
	lua_register_mapserver_RechargeOrderBeanReader(tolua_S);
	lua_register_mapserver_CLoginWaiter(tolua_S);
	lua_register_mapserver_CGameRoleModule(tolua_S);
	lua_register_mapserver_CModChat(tolua_S);
	lua_register_mapserver_CMBagExtend(tolua_S);
	lua_register_mapserver_CHumanMissionData(tolua_S);
	lua_register_mapserver_WMServerInfo(tolua_S);
	lua_register_mapserver_CModBuffer(tolua_S);
	lua_register_mapserver_WMUpdateUserData(tolua_S);
	lua_register_mapserver_CConfigTbl(tolua_S);
	lua_register_mapserver_CMapConfigTbl(tolua_S);
	lua_register_mapserver_CWorldUserData(tolua_S);
	lua_register_mapserver_CBufferConfigTbl(tolua_S);
	lua_register_mapserver_SockAttr(tolua_S);
	lua_register_mapserver__PackSimpleBuff(tolua_S);
	lua_register_mapserver_CRoleManagerBase(tolua_S);
	lua_register_mapserver_SkillAttr(tolua_S);
	lua_register_mapserver_CLWRoleCreateRet(tolua_S);
	lua_register_mapserver_M2WRoleDataUpdate(tolua_S);
	lua_register_mapserver_LoginAwardBeanReader(tolua_S);
	lua_register_mapserver__MissionItem(tolua_S);
	lua_register_mapserver_MWChangeLine(tolua_S);
	lua_register_mapserver_CAttackTarget(tolua_S);
	lua_register_mapserver_IAttrBase(tolua_S);
	lua_register_mapserver_MCEnterSceneRet(tolua_S);
	lua_register_mapserver__CharacterInit(tolua_S);
	lua_register_mapserver_CCharMoveCore(tolua_S);
	lua_register_mapserver_CWLRegiste(tolua_S);
	lua_register_mapserver_LimitChat(tolua_S);
	lua_register_mapserver_CMBagOperate(tolua_S);
	lua_register_mapserver_WMAwardBindRmb(tolua_S);
	lua_register_mapserver_CMTransmite(tolua_S);
	lua_register_mapserver_MWExchangeGiftReq(tolua_S);
	lua_register_mapserver_CDhmTbl(tolua_S);
	lua_register_mapserver_LimitAccount(tolua_S);
	lua_register_mapserver_AreaRect(tolua_S);
	lua_register_mapserver_CMEnterGame(tolua_S);
	lua_register_mapserver_CModMission(tolua_S);
	lua_register_mapserver_MCMoveRet(tolua_S);
	lua_register_mapserver__ItemType(tolua_S);
	lua_register_mapserver_CMWorldChatMsg(tolua_S);
	lua_register_mapserver_CRandGen(tolua_S);
	lua_register_mapserver_CBufferEffect(tolua_S);
	lua_register_mapserver_PackLoginRole(tolua_S);
	lua_register_mapserver_MWGetRandNameList(tolua_S);
	lua_register_mapserver_CCharMsgHandle(tolua_S);
	lua_register_mapserver_CRandDropTblLoader(tolua_S);
	lua_register_mapserver_CGameDatabaseHandler(tolua_S);
	lua_register_mapserver_CMapDbPlayerHandlerBase(tolua_S);
	lua_register_mapserver_CAttackPos(tolua_S);
	lua_register_mapserver__ChartCampData(tolua_S);
	lua_register_mapserver_DBAcceptMission(tolua_S);
	lua_register_mapserver_ChangeLineTempData(tolua_S);
	lua_register_mapserver_TGMFunc(tolua_S);
	lua_register_mapserver_MMChangeScene(tolua_S);
	lua_register_mapserver_BuffImpact(tolua_S);
	lua_register_mapserver_MCUpdateItems(tolua_S);
	lua_register_mapserver_PackRoleShape(tolua_S);
	lua_register_mapserver_CLevelUpTblLoader(tolua_S);
	lua_register_mapserver_PackMissionParams(tolua_S);
	lua_register_mapserver_MCEnterScene(tolua_S);
	lua_register_mapserver_MCMoveBroad(tolua_S);
	lua_register_mapserver_CLevelUpTbl(tolua_S);
	lua_register_mapserver_ExtItem(tolua_S);
	lua_register_mapserver_RoleSceneRecord(tolua_S);
	lua_register_mapserver_CWLLimitInfoReq(tolua_S);
	lua_register_mapserver_OwnerBuffer(tolua_S);
	lua_register_mapserver_MissionParam(tolua_S);
	lua_register_mapserver_CMapSceneBase(tolua_S);
	lua_register_mapserver_Attr(tolua_S);
	lua_register_mapserver_MWUnloadRoleDataRet(tolua_S);
	lua_register_mapserver_MCTransmiteRet(tolua_S);
	lua_register_mapserver_CCombatTempData(tolua_S);
	lua_register_mapserver_ChatMsgBeanReader(tolua_S);
	lua_register_mapserver_CLoginWaiterManager(tolua_S);
	lua_register_mapserver_W2MUserDataUpdate(tolua_S);
	lua_register_mapserver_MCDelItems(tolua_S);
	lua_register_mapserver_CLimitManager(tolua_S);
	lua_register_mapserver_CSkillLogicBase(tolua_S);
	lua_register_mapserver_MWUpdateServer(tolua_S);
	lua_register_mapserver_CBasePackHandleAry(tolua_S);
	lua_register_mapserver_MCRandRoleNameRet(tolua_S);
	lua_register_mapserver_LimitAccountDB(tolua_S);
	lua_register_mapserver_CMapDataManagerBase(tolua_S);
	lua_register_mapserver_CMapDataManager(tolua_S);
	lua_register_mapserver_CTransportConfigTbl(tolua_S);
	lua_register_mapserver_CConfigLoaderBase(tolua_S);
	lua_register_mapserver_WMRoleHeartRet(tolua_S);
	lua_register_mapserver_CCharAttributeCore(tolua_S);
	lua_register_mapserver_SceneData(tolua_S);
	lua_register_mapserver_MWTransPacket(tolua_S);
	lua_register_mapserver_CMWLimitInfoReq(tolua_S);
	lua_register_mapserver_CLimitHandle(tolua_S);
	lua_register_mapserver_RandDropComInfoEx(tolua_S);
	lua_register_mapserver_CMsgBase(tolua_S);
	lua_register_mapserver_MCMoveItems(tolua_S);
	lua_register_mapserver_CMapDbPlayerHandler(tolua_S);
	lua_register_mapserver_CBufferConfigTblLoader(tolua_S);
	lua_register_mapserver_WMRenameRoleNameRet(tolua_S);
	lua_register_mapserver_MCDynamicMapListRet(tolua_S);
	lua_register_mapserver_COpenDynamicScene(tolua_S);
	lua_register_mapserver_CMLocalLoginGame(tolua_S);
	lua_register_mapserver_CAnnouncementTblLoader(tolua_S);
	lua_register_mapserver_MWOpenScene(tolua_S);
	lua_register_mapserver_CSceneManagerBase(tolua_S);
	lua_register_mapserver_LimitAccountInfo(tolua_S);
	lua_register_mapserver_RandDropConfigInfoEx(tolua_S);
	lua_register_mapserver_MissionBase(tolua_S);
	lua_register_mapserver_CGameObject(tolua_S);
	lua_register_mapserver_CDynamicObject(tolua_S);
	lua_register_mapserver_CPlayerRegisteTask(tolua_S);
	lua_register_mapserver__ObjManagerInit(tolua_S);
	lua_register_mapserver_MCLeaveView(tolua_S);
	lua_register_mapserver__PathPoint(tolua_S);
	lua_register_mapserver_MapServerUpdate(tolua_S);
	lua_register_mapserver__MonsterAttrBackup(tolua_S);
	lua_register_mapserver__OwnMission(tolua_S);
	lua_register_mapserver_MCMissionOperateRet(tolua_S);
	lua_register_mapserver_CDBLoadBase(tolua_S);
	lua_register_mapserver_MCCompress(tolua_S);
	lua_register_mapserver_GiftBeanReader(tolua_S);
	lua_register_mapserver_CMapServerEvent(tolua_S);
	lua_register_mapserver_MCChatBroad(tolua_S);
	lua_register_mapserver_OwnSkill(tolua_S);
	lua_register_mapserver_CNpcTblLoader(tolua_S);
	lua_register_mapserver_CBufferManager(tolua_S);
	lua_register_mapserver_DBFinishMissionBit(tolua_S);
	lua_register_mapserver_MWRegiste(tolua_S);
	lua_register_mapserver_AttrBackupBase(tolua_S);
	lua_register_mapserver_RoleAttrBackup(tolua_S);
	lua_register_mapserver_CObjList(tolua_S);
	lua_register_mapserver_MCAnnouncement(tolua_S);
	lua_register_mapserver_CSkillAttr(tolua_S);
	lua_register_mapserver_MailBeanReader(tolua_S);
	lua_register_mapserver_WMUnloadRoleData(tolua_S);
	lua_register_mapserver_CCharAttributeCoreExt(tolua_S);
	lua_register_mapserver_CCharSkillCore(tolua_S);
	lua_register_mapserver_CCharFightCore(tolua_S);
	lua_register_mapserver_CCharRelationCore(tolua_S);
	lua_register_mapserver_CCharAICore(tolua_S);
	lua_register_mapserver_CCharacterObject(tolua_S);
	lua_register_mapserver_CRoleBase(tolua_S);
	lua_register_mapserver_LimitChatDB(tolua_S);
	lua_register_mapserver_CBufferImpactBase(tolua_S);
	lua_register_mapserver_ServerBeanReader(tolua_S);
	lua_register_mapserver_RandDropComInfo(tolua_S);
	lua_register_mapserver_CItemManager(tolua_S);
	lua_register_mapserver_BroadInfo(tolua_S);
	lua_register_mapserver_FightRecord(tolua_S);
	lua_register_mapserver_CItem(tolua_S);
	lua_register_mapserver_CTempItem(tolua_S);
	lua_register_mapserver_CGameMoudle(tolua_S);
	lua_register_mapserver_MWRandRoleName(tolua_S);
	lua_register_mapserver_CLWLimitAccountInfo(tolua_S);
	lua_register_mapserver_CBroadTimer(tolua_S);
	lua_register_mapserver_CMOpenDynamicMap(tolua_S);
	lua_register_mapserver__AxisRect(tolua_S);
	lua_register_mapserver__xinxiang(tolua_S);
	lua_register_mapserver_CPlayerRegisteRetTask(tolua_S);
	lua_register_mapserver_FriendPageBeanReader(tolua_S);
	lua_register_mapserver_WLChargeRmb(tolua_S);
	lua_register_mapserver_CMapDbRequestTask(tolua_S);
	lua_register_mapserver_CSaveRoleDataTask(tolua_S);
	lua_register_mapserver_CGameMisc(tolua_S);
	lua_register_mapserver_PlayerPeriodActionReader(tolua_S);
	lua_register_mapserver__ChangeMapSaveData(tolua_S);
	lua_register_mapserver_MCEnterGameRet(tolua_S);
	lua_register_mapserver__BlockRect(tolua_S);
	lua_register_mapserver_RoleDetail(tolua_S);
	lua_register_mapserver_CObjectManager(tolua_S);
	lua_register_mapserver_AddAttr(tolua_S);
	lua_register_mapserver_CHumanDB(tolua_S);
	lua_register_mapserver_CMLand(tolua_S);
	lua_register_mapserver_CHumanDBMissionLoad(tolua_S);
	lua_register_mapserver_CWMLimitChatInfo(tolua_S);
	lua_register_mapserver_CItemProperty(tolua_S);
	lua_register_mapserver_ServerPwdInfo(tolua_S);
	lua_register_mapserver_CItemTblLoader(tolua_S);
	lua_register_mapserver_CScriptEngineCommon(tolua_S);
	lua_register_mapserver_MCChangeMapRet(tolua_S);
	lua_register_mapserver_CActionBan(tolua_S);
	lua_register_mapserver_CHumanDBBackup(tolua_S);
	lua_register_mapserver_CMMove(tolua_S);
	lua_register_mapserver_CranddropItemMgr(tolua_S);
	lua_register_mapserver_CModBag(tolua_S);
	lua_register_mapserver_MCSceneData(tolua_S);
	lua_register_mapserver_UrlDownFile(tolua_S);
	lua_register_mapserver_CHumanDBData(tolua_S);
	lua_register_mapserver_AxisPos(tolua_S);
	lua_register_mapserver_CSceneManager(tolua_S);
	lua_register_mapserver_MCOpenDynamicMapRet(tolua_S);
	lua_register_mapserver_SimplePlayerInfoBeanReader(tolua_S);
	lua_register_mapserver_RoleHeart(tolua_S);
	lua_register_mapserver__ObjInit(tolua_S);
	lua_register_mapserver_MWAnnoucement(tolua_S);
	lua_register_mapserver_MCRoomChatMsg(tolua_S);
	lua_register_mapserver_LoadRoleData(tolua_S);
	lua_register_mapserver_CMExchangeGiftReq(tolua_S);
	lua_register_mapserver_PackEncrypt(tolua_S);
	lua_register_mapserver_CLWLimitInfoUpdate(tolua_S);
	lua_register_mapserver_MCUpdateMissionList(tolua_S);
	lua_register_mapserver_CMDynamicMapList(tolua_S);
	lua_register_mapserver_MCAddItems(tolua_S);
	lua_register_mapserver_CMapServerInitFlag(tolua_S);
	lua_register_mapserver_CGameSocketPacketHandler(tolua_S);
	lua_register_mapserver_CMLocalLoginGameAccount(tolua_S);
	lua_register_mapserver_WMGetRandNameListRet(tolua_S);
	lua_register_mapserver_MoveItem(tolua_S);
	lua_register_mapserver_ApproachObjectList(tolua_S);
	lua_register_mapserver_ItemPosition(tolua_S);
	lua_register_mapserver_MWRechargeRet(tolua_S);
	lua_register_mapserver__ReliveInfo(tolua_S);
	lua_register_mapserver_CTransportTblLoader(tolua_S);
	lua_register_mapserver_CBufferAttr(tolua_S);
	lua_register_mapserver_ExtUseSkill(tolua_S);
	lua_register_mapserver_LoadWaitEnter(tolua_S);
	lua_register_mapserver_CMapTblLoader(tolua_S);
	lua_register_mapserver_CRandDropTbl(tolua_S);
	lua_register_mapserver_CAnnouncement(tolua_S);
	lua_register_mapserver_MCCallBackRetCode(tolua_S);
	lua_register_mapserver_MCLocalLoginGameAccountRet(tolua_S);
	lua_register_mapserver_CMChat(tolua_S);
	lua_register_mapserver_CMapServerBase(tolua_S);
	lua_register_mapserver_SimpleRankBeanReader(tolua_S);
	lua_register_mapserver_MCKickRole(tolua_S);
	lua_register_mapserver_MCLandRet(tolua_S);
	lua_register_mapserver_CConstantTblLoader(tolua_S);
	lua_register_mapserver_MCBagExtendRet(tolua_S);
	lua_register_mapserver_CMapWorldServerHandlerBase(tolua_S);
	lua_register_mapserver_CMapWorldServerHandler(tolua_S);
	lua_register_mapserver__ObjListNode(tolua_S);
	lua_register_mapserver_TUnpacketIDHandler(tolua_S);
	lua_register_mapserver_CItemBuff(tolua_S);
	lua_register_mapserver_PackMission(tolua_S);
	lua_register_mapserver_LoginServerData(tolua_S);
	lua_register_mapserver_CWLRoleLogin(tolua_S);
	lua_register_mapserver_WMUpdateServer(tolua_S);
	lua_register_mapserver_CAttackInfo(tolua_S);
	lua_register_mapserver__DBAppendAttr(tolua_S);
	lua_register_mapserver_DBSkillCoolDown(tolua_S);
	lua_register_mapserver_PackMonsterShape(tolua_S);
	lua_register_mapserver_CAnnouncementSysManager(tolua_S);
	lua_register_mapserver_LimitChatInfo(tolua_S);
	lua_register_mapserver_WMRandRoleNameRet(tolua_S);
	lua_register_mapserver_FriendSimplePageBeanReader(tolua_S);
	lua_register_mapserver_MWTrans2WorldPacket(tolua_S);
	lua_register_mapserver_MCScreenAnnounce(tolua_S);
	lua_register_mapserver_CAttackorList(tolua_S);
	lua_register_mapserver_CMapBase(tolua_S);
	lua_register_mapserver_LimitServerIDInfo(tolua_S);
	lua_register_mapserver_MCSyncRoleData(tolua_S);
	lua_register_mapserver_CDhmTblLoader(tolua_S);
	lua_register_mapserver_CCconfigLoaderParam(tolua_S);
	lua_register_mapserver__ApproachObject(tolua_S);
	lua_register_mapserver_CMServerHelper(tolua_S);
	lua_register_mapserver__MapData(tolua_S);
	lua_register_mapserver__DBGemFix(tolua_S);
	lua_register_mapserver_GuessBeanReader(tolua_S);
	lua_register_mapserver_CStopTimer(tolua_S);
	lua_register_mapserver_ServerData(tolua_S);
	lua_register_mapserver_WMChangeLine(tolua_S);
	lua_register_mapserver_MWRenameRoleName(tolua_S);
	lua_register_mapserver_CLogoutWaiter(tolua_S);
	lua_register_mapserver_CNpcConfigTbl(tolua_S);
	lua_register_mapserver_CMDrop(tolua_S);
	lua_register_mapserver_MCDeleteMission(tolua_S);
	lua_register_mapserver_CItemContainer(tolua_S);
	lua_register_mapserver_CCombatResult(tolua_S);
	lua_register_mapserver_CSkillTargetScanInit(tolua_S);
	lua_register_mapserver_MWUserLogin(tolua_S);
	lua_register_mapserver_CMapDbResponseTask(tolua_S);
	lua_register_mapserver_CMEnterScene(tolua_S);
	lua_register_mapserver_CConstantTbl(tolua_S);
	lua_register_mapserver_CLoadRoleDataRetTask(tolua_S);
	lua_register_mapserver_MCDropRet(tolua_S);
	lua_register_mapserver_RandDropConfigInfo(tolua_S);
	lua_register_mapserver_MWBroadPacket(tolua_S);
	lua_register_mapserver_CMRandRoleName(tolua_S);
	lua_register_mapserver_WMLoadRoleData(tolua_S);
	lua_register_mapserver_WMExchangeGiftRet(tolua_S);
	lua_register_mapserver_CSceneObjectManager(tolua_S);
	lua_register_mapserver_WorldServerName(tolua_S);
	lua_register_mapserver_CTimeWaiter(tolua_S);
	lua_register_mapserver_PacketSingletonInfo(tolua_S);
	lua_register_mapserver_RankBeanReader(tolua_S);
	lua_register_mapserver_GiveGiftSimpleBeanReader(tolua_S);
	lua_register_mapserver__MapDataHeader(tolua_S);
	lua_register_mapserver_PlayerInfoBeanReader(tolua_S);
	lua_register_mapserver_ShopItemBeanReader(tolua_S);
	lua_register_mapserver_CannonBeanReader(tolua_S);
	lua_register_mapserver_CLWLimitChatInfo(tolua_S);
	lua_register_mapserver__MissionDropItem(tolua_S);
	lua_register_mapserver_CHumanBaseData(tolua_S);
	lua_register_mapserver_CMapScene(tolua_S);
	lua_register_mapserver_CLWRoleLoginRet(tolua_S);
	lua_register_mapserver_GiveGiftBeanReader(tolua_S);
	lua_register_mapserver_IPlayer(tolua_S);
	lua_register_mapserver_MCEnterView(tolua_S);
	lua_register_mapserver_SelfPeriodReportReader(tolua_S);
	lua_register_mapserver_CRoleManager(tolua_S);
	lua_register_mapserver_WMChangeLineRet(tolua_S);
	lua_register_mapserver_AttackorImpact(tolua_S);
	lua_register_mapserver_MWLoadRoleDataRet(tolua_S);
	lua_register_mapserver_CLoadRoleDataTask(tolua_S);
	lua_register_mapserver_TwoValueBeanReader(tolua_S);
	lua_register_mapserver_MapIDPos(tolua_S);
	lua_register_mapserver_CLWRegisteRet(tolua_S);
	lua_register_mapserver_CSkillLogicManager(tolua_S);
	lua_register_mapserver_MCExchangeItem(tolua_S);
	lua_register_mapserver_TUserFlag(tolua_S);
	lua_register_mapserver_MCLocalLoginGameRet(tolua_S);
	lua_register_mapserver_CArea(tolua_S);
	lua_register_mapserver_CSceneRoleManager(tolua_S);
	lua_register_mapserver_CSkillInfo(tolua_S);
	lua_register_mapserver_MapIDRangePos(tolua_S);
	lua_register_mapserver_CWLDataUpdate(tolua_S);
	lua_register_mapserver_MyGuessBeanReader(tolua_S);
	lua_register_mapserver_CSaveRoleDataRetTask(tolua_S);
	lua_register_mapserver_CMChangeMap(tolua_S);
	lua_register_mapserver_MCUpdateMissionParam(tolua_S);
	lua_register_mapserver_MCPlayerHeart(tolua_S);
	lua_register_mapserver_MCResetPos(tolua_S);
	lua_register_mapserver_PackHandleAttr(tolua_S);
	lua_register_mapserver_MWCloseScene(tolua_S);
	lua_register_mapserver_ExtendAttr(tolua_S);
	lua_register_mapserver_RoleManageInfo(tolua_S);
	lua_register_mapserver_MWRoleKick(tolua_S);
	lua_register_mapserver_CItemOperator(tolua_S);
	lua_register_mapserver_CMJump(tolua_S);
	lua_register_mapserver_DBItemCoolDown(tolua_S);
	lua_register_mapserver_CItemConfigTbl(tolua_S);
	lua_register_mapserver_PeriodReportReader(tolua_S);
	lua_register_mapserver_CMapPlayerHandler(tolua_S);
	lua_register_mapserver_PackItem(tolua_S);
	lua_register_mapserver_MCExchangeGiftRet(tolua_S);
	lua_register_mapserver__DbItem(tolua_S);
	lua_register_mapserver_WMTransPacketError(tolua_S);
	lua_register_mapserver_CMissionTblLoader(tolua_S);
	lua_register_mapserver_CMapServer(tolua_S);
	lua_register_mapserver_CMRenameRoleName(tolua_S);
	lua_register_mapserver_VipInfoBeanReader(tolua_S);
	lua_register_mapserver_CItemHelper(tolua_S);
	lua_register_mapserver_CWLRoleCreate(tolua_S);
	lua_register_mapserver_CItemInit(tolua_S);
	lua_register_mapserver__MissionKills(tolua_S);
	lua_register_mapserver_MCRenameRoleNameRet(tolua_S);
	lua_register_mapserver_HoleGemInfo(tolua_S);
	lua_register_mapserver_CRoleScriptObject(tolua_S);
	lua_register_mapserver_CGameConfig(tolua_S);
	lua_register_mapserver_WMRecharge(tolua_S);
	lua_register_mapserver_CMap(tolua_S);
	lua_register_mapserver_PackCompress(tolua_S);
	lua_register_mapserver_CGameServerSocketPacketHandler(tolua_S);
	lua_register_mapserver_MCJumpRet(tolua_S);
	lua_register_mapserver_PacketLoginTime(tolua_S);
	lua_register_mapserver_CCooldown(tolua_S);
	lua_register_mapserver_CMPlayerHeartRet(tolua_S);
	lua_register_mapserver_UserDbData(tolua_S);
	lua_register_mapserver_SimpleItem(tolua_S);
	lua_register_mapserver_MapPos(tolua_S);
	lua_register_mapserver_PlayerSeatBeanReader(tolua_S);
	lua_register_mapserver__BlockInfo(tolua_S);
	lua_register_mapserver_CRole(tolua_S);
	lua_register_mapserver_CMissionConfigTbl(tolua_S);
	lua_register_mapserver_ItemIDNum(tolua_S);
	lua_register_mapserver_CAnnouncementTbl(tolua_S);
	lua_register_mapserver_CScriptEngine(tolua_S);
	lua_register_mapserver_CModFight(tolua_S);
	lua_register_mapserver_CharmsItemBeanReader(tolua_S);
	lua_register_mapserver_MCWorldChatMsg(tolua_S);
	lua_register_mapserver_CMapServerData(tolua_S);
	lua_register_mapserver_WorldServerData(tolua_S);
	lua_register_mapserver_CMapDbServerHandler(tolua_S);
	lua_register_mapserver_MWRoleHeart(tolua_S);
	lua_register_mapserver_ZoneServer(tolua_S);
	lua_register_mapserver_TradeItemBeanReader(tolua_S);
	lua_register_mapserver_PacketNewRegister(tolua_S);
	lua_register_mapserver_CMRoomChatMsg(tolua_S);
	lua_register_mapserver_PacketSourceWay(tolua_S);
	lua_register_mapserver_CUpdateRoleDataTimerTask(tolua_S);
	lua_register_mapserver_TAdjust(tolua_S);
	lua_register_mapserver_RankDayBeanReader(tolua_S);
	lua_register_mapserver_UpdateItem(tolua_S);
	lua_register_mapserver_CAvoidOverlap(tolua_S);
	lua_register_mapserver_CItemTbls(tolua_S);
	lua_register_mapserver_CNewRoleTbl(tolua_S);
	lua_register_mapserver_ChangeLineWait(tolua_S);
	lua_register_mapserver_MCBagOperateRet(tolua_S);
	lua_register_mapserver_MapRangePos(tolua_S);
	lua_register_mapserver_SeatPlayerBeanReader(tolua_S);
	lua_register_mapserver_ItemReward(tolua_S);
	lua_register_mapserver_WMRegisteRet(tolua_S);
	lua_register_mapserver__ScanOperatorInit(tolua_S);

	tolua_endmodule(tolua_S);
	return 1;
}

