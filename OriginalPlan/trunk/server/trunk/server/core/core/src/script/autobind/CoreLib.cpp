#include "script_lua_inc.h"
#include "lua_tinker.h"
#include "tolua++.h"
#include "lua_base_conversions.h"
#include "lua_base_conversions_impl.h"
#include "tolua_fix.h"


#include "__header.h"

static int lua_corelib_CFixNullBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CFixNullBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CFixNullBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CFixNullBase* self = (GXMISC::CFixNullBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CFixNullBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CFixNullBase");
    tolua_cclass(tolua_S,"CFixNullBase","CFixNullBase","",nullptr);

    tolua_beginmodule(tolua_S,"CFixNullBase");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CFixNullBase).name();
    g_luaType[typeName] = "CFixNullBase";
    g_typeCast["CFixNullBase"] = "CFixNullBase";
    return 1;
}

static int lua_corelib_CFixLenBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CFixLenBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CFixLenBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CFixLenBase* self = (GXMISC::CFixLenBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CFixLenBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CFixLenBase");
    tolua_cclass(tolua_S,"CFixLenBase","CFixLenBase","",nullptr);

    tolua_beginmodule(tolua_S,"CFixLenBase");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CFixLenBase).name();
    g_luaType[typeName] = "CFixLenBase";
    g_typeCast["CFixLenBase"] = "CFixLenBase";
    return 1;
}

static int lua_corelib_IStreamable_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IStreamable)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IStreamable",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IStreamable* self = (GXMISC::IStreamable*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IStreamable(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IStreamable");
    tolua_cclass(tolua_S,"IStreamable","IStreamable","",nullptr);

    tolua_beginmodule(tolua_S,"IStreamable");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IStreamable).name();
    g_luaType[typeName] = "IStreamable";
    g_typeCast["IStreamable"] = "IStreamable";
    return 1;
}

static int lua_corelib_IUnStreamable_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IUnStreamable)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IUnStreamable",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IUnStreamable* self = (GXMISC::IUnStreamable*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IUnStreamable(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IUnStreamable");
    tolua_cclass(tolua_S,"IUnStreamable","IUnStreamable","",nullptr);

    tolua_beginmodule(tolua_S,"IUnStreamable");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IUnStreamable).name();
    g_luaType[typeName] = "IUnStreamable";
    g_typeCast["IUnStreamable"] = "IUnStreamable";
    return 1;
}

static int lua_corelib_IStreamableAll_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IStreamableAll)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IStreamableAll",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IStreamableAll* self = (GXMISC::IStreamableAll*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IStreamableAll(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IStreamableAll");
    tolua_cclass(tolua_S,"IStreamableAll","IStreamableAll","",nullptr);

    tolua_beginmodule(tolua_S,"IStreamableAll");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IStreamableAll).name();
    g_luaType[typeName] = "IStreamableAll";
    g_typeCast["IStreamableAll"] = "IStreamableAll";
    return 1;
}

static int lua_corelib_IStream_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IStream)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IStream",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IStream* self = (GXMISC::IStream*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IStream(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IStream");
    tolua_cclass(tolua_S,"IStream","IStream","",nullptr);

    tolua_beginmodule(tolua_S,"IStream");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IStream).name();
    g_luaType[typeName] = "IStream";
    g_typeCast["IStream"] = "IStream";
    return 1;
}

static int lua_corelib_IUnStream_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IUnStream)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IUnStream",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IUnStream* self = (GXMISC::IUnStream*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IUnStream(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IUnStream");
    tolua_cclass(tolua_S,"IUnStream","IUnStream","",nullptr);

    tolua_beginmodule(tolua_S,"IUnStream");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IUnStream).name();
    g_luaType[typeName] = "IUnStream";
    g_typeCast["IUnStream"] = "IUnStream";
    return 1;
}

int lua_corelib_ILockable_leave(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ILockable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ILockable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ILockable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ILockable_leave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->leave();
        return 0;
    }

    gxError("ILockable:leave has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ILockable_leave'.",&tolua_err);
	return 0;
}
int lua_corelib_ILockable_enter(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ILockable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ILockable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ILockable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ILockable_enter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->enter();
        return 0;
    }

    gxError("ILockable:enter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ILockable_enter'.",&tolua_err);
	return 0;
}
static int lua_corelib_ILockable_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ILockable)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ILockable",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::ILockable* self = (GXMISC::ILockable*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_ILockable(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ILockable");
    tolua_cclass(tolua_S,"ILockable","ILockable","",nullptr);

    tolua_beginmodule(tolua_S,"ILockable");
        tolua_function(tolua_S,"leave",lua_corelib_ILockable_leave);
        tolua_function(tolua_S,"enter",lua_corelib_ILockable_enter);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::ILockable).name();
    g_luaType[typeName] = "ILockable";
    g_typeCast["ILockable"] = "ILockable";
    return 1;
}

int lua_corelib_CEmptyLock_leave(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CEmptyLock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CEmptyLock",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CEmptyLock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CEmptyLock_leave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->leave();
        return 0;
    }

    gxError("CEmptyLock:leave has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CEmptyLock_leave'.",&tolua_err);
	return 0;
}
int lua_corelib_CEmptyLock_enter(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CEmptyLock* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CEmptyLock",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CEmptyLock*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CEmptyLock_enter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->enter();
        return 0;
    }

    gxError("CEmptyLock:enter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CEmptyLock_enter'.",&tolua_err);
	return 0;
}
static int lua_corelib_CEmptyLock_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CEmptyLock)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CEmptyLock",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CEmptyLock* self = (GXMISC::CEmptyLock*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CEmptyLock(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CEmptyLock");
    tolua_cclass(tolua_S,"CEmptyLock","CEmptyLock","ILockable",nullptr);

    tolua_beginmodule(tolua_S,"CEmptyLock");
        tolua_function(tolua_S,"leave",lua_corelib_CEmptyLock_leave);
        tolua_function(tolua_S,"enter",lua_corelib_CEmptyLock_enter);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CEmptyLock).name();
    g_luaType[typeName] = "CEmptyLock";
    g_typeCast["CEmptyLock"] = "CEmptyLock";
    return 1;
}

int lua_corelib_CUnfairMutex_leave(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CUnfairMutex* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CUnfairMutex",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CUnfairMutex*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CUnfairMutex_leave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->leave();
        return 0;
    }

    gxError("CUnfairMutex:leave has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CUnfairMutex_leave'.",&tolua_err);
	return 0;
}
int lua_corelib_CUnfairMutex_enter(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CUnfairMutex* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CUnfairMutex",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CUnfairMutex*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CUnfairMutex_enter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->enter();
        return 0;
    }

    gxError("CUnfairMutex:enter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CUnfairMutex_enter'.",&tolua_err);
	return 0;
}
int lua_corelib_CUnfairMutex_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CUnfairMutex* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            std::string arg0;
            ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CUnfairMutex:CUnfairMutex");

            if (!ok) { break; }
            cobj = new GXMISC::CUnfairMutex(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CUnfairMutex");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CUnfairMutex();
            tolua_pushusertype(tolua_S,(void*)cobj,"CUnfairMutex");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CUnfairMutex:CUnfairMutex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CUnfairMutex_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CUnfairMutex)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CUnfairMutex",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CUnfairMutex* self = (GXMISC::CUnfairMutex*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CUnfairMutex(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CUnfairMutex");
    tolua_cclass(tolua_S,"CUnfairMutex","CUnfairMutex","",lua_corelib_CUnfairMutex_finalize);

    tolua_beginmodule(tolua_S,"CUnfairMutex");
        tolua_function(tolua_S,"new",lua_corelib_CUnfairMutex_constructor);
        tolua_function(tolua_S,"leave",lua_corelib_CUnfairMutex_leave);
        tolua_function(tolua_S,"enter",lua_corelib_CUnfairMutex_enter);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CUnfairMutex).name();
    g_luaType[typeName] = "CUnfairMutex";
    g_typeCast["CUnfairMutex"] = "CUnfairMutex";
    return 1;
}

int lua_corelib_CFastLock_Set(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CFastLock",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        unsigned int arg0;
        int arg1;
        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CFastLock:Set");
        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CFastLock:Set");
        if(!ok)
            return 0;
        GXMISC::CFastLock::Set(arg0, arg1);
        return 0;
    }
    gxError("CFastLock:Set has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CFastLock_Set'.", &tolua_err);
    return 0;
}
int lua_corelib_CFastLock_unlock(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CFastLock",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned int arg0;
        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CFastLock:unlock");
        if(!ok)
            return 0;
        GXMISC::CFastLock::unlock(arg0);
        return 0;
    }
    gxError("CFastLock:unlock has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CFastLock_unlock'.", &tolua_err);
    return 0;
}
int lua_corelib_CFastLock_Increase(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CFastLock",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        unsigned int arg0;
        int arg1;
        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CFastLock:Increase");
        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CFastLock:Increase");
        if(!ok)
            return 0;
        GXMISC::CFastLock::Increase(arg0, arg1);
        return 0;
    }
    gxError("CFastLock:Increase has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CFastLock_Increase'.", &tolua_err);
    return 0;
}
int lua_corelib_CFastLock_isLocked(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CFastLock",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned int arg0;
        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CFastLock:isLocked");
        if(!ok)
            return 0;
        bool ret = GXMISC::CFastLock::isLocked(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CFastLock:isLocked has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CFastLock_isLocked'.", &tolua_err);
    return 0;
}
int lua_corelib_CFastLock_tryLock(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CFastLock",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned int arg0;
        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CFastLock:tryLock");
        if(!ok)
            return 0;
        bool ret = GXMISC::CFastLock::tryLock(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CFastLock:tryLock has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CFastLock_tryLock'.", &tolua_err);
    return 0;
}
int lua_corelib_CFastLock_Descrease(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CFastLock",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        unsigned int arg0;
        int arg1;
        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CFastLock:Descrease");
        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CFastLock:Descrease");
        if(!ok)
            return 0;
        GXMISC::CFastLock::Descrease(arg0, arg1);
        return 0;
    }
    gxError("CFastLock:Descrease has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CFastLock_Descrease'.", &tolua_err);
    return 0;
}
static int lua_corelib_CFastLock_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CFastLock)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CFastLock",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CFastLock* self = (GXMISC::CFastLock*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CFastLock(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CFastLock");
    tolua_cclass(tolua_S,"CFastLock","CFastLock","",nullptr);

    tolua_beginmodule(tolua_S,"CFastLock");
        tolua_function(tolua_S,"Set", lua_corelib_CFastLock_Set);
        tolua_function(tolua_S,"unlock", lua_corelib_CFastLock_unlock);
        tolua_function(tolua_S,"Increase", lua_corelib_CFastLock_Increase);
        tolua_function(tolua_S,"isLocked", lua_corelib_CFastLock_isLocked);
        tolua_function(tolua_S,"tryLock", lua_corelib_CFastLock_tryLock);
        tolua_function(tolua_S,"Descrease", lua_corelib_CFastLock_Descrease);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CFastLock).name();
    g_luaType[typeName] = "CFastLock";
    g_typeCast["CFastLock"] = "CFastLock";
    return 1;
}

int lua_corelib_CFairMutex_leave(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CFairMutex* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CFairMutex",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CFairMutex*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CFairMutex_leave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->leave();
        return 0;
    }

    gxError("CFairMutex:leave has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CFairMutex_leave'.",&tolua_err);
	return 0;
}
int lua_corelib_CFairMutex_enter(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CFairMutex* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CFairMutex",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CFairMutex*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CFairMutex_enter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->enter();
        return 0;
    }

    gxError("CFairMutex:enter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CFairMutex_enter'.",&tolua_err);
	return 0;
}
int lua_corelib_CFairMutex_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CFairMutex* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            std::string arg0;
            ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CFairMutex:CFairMutex");

            if (!ok) { break; }
            cobj = new GXMISC::CFairMutex(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CFairMutex");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CFairMutex();
            tolua_pushusertype(tolua_S,(void*)cobj,"CFairMutex");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CFairMutex:CFairMutex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CFairMutex_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CFairMutex)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CFairMutex",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CFairMutex* self = (GXMISC::CFairMutex*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CFairMutex(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CFairMutex");
    tolua_cclass(tolua_S,"CFairMutex","CFairMutex","",lua_corelib_CFairMutex_finalize);

    tolua_beginmodule(tolua_S,"CFairMutex");
        tolua_function(tolua_S,"new",lua_corelib_CFairMutex_constructor);
        tolua_function(tolua_S,"leave",lua_corelib_CFairMutex_leave);
        tolua_function(tolua_S,"enter",lua_corelib_CFairMutex_enter);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CFairMutex).name();
    g_luaType[typeName] = "CFairMutex";
    g_typeCast["CFairMutex"] = "CFairMutex";
    return 1;
}

int lua_corelib_CTimeVal_toTimeVal(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeVal* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeVal",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeVal*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeVal_toTimeVal'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        timeval* ret = cobj->toTimeVal();
        object_to_luaval<timeval>(tolua_S, "timeval",(timeval*)ret);
        return 1;
    }

    gxError("CTimeVal:toTimeVal has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeVal_toTimeVal'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeVal_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeVal* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimeVal:CTimeVal");
        if(!ok)
            return 0;
        cobj = new GXMISC::CTimeVal(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CTimeVal");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CTimeVal:CTimeVal has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CTimeVal_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTimeVal)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTimeVal",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CTimeVal* self = (GXMISC::CTimeVal*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CTimeVal(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTimeVal");
    tolua_cclass(tolua_S,"CTimeVal","CTimeVal","",lua_corelib_CTimeVal_finalize);

    tolua_beginmodule(tolua_S,"CTimeVal");
        tolua_function(tolua_S,"new",lua_corelib_CTimeVal_constructor);
        tolua_function(tolua_S,"toTimeVal",lua_corelib_CTimeVal_toTimeVal);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CTimeVal).name();
    g_luaType[typeName] = "CTimeVal";
    g_typeCast["CTimeVal"] = "CTimeVal";
    return 1;
}

int lua_corelib_CTime_TicksToSecond(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTime",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        long long arg0;
        ok &= luaval_to_sint64(tolua_S, 2,(sint64*)&arg0, "CTime:TicksToSecond");
        if(!ok)
            return 0;
        double ret = GXMISC::CTime::TicksToSecond(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CTime:TicksToSecond has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTime_TicksToSecond'.", &tolua_err);
    return 0;
}
int lua_corelib_CTime_GetHumanRelativeTime(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTime",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTime:GetHumanRelativeTime");
        if(!ok)
            return 0;
        std::string ret = GXMISC::CTime::GetHumanRelativeTime(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }
    gxError("CTime:GetHumanRelativeTime has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTime_GetHumanRelativeTime'.", &tolua_err);
    return 0;
}
int lua_corelib_CTime_GetPerformanceTime(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTime",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        long long ret = GXMISC::CTime::GetPerformanceTime();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }
    gxError("CTime:GetPerformanceTime has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTime_GetPerformanceTime'.", &tolua_err);
    return 0;
}
int lua_corelib_CTime_GetLocalTime(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTime",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        long long ret = GXMISC::CTime::GetLocalTime();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }
    gxError("CTime:GetLocalTime has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTime_GetLocalTime'.", &tolua_err);
    return 0;
}
int lua_corelib_CTime_GetSecondsSince1970(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTime",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        unsigned int ret = GXMISC::CTime::GetSecondsSince1970();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CTime:GetSecondsSince1970 has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTime_GetSecondsSince1970'.", &tolua_err);
    return 0;
}
static int lua_corelib_CTime_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTime)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTime",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CTime* self = (GXMISC::CTime*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CTime(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTime");
    tolua_cclass(tolua_S,"CTime","CTime","",nullptr);

    tolua_beginmodule(tolua_S,"CTime");
        tolua_function(tolua_S,"TicksToSecond", lua_corelib_CTime_TicksToSecond);
        tolua_function(tolua_S,"GetHumanRelativeTime", lua_corelib_CTime_GetHumanRelativeTime);
        tolua_function(tolua_S,"GetPerformanceTime", lua_corelib_CTime_GetPerformanceTime);
        tolua_function(tolua_S,"GetLocalTime", lua_corelib_CTime_GetLocalTime);
        tolua_function(tolua_S,"GetSecondsSince1970", lua_corelib_CTime_GetSecondsSince1970);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CTime).name();
    g_luaType[typeName] = "CTime";
    g_typeCast["CTime"] = "CTime";
    return 1;
}

int lua_corelib_CTimespan_reset(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimespan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimespan",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimespan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimespan_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }

    gxError("CTimespan:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimespan_reset'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimespan_totalHours(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimespan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimespan",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimespan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimespan_totalHours'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->totalHours();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimespan:totalHours has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimespan_totalHours'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimespan_seconds(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimespan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimespan",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimespan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimespan_seconds'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->seconds();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimespan:seconds has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimespan_seconds'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimespan_days(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimespan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimespan",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimespan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimespan_days'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->days();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimespan:days has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimespan_days'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimespan_hours(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimespan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimespan",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimespan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimespan_hours'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->hours();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimespan:hours has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimespan_hours'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimespan_totalMinutes(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimespan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimespan",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimespan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimespan_totalMinutes'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->totalMinutes();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimespan:totalMinutes has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimespan_totalMinutes'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimespan_getTimeSpan(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimespan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimespan",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimespan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimespan_getTimeSpan'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getTimeSpan();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CTimespan:getTimeSpan has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimespan_getTimeSpan'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimespan_totalSeconds(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimespan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimespan",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimespan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimespan_totalSeconds'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->totalSeconds();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimespan:totalSeconds has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimespan_totalSeconds'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimespan_minutes(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimespan* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimespan",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimespan*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimespan_minutes'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->minutes();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimespan:minutes has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimespan_minutes'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimespan_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimespan* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            unsigned long long arg0;
            ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CTimespan:CTimespan");

            if (!ok) { break; }
            cobj = new GXMISC::CTimespan(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CTimespan");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CTimespan();
            tolua_pushusertype(tolua_S,(void*)cobj,"CTimespan");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTimespan:CTimespan");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CTimespan:CTimespan");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CTimespan:CTimespan");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CTimespan:CTimespan");

            if (!ok) { break; }
            cobj = new GXMISC::CTimespan(arg0, arg1, arg2, arg3);
            tolua_pushusertype(tolua_S,(void*)cobj,"CTimespan");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CTimespan:CTimespan has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

}

static int lua_corelib_CTimespan_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTimespan)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTimespan",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CTimespan* self = (GXMISC::CTimespan*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CTimespan(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTimespan");
    tolua_cclass(tolua_S,"CTimespan","CTimespan","",lua_corelib_CTimespan_finalize);

    tolua_beginmodule(tolua_S,"CTimespan");
        tolua_function(tolua_S,"new",lua_corelib_CTimespan_constructor);
        tolua_function(tolua_S,"reset",lua_corelib_CTimespan_reset);
        tolua_function(tolua_S,"totalHours",lua_corelib_CTimespan_totalHours);
        tolua_function(tolua_S,"seconds",lua_corelib_CTimespan_seconds);
        tolua_function(tolua_S,"days",lua_corelib_CTimespan_days);
        tolua_function(tolua_S,"hours",lua_corelib_CTimespan_hours);
        tolua_function(tolua_S,"totalMinutes",lua_corelib_CTimespan_totalMinutes);
        tolua_function(tolua_S,"getTimeSpan",lua_corelib_CTimespan_getTimeSpan);
        tolua_function(tolua_S,"totalSeconds",lua_corelib_CTimespan_totalSeconds);
        tolua_function(tolua_S,"minutes",lua_corelib_CTimespan_minutes);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CTimespan).name();
    g_luaType[typeName] = "CTimespan";
    g_typeCast["CTimespan"] = "CTimespan";
    return 1;
}

int lua_corelib_CDateTime_week(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_week'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->week();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CDateTime:week");
        if(!ok)
            return 0;
        int ret = cobj->week(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:week has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_week'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_dayOfWeek(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_dayOfWeek'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->dayOfWeek();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:dayOfWeek has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_dayOfWeek'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_isAM(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_isAM'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isAM();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDateTime:isAM has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_isAM'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_totalMins(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_totalMins'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->totalMins();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:totalMins has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_totalMins'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_totalDays(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_totalDays'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->totalDays();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:totalDays has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_totalDays'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_hour(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_hour'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->hour();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:hour has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_hour'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_isPM(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_isPM'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isPM();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDateTime:isPM has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_isPM'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_totalSecs(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_totalSecs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->totalSecs();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:totalSecs has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_totalSecs'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_minute(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_minute'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->minute();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:minute has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_minute'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_update(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->update();
        return 0;
    }

    gxError("CDateTime:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_update'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_month(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_month'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->month();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:month has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_month'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_totalHours(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_totalHours'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->totalHours();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:totalHours has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_totalHours'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_hourAMPM(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_hourAMPM'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->hourAMPM();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:hourAMPM has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_hourAMPM'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_second(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_second'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->second();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:second has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_second'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_dayOfYear(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_dayOfYear'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->dayOfYear();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:dayOfYear has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_dayOfYear'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_year(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_year'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->year();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:year has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_year'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_utcTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_utcTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        long long ret = cobj->utcTime();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }

    gxError("CDateTime:utcTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_utcTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_day(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDateTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDateTime_day'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->day();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDateTime:day has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_day'.",&tolua_err);
	return 0;
}
int lua_corelib_CDateTime_IsValid(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CDateTime",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        int arg0;
        int arg1;
        int arg2;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CDateTime:IsValid");
        if(!ok)
            return 0;
        bool ret = GXMISC::CDateTime::IsValid(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 4)
    {
        int arg0;
        int arg1;
        int arg2;
        int arg3;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CDateTime:IsValid");
        if(!ok)
            return 0;
        bool ret = GXMISC::CDateTime::IsValid(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 5)
    {
        int arg0;
        int arg1;
        int arg2;
        int arg3;
        int arg4;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CDateTime:IsValid");
        if(!ok)
            return 0;
        bool ret = GXMISC::CDateTime::IsValid(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 6)
    {
        int arg0;
        int arg1;
        int arg2;
        int arg3;
        int arg4;
        int arg5;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CDateTime:IsValid");
        ok &= luaval_to_sint32(tolua_S, 7,(sint32*)&arg5, "CDateTime:IsValid");
        if(!ok)
            return 0;
        bool ret = GXMISC::CDateTime::IsValid(arg0, arg1, arg2, arg3, arg4, arg5);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CDateTime:IsValid has wrong number of arguments: {0}, was expecting {1}\n ", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_IsValid'.", &tolua_err);
    return 0;
}
int lua_corelib_CDateTime_DaysOfMonth(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CDateTime",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        int arg0;
        int arg1;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CDateTime:DaysOfMonth");
        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CDateTime:DaysOfMonth");
        if(!ok)
            return 0;
        int ret = GXMISC::CDateTime::DaysOfMonth(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CDateTime:DaysOfMonth has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_DaysOfMonth'.", &tolua_err);
    return 0;
}
int lua_corelib_CDateTime_ToWeak(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CDateTime",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CDateTime:ToWeak");
        if(!ok)
            return 0;
        int ret = (int)GXMISC::CDateTime::ToWeak(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CDateTime:ToWeak has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_ToWeak'.", &tolua_err);
    return 0;
}
int lua_corelib_CDateTime_IsLeapYear(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CDateTime",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CDateTime:IsLeapYear");
        if(!ok)
            return 0;
        bool ret = GXMISC::CDateTime::IsLeapYear(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CDateTime:IsLeapYear has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDateTime_IsLeapYear'.", &tolua_err);
    return 0;
}
int lua_corelib_CDateTime_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDateTime* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CDateTime:CDateTime");

            if (!ok) { break; }
            cobj = new GXMISC::CDateTime(arg0, arg1, arg2);
            tolua_pushusertype(tolua_S,(void*)cobj,"CDateTime");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CDateTime:CDateTime");

            if (!ok) { break; }
            cobj = new GXMISC::CDateTime(arg0, arg1, arg2, arg3);
            tolua_pushusertype(tolua_S,(void*)cobj,"CDateTime");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg4;
            ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CDateTime:CDateTime");

            if (!ok) { break; }
            cobj = new GXMISC::CDateTime(arg0, arg1, arg2, arg3, arg4);
            tolua_pushusertype(tolua_S,(void*)cobj,"CDateTime");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 6) {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg4;
            ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CDateTime:CDateTime");

            if (!ok) { break; }
            int arg5;
            ok &= luaval_to_sint32(tolua_S, 7,(sint32*)&arg5, "CDateTime:CDateTime");

            if (!ok) { break; }
            cobj = new GXMISC::CDateTime(arg0, arg1, arg2, arg3, arg4, arg5);
            tolua_pushusertype(tolua_S,(void*)cobj,"CDateTime");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CDateTime();
            tolua_pushusertype(tolua_S,(void*)cobj,"CDateTime");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            bool arg0;
            ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CDateTime:CDateTime");

            if (!ok) { break; }
            cobj = new GXMISC::CDateTime(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CDateTime");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            long long arg0;
            ok &= luaval_to_sint64(tolua_S, 2,(sint64*)&arg0, "CDateTime:CDateTime");

            if (!ok) { break; }
            cobj = new GXMISC::CDateTime(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CDateTime");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CDateTime:CDateTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CDateTime_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDateTime)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDateTime",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CDateTime* self = (GXMISC::CDateTime*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CDateTime(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDateTime");
    tolua_cclass(tolua_S,"CDateTime","CDateTime","",lua_corelib_CDateTime_finalize);

    tolua_beginmodule(tolua_S,"CDateTime");
        tolua_function(tolua_S,"new",lua_corelib_CDateTime_constructor);
        tolua_function(tolua_S,"week",lua_corelib_CDateTime_week);
        tolua_function(tolua_S,"dayOfWeek",lua_corelib_CDateTime_dayOfWeek);
        tolua_function(tolua_S,"isAM",lua_corelib_CDateTime_isAM);
        tolua_function(tolua_S,"totalMins",lua_corelib_CDateTime_totalMins);
        tolua_function(tolua_S,"totalDays",lua_corelib_CDateTime_totalDays);
        tolua_function(tolua_S,"hour",lua_corelib_CDateTime_hour);
        tolua_function(tolua_S,"isPM",lua_corelib_CDateTime_isPM);
        tolua_function(tolua_S,"totalSecs",lua_corelib_CDateTime_totalSecs);
        tolua_function(tolua_S,"minute",lua_corelib_CDateTime_minute);
        tolua_function(tolua_S,"update",lua_corelib_CDateTime_update);
        tolua_function(tolua_S,"month",lua_corelib_CDateTime_month);
        tolua_function(tolua_S,"totalHours",lua_corelib_CDateTime_totalHours);
        tolua_function(tolua_S,"hourAMPM",lua_corelib_CDateTime_hourAMPM);
        tolua_function(tolua_S,"second",lua_corelib_CDateTime_second);
        tolua_function(tolua_S,"dayOfYear",lua_corelib_CDateTime_dayOfYear);
        tolua_function(tolua_S,"year",lua_corelib_CDateTime_year);
        tolua_function(tolua_S,"utcTime",lua_corelib_CDateTime_utcTime);
        tolua_function(tolua_S,"day",lua_corelib_CDateTime_day);
        tolua_function(tolua_S,"IsValid", lua_corelib_CDateTime_IsValid);
        tolua_function(tolua_S,"DaysOfMonth", lua_corelib_CDateTime_DaysOfMonth);
        tolua_function(tolua_S,"ToWeak", lua_corelib_CDateTime_ToWeak);
        tolua_function(tolua_S,"IsLeapYear", lua_corelib_CDateTime_IsLeapYear);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CDateTime).name();
    g_luaType[typeName] = "CDateTime";
    g_typeCast["CDateTime"] = "CDateTime";
    return 1;
}

int lua_corelib_CTimeManager_getWeek(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_getWeek'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getWeek();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:getWeek has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_getWeek'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_getHour(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_getHour'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getHour();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:getHour has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_getHour'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_getYear(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_getYear'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getYear();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:getYear has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_getYear'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_getMonth(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_getMonth'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMonth();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:getMonth has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_getMonth'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_time2Number(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_time2Number'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->time2Number();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:time2Number has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_time2Number'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_nowSysTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_nowSysTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->nowSysTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:nowSysTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_nowSysTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_getSecond(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_getSecond'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getSecond();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:getSecond has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_getSecond'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_update(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        long long ret = cobj->update();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }

    gxError("CTimeManager:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_update'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_getDay(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_getDay'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getDay();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:getDay has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_getDay'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_toStandardTimeFormat(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_corelib_CTimeManager_toStandardTimeFormat'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            const char* ret = cobj->toStandardTimeFormat();
            tolua_pushstring(tolua_S,(const char*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string arg0;
            ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CTimeManager:toStandardTimeFormat");

            if (!ok) { break; }
            const char* ret = cobj->toStandardTimeFormat(arg0);
            tolua_pushstring(tolua_S,(const char*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CTimeManager:toStandardTimeFormat has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_toStandardTimeFormat'.",&tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_runTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_runTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        long long ret = cobj->runTime();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }

    gxError("CTimeManager:runTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_runTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_getMinute(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_getMinute'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMinute();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:getMinute has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_getMinute'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_localTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_localTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->localTime();
        return 0;
    }

    gxError("CTimeManager:localTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_localTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_nowAppTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_nowAppTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        long long ret = cobj->nowAppTime();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }

    gxError("CTimeManager:nowAppTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_nowAppTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_getANSITime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_getANSITime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getANSITime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:getANSITime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_getANSITime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_startAppTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_startAppTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        long long ret = cobj->startAppTime();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }

    gxError("CTimeManager:startAppTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_startAppTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_getTodayTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_getTodayTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getTodayTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:getTodayTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_getTodayTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_getLocalWeek(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_getLocalWeek'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getLocalWeek();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:getLocalWeek has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_getLocalWeek'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_getLocalMonth(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_getLocalMonth'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getLocalMonth();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:getLocalMonth has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_getLocalMonth'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_getDayTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_getDayTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getDayTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:getDayTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_getDayTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_currentDate(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimeManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimeManager_currentDate'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->currentDate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimeManager:currentDate has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_currentDate'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimeManager_getHumanRelativeTime(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTimeManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTimeManager:getHumanRelativeTime");
        if(!ok)
            return 0;
        std::string ret = GXMISC::CTimeManager::getHumanRelativeTime(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }
    gxError("CTimeManager:getHumanRelativeTime has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_getHumanRelativeTime'.", &tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_LocalNowTime(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTimeManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        unsigned int ret = GXMISC::CTimeManager::LocalNowTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CTimeManager:LocalNowTime has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_LocalNowTime'.", &tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_ToLocalTime(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTimeManager",0,&tolua_err)) goto tolua_lerror;

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 0)
        {
            unsigned int ret = GXMISC::CTimeManager::ToLocalTime();
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 1)
        {
            long long arg0;
            ok &= luaval_to_sint64(tolua_S, 2,(sint64*)&arg0, "CTimeManager:ToLocalTime");
            if (!ok) { break; }
            unsigned int ret = GXMISC::CTimeManager::ToLocalTime(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    } while (0);
    ok  = true;

    gxError("CTimeManager:ToLocalTime has wrong number of arguments: {0}, was expecting {1}",argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_ToLocalTime'.",&tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_GetTimeUTCDiff(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTimeManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        unsigned int ret = GXMISC::CTimeManager::GetTimeUTCDiff();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CTimeManager:GetTimeUTCDiff has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_GetTimeUTCDiff'.", &tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_FormatSystemTime(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTimeManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        long long arg0;
        std::string arg1;
        ok &= luaval_to_sint64(tolua_S, 2,(sint64*)&arg0, "CTimeManager:FormatSystemTime");
        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CTimeManager:FormatSystemTime");
        if(!ok)
            return 0;
        GXMISC::CTimeManager::FormatSystemTime(arg0, arg1);
        return 0;
    }
    gxError("CTimeManager:FormatSystemTime has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_FormatSystemTime'.", &tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_DiffTime(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTimeManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        unsigned int arg0;
        unsigned int arg1;
        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimeManager:DiffTime");
        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CTimeManager:DiffTime");
        if(!ok)
            return 0;
        unsigned int ret = GXMISC::CTimeManager::DiffTime(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CTimeManager:DiffTime has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_DiffTime'.", &tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_SysNowTime(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTimeManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        unsigned int ret = GXMISC::CTimeManager::SysNowTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CTimeManager:SysNowTime has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_SysNowTime'.", &tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_ConvertTU(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTimeManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        tm* arg0;
        unsigned int arg1;
        ok &= luaval_to_object<tm>(tolua_S, 2, "tm", &arg0, "CTimeManager:ConvertTU");
        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CTimeManager:ConvertTU");
        if(!ok)
            return 0;
        GXMISC::CTimeManager::ConvertTU(arg0, arg1);
        return 0;
    }
    gxError("CTimeManager:ConvertTU has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_ConvertTU'.", &tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_FormatTodayTime(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTimeManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned int arg0;
        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimeManager:FormatTodayTime");
        if(!ok)
            return 0;
        bool ret = GXMISC::CTimeManager::FormatTodayTime(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CTimeManager:FormatTodayTime has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_FormatTodayTime'.", &tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_ConvertUT(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTimeManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        unsigned int arg0;
        tm* arg1;
        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimeManager:ConvertUT");
        ok &= luaval_to_object<tm>(tolua_S, 3, "tm", &arg1, "CTimeManager:ConvertUT");
        if(!ok)
            return 0;
        GXMISC::CTimeManager::ConvertUT(arg0, arg1);
        return 0;
    }
    gxError("CTimeManager:ConvertUT has wrong number of arguments: {0}, was expecting {1}\n ", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_ConvertUT'.", &tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_GxToAnsiTime(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTimeManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned int arg0;
        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimeManager:GxToAnsiTime");
        if(!ok)
            return 0;
        long long ret = GXMISC::CTimeManager::GxToAnsiTime(arg0);
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }
    gxError("CTimeManager:GxToAnsiTime has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_GxToAnsiTime'.", &tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_AppNowTime(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTimeManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        long long ret = GXMISC::CTimeManager::AppNowTime();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }
    gxError("CTimeManager:AppNowTime has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_AppNowTime'.", &tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_AnsiToGxTime(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CTimeManager",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        long long arg0;
        ok &= luaval_to_sint64(tolua_S, 2,(sint64*)&arg0, "CTimeManager:AnsiToGxTime");
        if(!ok)
            return 0;
        unsigned int ret = GXMISC::CTimeManager::AnsiToGxTime(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    gxError("CTimeManager:AnsiToGxTime has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimeManager_AnsiToGxTime'.", &tolua_err);
    return 0;
}
int lua_corelib_CTimeManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimeManager* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CTimeManager();
        tolua_pushusertype(tolua_S,(void*)cobj,"CTimeManager");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CTimeManager:CTimeManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CTimeManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTimeManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTimeManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CTimeManager* self = (GXMISC::CTimeManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CTimeManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTimeManager");
    tolua_cclass(tolua_S,"CTimeManager","CTimeManager","",lua_corelib_CTimeManager_finalize);

    tolua_beginmodule(tolua_S,"CTimeManager");
        tolua_function(tolua_S,"new",lua_corelib_CTimeManager_constructor);
        tolua_function(tolua_S,"getWeek",lua_corelib_CTimeManager_getWeek);
        tolua_function(tolua_S,"getHour",lua_corelib_CTimeManager_getHour);
        tolua_function(tolua_S,"getYear",lua_corelib_CTimeManager_getYear);
        tolua_function(tolua_S,"getMonth",lua_corelib_CTimeManager_getMonth);
        tolua_function(tolua_S,"time2Number",lua_corelib_CTimeManager_time2Number);
        tolua_function(tolua_S,"nowSysTime",lua_corelib_CTimeManager_nowSysTime);
        tolua_function(tolua_S,"getSecond",lua_corelib_CTimeManager_getSecond);
        tolua_function(tolua_S,"update",lua_corelib_CTimeManager_update);
        tolua_function(tolua_S,"getDay",lua_corelib_CTimeManager_getDay);
        tolua_function(tolua_S,"toStandardTimeFormat",lua_corelib_CTimeManager_toStandardTimeFormat);
        tolua_function(tolua_S,"runTime",lua_corelib_CTimeManager_runTime);
        tolua_function(tolua_S,"getMinute",lua_corelib_CTimeManager_getMinute);
        tolua_function(tolua_S,"localTime",lua_corelib_CTimeManager_localTime);
        tolua_function(tolua_S,"nowAppTime",lua_corelib_CTimeManager_nowAppTime);
        tolua_function(tolua_S,"getANSITime",lua_corelib_CTimeManager_getANSITime);
        tolua_function(tolua_S,"startAppTime",lua_corelib_CTimeManager_startAppTime);
        tolua_function(tolua_S,"getTodayTime",lua_corelib_CTimeManager_getTodayTime);
        tolua_function(tolua_S,"getLocalWeek",lua_corelib_CTimeManager_getLocalWeek);
        tolua_function(tolua_S,"getLocalMonth",lua_corelib_CTimeManager_getLocalMonth);
        tolua_function(tolua_S,"getDayTime",lua_corelib_CTimeManager_getDayTime);
        tolua_function(tolua_S,"currentDate",lua_corelib_CTimeManager_currentDate);
        tolua_function(tolua_S,"getHumanRelativeTime", lua_corelib_CTimeManager_getHumanRelativeTime);
        tolua_function(tolua_S,"LocalNowTime", lua_corelib_CTimeManager_LocalNowTime);
        tolua_function(tolua_S,"ToLocalTime", lua_corelib_CTimeManager_ToLocalTime);
        tolua_function(tolua_S,"GetTimeUTCDiff", lua_corelib_CTimeManager_GetTimeUTCDiff);
        tolua_function(tolua_S,"FormatSystemTime", lua_corelib_CTimeManager_FormatSystemTime);
        tolua_function(tolua_S,"DiffTime", lua_corelib_CTimeManager_DiffTime);
        tolua_function(tolua_S,"SysNowTime", lua_corelib_CTimeManager_SysNowTime);
        tolua_function(tolua_S,"ConvertTU", lua_corelib_CTimeManager_ConvertTU);
        tolua_function(tolua_S,"FormatTodayTime", lua_corelib_CTimeManager_FormatTodayTime);
        tolua_function(tolua_S,"ConvertUT", lua_corelib_CTimeManager_ConvertUT);
        tolua_function(tolua_S,"GxToAnsiTime", lua_corelib_CTimeManager_GxToAnsiTime);
        tolua_function(tolua_S,"AppNowTime", lua_corelib_CTimeManager_AppNowTime);
        tolua_function(tolua_S,"AnsiToGxTime", lua_corelib_CTimeManager_AnsiToGxTime);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CTimeManager).name();
    g_luaType[typeName] = "CTimeManager";
    g_typeCast["CTimeManager"] = "CTimeManager";
    return 1;
}

int lua_corelib_CGxContext_getMainThread(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_getMainThread'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getMainThread();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CGxContext:getMainThread has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_getMainThread'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_getStopSigno(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_getStopSigno'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getStopSigno();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGxContext:getStopSigno has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_getStopSigno'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_getStopHandler(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_getStopHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::IStopHandler* ret = cobj->getStopHandler();
        object_to_luaval<GXMISC::IStopHandler>(tolua_S, "IStopHandler",(GXMISC::IStopHandler*)ret);
        return 1;
    }

    gxError("CGxContext:getStopHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_getStopHandler'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_callOnCrash(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_callOnCrash'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CGxContext:callOnCrash");
        if(!ok)
            return 0;
        cobj->callOnCrash(arg0);
        return 0;
    }

    gxError("CGxContext:callOnCrash has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_callOnCrash'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_clear(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_clear'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->clear();
        return 0;
    }

    gxError("CGxContext:clear has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_clear'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_getMainLog(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_getMainLog'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CLogger* ret = cobj->getMainLog();
        object_to_luaval<GXMISC::CLogger>(tolua_S, "CLogger",(GXMISC::CLogger*)ret);
        return 1;
    }

    gxError("CGxContext:getMainLog has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_getMainLog'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_update(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGxContext:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CGxContext:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_update'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_getFastLogThread(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_getFastLogThread'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getFastLogThread();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CGxContext:getFastLogThread has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_getFastLogThread'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CGxContext:init");
        if(!ok)
            return 0;
        bool ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGxContext:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_init'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_setFastLogThread(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_setFastLogThread'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CGxContext:setFastLogThread");
        if(!ok)
            return 0;
        cobj->setFastLogThread(arg0);
        return 0;
    }

    gxError("CGxContext:setFastLogThread has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_setFastLogThread'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_setServerName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_setServerName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CGxContext:setServerName");
        if(!ok)
            return 0;
        cobj->setServerName(arg0);
        return 0;
    }

    gxError("CGxContext:setServerName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_setServerName'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_getServerName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_getServerName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string& ret = cobj->getServerName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CGxContext:getServerName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_getServerName'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_setStopSigno(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_setStopSigno'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setStopSigno();
        return 0;
    }
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGxContext:setStopSigno");
        if(!ok)
            return 0;
        cobj->setStopSigno(arg0);
        return 0;
    }

    gxError("CGxContext:setStopSigno has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_setStopSigno'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_setDumpHandler(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_setDumpHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::IDumpHandler* arg0;

        ok &= luaval_to_object<GXMISC::IDumpHandler>(tolua_S, 2, "IDumpHandler", &arg0, "CGxContext:setDumpHandler");
        if(!ok)
            return 0;
        cobj->setDumpHandler(arg0);
        return 0;
    }

    gxError("CGxContext:setDumpHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_setDumpHandler'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_setStopHandler(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_setStopHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::IStopHandler* arg0;

        ok &= luaval_to_object<GXMISC::IStopHandler>(tolua_S, 2, "IStopHandler", &arg0, "CGxContext:setStopHandler");
        if(!ok)
            return 0;
        cobj->setStopHandler(arg0);
        return 0;
    }

    gxError("CGxContext:setStopHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_setStopHandler'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_exitCallback(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGxContext*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGxContext_exitCallback'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        EExitCode arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGxContext:exitCallback");
        if(!ok)
            return 0;
        cobj->exitCallback(arg0);
        return 0;
    }

    gxError("CGxContext:exitCallback has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_exitCallback'.",&tolua_err);
	return 0;
}
int lua_corelib_CGxContext_StopService(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGxContext",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        GXMISC::CGxContext::StopService();
        return 0;
    }
    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CGxContext:StopService");
        if(!ok)
            return 0;
        GXMISC::CGxContext::StopService(arg0);
        return 0;
    }
    gxError("CGxContext:StopService has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_StopService'.", &tolua_err);
    return 0;
}
int lua_corelib_CGxContext_GetStack(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CGxContext",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string arg0;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CGxContext:GetStack");
        if(!ok)
            return 0;
        GXMISC::CGxContext::GetStack(arg0);
        return 0;
    }
    gxError("CGxContext:GetStack has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGxContext_GetStack'.", &tolua_err);
    return 0;
}
int lua_corelib_CGxContext_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxContext* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CGxContext:CGxContext");
        if(!ok)
            return 0;
        cobj = new GXMISC::CGxContext(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CGxContext");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CGxContext:CGxContext has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CGxContext_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGxContext)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGxContext",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CGxContext* self = (GXMISC::CGxContext*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CGxContext(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGxContext");
    tolua_cclass(tolua_S,"CGxContext","CGxContext","CManualSingleton<CGxContext>",lua_corelib_CGxContext_finalize);

    tolua_beginmodule(tolua_S,"CGxContext");
        tolua_function(tolua_S,"new",lua_corelib_CGxContext_constructor);
        tolua_function(tolua_S,"getMainThread",lua_corelib_CGxContext_getMainThread);
        tolua_function(tolua_S,"getStopSigno",lua_corelib_CGxContext_getStopSigno);
        tolua_function(tolua_S,"getStopHandler",lua_corelib_CGxContext_getStopHandler);
        tolua_function(tolua_S,"callOnCrash",lua_corelib_CGxContext_callOnCrash);
        tolua_function(tolua_S,"clear",lua_corelib_CGxContext_clear);
        tolua_function(tolua_S,"getMainLog",lua_corelib_CGxContext_getMainLog);
        tolua_function(tolua_S,"update",lua_corelib_CGxContext_update);
        tolua_function(tolua_S,"getFastLogThread",lua_corelib_CGxContext_getFastLogThread);
        tolua_function(tolua_S,"init",lua_corelib_CGxContext_init);
        tolua_function(tolua_S,"setFastLogThread",lua_corelib_CGxContext_setFastLogThread);
        tolua_function(tolua_S,"setServerName",lua_corelib_CGxContext_setServerName);
        tolua_function(tolua_S,"getServerName",lua_corelib_CGxContext_getServerName);
        tolua_function(tolua_S,"setStopSigno",lua_corelib_CGxContext_setStopSigno);
        tolua_function(tolua_S,"setDumpHandler",lua_corelib_CGxContext_setDumpHandler);
        tolua_function(tolua_S,"setStopHandler",lua_corelib_CGxContext_setStopHandler);
        tolua_function(tolua_S,"exitCallback",lua_corelib_CGxContext_exitCallback);
        tolua_function(tolua_S,"StopService", lua_corelib_CGxContext_StopService);
        tolua_function(tolua_S,"GetStack", lua_corelib_CGxContext_GetStack);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CGxContext).name();
    g_luaType[typeName] = "CGxContext";
    g_typeCast["CGxContext"] = "CGxContext";
    return 1;
}

int lua_corelib_CLogger_addNegativeFilter(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_addNegativeFilter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CLogger:addNegativeFilter"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        cobj->addNegativeFilter(arg0);
        return 0;
    }

    gxError("CLogger:addNegativeFilter has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_addNegativeFilter'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_displayFilter(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_displayFilter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CLogger* arg0;

        ok &= luaval_to_object<GXMISC::CLogger>(tolua_S, 2, "CLogger", &arg0, "CLogger:displayFilter");
        if(!ok)
            return 0;
        cobj->displayFilter(arg0);
        return 0;
    }

    gxError("CLogger:displayFilter has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_displayFilter'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_resetFilters(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_resetFilters'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->resetFilters();
        return 0;
    }

    gxError("CLogger:resetFilters has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_resetFilters'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_flush(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_flush'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->flush();
        return 0;
    }

    gxError("CLogger:flush has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_flush'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_attached(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_attached'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::IDisplayer* arg0;

        ok &= luaval_to_object<GXMISC::IDisplayer>(tolua_S, 2, "IDisplayer", &arg0, "CLogger:attached");
        if(!ok)
            return 0;
        bool ret = cobj->attached(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CLogger:attached has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_attached'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_update(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CLogger:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CLogger:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_update'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_removeFilter(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_removeFilter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->removeFilter();
        return 0;
    }
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CLogger:removeFilter"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        cobj->removeFilter(arg0);
        return 0;
    }

    gxError("CLogger:removeFilter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_removeFilter'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_addPositiveFilter(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_addPositiveFilter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CLogger:addPositiveFilter"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        cobj->addPositiveFilter(arg0);
        return 0;
    }

    gxError("CLogger:addPositiveFilter has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_addPositiveFilter'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_removeDisplayer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_corelib_CLogger_removeDisplayer'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CLogger:removeDisplayer"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            cobj->removeDisplayer(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            GXMISC::IDisplayer* arg0;
            ok &= luaval_to_object<GXMISC::IDisplayer>(tolua_S, 2, "IDisplayer", &arg0, "CLogger:removeDisplayer");

            if (!ok) { break; }
            cobj->removeDisplayer(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CLogger:removeDisplayer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_removeDisplayer'.",&tolua_err);
    return 0;
}
int lua_corelib_CLogger_synLog(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_synLog'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CLogger:synLog");
        if(!ok)
            return 0;
        cobj->synLog(arg0);
        return 0;
    }

    gxError("CLogger:synLog has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_synLog'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_calcLogNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_calcLogNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->calcLogNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLogger:calcLogNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_calcLogNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_setPosition(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_setPosition'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        GXMISC::CLogger::ELogType arg0;
        bool arg1;
        int arg2;
        const char* arg3;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLogger:setPosition");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CLogger:setPosition");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CLogger:setPosition");

        CScriptString arg3_tmp; ok &= luaval_to_script_string(tolua_S, 5, &arg3_tmp, "CLogger:setPosition"); arg3 = (char*)arg3_tmp.buffer;
        if(!ok)
            return 0;
        cobj->setPosition(arg0, arg1, arg2, arg3);
        return 0;
    }
    if (argc == 5) 
    {
        GXMISC::CLogger::ELogType arg0;
        bool arg1;
        int arg2;
        const char* arg3;
        const char* arg4;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLogger:setPosition");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CLogger:setPosition");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CLogger:setPosition");

        CScriptString arg3_tmp; ok &= luaval_to_script_string(tolua_S, 5, &arg3_tmp, "CLogger:setPosition"); arg3 = (char*)arg3_tmp.buffer;

        CScriptString arg4_tmp; ok &= luaval_to_script_string(tolua_S, 6, &arg4_tmp, "CLogger:setPosition"); arg4 = (char*)arg4_tmp.buffer;
        if(!ok)
            return 0;
        cobj->setPosition(arg0, arg1, arg2, arg3, arg4);
        return 0;
    }
    if (argc == 6) 
    {
        GXMISC::CLogger::ELogType arg0;
        bool arg1;
        int arg2;
        const char* arg3;
        const char* arg4;
        const char* arg5;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLogger:setPosition");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CLogger:setPosition");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CLogger:setPosition");

        CScriptString arg3_tmp; ok &= luaval_to_script_string(tolua_S, 5, &arg3_tmp, "CLogger:setPosition"); arg3 = (char*)arg3_tmp.buffer;

        CScriptString arg4_tmp; ok &= luaval_to_script_string(tolua_S, 6, &arg4_tmp, "CLogger:setPosition"); arg4 = (char*)arg4_tmp.buffer;

        CScriptString arg5_tmp; ok &= luaval_to_script_string(tolua_S, 7, &arg5_tmp, "CLogger:setPosition"); arg5 = (char*)arg5_tmp.buffer;
        if(!ok)
            return 0;
        cobj->setPosition(arg0, arg1, arg2, arg3, arg4, arg5);
        return 0;
    }
    if (argc == 7) 
    {
        GXMISC::CLogger::ELogType arg0;
        bool arg1;
        int arg2;
        const char* arg3;
        const char* arg4;
        const char* arg5;
        bool arg6;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLogger:setPosition");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CLogger:setPosition");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CLogger:setPosition");

        CScriptString arg3_tmp; ok &= luaval_to_script_string(tolua_S, 5, &arg3_tmp, "CLogger:setPosition"); arg3 = (char*)arg3_tmp.buffer;

        CScriptString arg4_tmp; ok &= luaval_to_script_string(tolua_S, 6, &arg4_tmp, "CLogger:setPosition"); arg4 = (char*)arg4_tmp.buffer;

        CScriptString arg5_tmp; ok &= luaval_to_script_string(tolua_S, 7, &arg5_tmp, "CLogger:setPosition"); arg5 = (char*)arg5_tmp.buffer;

        ok &= luaval_to_boolean(tolua_S, 8,(bool*)&arg6, "CLogger:setPosition");
        if(!ok)
            return 0;
        cobj->setPosition(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
        return 0;
    }

    gxError("CLogger:setPosition has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_setPosition'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_getDisplayer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_getDisplayer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CLogger:getDisplayer"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        GXMISC::IDisplayer* ret = cobj->getDisplayer(arg0);
        object_to_luaval<GXMISC::IDisplayer>(tolua_S, "IDisplayer",(GXMISC::IDisplayer*)ret);
        return 1;
    }

    gxError("CLogger:getDisplayer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_getDisplayer'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_addDisplayer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_addDisplayer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::IDisplayer* arg0;

        ok &= luaval_to_object<GXMISC::IDisplayer>(tolua_S, 2, "IDisplayer", &arg0, "CLogger:addDisplayer");
        if(!ok)
            return 0;
        cobj->addDisplayer(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        GXMISC::IDisplayer* arg0;
        bool arg1;

        ok &= luaval_to_object<GXMISC::IDisplayer>(tolua_S, 2, "IDisplayer", &arg0, "CLogger:addDisplayer");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CLogger:addDisplayer");
        if(!ok)
            return 0;
        cobj->addDisplayer(arg0, arg1);
        return 0;
    }

    gxError("CLogger:addDisplayer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_addDisplayer'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_noDisplayer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLogger*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLogger_noDisplayer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->noDisplayer();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CLogger:noDisplayer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_noDisplayer'.",&tolua_err);
	return 0;
}
int lua_corelib_CLogger_SetProcessName(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CLogger",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string arg0;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CLogger:SetProcessName");
        if(!ok)
            return 0;
        GXMISC::CLogger::SetProcessName(arg0);
        return 0;
    }
    gxError("CLogger:SetProcessName has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_SetProcessName'.", &tolua_err);
    return 0;
}
int lua_corelib_CLogger_SetDefaultProcessName(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CLogger",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        GXMISC::CLogger::SetDefaultProcessName();
        return 0;
    }
    gxError("CLogger:SetDefaultProcessName has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLogger_SetDefaultProcessName'.", &tolua_err);
    return 0;
}
int lua_corelib_CLogger_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLogger* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CLogger();
        tolua_pushusertype(tolua_S,(void*)cobj,"CLogger");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CLogger:CLogger has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CLogger_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLogger)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLogger",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CLogger* self = (GXMISC::CLogger*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CLogger(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLogger");
    tolua_cclass(tolua_S,"CLogger","CLogger","",lua_corelib_CLogger_finalize);

    tolua_beginmodule(tolua_S,"CLogger");
        tolua_function(tolua_S,"new",lua_corelib_CLogger_constructor);
        tolua_function(tolua_S,"addNegativeFilter",lua_corelib_CLogger_addNegativeFilter);
        tolua_function(tolua_S,"displayFilter",lua_corelib_CLogger_displayFilter);
        tolua_function(tolua_S,"resetFilters",lua_corelib_CLogger_resetFilters);
        tolua_function(tolua_S,"flush",lua_corelib_CLogger_flush);
        tolua_function(tolua_S,"attached",lua_corelib_CLogger_attached);
        tolua_function(tolua_S,"update",lua_corelib_CLogger_update);
        tolua_function(tolua_S,"removeFilter",lua_corelib_CLogger_removeFilter);
        tolua_function(tolua_S,"addPositiveFilter",lua_corelib_CLogger_addPositiveFilter);
        tolua_function(tolua_S,"removeDisplayer",lua_corelib_CLogger_removeDisplayer);
        tolua_function(tolua_S,"synLog",lua_corelib_CLogger_synLog);
        tolua_function(tolua_S,"calcLogNum",lua_corelib_CLogger_calcLogNum);
        tolua_function(tolua_S,"setPosition",lua_corelib_CLogger_setPosition);
        tolua_function(tolua_S,"getDisplayer",lua_corelib_CLogger_getDisplayer);
        tolua_function(tolua_S,"addDisplayer",lua_corelib_CLogger_addDisplayer);
        tolua_function(tolua_S,"noDisplayer",lua_corelib_CLogger_noDisplayer);
        tolua_function(tolua_S,"SetProcessName", lua_corelib_CLogger_SetProcessName);
        tolua_function(tolua_S,"SetDefaultProcessName", lua_corelib_CLogger_SetDefaultProcessName);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CLogger).name();
    g_luaType[typeName] = "CLogger";
    g_typeCast["CLogger"] = "CLogger";
    return 1;
}

static int lua_corelib_CSafeLog_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSafeLog)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSafeLog",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSafeLog* self = (GXMISC::CSafeLog*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSafeLog(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSafeLog");
    tolua_cclass(tolua_S,"CSafeLog","CSafeLog","CLogger",nullptr);

    tolua_beginmodule(tolua_S,"CSafeLog");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSafeLog).name();
    g_luaType[typeName] = "CSafeLog";
    g_typeCast["CSafeLog"] = "CSafeLog";
    return 1;
}

int lua_corelib_IDisplayer_leave(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IDisplayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IDisplayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IDisplayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IDisplayer_leave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->leave();
        return 0;
    }

    gxError("IDisplayer:leave has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IDisplayer_leave'.",&tolua_err);
	return 0;
}
int lua_corelib_IDisplayer_isNeedDeleteByLog(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IDisplayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IDisplayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IDisplayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IDisplayer_isNeedDeleteByLog'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNeedDeleteByLog();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IDisplayer:isNeedDeleteByLog has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IDisplayer_isNeedDeleteByLog'.",&tolua_err);
	return 0;
}
int lua_corelib_IDisplayer_getName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IDisplayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IDisplayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IDisplayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IDisplayer_getName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string& ret = cobj->getName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("IDisplayer:getName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IDisplayer_getName'.",&tolua_err);
	return 0;
}
int lua_corelib_IDisplayer_enter(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IDisplayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IDisplayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IDisplayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IDisplayer_enter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->enter();
        return 0;
    }

    gxError("IDisplayer:enter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IDisplayer_enter'.",&tolua_err);
	return 0;
}
int lua_corelib_IDisplayer_DateToHumanString(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"IDisplayer",0,&tolua_err)) goto tolua_lerror;

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 1)
        {
            long long arg0;
            ok &= luaval_to_sint64(tolua_S, 2,(sint64*)&arg0, "IDisplayer:DateToHumanString");
            if (!ok) { break; }
            const char* ret = GXMISC::IDisplayer::DateToHumanString(arg0);
            tolua_pushstring(tolua_S,(const char*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 0)
        {
            const char* ret = GXMISC::IDisplayer::DateToHumanString();
            tolua_pushstring(tolua_S,(const char*)ret);
            return 1;
        }
    } while (0);
    ok  = true;

    gxError("IDisplayer:DateToHumanString has wrong number of arguments: {0}, was expecting {1}",argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IDisplayer_DateToHumanString'.",&tolua_err);
    return 0;
}
int lua_corelib_IDisplayer_LogTypeToString(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"IDisplayer",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        GXMISC::CLogger::ELogType arg0;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IDisplayer:LogTypeToString");
        if(!ok)
            return 0;
        const char* ret = GXMISC::IDisplayer::LogTypeToString(arg0);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }
    if (argc == 2)
    {
        GXMISC::CLogger::ELogType arg0;
        bool arg1;
        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IDisplayer:LogTypeToString");
        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "IDisplayer:LogTypeToString");
        if(!ok)
            return 0;
        const char* ret = GXMISC::IDisplayer::LogTypeToString(arg0, arg1);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }
    gxError("IDisplayer:LogTypeToString has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IDisplayer_LogTypeToString'.", &tolua_err);
    return 0;
}
int lua_corelib_IDisplayer_IsSyncString(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"IDisplayer",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        bool arg0;
        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "IDisplayer:IsSyncString");
        if(!ok)
            return 0;
        const char* ret = GXMISC::IDisplayer::IsSyncString(arg0);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }
    gxError("IDisplayer:IsSyncString has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IDisplayer_IsSyncString'.", &tolua_err);
    return 0;
}
int lua_corelib_IDisplayer_DateToComputerString(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"IDisplayer",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        long long arg0;
        ok &= luaval_to_sint64(tolua_S, 2,(sint64*)&arg0, "IDisplayer:DateToComputerString");
        if(!ok)
            return 0;
        const char* ret = GXMISC::IDisplayer::DateToComputerString(arg0);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }
    gxError("IDisplayer:DateToComputerString has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IDisplayer_DateToComputerString'.", &tolua_err);
    return 0;
}
static int lua_corelib_IDisplayer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IDisplayer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IDisplayer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IDisplayer* self = (GXMISC::IDisplayer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IDisplayer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IDisplayer");
    tolua_cclass(tolua_S,"IDisplayer","IDisplayer","",nullptr);

    tolua_beginmodule(tolua_S,"IDisplayer");
        tolua_function(tolua_S,"leave",lua_corelib_IDisplayer_leave);
        tolua_function(tolua_S,"isNeedDeleteByLog",lua_corelib_IDisplayer_isNeedDeleteByLog);
        tolua_function(tolua_S,"getName",lua_corelib_IDisplayer_getName);
        tolua_function(tolua_S,"enter",lua_corelib_IDisplayer_enter);
        tolua_function(tolua_S,"DateToHumanString", lua_corelib_IDisplayer_DateToHumanString);
        tolua_function(tolua_S,"LogTypeToString", lua_corelib_IDisplayer_LogTypeToString);
        tolua_function(tolua_S,"IsSyncString", lua_corelib_IDisplayer_IsSyncString);
        tolua_function(tolua_S,"DateToComputerString", lua_corelib_IDisplayer_DateToComputerString);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IDisplayer).name();
    g_luaType[typeName] = "IDisplayer";
    g_typeCast["IDisplayer"] = "IDisplayer";
    return 1;
}

int lua_corelib_CStdDisplayer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CStdDisplayer* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CStdDisplayer();
        tolua_pushusertype(tolua_S,(void*)cobj,"CStdDisplayer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CStdDisplayer:CStdDisplayer");
        if(!ok)
            return 0;
        cobj = new GXMISC::CStdDisplayer(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CStdDisplayer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 2) 
    {
        bool arg0;
        const char* arg1;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CStdDisplayer:CStdDisplayer");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CStdDisplayer:CStdDisplayer"); arg1 = (char*)arg1_tmp.buffer;
        if(!ok)
            return 0;
        cobj = new GXMISC::CStdDisplayer(arg0, arg1);
        tolua_pushusertype(tolua_S,(void*)cobj,"CStdDisplayer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 3) 
    {
        bool arg0;
        const char* arg1;
        bool arg2;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CStdDisplayer:CStdDisplayer");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CStdDisplayer:CStdDisplayer"); arg1 = (char*)arg1_tmp.buffer;

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CStdDisplayer:CStdDisplayer");
        if(!ok)
            return 0;
        cobj = new GXMISC::CStdDisplayer(arg0, arg1, arg2);
        tolua_pushusertype(tolua_S,(void*)cobj,"CStdDisplayer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CStdDisplayer:CStdDisplayer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CStdDisplayer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CStdDisplayer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CStdDisplayer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CStdDisplayer* self = (GXMISC::CStdDisplayer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CStdDisplayer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CStdDisplayer");
    tolua_cclass(tolua_S,"CStdDisplayer","CStdDisplayer","IDisplayer",lua_corelib_CStdDisplayer_finalize);

    tolua_beginmodule(tolua_S,"CStdDisplayer");
        tolua_function(tolua_S,"new",lua_corelib_CStdDisplayer_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CStdDisplayer).name();
    g_luaType[typeName] = "CStdDisplayer";
    g_typeCast["CStdDisplayer"] = "CStdDisplayer";
    return 1;
}

int lua_corelib_CSafeStdDisplayer_leave(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSafeStdDisplayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSafeStdDisplayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSafeStdDisplayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSafeStdDisplayer_leave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->leave();
        return 0;
    }

    gxError("CSafeStdDisplayer:leave has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSafeStdDisplayer_leave'.",&tolua_err);
	return 0;
}
int lua_corelib_CSafeStdDisplayer_enter(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSafeStdDisplayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSafeStdDisplayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSafeStdDisplayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSafeStdDisplayer_enter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->enter();
        return 0;
    }

    gxError("CSafeStdDisplayer:enter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSafeStdDisplayer_enter'.",&tolua_err);
	return 0;
}
int lua_corelib_CSafeStdDisplayer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSafeStdDisplayer* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CSafeStdDisplayer();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSafeStdDisplayer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CSafeStdDisplayer:CSafeStdDisplayer");
        if(!ok)
            return 0;
        cobj = new GXMISC::CSafeStdDisplayer(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CSafeStdDisplayer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 2) 
    {
        bool arg0;
        const char* arg1;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CSafeStdDisplayer:CSafeStdDisplayer");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CSafeStdDisplayer:CSafeStdDisplayer"); arg1 = (char*)arg1_tmp.buffer;
        if(!ok)
            return 0;
        cobj = new GXMISC::CSafeStdDisplayer(arg0, arg1);
        tolua_pushusertype(tolua_S,(void*)cobj,"CSafeStdDisplayer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 3) 
    {
        bool arg0;
        const char* arg1;
        bool arg2;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CSafeStdDisplayer:CSafeStdDisplayer");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CSafeStdDisplayer:CSafeStdDisplayer"); arg1 = (char*)arg1_tmp.buffer;

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CSafeStdDisplayer:CSafeStdDisplayer");
        if(!ok)
            return 0;
        cobj = new GXMISC::CSafeStdDisplayer(arg0, arg1, arg2);
        tolua_pushusertype(tolua_S,(void*)cobj,"CSafeStdDisplayer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSafeStdDisplayer:CSafeStdDisplayer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CSafeStdDisplayer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSafeStdDisplayer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSafeStdDisplayer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSafeStdDisplayer* self = (GXMISC::CSafeStdDisplayer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSafeStdDisplayer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSafeStdDisplayer");
    tolua_cclass(tolua_S,"CSafeStdDisplayer","CSafeStdDisplayer","CStdDisplayer",lua_corelib_CSafeStdDisplayer_finalize);

    tolua_beginmodule(tolua_S,"CSafeStdDisplayer");
        tolua_function(tolua_S,"new",lua_corelib_CSafeStdDisplayer_constructor);
        tolua_function(tolua_S,"leave",lua_corelib_CSafeStdDisplayer_leave);
        tolua_function(tolua_S,"enter",lua_corelib_CSafeStdDisplayer_enter);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSafeStdDisplayer).name();
    g_luaType[typeName] = "CSafeStdDisplayer";
    g_typeCast["CSafeStdDisplayer"] = "CSafeStdDisplayer";
    return 1;
}

int lua_corelib_CFileDisplayer_setParam(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CFileDisplayer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CFileDisplayer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CFileDisplayer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CFileDisplayer_setParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CFileDisplayer:setParam");
        if(!ok)
            return 0;
        cobj->setParam(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        std::string arg0;
        unsigned int arg1;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CFileDisplayer:setParam");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CFileDisplayer:setParam");
        if(!ok)
            return 0;
        cobj->setParam(arg0, arg1);
        return 0;
    }
    if (argc == 3) 
    {
        std::string arg0;
        unsigned int arg1;
        bool arg2;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CFileDisplayer:setParam");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CFileDisplayer:setParam");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CFileDisplayer:setParam");
        if(!ok)
            return 0;
        cobj->setParam(arg0, arg1, arg2);
        return 0;
    }

    gxError("CFileDisplayer:setParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CFileDisplayer_setParam'.",&tolua_err);
	return 0;
}
int lua_corelib_CFileDisplayer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CFileDisplayer* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            bool arg0;
            ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            cobj = new GXMISC::CFileDisplayer(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CFileDisplayer");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            bool arg0;
            ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            std::string arg1;
            ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            cobj = new GXMISC::CFileDisplayer(arg0, arg1);
            tolua_pushusertype(tolua_S,(void*)cobj,"CFileDisplayer");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            bool arg0;
            ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            std::string arg1;
            ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            unsigned int arg2;
            ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            cobj = new GXMISC::CFileDisplayer(arg0, arg1, arg2);
            tolua_pushusertype(tolua_S,(void*)cobj,"CFileDisplayer");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            bool arg0;
            ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            std::string arg1;
            ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            unsigned int arg2;
            ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            cobj = new GXMISC::CFileDisplayer(arg0, arg1, arg2, arg3);
            tolua_pushusertype(tolua_S,(void*)cobj,"CFileDisplayer");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            bool arg0;
            ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            std::string arg1;
            ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            unsigned int arg2;
            ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            bool arg4;
            ok &= luaval_to_boolean(tolua_S, 6,(bool*)&arg4, "CFileDisplayer:CFileDisplayer");

            if (!ok) { break; }
            cobj = new GXMISC::CFileDisplayer(arg0, arg1, arg2, arg3, arg4);
            tolua_pushusertype(tolua_S,(void*)cobj,"CFileDisplayer");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CFileDisplayer:CFileDisplayer has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

}

static int lua_corelib_CFileDisplayer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CFileDisplayer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CFileDisplayer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CFileDisplayer* self = (GXMISC::CFileDisplayer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CFileDisplayer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CFileDisplayer");
    tolua_cclass(tolua_S,"CFileDisplayer","CFileDisplayer","IDisplayer",lua_corelib_CFileDisplayer_finalize);

    tolua_beginmodule(tolua_S,"CFileDisplayer");
        tolua_function(tolua_S,"new",lua_corelib_CFileDisplayer_constructor);
        tolua_function(tolua_S,"setParam",lua_corelib_CFileDisplayer_setParam);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CFileDisplayer).name();
    g_luaType[typeName] = "CFileDisplayer";
    g_typeCast["CFileDisplayer"] = "CFileDisplayer";
    return 1;
}

int lua_corelib_CSafeFileDispalyer_leave(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSafeFileDispalyer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSafeFileDispalyer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSafeFileDispalyer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSafeFileDispalyer_leave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->leave();
        return 0;
    }

    gxError("CSafeFileDispalyer:leave has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSafeFileDispalyer_leave'.",&tolua_err);
	return 0;
}
int lua_corelib_CSafeFileDispalyer_enter(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSafeFileDispalyer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSafeFileDispalyer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSafeFileDispalyer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSafeFileDispalyer_enter'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->enter();
        return 0;
    }

    gxError("CSafeFileDispalyer:enter has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSafeFileDispalyer_enter'.",&tolua_err);
	return 0;
}
int lua_corelib_CSafeFileDispalyer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSafeFileDispalyer* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        bool arg0;
        std::string arg1;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CSafeFileDispalyer:CSafeFileDispalyer");

        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CSafeFileDispalyer:CSafeFileDispalyer");
        if(!ok)
            return 0;
        cobj = new GXMISC::CSafeFileDispalyer(arg0, arg1);
        tolua_pushusertype(tolua_S,(void*)cobj,"CSafeFileDispalyer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 3) 
    {
        bool arg0;
        std::string arg1;
        unsigned int arg2;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CSafeFileDispalyer:CSafeFileDispalyer");

        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CSafeFileDispalyer:CSafeFileDispalyer");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CSafeFileDispalyer:CSafeFileDispalyer");
        if(!ok)
            return 0;
        cobj = new GXMISC::CSafeFileDispalyer(arg0, arg1, arg2);
        tolua_pushusertype(tolua_S,(void*)cobj,"CSafeFileDispalyer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 4) 
    {
        bool arg0;
        std::string arg1;
        unsigned int arg2;
        bool arg3;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CSafeFileDispalyer:CSafeFileDispalyer");

        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CSafeFileDispalyer:CSafeFileDispalyer");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CSafeFileDispalyer:CSafeFileDispalyer");

        ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CSafeFileDispalyer:CSafeFileDispalyer");
        if(!ok)
            return 0;
        cobj = new GXMISC::CSafeFileDispalyer(arg0, arg1, arg2, arg3);
        tolua_pushusertype(tolua_S,(void*)cobj,"CSafeFileDispalyer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 5) 
    {
        bool arg0;
        std::string arg1;
        unsigned int arg2;
        bool arg3;
        bool arg4;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CSafeFileDispalyer:CSafeFileDispalyer");

        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CSafeFileDispalyer:CSafeFileDispalyer");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CSafeFileDispalyer:CSafeFileDispalyer");

        ok &= luaval_to_boolean(tolua_S, 5,(bool*)&arg3, "CSafeFileDispalyer:CSafeFileDispalyer");

        ok &= luaval_to_boolean(tolua_S, 6,(bool*)&arg4, "CSafeFileDispalyer:CSafeFileDispalyer");
        if(!ok)
            return 0;
        cobj = new GXMISC::CSafeFileDispalyer(arg0, arg1, arg2, arg3, arg4);
        tolua_pushusertype(tolua_S,(void*)cobj,"CSafeFileDispalyer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSafeFileDispalyer:CSafeFileDispalyer has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

}

static int lua_corelib_CSafeFileDispalyer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSafeFileDispalyer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSafeFileDispalyer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSafeFileDispalyer* self = (GXMISC::CSafeFileDispalyer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSafeFileDispalyer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSafeFileDispalyer");
    tolua_cclass(tolua_S,"CSafeFileDispalyer","CSafeFileDispalyer","CFileDisplayer",lua_corelib_CSafeFileDispalyer_finalize);

    tolua_beginmodule(tolua_S,"CSafeFileDispalyer");
        tolua_function(tolua_S,"new",lua_corelib_CSafeFileDispalyer_constructor);
        tolua_function(tolua_S,"leave",lua_corelib_CSafeFileDispalyer_leave);
        tolua_function(tolua_S,"enter",lua_corelib_CSafeFileDispalyer_enter);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSafeFileDispalyer).name();
    g_luaType[typeName] = "CSafeFileDispalyer";
    g_typeCast["CSafeFileDispalyer"] = "CSafeFileDispalyer";
    return 1;
}

int lua_corelib_CBit8_toUInt8(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CBit8* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBit8",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CBit8*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CBit8_toUInt8'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->toUInt8();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBit8:toUInt8 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CBit8_toUInt8'.",&tolua_err);
	return 0;
}
int lua_corelib_CBit8_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CBit8* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            unsigned char arg0;
            ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CBit8:CBit8");

            if (!ok) { break; }
            cobj = new GXMISC::CBit8(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CBit8");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CBit8();
            tolua_pushusertype(tolua_S,(void*)cobj,"CBit8");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CBit8:CBit8 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CBit8_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBit8)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBit8",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CBit8* self = (GXMISC::CBit8*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CBit8(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBit8");
    tolua_cclass(tolua_S,"CBit8","CBit8","CFixBitSet<8>",lua_corelib_CBit8_finalize);

    tolua_beginmodule(tolua_S,"CBit8");
        tolua_function(tolua_S,"new",lua_corelib_CBit8_constructor);
        tolua_function(tolua_S,"toUInt8",lua_corelib_CBit8_toUInt8);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CBit8).name();
    g_luaType[typeName] = "CBit8";
    g_typeCast["CBit8"] = "CBit8";
    return 1;
}

int lua_corelib_CBit16_toUInt16(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CBit16* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBit16",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CBit16*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CBit16_toUInt16'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->toUInt16();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBit16:toUInt16 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CBit16_toUInt16'.",&tolua_err);
	return 0;
}
int lua_corelib_CBit16_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CBit16* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            unsigned short arg0;
            ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CBit16:CBit16");

            if (!ok) { break; }
            cobj = new GXMISC::CBit16(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CBit16");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CBit16();
            tolua_pushusertype(tolua_S,(void*)cobj,"CBit16");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CBit16:CBit16 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CBit16_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBit16)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBit16",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CBit16* self = (GXMISC::CBit16*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CBit16(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBit16");
    tolua_cclass(tolua_S,"CBit16","CBit16","CFixBitSet<16>",lua_corelib_CBit16_finalize);

    tolua_beginmodule(tolua_S,"CBit16");
        tolua_function(tolua_S,"new",lua_corelib_CBit16_constructor);
        tolua_function(tolua_S,"toUInt16",lua_corelib_CBit16_toUInt16);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CBit16).name();
    g_luaType[typeName] = "CBit16";
    g_typeCast["CBit16"] = "CBit16";
    return 1;
}

int lua_corelib_CBit32_toUInt32(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CBit32* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBit32",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CBit32*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CBit32_toUInt32'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->toUInt32();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CBit32:toUInt32 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CBit32_toUInt32'.",&tolua_err);
	return 0;
}
int lua_corelib_CBit32_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CBit32* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CBit32:CBit32");

            if (!ok) { break; }
            cobj = new GXMISC::CBit32(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CBit32");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CBit32();
            tolua_pushusertype(tolua_S,(void*)cobj,"CBit32");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CBit32:CBit32 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CBit32_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBit32)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBit32",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CBit32* self = (GXMISC::CBit32*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CBit32(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBit32");
    tolua_cclass(tolua_S,"CBit32","CBit32","CFixBitSet<32>",lua_corelib_CBit32_finalize);

    tolua_beginmodule(tolua_S,"CBit32");
        tolua_function(tolua_S,"new",lua_corelib_CBit32_constructor);
        tolua_function(tolua_S,"toUInt32",lua_corelib_CBit32_toUInt32);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CBit32).name();
    g_luaType[typeName] = "CBit32";
    g_typeCast["CBit32"] = "CBit32";
    return 1;
}

int lua_corelib_CBit64_toUInt64(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CBit64* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBit64",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CBit64*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CBit64_toUInt64'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        uint64 ret = cobj->toUInt64();
        lua_tinker::push(tolua_S,ret);
        return 1;
    }

    gxError("CBit64:toUInt64 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CBit64_toUInt64'.",&tolua_err);
	return 0;
}
int lua_corelib_CBit64_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CBit64* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            uint64 arg0;
            ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CBit64:CBit64");

            if (!ok) { break; }
            cobj = new GXMISC::CBit64(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CBit64");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CBit64();
            tolua_pushusertype(tolua_S,(void*)cobj,"CBit64");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CBit64:CBit64 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CBit64_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBit64)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBit64",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CBit64* self = (GXMISC::CBit64*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CBit64(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBit64");
    tolua_cclass(tolua_S,"CBit64","CBit64","CFixBitSet<64>",lua_corelib_CBit64_finalize);

    tolua_beginmodule(tolua_S,"CBit64");
        tolua_function(tolua_S,"new",lua_corelib_CBit64_constructor);
        tolua_function(tolua_S,"toUInt64",lua_corelib_CBit64_toUInt64);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CBit64).name();
    g_luaType[typeName] = "CBit64";
    g_typeCast["CBit64"] = "CBit64";
    return 1;
}

int lua_corelib_CCPUTimeStat_getProcessSystemLoad(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CCPUTimeStat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCPUTimeStat",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CCPUTimeStat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CCPUTimeStat_getProcessSystemLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        double ret = cobj->getProcessSystemLoad();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        GXMISC::CCPUTimeStat::TMeasureType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCPUTimeStat:getProcessSystemLoad");
        if(!ok)
            return 0;
        double ret = cobj->getProcessSystemLoad(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCPUTimeStat:getProcessSystemLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_getProcessSystemLoad'.",&tolua_err);
	return 0;
}
int lua_corelib_CCPUTimeStat_getProcessCSystemLoad(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CCPUTimeStat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCPUTimeStat",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CCPUTimeStat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CCPUTimeStat_getProcessCSystemLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        double ret = cobj->getProcessCSystemLoad();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        GXMISC::CCPUTimeStat::TMeasureType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCPUTimeStat:getProcessCSystemLoad");
        if(!ok)
            return 0;
        double ret = cobj->getProcessCSystemLoad(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCPUTimeStat:getProcessCSystemLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_getProcessCSystemLoad'.",&tolua_err);
	return 0;
}
int lua_corelib_CCPUTimeStat_getCPUNiceLoad(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CCPUTimeStat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCPUTimeStat",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CCPUTimeStat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CCPUTimeStat_getCPUNiceLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        double ret = cobj->getCPUNiceLoad();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        GXMISC::CCPUTimeStat::TMeasureType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCPUTimeStat:getCPUNiceLoad");
        if(!ok)
            return 0;
        double ret = cobj->getCPUNiceLoad(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCPUTimeStat:getCPUNiceLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_getCPUNiceLoad'.",&tolua_err);
	return 0;
}
int lua_corelib_CCPUTimeStat_getProcessCUserLoad(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CCPUTimeStat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCPUTimeStat",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CCPUTimeStat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CCPUTimeStat_getProcessCUserLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        double ret = cobj->getProcessCUserLoad();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        GXMISC::CCPUTimeStat::TMeasureType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCPUTimeStat:getProcessCUserLoad");
        if(!ok)
            return 0;
        double ret = cobj->getProcessCUserLoad(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCPUTimeStat:getProcessCUserLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_getProcessCUserLoad'.",&tolua_err);
	return 0;
}
int lua_corelib_CCPUTimeStat_getCPUIOWaitLoad(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CCPUTimeStat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCPUTimeStat",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CCPUTimeStat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CCPUTimeStat_getCPUIOWaitLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        double ret = cobj->getCPUIOWaitLoad();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        GXMISC::CCPUTimeStat::TMeasureType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCPUTimeStat:getCPUIOWaitLoad");
        if(!ok)
            return 0;
        double ret = cobj->getCPUIOWaitLoad(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCPUTimeStat:getCPUIOWaitLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_getCPUIOWaitLoad'.",&tolua_err);
	return 0;
}
int lua_corelib_CCPUTimeStat_getCPUUserLoad(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CCPUTimeStat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCPUTimeStat",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CCPUTimeStat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CCPUTimeStat_getCPUUserLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        double ret = cobj->getCPUUserLoad();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        GXMISC::CCPUTimeStat::TMeasureType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCPUTimeStat:getCPUUserLoad");
        if(!ok)
            return 0;
        double ret = cobj->getCPUUserLoad(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCPUTimeStat:getCPUUserLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_getCPUUserLoad'.",&tolua_err);
	return 0;
}
int lua_corelib_CCPUTimeStat_getProcessCLoad(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CCPUTimeStat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCPUTimeStat",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CCPUTimeStat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CCPUTimeStat_getProcessCLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        double ret = cobj->getProcessCLoad();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        GXMISC::CCPUTimeStat::TMeasureType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCPUTimeStat:getProcessCLoad");
        if(!ok)
            return 0;
        double ret = cobj->getProcessCLoad(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCPUTimeStat:getProcessCLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_getProcessCLoad'.",&tolua_err);
	return 0;
}
int lua_corelib_CCPUTimeStat_getProcessLoad(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CCPUTimeStat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCPUTimeStat",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CCPUTimeStat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CCPUTimeStat_getProcessLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        double ret = cobj->getProcessLoad();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        GXMISC::CCPUTimeStat::TMeasureType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCPUTimeStat:getProcessLoad");
        if(!ok)
            return 0;
        double ret = cobj->getProcessLoad(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCPUTimeStat:getProcessLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_getProcessLoad'.",&tolua_err);
	return 0;
}
int lua_corelib_CCPUTimeStat_peekMeasures(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CCPUTimeStat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCPUTimeStat",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CCPUTimeStat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CCPUTimeStat_peekMeasures'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->peekMeasures();
        return 0;
    }

    gxError("CCPUTimeStat:peekMeasures has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_peekMeasures'.",&tolua_err);
	return 0;
}
int lua_corelib_CCPUTimeStat_getCPUSystemLoad(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CCPUTimeStat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCPUTimeStat",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CCPUTimeStat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CCPUTimeStat_getCPUSystemLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        double ret = cobj->getCPUSystemLoad();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        GXMISC::CCPUTimeStat::TMeasureType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCPUTimeStat:getCPUSystemLoad");
        if(!ok)
            return 0;
        double ret = cobj->getCPUSystemLoad(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCPUTimeStat:getCPUSystemLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_getCPUSystemLoad'.",&tolua_err);
	return 0;
}
int lua_corelib_CCPUTimeStat_getCPULoad(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CCPUTimeStat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCPUTimeStat",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CCPUTimeStat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CCPUTimeStat_getCPULoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        double ret = cobj->getCPULoad();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        GXMISC::CCPUTimeStat::TMeasureType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCPUTimeStat:getCPULoad");
        if(!ok)
            return 0;
        double ret = cobj->getCPULoad(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCPUTimeStat:getCPULoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_getCPULoad'.",&tolua_err);
	return 0;
}
int lua_corelib_CCPUTimeStat_getProcessUserLoad(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CCPUTimeStat* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CCPUTimeStat",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CCPUTimeStat*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CCPUTimeStat_getProcessUserLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        double ret = cobj->getProcessUserLoad();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        GXMISC::CCPUTimeStat::TMeasureType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CCPUTimeStat:getProcessUserLoad");
        if(!ok)
            return 0;
        double ret = cobj->getProcessUserLoad(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CCPUTimeStat:getProcessUserLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_getProcessUserLoad'.",&tolua_err);
	return 0;
}
int lua_corelib_CCPUTimeStat_getPIDTicks(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CCPUTimeStat",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 5)
    {
        uint64 arg0;
        uint64 arg1;
        uint64 arg2;
        uint64 arg3;
        unsigned int arg4;
        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CCPUTimeStat:getPIDTicks");
        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CCPUTimeStat:getPIDTicks");
        ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CCPUTimeStat:getPIDTicks");
        ok &= luaval_to_uint64(tolua_S, 5, (uint64*)&arg3, "CCPUTimeStat:getPIDTicks");
        ok &= luaval_to_uint32(tolua_S, 6,(uint32*)&arg4, "CCPUTimeStat:getPIDTicks");
        if(!ok)
            return 0;
        bool ret = GXMISC::CCPUTimeStat::getPIDTicks(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CCPUTimeStat:getPIDTicks has wrong number of arguments: {0}, was expecting {1}\n ", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_getPIDTicks'.", &tolua_err);
    return 0;
}
int lua_corelib_CCPUTimeStat_getCPUTicks(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CCPUTimeStat",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 5)
    {
        uint64 arg0;
        uint64 arg1;
        uint64 arg2;
        uint64 arg3;
        uint64 arg4;
        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CCPUTimeStat:getCPUTicks");
        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CCPUTimeStat:getCPUTicks");
        ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CCPUTimeStat:getCPUTicks");
        ok &= luaval_to_uint64(tolua_S, 5, (uint64*)&arg3, "CCPUTimeStat:getCPUTicks");
        ok &= luaval_to_uint64(tolua_S, 6, (uint64*)&arg4, "CCPUTimeStat:getCPUTicks");
        if(!ok)
            return 0;
        bool ret = GXMISC::CCPUTimeStat::getCPUTicks(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    gxError("CCPUTimeStat:getCPUTicks has wrong number of arguments: {0}, was expecting {1}\n ", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CCPUTimeStat_getCPUTicks'.", &tolua_err);
    return 0;
}
int lua_corelib_CCPUTimeStat_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CCPUTimeStat* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CCPUTimeStat();
        tolua_pushusertype(tolua_S,(void*)cobj,"CCPUTimeStat");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CCPUTimeStat:CCPUTimeStat has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CCPUTimeStat_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CCPUTimeStat)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CCPUTimeStat",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CCPUTimeStat* self = (GXMISC::CCPUTimeStat*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CCPUTimeStat(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CCPUTimeStat");
    tolua_cclass(tolua_S,"CCPUTimeStat","CCPUTimeStat","",lua_corelib_CCPUTimeStat_finalize);

    tolua_beginmodule(tolua_S,"CCPUTimeStat");
        tolua_function(tolua_S,"new",lua_corelib_CCPUTimeStat_constructor);
        tolua_function(tolua_S,"getProcessSystemLoad",lua_corelib_CCPUTimeStat_getProcessSystemLoad);
        tolua_function(tolua_S,"getProcessCSystemLoad",lua_corelib_CCPUTimeStat_getProcessCSystemLoad);
        tolua_function(tolua_S,"getCPUNiceLoad",lua_corelib_CCPUTimeStat_getCPUNiceLoad);
        tolua_function(tolua_S,"getProcessCUserLoad",lua_corelib_CCPUTimeStat_getProcessCUserLoad);
        tolua_function(tolua_S,"getCPUIOWaitLoad",lua_corelib_CCPUTimeStat_getCPUIOWaitLoad);
        tolua_function(tolua_S,"getCPUUserLoad",lua_corelib_CCPUTimeStat_getCPUUserLoad);
        tolua_function(tolua_S,"getProcessCLoad",lua_corelib_CCPUTimeStat_getProcessCLoad);
        tolua_function(tolua_S,"getProcessLoad",lua_corelib_CCPUTimeStat_getProcessLoad);
        tolua_function(tolua_S,"peekMeasures",lua_corelib_CCPUTimeStat_peekMeasures);
        tolua_function(tolua_S,"getCPUSystemLoad",lua_corelib_CCPUTimeStat_getCPUSystemLoad);
        tolua_function(tolua_S,"getCPULoad",lua_corelib_CCPUTimeStat_getCPULoad);
        tolua_function(tolua_S,"getProcessUserLoad",lua_corelib_CCPUTimeStat_getProcessUserLoad);
        tolua_function(tolua_S,"getPIDTicks", lua_corelib_CCPUTimeStat_getPIDTicks);
        tolua_function(tolua_S,"getCPUTicks", lua_corelib_CCPUTimeStat_getCPUTicks);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CCPUTimeStat).name();
    g_luaType[typeName] = "CCPUTimeStat";
    g_typeCast["CCPUTimeStat"] = "CCPUTimeStat";
    return 1;
}

int lua_corelib_CSimpleAllocator_alloc(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSimpleAllocator* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSimpleAllocator",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSimpleAllocator*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSimpleAllocator_alloc'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSimpleAllocator:alloc");
        if(!ok)
            return 0;
        char* ret = cobj->alloc(arg0);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CSimpleAllocator:alloc has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSimpleAllocator_alloc'.",&tolua_err);
	return 0;
}
int lua_corelib_CSimpleAllocator_getTotalAllocSize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSimpleAllocator* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSimpleAllocator",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSimpleAllocator*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSimpleAllocator_getTotalAllocSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getTotalAllocSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSimpleAllocator:getTotalAllocSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSimpleAllocator_getTotalAllocSize'.",&tolua_err);
	return 0;
}
int lua_corelib_CSimpleAllocator_setThreadID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSimpleAllocator* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSimpleAllocator",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSimpleAllocator*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSimpleAllocator_setThreadID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setThreadID();
        return 0;
    }
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSimpleAllocator:setThreadID");
        if(!ok)
            return 0;
        cobj->setThreadID(arg0);
        return 0;
    }

    gxError("CSimpleAllocator:setThreadID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSimpleAllocator_setThreadID'.",&tolua_err);
	return 0;
}
int lua_corelib_CSimpleAllocator_free(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSimpleAllocator* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSimpleAllocator",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSimpleAllocator*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSimpleAllocator_free'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSimpleAllocator:free"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        cobj->free(arg0);
        return 0;
    }

    gxError("CSimpleAllocator:free has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSimpleAllocator_free'.",&tolua_err);
	return 0;
}
static int lua_corelib_CSimpleAllocator_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSimpleAllocator)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSimpleAllocator",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSimpleAllocator* self = (GXMISC::CSimpleAllocator*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSimpleAllocator(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSimpleAllocator");
    tolua_cclass(tolua_S,"CSimpleAllocator","CSimpleAllocator","",nullptr);

    tolua_beginmodule(tolua_S,"CSimpleAllocator");
        tolua_function(tolua_S,"alloc",lua_corelib_CSimpleAllocator_alloc);
        tolua_function(tolua_S,"getTotalAllocSize",lua_corelib_CSimpleAllocator_getTotalAllocSize);
        tolua_function(tolua_S,"setThreadID",lua_corelib_CSimpleAllocator_setThreadID);
        tolua_function(tolua_S,"free",lua_corelib_CSimpleAllocator_free);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSimpleAllocator).name();
    g_luaType[typeName] = "CSimpleAllocator";
    g_typeCast["CSimpleAllocator"] = "CSimpleAllocator";
    return 1;
}

int lua_corelib_IStopHandler_setStop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IStopHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IStopHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IStopHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IStopHandler_setStop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setStop();
        return 0;
    }

    gxError("IStopHandler:setStop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IStopHandler_setStop'.",&tolua_err);
	return 0;
}
int lua_corelib_IStopHandler_setStart(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IStopHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IStopHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IStopHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IStopHandler_setStart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setStart();
        return 0;
    }

    gxError("IStopHandler:setStart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IStopHandler_setStart'.",&tolua_err);
	return 0;
}
int lua_corelib_IStopHandler_onStop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IStopHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IStopHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IStopHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IStopHandler_onStop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onStop();
        return 0;
    }

    gxError("IStopHandler:onStop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IStopHandler_onStop'.",&tolua_err);
	return 0;
}
int lua_corelib_IStopHandler_isStop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IStopHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IStopHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IStopHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IStopHandler_isStop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isStop();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IStopHandler:isStop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IStopHandler_isStop'.",&tolua_err);
	return 0;
}
int lua_corelib_IStopHandler_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IStopHandler* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::IStopHandler();
        tolua_pushusertype(tolua_S,(void*)cobj,"IStopHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("IStopHandler:IStopHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_IStopHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IStopHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IStopHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IStopHandler* self = (GXMISC::IStopHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IStopHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IStopHandler");
    tolua_cclass(tolua_S,"IStopHandler","IStopHandler","",lua_corelib_IStopHandler_finalize);

    tolua_beginmodule(tolua_S,"IStopHandler");
        tolua_function(tolua_S,"new",lua_corelib_IStopHandler_constructor);
        tolua_function(tolua_S,"setStop",lua_corelib_IStopHandler_setStop);
        tolua_function(tolua_S,"setStart",lua_corelib_IStopHandler_setStart);
        tolua_function(tolua_S,"onStop",lua_corelib_IStopHandler_onStop);
        tolua_function(tolua_S,"isStop",lua_corelib_IStopHandler_isStop);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IStopHandler).name();
    g_luaType[typeName] = "IStopHandler";
    g_typeCast["IStopHandler"] = "IStopHandler";
    return 1;
}

int lua_corelib_IRunnable_run(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IRunnable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IRunnable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IRunnable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IRunnable_run'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->run();
        return 0;
    }

    gxError("IRunnable:run has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IRunnable_run'.",&tolua_err);
	return 0;
}
int lua_corelib_IRunnable_setName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IRunnable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IRunnable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IRunnable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IRunnable_setName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "IRunnable:setName");
        if(!ok)
            return 0;
        cobj->setName(arg0);
        return 0;
    }

    gxError("IRunnable:setName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IRunnable_setName'.",&tolua_err);
	return 0;
}
int lua_corelib_IRunnable_getThreadID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IRunnable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IRunnable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IRunnable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IRunnable_getThreadID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getThreadID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("IRunnable:getThreadID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IRunnable_getThreadID'.",&tolua_err);
	return 0;
}
int lua_corelib_IRunnable_getName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IRunnable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IRunnable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IRunnable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IRunnable_getName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("IRunnable:getName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IRunnable_getName'.",&tolua_err);
	return 0;
}
int lua_corelib_IRunnable_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IRunnable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IRunnable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IRunnable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IRunnable_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("IRunnable:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IRunnable_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_IRunnable_setThreadID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IRunnable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IRunnable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IRunnable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IRunnable_setThreadID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "IRunnable:setThreadID");
        if(!ok)
            return 0;
        cobj->setThreadID(arg0);
        return 0;
    }

    gxError("IRunnable:setThreadID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IRunnable_setThreadID'.",&tolua_err);
	return 0;
}
int lua_corelib_IRunnable_isExitRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IRunnable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IRunnable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IRunnable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IRunnable_isExitRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isExitRun();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IRunnable:isExitRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IRunnable_isExitRun'.",&tolua_err);
	return 0;
}
int lua_corelib_IRunnable_setExitRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IRunnable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IRunnable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IRunnable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IRunnable_setExitRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setExitRun();
        return 0;
    }

    gxError("IRunnable:setExitRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IRunnable_setExitRun'.",&tolua_err);
	return 0;
}
static int lua_corelib_IRunnable_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IRunnable)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IRunnable",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IRunnable* self = (GXMISC::IRunnable*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IRunnable(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IRunnable");
    tolua_cclass(tolua_S,"IRunnable","IRunnable","IStopHandler",nullptr);

    tolua_beginmodule(tolua_S,"IRunnable");
        tolua_function(tolua_S,"run",lua_corelib_IRunnable_run);
        tolua_function(tolua_S,"setName",lua_corelib_IRunnable_setName);
        tolua_function(tolua_S,"getThreadID",lua_corelib_IRunnable_getThreadID);
        tolua_function(tolua_S,"getName",lua_corelib_IRunnable_getName);
        tolua_function(tolua_S,"cleanUp",lua_corelib_IRunnable_cleanUp);
        tolua_function(tolua_S,"setThreadID",lua_corelib_IRunnable_setThreadID);
        tolua_function(tolua_S,"isExitRun",lua_corelib_IRunnable_isExitRun);
        tolua_function(tolua_S,"setExitRun",lua_corelib_IRunnable_setExitRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IRunnable).name();
    g_luaType[typeName] = "IRunnable";
    g_typeCast["IRunnable"] = "IRunnable";
    return 1;
}

int lua_corelib_IAllocatable_allocArg(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IAllocatable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAllocatable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IAllocatable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IAllocatable_allocArg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "IAllocatable:allocArg");
        if(!ok)
            return 0;
        char* ret = cobj->allocArg(arg0);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("IAllocatable:allocArg has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IAllocatable_allocArg'.",&tolua_err);
	return 0;
}
int lua_corelib_IAllocatable_freeArg(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IAllocatable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IAllocatable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IAllocatable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IAllocatable_freeArg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "IAllocatable:freeArg"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        cobj->freeArg(arg0);
        return 0;
    }

    gxError("IAllocatable:freeArg has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IAllocatable_freeArg'.",&tolua_err);
	return 0;
}
static int lua_corelib_IAllocatable_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IAllocatable)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IAllocatable",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IAllocatable* self = (GXMISC::IAllocatable*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IAllocatable(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IAllocatable");
    tolua_cclass(tolua_S,"IAllocatable","IAllocatable","",nullptr);

    tolua_beginmodule(tolua_S,"IAllocatable");
        tolua_function(tolua_S,"allocArg",lua_corelib_IAllocatable_allocArg);
        tolua_function(tolua_S,"freeArg",lua_corelib_IAllocatable_freeArg);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IAllocatable).name();
    g_luaType[typeName] = "IAllocatable";
    g_typeCast["IAllocatable"] = "IAllocatable";
    return 1;
}

int lua_corelib_ISyncable_setUsed(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISyncable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISyncable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISyncable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISyncable_setUsed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setUsed();
        return 0;
    }

    gxError("ISyncable:setUsed has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISyncable_setUsed'.",&tolua_err);
	return 0;
}
int lua_corelib_ISyncable_doAfterUsed(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISyncable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISyncable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISyncable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISyncable_doAfterUsed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doAfterUsed();
        return 0;
    }

    gxError("ISyncable:doAfterUsed has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISyncable_doAfterUsed'.",&tolua_err);
	return 0;
}
int lua_corelib_ISyncable_doAfterFromQueue(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISyncable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISyncable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISyncable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISyncable_doAfterFromQueue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doAfterFromQueue();
        return 0;
    }

    gxError("ISyncable:doAfterFromQueue has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISyncable_doAfterFromQueue'.",&tolua_err);
	return 0;
}
int lua_corelib_ISyncable_setFreed(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISyncable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISyncable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISyncable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISyncable_setFreed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setFreed();
        return 0;
    }

    gxError("ISyncable:setFreed has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISyncable_setFreed'.",&tolua_err);
	return 0;
}
int lua_corelib_ISyncable_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISyncable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISyncable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISyncable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISyncable_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("ISyncable:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISyncable_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_ISyncable_doBeforeToQueueue(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISyncable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISyncable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISyncable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISyncable_doBeforeToQueueue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doBeforeToQueueue();
        return 0;
    }

    gxError("ISyncable:doBeforeToQueueue has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISyncable_doBeforeToQueueue'.",&tolua_err);
	return 0;
}
int lua_corelib_ISyncable_canFree(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISyncable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISyncable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISyncable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISyncable_canFree'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canFree();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("ISyncable:canFree has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISyncable_canFree'.",&tolua_err);
	return 0;
}
static int lua_corelib_ISyncable_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ISyncable)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ISyncable",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::ISyncable* self = (GXMISC::ISyncable*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_ISyncable(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ISyncable");
    tolua_cclass(tolua_S,"ISyncable","ISyncable","IRunnable",nullptr);

    tolua_beginmodule(tolua_S,"ISyncable");
        tolua_function(tolua_S,"setUsed",lua_corelib_ISyncable_setUsed);
        tolua_function(tolua_S,"doAfterUsed",lua_corelib_ISyncable_doAfterUsed);
        tolua_function(tolua_S,"doAfterFromQueue",lua_corelib_ISyncable_doAfterFromQueue);
        tolua_function(tolua_S,"setFreed",lua_corelib_ISyncable_setFreed);
        tolua_function(tolua_S,"cleanUp",lua_corelib_ISyncable_cleanUp);
        tolua_function(tolua_S,"doBeforeToQueueue",lua_corelib_ISyncable_doBeforeToQueueue);
        tolua_function(tolua_S,"canFree",lua_corelib_ISyncable_canFree);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::ISyncable).name();
    g_luaType[typeName] = "ISyncable";
    g_typeCast["ISyncable"] = "ISyncable";
    return 1;
}

int lua_corelib_IFreeable_isNeedFree(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IFreeable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IFreeable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IFreeable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IFreeable_isNeedFree'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNeedFree();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IFreeable:isNeedFree has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IFreeable_isNeedFree'.",&tolua_err);
	return 0;
}
int lua_corelib_IFreeable_setNeedFree(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IFreeable* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IFreeable",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IFreeable*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IFreeable_setNeedFree'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setNeedFree();
        return 0;
    }

    gxError("IFreeable:setNeedFree has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IFreeable_setNeedFree'.",&tolua_err);
	return 0;
}
static int lua_corelib_IFreeable_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IFreeable)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IFreeable",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IFreeable* self = (GXMISC::IFreeable*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IFreeable(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IFreeable");
    tolua_cclass(tolua_S,"IFreeable","IFreeable","",nullptr);

    tolua_beginmodule(tolua_S,"IFreeable");
        tolua_function(tolua_S,"isNeedFree",lua_corelib_IFreeable_isNeedFree);
        tolua_function(tolua_S,"setNeedFree",lua_corelib_IFreeable_setNeedFree);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IFreeable).name();
    g_luaType[typeName] = "IFreeable";
    g_typeCast["IFreeable"] = "IFreeable";
    return 1;
}

int lua_corelib_IDumpHandler_onDump(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IDumpHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IDumpHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IDumpHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IDumpHandler_onDump'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "IDumpHandler:onDump");
        if(!ok)
            return 0;
        cobj->onDump(arg0);
        return 0;
    }

    gxError("IDumpHandler:onDump has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IDumpHandler_onDump'.",&tolua_err);
	return 0;
}
int lua_corelib_IDumpHandler_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IDumpHandler* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::IDumpHandler();
        tolua_pushusertype(tolua_S,(void*)cobj,"IDumpHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("IDumpHandler:IDumpHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_IDumpHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IDumpHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IDumpHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IDumpHandler* self = (GXMISC::IDumpHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IDumpHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IDumpHandler");
    tolua_cclass(tolua_S,"IDumpHandler","IDumpHandler","",lua_corelib_IDumpHandler_finalize);

    tolua_beginmodule(tolua_S,"IDumpHandler");
        tolua_function(tolua_S,"new",lua_corelib_IDumpHandler_constructor);
        tolua_function(tolua_S,"onDump",lua_corelib_IDumpHandler_onDump);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IDumpHandler).name();
    g_luaType[typeName] = "IDumpHandler";
    g_typeCast["IDumpHandler"] = "IDumpHandler";
    return 1;
}

int lua_corelib_ISimpleNoncopyable_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISimpleNoncopyable* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::ISimpleNoncopyable();
        tolua_pushusertype(tolua_S,(void*)cobj,"ISimpleNoncopyable");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("ISimpleNoncopyable:ISimpleNoncopyable has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_ISimpleNoncopyable_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ISimpleNoncopyable)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ISimpleNoncopyable",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::ISimpleNoncopyable* self = (GXMISC::ISimpleNoncopyable*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_ISimpleNoncopyable(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ISimpleNoncopyable");
    tolua_cclass(tolua_S,"ISimpleNoncopyable","ISimpleNoncopyable","",lua_corelib_ISimpleNoncopyable_finalize);

    tolua_beginmodule(tolua_S,"ISimpleNoncopyable");
        tolua_function(tolua_S,"new",lua_corelib_ISimpleNoncopyable_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::ISimpleNoncopyable).name();
    g_luaType[typeName] = "ISimpleNoncopyable";
    g_typeCast["ISimpleNoncopyable"] = "ISimpleNoncopyable";
    return 1;
}

static int lua_corelib_INoncopyable_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (INoncopyable)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"INoncopyable",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::INoncopyable* self = (GXMISC::INoncopyable*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_INoncopyable(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"INoncopyable");
    tolua_cclass(tolua_S,"INoncopyable","INoncopyable","",nullptr);

    tolua_beginmodule(tolua_S,"INoncopyable");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::INoncopyable).name();
    g_luaType[typeName] = "INoncopyable";
    g_typeCast["INoncopyable"] = "INoncopyable";
    return 1;
}

int lua_corelib_CDebugControl_setTaskVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_setTaskVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CDebugControl:setTaskVar");
        if(!ok)
            return 0;
        cobj->setTaskVar(arg0);
        return 0;
    }

    gxError("CDebugControl:setTaskVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_setTaskVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_getDatabaseProfileVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_getDatabaseProfileVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getDatabaseProfileVar();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDebugControl:getDatabaseProfileVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_getDatabaseProfileVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_setDatabaseProfileVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_setDatabaseProfileVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CDebugControl:setDatabaseProfileVar");
        if(!ok)
            return 0;
        cobj->setDatabaseProfileVar(arg0);
        return 0;
    }

    gxError("CDebugControl:setDatabaseProfileVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_setDatabaseProfileVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_getServiceStopVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_getServiceStopVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getServiceStopVar();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDebugControl:getServiceStopVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_getServiceStopVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_getTaskBlockAllocVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_getTaskBlockAllocVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getTaskBlockAllocVar();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDebugControl:getTaskBlockAllocVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_getTaskBlockAllocVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_setServiceStopVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_setServiceStopVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CDebugControl:setServiceStopVar");
        if(!ok)
            return 0;
        cobj->setServiceStopVar(arg0);
        return 0;
    }

    gxError("CDebugControl:setServiceStopVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_setServiceStopVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_setTaskProfileVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_setTaskProfileVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CDebugControl:setTaskProfileVar");
        if(!ok)
            return 0;
        cobj->setTaskProfileVar(arg0);
        return 0;
    }

    gxError("CDebugControl:setTaskProfileVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_setTaskProfileVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_getTaskProfileVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_getTaskProfileVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getTaskProfileVar();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDebugControl:getTaskProfileVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_getTaskProfileVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_setMainLoopProfileVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_setMainLoopProfileVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CDebugControl:setMainLoopProfileVar");
        if(!ok)
            return 0;
        cobj->setMainLoopProfileVar(arg0);
        return 0;
    }

    gxError("CDebugControl:setMainLoopProfileVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_setMainLoopProfileVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_setTaskBlockAllocVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_setTaskBlockAllocVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CDebugControl:setTaskBlockAllocVar");
        if(!ok)
            return 0;
        cobj->setTaskBlockAllocVar(arg0);
        return 0;
    }

    gxError("CDebugControl:setTaskBlockAllocVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_setTaskBlockAllocVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_addHandler(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_addHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CDebugControl:addHandler");
        if(!ok)
            return 0;
        cobj->addHandler(arg0);
        return 0;
    }

    gxError("CDebugControl:addHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_addHandler'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_setSocketProfileVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_setSocketProfileVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CDebugControl:setSocketProfileVar");
        if(!ok)
            return 0;
        cobj->setSocketProfileVar(arg0);
        return 0;
    }

    gxError("CDebugControl:setSocketProfileVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_setSocketProfileVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_getSocketLoopProfileVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_getSocketLoopProfileVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getSocketLoopProfileVar();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDebugControl:getSocketLoopProfileVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_getSocketLoopProfileVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_getSocketProfileVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_getSocketProfileVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getSocketProfileVar();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDebugControl:getSocketProfileVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_getSocketProfileVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_setSocketLoopProfileVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_setSocketLoopProfileVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CDebugControl:setSocketLoopProfileVar");
        if(!ok)
            return 0;
        cobj->setSocketLoopProfileVar(arg0);
        return 0;
    }

    gxError("CDebugControl:setSocketLoopProfileVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_setSocketLoopProfileVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_isHandler(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_isHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CDebugControl:isHandler");
        if(!ok)
            return 0;
        bool ret = cobj->isHandler(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDebugControl:isHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_isHandler'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_getMainLoopProfileVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_getMainLoopProfileVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getMainLoopProfileVar();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDebugControl:getMainLoopProfileVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_getMainLoopProfileVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_getSocketBufferVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_getSocketBufferVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getSocketBufferVar();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDebugControl:getSocketBufferVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_getSocketBufferVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_getTaskVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_getTaskVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getTaskVar();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDebugControl:getTaskVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_getTaskVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_setSocketBufferVar(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDebugControl*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDebugControl_setSocketBufferVar'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CDebugControl:setSocketBufferVar");
        if(!ok)
            return 0;
        cobj->setSocketBufferVar(arg0);
        return 0;
    }

    gxError("CDebugControl:setSocketBufferVar has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDebugControl_setSocketBufferVar'.",&tolua_err);
	return 0;
}
int lua_corelib_CDebugControl_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDebugControl* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CDebugControl();
        tolua_pushusertype(tolua_S,(void*)cobj,"CDebugControl");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CDebugControl:CDebugControl has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CDebugControl_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDebugControl)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDebugControl",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CDebugControl* self = (GXMISC::CDebugControl*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CDebugControl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDebugControl");
    tolua_cclass(tolua_S,"CDebugControl","CDebugControl","CManualSingleton<CDebugControl>",lua_corelib_CDebugControl_finalize);

    tolua_beginmodule(tolua_S,"CDebugControl");
        tolua_function(tolua_S,"new",lua_corelib_CDebugControl_constructor);
        tolua_function(tolua_S,"setTaskVar",lua_corelib_CDebugControl_setTaskVar);
        tolua_function(tolua_S,"getDatabaseProfileVar",lua_corelib_CDebugControl_getDatabaseProfileVar);
        tolua_function(tolua_S,"setDatabaseProfileVar",lua_corelib_CDebugControl_setDatabaseProfileVar);
        tolua_function(tolua_S,"getServiceStopVar",lua_corelib_CDebugControl_getServiceStopVar);
        tolua_function(tolua_S,"getTaskBlockAllocVar",lua_corelib_CDebugControl_getTaskBlockAllocVar);
        tolua_function(tolua_S,"setServiceStopVar",lua_corelib_CDebugControl_setServiceStopVar);
        tolua_function(tolua_S,"setTaskProfileVar",lua_corelib_CDebugControl_setTaskProfileVar);
        tolua_function(tolua_S,"getTaskProfileVar",lua_corelib_CDebugControl_getTaskProfileVar);
        tolua_function(tolua_S,"setMainLoopProfileVar",lua_corelib_CDebugControl_setMainLoopProfileVar);
        tolua_function(tolua_S,"setTaskBlockAllocVar",lua_corelib_CDebugControl_setTaskBlockAllocVar);
        tolua_function(tolua_S,"addHandler",lua_corelib_CDebugControl_addHandler);
        tolua_function(tolua_S,"setSocketProfileVar",lua_corelib_CDebugControl_setSocketProfileVar);
        tolua_function(tolua_S,"getSocketLoopProfileVar",lua_corelib_CDebugControl_getSocketLoopProfileVar);
        tolua_function(tolua_S,"getSocketProfileVar",lua_corelib_CDebugControl_getSocketProfileVar);
        tolua_function(tolua_S,"setSocketLoopProfileVar",lua_corelib_CDebugControl_setSocketLoopProfileVar);
        tolua_function(tolua_S,"isHandler",lua_corelib_CDebugControl_isHandler);
        tolua_function(tolua_S,"getMainLoopProfileVar",lua_corelib_CDebugControl_getMainLoopProfileVar);
        tolua_function(tolua_S,"getSocketBufferVar",lua_corelib_CDebugControl_getSocketBufferVar);
        tolua_function(tolua_S,"getTaskVar",lua_corelib_CDebugControl_getTaskVar);
        tolua_function(tolua_S,"setSocketBufferVar",lua_corelib_CDebugControl_setSocketBufferVar);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CDebugControl).name();
    g_luaType[typeName] = "CDebugControl";
    g_typeCast["CDebugControl"] = "CDebugControl";
    return 1;
}

int lua_corelib_CTask_doAfterUsed(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_doAfterUsed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doAfterUsed();
        return 0;
    }

    gxError("CTask:doAfterUsed has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_doAfterUsed'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_setTaskQueueWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_setTaskQueueWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CSyncActiveQueueWrap* arg0;

        ok &= luaval_to_object<GXMISC::CSyncActiveQueueWrap>(tolua_S, 2, "CSyncActiveQueueWrap", &arg0, "CTask:setTaskQueueWrap");
        if(!ok)
            return 0;
        cobj->setTaskQueueWrap(arg0);
        return 0;
    }

    gxError("CTask:setTaskQueueWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_setTaskQueueWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_getLoopThread(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_getLoopThread'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CModuleThreadLoop* ret = cobj->getLoopThread();
        object_to_luaval<GXMISC::CModuleThreadLoop>(tolua_S, "CModuleThreadLoop",(GXMISC::CModuleThreadLoop*)ret);
        return 1;
    }

    gxError("CTask:getLoopThread has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_getLoopThread'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_getArgNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_getArgNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getArgNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTask:getArgNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_getArgNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_setPriority(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_setPriority'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CTask:setPriority");
        if(!ok)
            return 0;
        cobj->setPriority(arg0);
        return 0;
    }

    gxError("CTask:setPriority has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_setPriority'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_setObjUID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_setObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CTask:setObjUID");
        if(!ok)
            return 0;
        cobj->setObjUID(arg0);
        return 0;
    }

    gxError("CTask:setObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_setObjUID'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_getArgLen(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_getArgLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTask:getArgLen");
        if(!ok)
            return 0;
        unsigned int ret = cobj->getArgLen(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTask:getArgLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_getArgLen'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_getStartTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_getStartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getStartTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTask:getStartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_getStartTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_allocArg(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_allocArg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTask:allocArg");
        if(!ok)
            return 0;
        char* ret = cobj->allocArg(arg0);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CTask:allocArg has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_allocArg'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_getName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_getName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CTask:getName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_getName'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_setLoopThreadWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_setLoopThreadWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CModuleThreadLoopWrap* arg0;

        ok &= luaval_to_object<GXMISC::CModuleThreadLoopWrap>(tolua_S, 2, "CModuleThreadLoopWrap", &arg0, "CTask:setLoopThreadWrap");
        if(!ok)
            return 0;
        cobj->setLoopThreadWrap(arg0);
        return 0;
    }

    gxError("CTask:setLoopThreadWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_setLoopThreadWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_addArg(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_addArg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char* arg0;
        unsigned int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CTask:addArg"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CTask:addArg");
        if(!ok)
            return 0;
        cobj->addArg(arg0, arg1);
        return 0;
    }

    gxError("CTask:addArg has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_addArg'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_getPriority(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_getPriority'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getPriority();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTask:getPriority has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_getPriority'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_getTotalArgLen(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_getTotalArgLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getTotalArgLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTask:getTotalArgLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_getTotalArgLen'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_type(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_type'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->type();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTask:type has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_type'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_run(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_run'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->run();
        return 0;
    }

    gxError("CTask:run has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_run'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_getLoopThreadWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_getLoopThreadWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CModuleThreadLoopWrap* ret = cobj->getLoopThreadWrap();
        object_to_luaval<GXMISC::CModuleThreadLoopWrap>(tolua_S, "CModuleThreadLoopWrap",(GXMISC::CModuleThreadLoopWrap*)ret);
        return 1;
    }

    gxError("CTask:getLoopThreadWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_getLoopThreadWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_getObjUID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_getObjUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getObjUID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CTask:getObjUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_getObjUID'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_setAllocable(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_setAllocable'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const GXMISC::IAllocatable* arg0;

        ok &= luaval_to_object<const GXMISC::IAllocatable>(tolua_S, 2, "IAllocatable", &arg0, "CTask:setAllocable");
        if(!ok)
            return 0;
        cobj->setAllocable(arg0);
        return 0;
    }

    gxError("CTask:setAllocable has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_setAllocable'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_setLoopThread(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_setLoopThread'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CModuleThreadLoop* arg0;

        ok &= luaval_to_object<GXMISC::CModuleThreadLoop>(tolua_S, 2, "CModuleThreadLoop", &arg0, "CTask:setLoopThread");
        if(!ok)
            return 0;
        cobj->setLoopThread(arg0);
        return 0;
    }

    gxError("CTask:setLoopThread has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_setLoopThread'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_freeArg(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_freeArg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->freeArg();
        return 0;
    }

    gxError("CTask:freeArg has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_freeArg'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CTask:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CTask_pushToQueue(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTask_pushToQueue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->pushToQueue();
        return 0;
    }

    gxError("CTask:pushToQueue has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTask_pushToQueue'.",&tolua_err);
	return 0;
}
static int lua_corelib_CTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CTask* self = (GXMISC::CTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTask");
    tolua_cclass(tolua_S,"CTask","CTask","ISyncable",nullptr);

    tolua_beginmodule(tolua_S,"CTask");
        tolua_function(tolua_S,"doAfterUsed",lua_corelib_CTask_doAfterUsed);
        tolua_function(tolua_S,"setTaskQueueWrap",lua_corelib_CTask_setTaskQueueWrap);
        tolua_function(tolua_S,"doRun",lua_corelib_CTask_doRun);
        tolua_function(tolua_S,"getLoopThread",lua_corelib_CTask_getLoopThread);
        tolua_function(tolua_S,"getArgNum",lua_corelib_CTask_getArgNum);
        tolua_function(tolua_S,"setPriority",lua_corelib_CTask_setPriority);
        tolua_function(tolua_S,"setObjUID",lua_corelib_CTask_setObjUID);
        tolua_function(tolua_S,"getArgLen",lua_corelib_CTask_getArgLen);
        tolua_function(tolua_S,"getStartTime",lua_corelib_CTask_getStartTime);
        tolua_function(tolua_S,"allocArg",lua_corelib_CTask_allocArg);
        tolua_function(tolua_S,"getName",lua_corelib_CTask_getName);
        tolua_function(tolua_S,"setLoopThreadWrap",lua_corelib_CTask_setLoopThreadWrap);
        tolua_function(tolua_S,"addArg",lua_corelib_CTask_addArg);
        tolua_function(tolua_S,"getPriority",lua_corelib_CTask_getPriority);
        tolua_function(tolua_S,"getTotalArgLen",lua_corelib_CTask_getTotalArgLen);
        tolua_function(tolua_S,"type",lua_corelib_CTask_type);
        tolua_function(tolua_S,"run",lua_corelib_CTask_run);
        tolua_function(tolua_S,"getLoopThreadWrap",lua_corelib_CTask_getLoopThreadWrap);
        tolua_function(tolua_S,"getObjUID",lua_corelib_CTask_getObjUID);
        tolua_function(tolua_S,"setAllocable",lua_corelib_CTask_setAllocable);
        tolua_function(tolua_S,"setLoopThread",lua_corelib_CTask_setLoopThread);
        tolua_function(tolua_S,"freeArg",lua_corelib_CTask_freeArg);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CTask_cleanUp);
        tolua_function(tolua_S,"pushToQueue",lua_corelib_CTask_pushToQueue);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CTask).name();
    g_luaType[typeName] = "CTask";
    g_typeCast["CTask"] = "CTask";
    return 1;
}

int lua_corelib_CSyncActiveQueue_setReadThreadID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_setReadThreadID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setReadThreadID();
        return 0;
    }
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSyncActiveQueue:setReadThreadID");
        if(!ok)
            return 0;
        cobj->setReadThreadID(arg0);
        return 0;
    }

    gxError("CSyncActiveQueue:setReadThreadID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_setReadThreadID'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_calcWriteMsgNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_calcWriteMsgNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->calcWriteMsgNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSyncActiveQueue:calcWriteMsgNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_calcWriteMsgNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_updateProfileData(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_updateProfileData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->updateProfileData();
        return 0;
    }

    gxError("CSyncActiveQueue:updateProfileData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_updateProfileData'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_setProfileFlag(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_setProfileFlag'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CSyncActiveQueue:setProfileFlag");
        if(!ok)
            return 0;
        cobj->setProfileFlag(arg0);
        return 0;
    }

    gxError("CSyncActiveQueue:setProfileFlag has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_setProfileFlag'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_getTaskNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_getTaskNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getTaskNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSyncActiveQueue:getTaskNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_getTaskNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_flushWriteMsg(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_flushWriteMsg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->flushWriteMsg();
        return 0;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CSyncActiveQueue:flushWriteMsg");
        if(!ok)
            return 0;
        cobj->flushWriteMsg(arg0);
        return 0;
    }

    gxError("CSyncActiveQueue:flushWriteMsg has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_flushWriteMsg'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_updateRead(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_updateRead'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CSyncActiveQueue:updateRead");
        if(!ok)
            return 0;
        cobj->updateRead(arg0);
        return 0;
    }

    gxError("CSyncActiveQueue:updateRead has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_updateRead'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_updateWrite(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_updateWrite'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CSyncActiveQueue:updateWrite");
        if(!ok)
            return 0;
        cobj->updateWrite(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        unsigned int arg0;
        bool arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CSyncActiveQueue:updateWrite");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CSyncActiveQueue:updateWrite");
        if(!ok)
            return 0;
        cobj->updateWrite(arg0, arg1);
        return 0;
    }

    gxError("CSyncActiveQueue:updateWrite has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_updateWrite'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_flushReadMsg(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_flushReadMsg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->flushReadMsg();
        return 0;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CSyncActiveQueue:flushReadMsg");
        if(!ok)
            return 0;
        cobj->flushReadMsg(arg0);
        return 0;
    }

    gxError("CSyncActiveQueue:flushReadMsg has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_flushReadMsg'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_setWriteThreadID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_setWriteThreadID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setWriteThreadID();
        return 0;
    }
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSyncActiveQueue:setWriteThreadID");
        if(!ok)
            return 0;
        cobj->setWriteThreadID(arg0);
        return 0;
    }

    gxError("CSyncActiveQueue:setWriteThreadID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_setWriteThreadID'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_setQueueName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_setQueueName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CSyncActiveQueue:setQueueName");
        if(!ok)
            return 0;
        cobj->setQueueName(arg0);
        return 0;
    }

    gxError("CSyncActiveQueue:setQueueName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_setQueueName'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CSyncActiveQueue:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_calcReadMsgNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_calcReadMsgNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->calcReadMsgNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSyncActiveQueue:calcReadMsgNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_calcReadMsgNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_doProfile(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_doProfile'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doProfile();
        return 0;
    }

    gxError("CSyncActiveQueue:doProfile has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_doProfile'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_cleanReadMsg(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueue_cleanReadMsg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanReadMsg();
        return 0;
    }

    gxError("CSyncActiveQueue:cleanReadMsg has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueue_cleanReadMsg'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueue_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueue* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CSyncActiveQueue();
            tolua_pushusertype(tolua_S,(void*)cobj,"CSyncActiveQueue");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string arg0;
            ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CSyncActiveQueue:CSyncActiveQueue");

            if (!ok) { break; }
            cobj = new GXMISC::CSyncActiveQueue(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CSyncActiveQueue");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CSyncActiveQueue:CSyncActiveQueue has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CSyncActiveQueue_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSyncActiveQueue)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSyncActiveQueue",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSyncActiveQueue* self = (GXMISC::CSyncActiveQueue*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSyncActiveQueue(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSyncActiveQueue");
    tolua_cclass(tolua_S,"CSyncActiveQueue","CSyncActiveQueue","IAllocatable",lua_corelib_CSyncActiveQueue_finalize);

    tolua_beginmodule(tolua_S,"CSyncActiveQueue");
        tolua_function(tolua_S,"new",lua_corelib_CSyncActiveQueue_constructor);
        tolua_function(tolua_S,"setReadThreadID",lua_corelib_CSyncActiveQueue_setReadThreadID);
        tolua_function(tolua_S,"calcWriteMsgNum",lua_corelib_CSyncActiveQueue_calcWriteMsgNum);
        tolua_function(tolua_S,"updateProfileData",lua_corelib_CSyncActiveQueue_updateProfileData);
        tolua_function(tolua_S,"setProfileFlag",lua_corelib_CSyncActiveQueue_setProfileFlag);
        tolua_function(tolua_S,"getTaskNum",lua_corelib_CSyncActiveQueue_getTaskNum);
        tolua_function(tolua_S,"flushWriteMsg",lua_corelib_CSyncActiveQueue_flushWriteMsg);
        tolua_function(tolua_S,"updateRead",lua_corelib_CSyncActiveQueue_updateRead);
        tolua_function(tolua_S,"updateWrite",lua_corelib_CSyncActiveQueue_updateWrite);
        tolua_function(tolua_S,"flushReadMsg",lua_corelib_CSyncActiveQueue_flushReadMsg);
        tolua_function(tolua_S,"setWriteThreadID",lua_corelib_CSyncActiveQueue_setWriteThreadID);
        tolua_function(tolua_S,"setQueueName",lua_corelib_CSyncActiveQueue_setQueueName);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CSyncActiveQueue_cleanUp);
        tolua_function(tolua_S,"calcReadMsgNum",lua_corelib_CSyncActiveQueue_calcReadMsgNum);
        tolua_function(tolua_S,"doProfile",lua_corelib_CSyncActiveQueue_doProfile);
        tolua_function(tolua_S,"cleanReadMsg",lua_corelib_CSyncActiveQueue_cleanReadMsg);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSyncActiveQueue).name();
    g_luaType[typeName] = "CSyncActiveQueue";
    g_typeCast["CSyncActiveQueue"] = "CSyncActiveQueue";
    return 1;
}

int lua_corelib_CSyncActiveQueueWrap_flushQueue(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueueWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueueWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueueWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueueWrap_flushQueue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->flushQueue();
        return 0;
    }

    gxError("CSyncActiveQueueWrap:flushQueue has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueueWrap_flushQueue'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueueWrap_setLoopThread(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueueWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueueWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueueWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueueWrap_setLoopThread'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CModuleThreadLoop* arg0;

        ok &= luaval_to_object<GXMISC::CModuleThreadLoop>(tolua_S, 2, "CModuleThreadLoop", &arg0, "CSyncActiveQueueWrap:setLoopThread");
        if(!ok)
            return 0;
        cobj->setLoopThread(arg0);
        return 0;
    }

    gxError("CSyncActiveQueueWrap:setLoopThread has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueueWrap_setLoopThread'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueueWrap_setLoopThreadWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueueWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueueWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueueWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueueWrap_setLoopThreadWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CModuleThreadLoopWrap* arg0;

        ok &= luaval_to_object<GXMISC::CModuleThreadLoopWrap>(tolua_S, 2, "CModuleThreadLoopWrap", &arg0, "CSyncActiveQueueWrap:setLoopThreadWrap");
        if(!ok)
            return 0;
        cobj->setLoopThreadWrap(arg0);
        return 0;
    }

    gxError("CSyncActiveQueueWrap:setLoopThreadWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueueWrap_setLoopThreadWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueueWrap_setCommunicationQ(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueueWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueueWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueueWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueueWrap_setCommunicationQ'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::CSyncActiveQueue* arg0;
        GXMISC::CSyncActiveQueue* arg1;

        ok &= luaval_to_object<GXMISC::CSyncActiveQueue>(tolua_S, 2, "CSyncActiveQueue", &arg0, "CSyncActiveQueueWrap:setCommunicationQ");

        ok &= luaval_to_object<GXMISC::CSyncActiveQueue>(tolua_S, 3, "CSyncActiveQueue", &arg1, "CSyncActiveQueueWrap:setCommunicationQ");
        if(!ok)
            return 0;
        cobj->setCommunicationQ(arg0, arg1);
        return 0;
    }

    gxError("CSyncActiveQueueWrap:setCommunicationQ has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueueWrap_setCommunicationQ'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueueWrap_update(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueueWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueueWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueueWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueueWrap_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CSyncActiveQueueWrap:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CSyncActiveQueueWrap:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueueWrap_update'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueueWrap_genUID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueueWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueueWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueueWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueueWrap_genUID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->genUID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CSyncActiveQueueWrap:genUID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueueWrap_genUID'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueueWrap_handleTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueueWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueueWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueueWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueueWrap_handleTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSyncActiveQueueWrap:handleTask");
        if(!ok)
            return 0;
        cobj->handleTask(arg0);
        return 0;
    }

    gxError("CSyncActiveQueueWrap:handleTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueueWrap_handleTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueueWrap_setThreadID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueueWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueueWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueueWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueueWrap_setThreadID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setThreadID();
        return 0;
    }
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSyncActiveQueueWrap:setThreadID");
        if(!ok)
            return 0;
        cobj->setThreadID(arg0);
        return 0;
    }

    gxError("CSyncActiveQueueWrap:setThreadID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueueWrap_setThreadID'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueueWrap_freeObj(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueueWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueueWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueueWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueueWrap_freeObj'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CTask* arg0;

        ok &= luaval_to_object<GXMISC::CTask>(tolua_S, 2, "CTask", &arg0, "CSyncActiveQueueWrap:freeObj");
        if(!ok)
            return 0;
        cobj->freeObj(arg0);
        return 0;
    }

    gxError("CSyncActiveQueueWrap:freeObj has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueueWrap_freeObj'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueueWrap_doProfile(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueueWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSyncActiveQueueWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSyncActiveQueueWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSyncActiveQueueWrap_doProfile'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doProfile();
        return 0;
    }

    gxError("CSyncActiveQueueWrap:doProfile has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSyncActiveQueueWrap_doProfile'.",&tolua_err);
	return 0;
}
int lua_corelib_CSyncActiveQueueWrap_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSyncActiveQueueWrap* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CSyncActiveQueueWrap();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSyncActiveQueueWrap");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSyncActiveQueueWrap:CSyncActiveQueueWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CSyncActiveQueueWrap_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSyncActiveQueueWrap)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSyncActiveQueueWrap",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSyncActiveQueueWrap* self = (GXMISC::CSyncActiveQueueWrap*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSyncActiveQueueWrap(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSyncActiveQueueWrap");
    tolua_cclass(tolua_S,"CSyncActiveQueueWrap","CSyncActiveQueueWrap","",lua_corelib_CSyncActiveQueueWrap_finalize);

    tolua_beginmodule(tolua_S,"CSyncActiveQueueWrap");
        tolua_function(tolua_S,"new",lua_corelib_CSyncActiveQueueWrap_constructor);
        tolua_function(tolua_S,"flushQueue",lua_corelib_CSyncActiveQueueWrap_flushQueue);
        tolua_function(tolua_S,"setLoopThread",lua_corelib_CSyncActiveQueueWrap_setLoopThread);
        tolua_function(tolua_S,"setLoopThreadWrap",lua_corelib_CSyncActiveQueueWrap_setLoopThreadWrap);
        tolua_function(tolua_S,"setCommunicationQ",lua_corelib_CSyncActiveQueueWrap_setCommunicationQ);
        tolua_function(tolua_S,"update",lua_corelib_CSyncActiveQueueWrap_update);
        tolua_function(tolua_S,"genUID",lua_corelib_CSyncActiveQueueWrap_genUID);
        tolua_function(tolua_S,"handleTask",lua_corelib_CSyncActiveQueueWrap_handleTask);
        tolua_function(tolua_S,"setThreadID",lua_corelib_CSyncActiveQueueWrap_setThreadID);
        tolua_function(tolua_S,"freeObj",lua_corelib_CSyncActiveQueueWrap_freeObj);
        tolua_function(tolua_S,"doProfile",lua_corelib_CSyncActiveQueueWrap_doProfile);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSyncActiveQueueWrap).name();
    g_luaType[typeName] = "CSyncActiveQueueWrap";
    g_typeCast["CSyncActiveQueueWrap"] = "CSyncActiveQueueWrap";
    return 1;
}

int lua_corelib_CIntervalTimer_reset(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimer_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CIntervalTimer:reset");
        if(!ok)
            return 0;
        cobj->reset(arg0);
        return 0;
    }

    gxError("CIntervalTimer:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimer_reset'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimer_getCurInterval(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimer_getCurInterval'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        long long ret = cobj->getCurInterval();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }

    gxError("CIntervalTimer:getCurInterval has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimer_getCurInterval'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimer_getRemainInterval(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimer_getRemainInterval'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        long long ret = cobj->getRemainInterval();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }

    gxError("CIntervalTimer:getRemainInterval has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimer_getRemainInterval'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimer_isValid(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimer_isValid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isValid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CIntervalTimer:isValid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimer_isValid'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimer_setMaxNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimer_setMaxNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CIntervalTimer:setMaxNum");
        if(!ok)
            return 0;
        cobj->setMaxNum(arg0);
        return 0;
    }

    gxError("CIntervalTimer:setMaxNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimer_setMaxNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimer_update(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimer_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        long long arg0;

        ok &= luaval_to_sint64(tolua_S, 2,(sint64*)&arg0, "CIntervalTimer:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CIntervalTimer:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimer_update'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimer_isPassed(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimer_isPassed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isPassed();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CIntervalTimer:isPassed has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimer_isPassed'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimer_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimer_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CIntervalTimer:init");
        if(!ok)
            return 0;
        cobj->init(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        unsigned int arg0;
        unsigned int arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CIntervalTimer:init");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CIntervalTimer:init");
        if(!ok)
            return 0;
        cobj->init(arg0, arg1);
        return 0;
    }

    gxError("CIntervalTimer:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimer_init'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimer_onTimeout(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimer_onTimeout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onTimeout();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CIntervalTimer:onTimeout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimer_onTimeout'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimer_doTimeout(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimer_doTimeout'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doTimeout();
        return 0;
    }

    gxError("CIntervalTimer:doTimeout has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimer_doTimeout'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimer_setMaxInterval(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimer_setMaxInterval'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        long long arg0;

        ok &= luaval_to_sint64(tolua_S, 2,(sint64*)&arg0, "CIntervalTimer:setMaxInterval");
        if(!ok)
            return 0;
        cobj->setMaxInterval(arg0);
        return 0;
    }

    gxError("CIntervalTimer:setMaxInterval has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimer_setMaxInterval'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimer_getRemainSecs(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimer_getRemainSecs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getRemainSecs();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CIntervalTimer:getRemainSecs has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimer_getRemainSecs'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimer_getMaxSecs(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimer_getMaxSecs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxSecs();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CIntervalTimer:getMaxSecs has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimer_getMaxSecs'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimer* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CIntervalTimer:CIntervalTimer");

            if (!ok) { break; }
            cobj = new GXMISC::CIntervalTimer(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CIntervalTimer");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CIntervalTimer:CIntervalTimer");

            if (!ok) { break; }
            unsigned int arg1;
            ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CIntervalTimer:CIntervalTimer");

            if (!ok) { break; }
            cobj = new GXMISC::CIntervalTimer(arg0, arg1);
            tolua_pushusertype(tolua_S,(void*)cobj,"CIntervalTimer");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CIntervalTimer();
            tolua_pushusertype(tolua_S,(void*)cobj,"CIntervalTimer");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CIntervalTimer:CIntervalTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CIntervalTimer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CIntervalTimer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CIntervalTimer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CIntervalTimer* self = (GXMISC::CIntervalTimer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CIntervalTimer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CIntervalTimer");
    tolua_cclass(tolua_S,"CIntervalTimer","CIntervalTimer","",lua_corelib_CIntervalTimer_finalize);

    tolua_beginmodule(tolua_S,"CIntervalTimer");
        tolua_function(tolua_S,"new",lua_corelib_CIntervalTimer_constructor);
        tolua_function(tolua_S,"reset",lua_corelib_CIntervalTimer_reset);
        tolua_function(tolua_S,"getCurInterval",lua_corelib_CIntervalTimer_getCurInterval);
        tolua_function(tolua_S,"getRemainInterval",lua_corelib_CIntervalTimer_getRemainInterval);
        tolua_function(tolua_S,"isValid",lua_corelib_CIntervalTimer_isValid);
        tolua_function(tolua_S,"setMaxNum",lua_corelib_CIntervalTimer_setMaxNum);
        tolua_function(tolua_S,"update",lua_corelib_CIntervalTimer_update);
        tolua_function(tolua_S,"isPassed",lua_corelib_CIntervalTimer_isPassed);
        tolua_function(tolua_S,"init",lua_corelib_CIntervalTimer_init);
        tolua_function(tolua_S,"onTimeout",lua_corelib_CIntervalTimer_onTimeout);
        tolua_function(tolua_S,"doTimeout",lua_corelib_CIntervalTimer_doTimeout);
        tolua_function(tolua_S,"setMaxInterval",lua_corelib_CIntervalTimer_setMaxInterval);
        tolua_function(tolua_S,"getRemainSecs",lua_corelib_CIntervalTimer_getRemainSecs);
        tolua_function(tolua_S,"getMaxSecs",lua_corelib_CIntervalTimer_getMaxSecs);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CIntervalTimer).name();
    g_luaType[typeName] = "CIntervalTimer";
    g_typeCast["CIntervalTimer"] = "CIntervalTimer";
    return 1;
}

int lua_corelib_CManualIntervalTimer_reset(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CManualIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CManualIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CManualIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CManualIntervalTimer_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CManualIntervalTimer:reset");
        if(!ok)
            return 0;
        cobj->reset(arg0);
        return 0;
    }

    gxError("CManualIntervalTimer:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CManualIntervalTimer_reset'.",&tolua_err);
	return 0;
}
int lua_corelib_CManualIntervalTimer_getCurInterval(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CManualIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CManualIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CManualIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CManualIntervalTimer_getCurInterval'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        long long ret = cobj->getCurInterval();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }

    gxError("CManualIntervalTimer:getCurInterval has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CManualIntervalTimer_getCurInterval'.",&tolua_err);
	return 0;
}
int lua_corelib_CManualIntervalTimer_getRemainInterval(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CManualIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CManualIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CManualIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CManualIntervalTimer_getRemainInterval'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        long long ret = cobj->getRemainInterval();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }

    gxError("CManualIntervalTimer:getRemainInterval has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CManualIntervalTimer_getRemainInterval'.",&tolua_err);
	return 0;
}
int lua_corelib_CManualIntervalTimer_update(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CManualIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CManualIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CManualIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CManualIntervalTimer_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        long long arg0;

        ok &= luaval_to_sint64(tolua_S, 2,(sint64*)&arg0, "CManualIntervalTimer:update");
        if(!ok)
            return 0;
        bool ret = cobj->update(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CManualIntervalTimer:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CManualIntervalTimer_update'.",&tolua_err);
	return 0;
}
int lua_corelib_CManualIntervalTimer_isPassed(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CManualIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CManualIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CManualIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CManualIntervalTimer_isPassed'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isPassed();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CManualIntervalTimer:isPassed has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CManualIntervalTimer_isPassed'.",&tolua_err);
	return 0;
}
int lua_corelib_CManualIntervalTimer_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CManualIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CManualIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CManualIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CManualIntervalTimer_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CManualIntervalTimer:init");
        if(!ok)
            return 0;
        cobj->init(arg0);
        return 0;
    }

    gxError("CManualIntervalTimer:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CManualIntervalTimer_init'.",&tolua_err);
	return 0;
}
int lua_corelib_CManualIntervalTimer_setMaxInterval(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CManualIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CManualIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CManualIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CManualIntervalTimer_setMaxInterval'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        long long arg0;

        ok &= luaval_to_sint64(tolua_S, 2,(sint64*)&arg0, "CManualIntervalTimer:setMaxInterval");
        if(!ok)
            return 0;
        cobj->setMaxInterval(arg0);
        return 0;
    }

    gxError("CManualIntervalTimer:setMaxInterval has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CManualIntervalTimer_setMaxInterval'.",&tolua_err);
	return 0;
}
int lua_corelib_CManualIntervalTimer_getRemainSecs(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CManualIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CManualIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CManualIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CManualIntervalTimer_getRemainSecs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getRemainSecs();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CManualIntervalTimer:getRemainSecs has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CManualIntervalTimer_getRemainSecs'.",&tolua_err);
	return 0;
}
int lua_corelib_CManualIntervalTimer_getMaxSecs(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CManualIntervalTimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CManualIntervalTimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CManualIntervalTimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CManualIntervalTimer_getMaxSecs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxSecs();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CManualIntervalTimer:getMaxSecs has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CManualIntervalTimer_getMaxSecs'.",&tolua_err);
	return 0;
}
int lua_corelib_CManualIntervalTimer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CManualIntervalTimer* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CManualIntervalTimer:CManualIntervalTimer");

            if (!ok) { break; }
            cobj = new GXMISC::CManualIntervalTimer(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CManualIntervalTimer");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CManualIntervalTimer();
            tolua_pushusertype(tolua_S,(void*)cobj,"CManualIntervalTimer");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CManualIntervalTimer:CManualIntervalTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CManualIntervalTimer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CManualIntervalTimer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CManualIntervalTimer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CManualIntervalTimer* self = (GXMISC::CManualIntervalTimer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CManualIntervalTimer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CManualIntervalTimer");
    tolua_cclass(tolua_S,"CManualIntervalTimer","CManualIntervalTimer","",lua_corelib_CManualIntervalTimer_finalize);

    tolua_beginmodule(tolua_S,"CManualIntervalTimer");
        tolua_function(tolua_S,"new",lua_corelib_CManualIntervalTimer_constructor);
        tolua_function(tolua_S,"reset",lua_corelib_CManualIntervalTimer_reset);
        tolua_function(tolua_S,"getCurInterval",lua_corelib_CManualIntervalTimer_getCurInterval);
        tolua_function(tolua_S,"getRemainInterval",lua_corelib_CManualIntervalTimer_getRemainInterval);
        tolua_function(tolua_S,"update",lua_corelib_CManualIntervalTimer_update);
        tolua_function(tolua_S,"isPassed",lua_corelib_CManualIntervalTimer_isPassed);
        tolua_function(tolua_S,"init",lua_corelib_CManualIntervalTimer_init);
        tolua_function(tolua_S,"setMaxInterval",lua_corelib_CManualIntervalTimer_setMaxInterval);
        tolua_function(tolua_S,"getRemainSecs",lua_corelib_CManualIntervalTimer_getRemainSecs);
        tolua_function(tolua_S,"getMaxSecs",lua_corelib_CManualIntervalTimer_getMaxSecs);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CManualIntervalTimer).name();
    g_luaType[typeName] = "CManualIntervalTimer";
    g_typeCast["CManualIntervalTimer"] = "CManualIntervalTimer";
    return 1;
}

int lua_corelib_CIntervalTimerMgr_addTimer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimerMgr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimerMgr",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimerMgr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimerMgr_addTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CIntervalTimer* arg0;

        ok &= luaval_to_object<GXMISC::CIntervalTimer>(tolua_S, 2, "CIntervalTimer", &arg0, "CIntervalTimerMgr:addTimer");
        if(!ok)
            return 0;
        cobj->addTimer(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        GXMISC::CIntervalTimer* arg0;
        bool arg1;

        ok &= luaval_to_object<GXMISC::CIntervalTimer>(tolua_S, 2, "CIntervalTimer", &arg0, "CIntervalTimerMgr:addTimer");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CIntervalTimerMgr:addTimer");
        if(!ok)
            return 0;
        cobj->addTimer(arg0, arg1);
        return 0;
    }

    gxError("CIntervalTimerMgr:addTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimerMgr_addTimer'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimerMgr_update(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimerMgr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIntervalTimerMgr",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIntervalTimerMgr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIntervalTimerMgr_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        long long arg0;

        ok &= luaval_to_sint64(tolua_S, 2,(sint64*)&arg0, "CIntervalTimerMgr:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CIntervalTimerMgr:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIntervalTimerMgr_update'.",&tolua_err);
	return 0;
}
int lua_corelib_CIntervalTimerMgr_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIntervalTimerMgr* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CIntervalTimerMgr();
        tolua_pushusertype(tolua_S,(void*)cobj,"CIntervalTimerMgr");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CIntervalTimerMgr:CIntervalTimerMgr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CIntervalTimerMgr_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CIntervalTimerMgr)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CIntervalTimerMgr",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CIntervalTimerMgr* self = (GXMISC::CIntervalTimerMgr*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CIntervalTimerMgr(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CIntervalTimerMgr");
    tolua_cclass(tolua_S,"CIntervalTimerMgr","CIntervalTimerMgr","CManualSingleton<CIntervalTimerMgr>",lua_corelib_CIntervalTimerMgr_finalize);

    tolua_beginmodule(tolua_S,"CIntervalTimerMgr");
        tolua_function(tolua_S,"new",lua_corelib_CIntervalTimerMgr_constructor);
        tolua_function(tolua_S,"addTimer",lua_corelib_CIntervalTimerMgr_addTimer);
        tolua_function(tolua_S,"update",lua_corelib_CIntervalTimerMgr_update);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CIntervalTimerMgr).name();
    g_luaType[typeName] = "CIntervalTimerMgr";
    g_typeCast["CIntervalTimerMgr"] = "CIntervalTimerMgr";
    return 1;
}

int lua_corelib_CConfigMap_readTypeIfExist(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CConfigMap* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConfigMap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CConfigMap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_corelib_CConfigMap_readTypeIfExist'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CConfigMap:readTypeIfExist"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            const char* arg1;
            CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CConfigMap:readTypeIfExist"); arg1 = (char*)arg1_tmp.buffer;

            if (!ok) { break; }
            std::string arg2;
            ok &= luaval_to_std_string(tolua_S, 4,&arg2, "CConfigMap:readTypeIfExist");

            if (!ok) { break; }
            bool ret = cobj->readTypeIfExist(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CConfigMap:readTypeIfExist"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            const char* arg1;
            CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CConfigMap:readTypeIfExist"); arg1 = (char*)arg1_tmp.buffer;

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "CConfigMap:readTypeIfExist");

            if (!ok) { break; }
            bool ret = cobj->readTypeIfExist(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CConfigMap:readTypeIfExist has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CConfigMap_readTypeIfExist'.",&tolua_err);
    return 0;
}
int lua_corelib_CConfigMap_getConfigs(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CConfigMap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConfigMap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CConfigMap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CConfigMap_getConfigs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::map<std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::basic_string<char> > > >, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::basic_string<char> > > > > > >* ret = cobj->getConfigs();
        object_to_luaval<std::map<std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<std::basic_string<char>, std::basic_string<char> > > >, std::less<std::basic_string<char> >, std::allocator<std::pair<std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<std::basic_string<char>, std::basic_string<char> > > > > > >>(tolua_S, "std::map<std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::basic_string<char> > > >, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::basic_string<char> > > > > > >*",(std::map<std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<std::basic_string<char>, std::basic_string<char> > > >, std::less<std::basic_string<char> >, std::allocator<std::pair<std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<std::basic_string<char>, std::basic_string<char> > > > > > >*)ret);
        return 1;
    }

    gxError("CConfigMap:getConfigs has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CConfigMap_getConfigs'.",&tolua_err);
	return 0;
}
int lua_corelib_CConfigMap_readConfigValue(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CConfigMap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConfigMap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CConfigMap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CConfigMap_readConfigValue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        const char* arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CConfigMap:readConfigValue"); arg0 = (char*)arg0_tmp.buffer;

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CConfigMap:readConfigValue"); arg1 = (char*)arg1_tmp.buffer;
        if(!ok)
            return 0;
        int ret = cobj->readConfigValue(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CConfigMap:readConfigValue has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CConfigMap_readConfigValue'.",&tolua_err);
	return 0;
}
int lua_corelib_CConfigMap_setConfigs(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CConfigMap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConfigMap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CConfigMap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CConfigMap_setConfigs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::map<std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::basic_string<char> > > >, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::basic_string<char> > > > > > >* arg0;

        ok &= luaval_to_object<std::map<std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::basic_string<char> > > >, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::basic_string<char> > > > > > >>(tolua_S, 2, "std::map<std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::basic_string<char> > > >, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::map<std::basic_string<char>, std::basic_string<char>, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, std::basic_string<char> > > > > > >*", &arg0, "CConfigMap:setConfigs");
        if(!ok)
            return 0;
        cobj->setConfigs(arg0);
        return 0;
    }

    gxError("CConfigMap:setConfigs has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CConfigMap_setConfigs'.",&tolua_err);
	return 0;
}
int lua_corelib_CConfigMap_readConfigText(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CConfigMap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CConfigMap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CConfigMap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CConfigMap_readConfigText'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        const char* arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CConfigMap:readConfigText"); arg0 = (char*)arg0_tmp.buffer;

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CConfigMap:readConfigText"); arg1 = (char*)arg1_tmp.buffer;
        if(!ok)
            return 0;
        std::string ret = cobj->readConfigText(arg0, arg1);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CConfigMap:readConfigText has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CConfigMap_readConfigText'.",&tolua_err);
	return 0;
}
int lua_corelib_CConfigMap_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CConfigMap* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CConfigMap();
        tolua_pushusertype(tolua_S,(void*)cobj,"CConfigMap");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CConfigMap:CConfigMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CConfigMap_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CConfigMap)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CConfigMap",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CConfigMap* self = (GXMISC::CConfigMap*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CConfigMap(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CConfigMap");
    tolua_cclass(tolua_S,"CConfigMap","CConfigMap","",lua_corelib_CConfigMap_finalize);

    tolua_beginmodule(tolua_S,"CConfigMap");
        tolua_function(tolua_S,"new",lua_corelib_CConfigMap_constructor);
        tolua_function(tolua_S,"readTypeIfExist",lua_corelib_CConfigMap_readTypeIfExist);
        tolua_function(tolua_S,"getConfigs",lua_corelib_CConfigMap_getConfigs);
        tolua_function(tolua_S,"readConfigValue",lua_corelib_CConfigMap_readConfigValue);
        tolua_function(tolua_S,"setConfigs",lua_corelib_CConfigMap_setConfigs);
        tolua_function(tolua_S,"readConfigText",lua_corelib_CConfigMap_readConfigText);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CConfigMap).name();
    g_luaType[typeName] = "CConfigMap";
    g_typeCast["CConfigMap"] = "CConfigMap";
    return 1;
}

int lua_corelib_IModuleConfig_getFrameNumPerSecond(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleConfig_getFrameNumPerSecond'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFrameNumPerSecond();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IModuleConfig:getFrameNumPerSecond has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleConfig_getFrameNumPerSecond'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleConfig_setModuleName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleConfig_setModuleName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "IModuleConfig:setModuleName");
        if(!ok)
            return 0;
        cobj->setModuleName(arg0);
        return 0;
    }

    gxError("IModuleConfig:setModuleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleConfig_setModuleName'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleConfig_getCloseWaitSecsAllLoop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleConfig_getCloseWaitSecsAllLoop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getCloseWaitSecsAllLoop();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IModuleConfig:getCloseWaitSecsAllLoop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleConfig_getCloseWaitSecsAllLoop'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleConfig_getMaxUserNumPerLoop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleConfig_getMaxUserNumPerLoop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxUserNumPerLoop();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IModuleConfig:getMaxUserNumPerLoop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleConfig_getMaxUserNumPerLoop'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleConfig_getModuleName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleConfig_getModuleName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getModuleName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("IModuleConfig:getModuleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleConfig_getModuleName'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleConfig_onLoadConfig(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleConfig_onLoadConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const GXMISC::CConfigMap* arg0;

        ok &= luaval_to_object<const GXMISC::CConfigMap>(tolua_S, 2, "CConfigMap", &arg0, "IModuleConfig:onLoadConfig");
        if(!ok)
            return 0;
        bool ret = cobj->onLoadConfig(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IModuleConfig:onLoadConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleConfig_onLoadConfig'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleConfig_getLoopThreadNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleConfig_getLoopThreadNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getLoopThreadNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IModuleConfig:getLoopThreadNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleConfig_getLoopThreadNum'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleConfig_check(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleConfig_check'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->check();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IModuleConfig:check has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleConfig_check'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleConfig_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleConfig* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "IModuleConfig:IModuleConfig");
        if(!ok)
            return 0;
        cobj = new GXMISC::IModuleConfig(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"IModuleConfig");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("IModuleConfig:IModuleConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_IModuleConfig_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IModuleConfig)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IModuleConfig",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IModuleConfig* self = (GXMISC::IModuleConfig*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IModuleConfig(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IModuleConfig");
    tolua_cclass(tolua_S,"IModuleConfig","IModuleConfig","",lua_corelib_IModuleConfig_finalize);

    tolua_beginmodule(tolua_S,"IModuleConfig");
        tolua_function(tolua_S,"new",lua_corelib_IModuleConfig_constructor);
        tolua_function(tolua_S,"getFrameNumPerSecond",lua_corelib_IModuleConfig_getFrameNumPerSecond);
        tolua_function(tolua_S,"setModuleName",lua_corelib_IModuleConfig_setModuleName);
        tolua_function(tolua_S,"getCloseWaitSecsAllLoop",lua_corelib_IModuleConfig_getCloseWaitSecsAllLoop);
        tolua_function(tolua_S,"getMaxUserNumPerLoop",lua_corelib_IModuleConfig_getMaxUserNumPerLoop);
        tolua_function(tolua_S,"getModuleName",lua_corelib_IModuleConfig_getModuleName);
        tolua_function(tolua_S,"onLoadConfig",lua_corelib_IModuleConfig_onLoadConfig);
        tolua_function(tolua_S,"getLoopThreadNum",lua_corelib_IModuleConfig_getLoopThreadNum);
        tolua_function(tolua_S,"check",lua_corelib_IModuleConfig_check);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IModuleConfig).name();
    g_luaType[typeName] = "IModuleConfig";
    g_typeCast["IModuleConfig"] = "IModuleConfig";
    return 1;
}

int lua_corelib_IModuleManager_setModuleName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleManager_setModuleName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "IModuleManager:setModuleName");
        if(!ok)
            return 0;
        cobj->setModuleName(arg0);
        return 0;
    }

    gxError("IModuleManager:setModuleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleManager_setModuleName'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleManager_start(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleManager_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IModuleManager:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleManager_start'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleManager_getModuleName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleManager_getModuleName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getModuleName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("IModuleManager:getModuleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleManager_getModuleName'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleManager_getModuleConfig(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleManager_getModuleConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::IModuleConfig* ret = cobj->getModuleConfig();
        object_to_luaval<GXMISC::IModuleConfig>(tolua_S, "IModuleConfig",(GXMISC::IModuleConfig*)ret);
        return 1;
    }

    gxError("IModuleManager:getModuleConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleManager_getModuleConfig'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleManager_onLoadConfig(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleManager_onLoadConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const GXMISC::CConfigMap* arg0;

        ok &= luaval_to_object<const GXMISC::CConfigMap>(tolua_S, 2, "CConfigMap", &arg0, "IModuleManager:onLoadConfig");
        if(!ok)
            return 0;
        bool ret = cobj->onLoadConfig(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IModuleManager:onLoadConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleManager_onLoadConfig'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleManager_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleManager_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IModuleManager:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleManager_init'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleManager_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleManager_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("IModuleManager:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleManager_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleManager_loop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleManager_loop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IModuleManager:loop");
        if(!ok)
            return 0;
        bool ret = cobj->loop(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IModuleManager:loop has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleManager_loop'.",&tolua_err);
	return 0;
}
int lua_corelib_IModuleManager_onStat(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IModuleManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IModuleManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IModuleManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IModuleManager_onStat'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onStat();
        return 0;
    }

    gxError("IModuleManager:onStat has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IModuleManager_onStat'.",&tolua_err);
	return 0;
}
static int lua_corelib_IModuleManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IModuleManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IModuleManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IModuleManager* self = (GXMISC::IModuleManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IModuleManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IModuleManager");
    tolua_cclass(tolua_S,"IModuleManager","IModuleManager","IStopHandler",nullptr);

    tolua_beginmodule(tolua_S,"IModuleManager");
        tolua_function(tolua_S,"setModuleName",lua_corelib_IModuleManager_setModuleName);
        tolua_function(tolua_S,"start",lua_corelib_IModuleManager_start);
        tolua_function(tolua_S,"getModuleName",lua_corelib_IModuleManager_getModuleName);
        tolua_function(tolua_S,"getModuleConfig",lua_corelib_IModuleManager_getModuleConfig);
        tolua_function(tolua_S,"onLoadConfig",lua_corelib_IModuleManager_onLoadConfig);
        tolua_function(tolua_S,"init",lua_corelib_IModuleManager_init);
        tolua_function(tolua_S,"cleanUp",lua_corelib_IModuleManager_cleanUp);
        tolua_function(tolua_S,"loop",lua_corelib_IModuleManager_loop);
        tolua_function(tolua_S,"onStat",lua_corelib_IModuleManager_onStat);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IModuleManager).name();
    g_luaType[typeName] = "IModuleManager";
    g_typeCast["IModuleManager"] = "IModuleManager";
    return 1;
}

int lua_corelib_IServiceModule_getCurrentLoopTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IServiceModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IServiceModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IServiceModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IServiceModule_getCurrentLoopTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        long long ret = cobj->getCurrentLoopTime();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }

    gxError("IServiceModule:getCurrentLoopTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IServiceModule_getCurrentLoopTime'.",&tolua_err);
	return 0;
}
int lua_corelib_IServiceModule_start(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IServiceModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IServiceModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IServiceModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IServiceModule_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IServiceModule:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IServiceModule_start'.",&tolua_err);
	return 0;
}
int lua_corelib_IServiceModule_isInitLoop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IServiceModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IServiceModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IServiceModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IServiceModule_isInitLoop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isInitLoop();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IServiceModule:isInitLoop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IServiceModule_isInitLoop'.",&tolua_err);
	return 0;
}
int lua_corelib_IServiceModule_getLastLoopTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IServiceModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IServiceModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IServiceModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IServiceModule_getLastLoopTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        long long ret = cobj->getLastLoopTime();
        lua_tinker::push(tolua_S,(sint64)ret);
        return 1;
    }

    gxError("IServiceModule:getLastLoopTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IServiceModule_getLastLoopTime'.",&tolua_err);
	return 0;
}
int lua_corelib_IServiceModule_loop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IServiceModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IServiceModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IServiceModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IServiceModule_loop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IServiceModule:loop");
        if(!ok)
            return 0;
        bool ret = cobj->loop(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IServiceModule:loop has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IServiceModule_loop'.",&tolua_err);
	return 0;
}
static int lua_corelib_IServiceModule_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IServiceModule)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IServiceModule",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IServiceModule* self = (GXMISC::IServiceModule*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IServiceModule(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IServiceModule");
    tolua_cclass(tolua_S,"IServiceModule","IServiceModule","IModuleManager",nullptr);

    tolua_beginmodule(tolua_S,"IServiceModule");
        tolua_function(tolua_S,"getCurrentLoopTime",lua_corelib_IServiceModule_getCurrentLoopTime);
        tolua_function(tolua_S,"start",lua_corelib_IServiceModule_start);
        tolua_function(tolua_S,"isInitLoop",lua_corelib_IServiceModule_isInitLoop);
        tolua_function(tolua_S,"getLastLoopTime",lua_corelib_IServiceModule_getLastLoopTime);
        tolua_function(tolua_S,"loop",lua_corelib_IServiceModule_loop);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IServiceModule).name();
    g_luaType[typeName] = "IServiceModule";
    g_typeCast["IServiceModule"] = "IServiceModule";
    return 1;
}

int lua_corelib_CModuleThreadLoop_getThreadLoopWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoop_getThreadLoopWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CModuleThreadLoopWrap* ret = cobj->getThreadLoopWrap();
        object_to_luaval<GXMISC::CModuleThreadLoopWrap>(tolua_S, "CModuleThreadLoopWrap",(GXMISC::CModuleThreadLoopWrap*)ret);
        return 1;
    }

    gxError("CModuleThreadLoop:getThreadLoopWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoop_getThreadLoopWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoop_run(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoop_run'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->run();
        return 0;
    }

    gxError("CModuleThreadLoop:run has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoop_run'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoop_setLoopWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoop_setLoopWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CModuleThreadLoopWrap* arg0;

        ok &= luaval_to_object<GXMISC::CModuleThreadLoopWrap>(tolua_S, 2, "CModuleThreadLoopWrap", &arg0, "CModuleThreadLoop:setLoopWrap");
        if(!ok)
            return 0;
        cobj->setLoopWrap(arg0);
        return 0;
    }

    gxError("CModuleThreadLoop:setLoopWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoop_setLoopWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoop_freeTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoop_freeTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CTask* arg0;

        ok &= luaval_to_object<GXMISC::CTask>(tolua_S, 2, "CTask", &arg0, "CModuleThreadLoop:freeTask");
        if(!ok)
            return 0;
        cobj->freeTask(arg0);
        return 0;
    }

    gxError("CModuleThreadLoop:freeTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoop_freeTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoop_setFreeFlag(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoop_setFreeFlag'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CModuleThreadLoop:setFreeFlag");
        if(!ok)
            return 0;
        cobj->setFreeFlag(arg0);
        return 0;
    }

    gxError("CModuleThreadLoop:setFreeFlag has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoop_setFreeFlag'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoop_setCommunicationQ(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoop_setCommunicationQ'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::CSyncActiveQueue* arg0;
        GXMISC::CSyncActiveQueue* arg1;

        ok &= luaval_to_object<GXMISC::CSyncActiveQueue>(tolua_S, 2, "CSyncActiveQueue", &arg0, "CModuleThreadLoop:setCommunicationQ");

        ok &= luaval_to_object<GXMISC::CSyncActiveQueue>(tolua_S, 3, "CSyncActiveQueue", &arg1, "CModuleThreadLoop:setCommunicationQ");
        if(!ok)
            return 0;
        cobj->setCommunicationQ(arg0, arg1);
        return 0;
    }

    gxError("CModuleThreadLoop:setCommunicationQ has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoop_setCommunicationQ'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoop_getTaskQueueWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoop_getTaskQueueWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const GXMISC::CSyncActiveQueueWrap* ret = cobj->getTaskQueueWrap();
        object_to_luaval<GXMISC::CSyncActiveQueueWrap>(tolua_S, "CSyncActiveQueueWrap",(GXMISC::CSyncActiveQueueWrap*)ret);
        return 1;
    }

    gxError("CModuleThreadLoop:getTaskQueueWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoop_getTaskQueueWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoop_start(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoop_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModuleThreadLoop:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoop_start'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoop_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoop_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModuleThreadLoop:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoop_init'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoop_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoop_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CModuleThreadLoop:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoop_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoop_needFree(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoop_needFree'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->needFree();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModuleThreadLoop:needFree has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoop_needFree'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoop_setModuleConfig(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoop_setModuleConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::IModuleConfig* arg0;

        ok &= luaval_to_object<GXMISC::IModuleConfig>(tolua_S, 2, "IModuleConfig", &arg0, "CModuleThreadLoop:setModuleConfig");
        if(!ok)
            return 0;
        cobj->setModuleConfig(arg0);
        return 0;
    }

    gxError("CModuleThreadLoop:setModuleConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoop_setModuleConfig'.",&tolua_err);
	return 0;
}
static int lua_corelib_CModuleThreadLoop_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CModuleThreadLoop)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CModuleThreadLoop",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CModuleThreadLoop* self = (GXMISC::CModuleThreadLoop*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CModuleThreadLoop(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CModuleThreadLoop");
    tolua_cclass(tolua_S,"CModuleThreadLoop","CModuleThreadLoop","IRunnable",nullptr);

    tolua_beginmodule(tolua_S,"CModuleThreadLoop");
        tolua_function(tolua_S,"getThreadLoopWrap",lua_corelib_CModuleThreadLoop_getThreadLoopWrap);
        tolua_function(tolua_S,"run",lua_corelib_CModuleThreadLoop_run);
        tolua_function(tolua_S,"setLoopWrap",lua_corelib_CModuleThreadLoop_setLoopWrap);
        tolua_function(tolua_S,"freeTask",lua_corelib_CModuleThreadLoop_freeTask);
        tolua_function(tolua_S,"setFreeFlag",lua_corelib_CModuleThreadLoop_setFreeFlag);
        tolua_function(tolua_S,"setCommunicationQ",lua_corelib_CModuleThreadLoop_setCommunicationQ);
        tolua_function(tolua_S,"getTaskQueueWrap",lua_corelib_CModuleThreadLoop_getTaskQueueWrap);
        tolua_function(tolua_S,"start",lua_corelib_CModuleThreadLoop_start);
        tolua_function(tolua_S,"init",lua_corelib_CModuleThreadLoop_init);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CModuleThreadLoop_cleanUp);
        tolua_function(tolua_S,"needFree",lua_corelib_CModuleThreadLoop_needFree);
        tolua_function(tolua_S,"setModuleConfig",lua_corelib_CModuleThreadLoop_setModuleConfig);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CModuleThreadLoop).name();
    g_luaType[typeName] = "CModuleThreadLoop";
    g_typeCast["CModuleThreadLoop"] = "CModuleThreadLoop";
    return 1;
}

int lua_corelib_CModuleThreadLoopWrap_isUserIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_isUserIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CModuleThreadLoopWrap:isUserIndex");
        if(!ok)
            return 0;
        bool ret = cobj->isUserIndex(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:isUserIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_isUserIndex'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_isMaxUserNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_isMaxUserNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isMaxUserNum();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:isMaxUserNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_isMaxUserNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_isRunning(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_isRunning'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isRunning();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:isRunning has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_isRunning'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_setTagId(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_setTagId'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CModuleThreadLoopWrap:setTagId");
        if(!ok)
            return 0;
        cobj->setTagId(arg0);
        return 0;
    }

    gxError("CModuleThreadLoopWrap:setTagId has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_setTagId'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_freeTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_freeTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CTask* arg0;

        ok &= luaval_to_object<GXMISC::CTask>(tolua_S, 2, "CTask", &arg0, "CModuleThreadLoopWrap:freeTask");
        if(!ok)
            return 0;
        cobj->freeTask(arg0);
        return 0;
    }

    gxError("CModuleThreadLoopWrap:freeTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_freeTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_setService(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_setService'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::GxService* arg0;

        ok &= luaval_to_object<GXMISC::GxService>(tolua_S, 2, "GxService", &arg0, "CModuleThreadLoopWrap:setService");
        if(!ok)
            return 0;
        cobj->setService(arg0);
        return 0;
    }

    gxError("CModuleThreadLoopWrap:setService has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_setService'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_stop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_stop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->stop();
        return 0;
    }

    gxError("CModuleThreadLoopWrap:stop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_stop'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_getTaskQueueWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_getTaskQueueWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const GXMISC::CSyncActiveQueueWrap* ret = cobj->getTaskQueueWrap();
        object_to_luaval<GXMISC::CSyncActiveQueueWrap>(tolua_S, "CSyncActiveQueueWrap",(GXMISC::CSyncActiveQueueWrap*)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:getTaskQueueWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_getTaskQueueWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_getService(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_getService'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::GxService* ret = cobj->getService();
        object_to_luaval<GXMISC::GxService>(tolua_S, "GxService",(GXMISC::GxService*)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:getService has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_getService'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_breath(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_breath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CModuleThreadLoopWrap:breath");
        if(!ok)
            return 0;
        cobj->breath(arg0);
        return 0;
    }

    gxError("CModuleThreadLoopWrap:breath has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_breath'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_start(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_start'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_init'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CModuleThreadLoopWrap:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_getMaxUserNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_getMaxUserNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxUserNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:getMaxUserNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_getMaxUserNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_getModuleThreadLoop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_getModuleThreadLoop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CModuleThreadLoop* ret = cobj->getModuleThreadLoop();
        object_to_luaval<GXMISC::CModuleThreadLoop>(tolua_S, "CModuleThreadLoop",(GXMISC::CModuleThreadLoop*)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:getModuleThreadLoop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_getModuleThreadLoop'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_isExitRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_isExitRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isExitRun();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:isExitRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_isExitRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_genUniqueIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_genUniqueIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->genUniqueIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:genUniqueIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_genUniqueIndex'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_getUserNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_getUserNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getUserNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:getUserNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_getUserNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_getTagId(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_getTagId'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getTagId();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:getTagId has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_getTagId'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleThreadLoopWrap_getOutputQSize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleThreadLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleThreadLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleThreadLoopWrap_getOutputQSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getOutputQSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModuleThreadLoopWrap:getOutputQSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleThreadLoopWrap_getOutputQSize'.",&tolua_err);
	return 0;
}
static int lua_corelib_CModuleThreadLoopWrap_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CModuleThreadLoopWrap)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CModuleThreadLoopWrap",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CModuleThreadLoopWrap* self = (GXMISC::CModuleThreadLoopWrap*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CModuleThreadLoopWrap(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CModuleThreadLoopWrap");
    tolua_cclass(tolua_S,"CModuleThreadLoopWrap","CModuleThreadLoopWrap","",nullptr);

    tolua_beginmodule(tolua_S,"CModuleThreadLoopWrap");
        tolua_function(tolua_S,"isUserIndex",lua_corelib_CModuleThreadLoopWrap_isUserIndex);
        tolua_function(tolua_S,"isMaxUserNum",lua_corelib_CModuleThreadLoopWrap_isMaxUserNum);
        tolua_function(tolua_S,"isRunning",lua_corelib_CModuleThreadLoopWrap_isRunning);
        tolua_function(tolua_S,"setTagId",lua_corelib_CModuleThreadLoopWrap_setTagId);
        tolua_function(tolua_S,"freeTask",lua_corelib_CModuleThreadLoopWrap_freeTask);
        tolua_function(tolua_S,"setService",lua_corelib_CModuleThreadLoopWrap_setService);
        tolua_function(tolua_S,"stop",lua_corelib_CModuleThreadLoopWrap_stop);
        tolua_function(tolua_S,"getTaskQueueWrap",lua_corelib_CModuleThreadLoopWrap_getTaskQueueWrap);
        tolua_function(tolua_S,"getService",lua_corelib_CModuleThreadLoopWrap_getService);
        tolua_function(tolua_S,"breath",lua_corelib_CModuleThreadLoopWrap_breath);
        tolua_function(tolua_S,"start",lua_corelib_CModuleThreadLoopWrap_start);
        tolua_function(tolua_S,"init",lua_corelib_CModuleThreadLoopWrap_init);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CModuleThreadLoopWrap_cleanUp);
        tolua_function(tolua_S,"getMaxUserNum",lua_corelib_CModuleThreadLoopWrap_getMaxUserNum);
        tolua_function(tolua_S,"getModuleThreadLoop",lua_corelib_CModuleThreadLoopWrap_getModuleThreadLoop);
        tolua_function(tolua_S,"isExitRun",lua_corelib_CModuleThreadLoopWrap_isExitRun);
        tolua_function(tolua_S,"genUniqueIndex",lua_corelib_CModuleThreadLoopWrap_genUniqueIndex);
        tolua_function(tolua_S,"getUserNum",lua_corelib_CModuleThreadLoopWrap_getUserNum);
        tolua_function(tolua_S,"getTagId",lua_corelib_CModuleThreadLoopWrap_getTagId);
        tolua_function(tolua_S,"getOutputQSize",lua_corelib_CModuleThreadLoopWrap_getOutputQSize);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CModuleThreadLoopWrap).name();
    g_luaType[typeName] = "CModuleThreadLoopWrap";
    g_typeCast["CModuleThreadLoopWrap"] = "CModuleThreadLoopWrap";
    return 1;
}

static int lua_corelib_CSimpleThreadLoopWrap_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSimpleThreadLoopWrap)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSimpleThreadLoopWrap",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSimpleThreadLoopWrap* self = (GXMISC::CSimpleThreadLoopWrap*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSimpleThreadLoopWrap(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSimpleThreadLoopWrap");
    tolua_cclass(tolua_S,"CSimpleThreadLoopWrap","CSimpleThreadLoopWrap","CModuleThreadLoopWrap",nullptr);

    tolua_beginmodule(tolua_S,"CSimpleThreadLoopWrap");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSimpleThreadLoopWrap).name();
    g_luaType[typeName] = "CSimpleThreadLoopWrap";
    g_typeCast["CSimpleThreadLoopWrap"] = "CSimpleThreadLoopWrap";
    return 1;
}

int lua_corelib_CModuleBase_checkAllLoopStop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleBase_checkAllLoopStop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->checkAllLoopStop();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModuleBase:checkAllLoopStop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleBase_checkAllLoopStop'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleBase_getMaxConnNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleBase_getMaxConnNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getMaxConnNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModuleBase:getMaxConnNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleBase_getMaxConnNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleBase_setService(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleBase_setService'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::GxService* arg0;

        ok &= luaval_to_object<GXMISC::GxService>(tolua_S, 2, "GxService", &arg0, "CModuleBase:setService");
        if(!ok)
            return 0;
        cobj->setService(arg0);
        return 0;
    }

    gxError("CModuleBase:setService has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleBase_setService'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleBase_getLeastLoop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleBase_getLeastLoop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CModuleThreadLoopWrap* ret = cobj->getLeastLoop();
        object_to_luaval<GXMISC::CModuleThreadLoopWrap>(tolua_S, "CModuleThreadLoopWrap",(GXMISC::CModuleThreadLoopWrap*)ret);
        return 1;
    }

    gxError("CModuleBase:getLeastLoop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleBase_getLeastLoop'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleBase_getService(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleBase_getService'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::GxService* ret = cobj->getService();
        object_to_luaval<GXMISC::GxService>(tolua_S, "GxService",(GXMISC::GxService*)ret);
        return 1;
    }

    gxError("CModuleBase:getService has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleBase_getService'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleBase_start(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleBase_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModuleBase:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleBase_start'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleBase_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleBase_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CModuleBase:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleBase_init'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleBase_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleBase_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CModuleBase:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleBase_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleBase_getLoopNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleBase_getLoopNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getLoopNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CModuleBase:getLoopNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleBase_getLoopNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CModuleBase_onStop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CModuleBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CModuleBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CModuleBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CModuleBase_onStop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onStop();
        return 0;
    }

    gxError("CModuleBase:onStop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CModuleBase_onStop'.",&tolua_err);
	return 0;
}
static int lua_corelib_CModuleBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CModuleBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CModuleBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CModuleBase* self = (GXMISC::CModuleBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CModuleBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CModuleBase");
    tolua_cclass(tolua_S,"CModuleBase","CModuleBase","IModuleManager",nullptr);

    tolua_beginmodule(tolua_S,"CModuleBase");
        tolua_function(tolua_S,"checkAllLoopStop",lua_corelib_CModuleBase_checkAllLoopStop);
        tolua_function(tolua_S,"getMaxConnNum",lua_corelib_CModuleBase_getMaxConnNum);
        tolua_function(tolua_S,"setService",lua_corelib_CModuleBase_setService);
        tolua_function(tolua_S,"getLeastLoop",lua_corelib_CModuleBase_getLeastLoop);
        tolua_function(tolua_S,"getService",lua_corelib_CModuleBase_getService);
        tolua_function(tolua_S,"start",lua_corelib_CModuleBase_start);
        tolua_function(tolua_S,"init",lua_corelib_CModuleBase_init);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CModuleBase_cleanUp);
        tolua_function(tolua_S,"getLoopNum",lua_corelib_CModuleBase_getLoopNum);
        tolua_function(tolua_S,"onStop",lua_corelib_CModuleBase_onStop);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CModuleBase).name();
    g_luaType[typeName] = "CModuleBase";
    g_typeCast["CModuleBase"] = "CModuleBase";
    return 1;
}

static int lua_corelib_CLoopToThreadTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLoopToThreadTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLoopToThreadTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CLoopToThreadTask* self = (GXMISC::CLoopToThreadTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CLoopToThreadTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLoopToThreadTask");
    tolua_cclass(tolua_S,"CLoopToThreadTask","CLoopToThreadTask","CTask",nullptr);

    tolua_beginmodule(tolua_S,"CLoopToThreadTask");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CLoopToThreadTask).name();
    g_luaType[typeName] = "CLoopToThreadTask";
    g_typeCast["CLoopToThreadTask"] = "CLoopToThreadTask";
    return 1;
}

int lua_corelib_CThreadToLoopTask_isSuccess(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CThreadToLoopTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CThreadToLoopTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CThreadToLoopTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CThreadToLoopTask_isSuccess'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isSuccess();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CThreadToLoopTask:isSuccess has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CThreadToLoopTask_isSuccess'.",&tolua_err);
	return 0;
}
int lua_corelib_CThreadToLoopTask_getErrorCode(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CThreadToLoopTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CThreadToLoopTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CThreadToLoopTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CThreadToLoopTask_getErrorCode'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        short ret = cobj->getErrorCode();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CThreadToLoopTask:getErrorCode has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CThreadToLoopTask_getErrorCode'.",&tolua_err);
	return 0;
}
int lua_corelib_CThreadToLoopTask_setSuccess(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CThreadToLoopTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CThreadToLoopTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CThreadToLoopTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CThreadToLoopTask_setSuccess'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setSuccess();
        return 0;
    }
    if (argc == 1) 
    {
        short arg0;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CThreadToLoopTask:setSuccess");
        if(!ok)
            return 0;
        cobj->setSuccess(arg0);
        return 0;
    }

    gxError("CThreadToLoopTask:setSuccess has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CThreadToLoopTask_setSuccess'.",&tolua_err);
	return 0;
}
static int lua_corelib_CThreadToLoopTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CThreadToLoopTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CThreadToLoopTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CThreadToLoopTask* self = (GXMISC::CThreadToLoopTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CThreadToLoopTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CThreadToLoopTask");
    tolua_cclass(tolua_S,"CThreadToLoopTask","CThreadToLoopTask","CTask",nullptr);

    tolua_beginmodule(tolua_S,"CThreadToLoopTask");
        tolua_function(tolua_S,"isSuccess",lua_corelib_CThreadToLoopTask_isSuccess);
        tolua_function(tolua_S,"getErrorCode",lua_corelib_CThreadToLoopTask_getErrorCode);
        tolua_function(tolua_S,"setSuccess",lua_corelib_CThreadToLoopTask_setSuccess);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CThreadToLoopTask).name();
    g_luaType[typeName] = "CThreadToLoopTask";
    g_typeCast["CThreadToLoopTask"] = "CThreadToLoopTask";
    return 1;
}

int lua_corelib_CDbConnTask_getDbUserIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDbConnTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDbConnTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDbConnTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDbConnTask_getDbUserIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getDbUserIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CDbConnTask:getDbUserIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDbConnTask_getDbUserIndex'.",&tolua_err);
	return 0;
}
int lua_corelib_CDbConnTask_getDbConnWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDbConnTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDbConnTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDbConnTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDbConnTask_getDbConnWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CDatabaseConnWrap* ret = cobj->getDbConnWrap();
        object_to_luaval<GXMISC::CDatabaseConnWrap>(tolua_S, "CDatabaseConnWrap",(GXMISC::CDatabaseConnWrap*)ret);
        return 1;
    }

    gxError("CDbConnTask:getDbConnWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDbConnTask_getDbConnWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CDbConnTask_setDbUserIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDbConnTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDbConnTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDbConnTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDbConnTask_setDbUserIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CDbConnTask:setDbUserIndex");
        if(!ok)
            return 0;
        cobj->setDbUserIndex(arg0);
        return 0;
    }

    gxError("CDbConnTask:setDbUserIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDbConnTask_setDbUserIndex'.",&tolua_err);
	return 0;
}
static int lua_corelib_CDbConnTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDbConnTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDbConnTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CDbConnTask* self = (GXMISC::CDbConnTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CDbConnTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDbConnTask");
    tolua_cclass(tolua_S,"CDbConnTask","CDbConnTask","CThreadToLoopTask",nullptr);

    tolua_beginmodule(tolua_S,"CDbConnTask");
        tolua_function(tolua_S,"getDbUserIndex",lua_corelib_CDbConnTask_getDbUserIndex);
        tolua_function(tolua_S,"getDbConnWrap",lua_corelib_CDbConnTask_getDbConnWrap);
        tolua_function(tolua_S,"setDbUserIndex",lua_corelib_CDbConnTask_setDbUserIndex);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CDbConnTask).name();
    g_luaType[typeName] = "CDbConnTask";
    g_typeCast["CDbConnTask"] = "CDbConnTask";
    return 1;
}

int lua_corelib_CDbWrapTask_setDbUserIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDbWrapTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDbWrapTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDbWrapTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDbWrapTask_setDbUserIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CDbWrapTask:setDbUserIndex");
        if(!ok)
            return 0;
        cobj->setDbUserIndex(arg0);
        return 0;
    }

    gxError("CDbWrapTask:setDbUserIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDbWrapTask_setDbUserIndex'.",&tolua_err);
	return 0;
}
int lua_corelib_CDbWrapTask_getDbUserIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDbWrapTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDbWrapTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDbWrapTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDbWrapTask_getDbUserIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getDbUserIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CDbWrapTask:getDbUserIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDbWrapTask_getDbUserIndex'.",&tolua_err);
	return 0;
}
int lua_corelib_CDbWrapTask_getDbConn(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDbWrapTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDbWrapTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDbWrapTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDbWrapTask_getDbConn'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CDatabaseConn* ret = cobj->getDbConn();
        object_to_luaval<GXMISC::CDatabaseConn>(tolua_S, "CDatabaseConn",(GXMISC::CDatabaseConn*)ret);
        return 1;
    }

    gxError("CDbWrapTask:getDbConn has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDbWrapTask_getDbConn'.",&tolua_err);
	return 0;
}
int lua_corelib_CDbWrapTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDbWrapTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDbWrapTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDbWrapTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDbWrapTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CDbWrapTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDbWrapTask_doRun'.",&tolua_err);
	return 0;
}
static int lua_corelib_CDbWrapTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDbWrapTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDbWrapTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CDbWrapTask* self = (GXMISC::CDbWrapTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CDbWrapTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDbWrapTask");
    tolua_cclass(tolua_S,"CDbWrapTask","CDbWrapTask","CLoopToThreadTask",nullptr);

    tolua_beginmodule(tolua_S,"CDbWrapTask");
        tolua_function(tolua_S,"setDbUserIndex",lua_corelib_CDbWrapTask_setDbUserIndex);
        tolua_function(tolua_S,"getDbUserIndex",lua_corelib_CDbWrapTask_getDbUserIndex);
        tolua_function(tolua_S,"getDbConn",lua_corelib_CDbWrapTask_getDbConn);
        tolua_function(tolua_S,"doRun",lua_corelib_CDbWrapTask_doRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CDbWrapTask).name();
    g_luaType[typeName] = "CDbWrapTask";
    g_typeCast["CDbWrapTask"] = "CDbWrapTask";
    return 1;
}

int lua_corelib_CDbTaskConnected_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDbTaskConnected* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDbTaskConnected",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDbTaskConnected*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDbTaskConnected_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CDbTaskConnected:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDbTaskConnected_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CDbTaskConnected_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDbTaskConnected* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CDbTaskConnected();
        tolua_pushusertype(tolua_S,(void*)cobj,"CDbTaskConnected");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CDbTaskConnected:CDbTaskConnected has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CDbTaskConnected_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDbTaskConnected)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDbTaskConnected",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CDbTaskConnected* self = (GXMISC::CDbTaskConnected*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CDbTaskConnected(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDbTaskConnected");
    tolua_cclass(tolua_S,"CDbTaskConnected","CDbTaskConnected","CDbConnTask",lua_corelib_CDbTaskConnected_finalize);

    tolua_beginmodule(tolua_S,"CDbTaskConnected");
        tolua_function(tolua_S,"new",lua_corelib_CDbTaskConnected_constructor);
        tolua_function(tolua_S,"doRun",lua_corelib_CDbTaskConnected_doRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CDbTaskConnected).name();
    g_luaType[typeName] = "CDbTaskConnected";
    g_typeCast["CDbTaskConnected"] = "CDbTaskConnected";
    return 1;
}

int lua_corelib_CDbTaskClose_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDbTaskClose* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDbTaskClose",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDbTaskClose*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDbTaskClose_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CDbTaskClose:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDbTaskClose_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CDbTaskClose_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDbTaskClose* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CDbTaskClose();
        tolua_pushusertype(tolua_S,(void*)cobj,"CDbTaskClose");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CDbTaskClose:CDbTaskClose has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CDbTaskClose_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDbTaskClose)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDbTaskClose",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CDbTaskClose* self = (GXMISC::CDbTaskClose*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CDbTaskClose(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDbTaskClose");
    tolua_cclass(tolua_S,"CDbTaskClose","CDbTaskClose","CDbConnTask",lua_corelib_CDbTaskClose_finalize);

    tolua_beginmodule(tolua_S,"CDbTaskClose");
        tolua_function(tolua_S,"new",lua_corelib_CDbTaskClose_constructor);
        tolua_function(tolua_S,"doRun",lua_corelib_CDbTaskClose_doRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CDbTaskClose).name();
    g_luaType[typeName] = "CDbTaskClose";
    g_typeCast["CDbTaskClose"] = "CDbTaskClose";
    return 1;
}

int lua_corelib_CDatabaseConn_stopMsgHandle(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_stopMsgHandle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->stopMsgHandle();
        return 0;
    }

    gxError("CDatabaseConn:stopMsgHandle has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_stopMsgHandle'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_setDbUrlInfo(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_setDbUrlInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        std::string arg0;
        std::string arg1;
        std::string arg2;
        std::string arg3;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CDatabaseConn:setDbUrlInfo");

        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CDatabaseConn:setDbUrlInfo");

        ok &= luaval_to_std_string(tolua_S, 4,&arg2, "CDatabaseConn:setDbUrlInfo");

        ok &= luaval_to_std_string(tolua_S, 5,&arg3, "CDatabaseConn:setDbUrlInfo");
        if(!ok)
            return 0;
        cobj->setDbUrlInfo(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CDatabaseConn:setDbUrlInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_setDbUrlInfo'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_setStartParam(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_setStartParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CDatabaseConn:setStartParam");
        if(!ok)
            return 0;
        cobj->setStartParam(arg0);
        return 0;
    }

    gxError("CDatabaseConn:setStartParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_setStartParam'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_onConntected(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_onConntected'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onConntected();
        return 0;
    }

    gxError("CDatabaseConn:onConntected has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_onConntected'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_pushTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_pushTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::CDbConnTask* arg0;
        unsigned long long arg1;

        ok &= luaval_to_object<GXMISC::CDbConnTask>(tolua_S, 2, "CDbConnTask", &arg0, "CDatabaseConn:pushTask");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CDatabaseConn:pushTask");
        if(!ok)
            return 0;
        cobj->pushTask(arg0, arg1);
        return 0;
    }

    gxError("CDatabaseConn:pushTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_pushTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_onClose(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_onClose'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onClose();
        return 0;
    }

    gxError("CDatabaseConn:onClose has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_onClose'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_isDelUser(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_isDelUser'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CDatabaseConn:isDelUser");
        if(!ok)
            return 0;
        bool ret = cobj->isDelUser(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDatabaseConn:isDelUser has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_isDelUser'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_ping(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_ping'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->ping();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDatabaseConn:ping has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_ping'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_isEmptyConn(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_isEmptyConn'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isEmptyConn();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDatabaseConn:isEmptyConn has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_isEmptyConn'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_start(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDatabaseConn:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_start'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDatabaseConn:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_init'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CDatabaseConn:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_toString(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CDatabaseConn:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_toString'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_reconnect(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_reconnect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->reconnect();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CDatabaseConn:reconnect");
        if(!ok)
            return 0;
        bool ret = cobj->reconnect(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDatabaseConn:reconnect has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_reconnect'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_pushDelUser(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_pushDelUser'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CDatabaseConn:pushDelUser");
        if(!ok)
            return 0;
        cobj->pushDelUser(arg0);
        return 0;
    }

    gxError("CDatabaseConn:pushDelUser has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_pushDelUser'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_isStopMsgHandle(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_isStopMsgHandle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isStopMsgHandle();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDatabaseConn:isStopMsgHandle has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_isStopMsgHandle'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_isActive(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConn*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConn_isActive'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isActive();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDatabaseConn:isActive has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConn_isActive'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConn* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CDatabaseConn();
        tolua_pushusertype(tolua_S,(void*)cobj,"CDatabaseConn");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CDatabaseConn:CDatabaseConn has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CDatabaseConn_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDatabaseConn)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDatabaseConn",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CDatabaseConn* self = (GXMISC::CDatabaseConn*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CDatabaseConn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDatabaseConn");
    tolua_cclass(tolua_S,"CDatabaseConn","CDatabaseConn","CModuleThreadLoop",lua_corelib_CDatabaseConn_finalize);

    tolua_beginmodule(tolua_S,"CDatabaseConn");
        tolua_function(tolua_S,"new",lua_corelib_CDatabaseConn_constructor);
        tolua_function(tolua_S,"stopMsgHandle",lua_corelib_CDatabaseConn_stopMsgHandle);
        tolua_function(tolua_S,"setDbUrlInfo",lua_corelib_CDatabaseConn_setDbUrlInfo);
        tolua_function(tolua_S,"setStartParam",lua_corelib_CDatabaseConn_setStartParam);
        tolua_function(tolua_S,"onConntected",lua_corelib_CDatabaseConn_onConntected);
        tolua_function(tolua_S,"pushTask",lua_corelib_CDatabaseConn_pushTask);
        tolua_function(tolua_S,"onClose",lua_corelib_CDatabaseConn_onClose);
        tolua_function(tolua_S,"isDelUser",lua_corelib_CDatabaseConn_isDelUser);
        tolua_function(tolua_S,"ping",lua_corelib_CDatabaseConn_ping);
        tolua_function(tolua_S,"isEmptyConn",lua_corelib_CDatabaseConn_isEmptyConn);
        tolua_function(tolua_S,"start",lua_corelib_CDatabaseConn_start);
        tolua_function(tolua_S,"init",lua_corelib_CDatabaseConn_init);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CDatabaseConn_cleanUp);
        tolua_function(tolua_S,"toString",lua_corelib_CDatabaseConn_toString);
        tolua_function(tolua_S,"reconnect",lua_corelib_CDatabaseConn_reconnect);
        tolua_function(tolua_S,"pushDelUser",lua_corelib_CDatabaseConn_pushDelUser);
        tolua_function(tolua_S,"isStopMsgHandle",lua_corelib_CDatabaseConn_isStopMsgHandle);
        tolua_function(tolua_S,"isActive",lua_corelib_CDatabaseConn_isActive);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CDatabaseConn).name();
    g_luaType[typeName] = "CDatabaseConn";
    g_typeCast["CDatabaseConn"] = "CDatabaseConn";
    return 1;
}

int lua_corelib_CDatabaseConnWrap_findUser(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_findUser'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CDatabaseConnWrap:findUser");
        if(!ok)
            return 0;
        GXMISC::CDatabaseHandler* ret = cobj->findUser(arg0);
        object_to_luaval<GXMISC::CDatabaseHandler>(tolua_S, "CDatabaseHandler",(GXMISC::CDatabaseHandler*)ret);
        return 1;
    }

    gxError("CDatabaseConnWrap:findUser has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_findUser'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_setDbUrlInfo(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_setDbUrlInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        std::string arg0;
        std::string arg1;
        std::string arg2;
        std::string arg3;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CDatabaseConnWrap:setDbUrlInfo");

        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "CDatabaseConnWrap:setDbUrlInfo");

        ok &= luaval_to_std_string(tolua_S, 4,&arg2, "CDatabaseConnWrap:setDbUrlInfo");

        ok &= luaval_to_std_string(tolua_S, 5,&arg3, "CDatabaseConnWrap:setDbUrlInfo");
        if(!ok)
            return 0;
        cobj->setDbUrlInfo(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CDatabaseConnWrap:setDbUrlInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_setDbUrlInfo'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_setStartParam(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_setStartParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CDatabaseConnWrap:setStartParam");
        if(!ok)
            return 0;
        cobj->setStartParam(arg0);
        return 0;
    }

    gxError("CDatabaseConnWrap:setStartParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_setStartParam'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_getDbConn(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_getDbConn'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const GXMISC::CDatabaseConn* ret = cobj->getDbConn();
        object_to_luaval<GXMISC::CDatabaseConn>(tolua_S, "CDatabaseConn",(GXMISC::CDatabaseConn*)ret);
        return 1;
    }

    gxError("CDatabaseConnWrap:getDbConn has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_getDbConn'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_isStop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_isStop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isStop();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDatabaseConnWrap:isStop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_isStop'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_addUser(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_addUser'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned long long arg0;
        GXMISC::CDatabaseHandler* arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CDatabaseConnWrap:addUser");

        ok &= luaval_to_object<GXMISC::CDatabaseHandler>(tolua_S, 3, "CDatabaseHandler", &arg1, "CDatabaseConnWrap:addUser");
        if(!ok)
            return 0;
        cobj->addUser(arg0, arg1);
        return 0;
    }

    gxError("CDatabaseConnWrap:addUser has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_addUser'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_pushTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_pushTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CDbWrapTask* arg0;

        ok &= luaval_to_object<GXMISC::CDbWrapTask>(tolua_S, 2, "CDbWrapTask", &arg0, "CDatabaseConnWrap:pushTask");
        if(!ok)
            return 0;
        cobj->pushTask(arg0);
        return 0;
    }

    gxError("CDatabaseConnWrap:pushTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_pushTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_setDbHostParam(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_setDbHostParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CDbHostParam* arg0;

        ok &= luaval_to_object<GXMISC::CDbHostParam>(tolua_S, 2, "CDbHostParam", &arg0, "CDatabaseConnWrap:setDbHostParam");
        if(!ok)
            return 0;
        cobj->setDbHostParam(arg0);
        return 0;
    }

    gxError("CDatabaseConnWrap:setDbHostParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_setDbHostParam'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_getDbConnMgr(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_getDbConnMgr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CDatabaseConnMgr* ret = cobj->getDbConnMgr();
        object_to_luaval<GXMISC::CDatabaseConnMgr>(tolua_S, "CDatabaseConnMgr",(GXMISC::CDatabaseConnMgr*)ret);
        return 1;
    }

    gxError("CDatabaseConnWrap:getDbConnMgr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_getDbConnMgr'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_onConnected(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_onConnected'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onConnected();
        return 0;
    }

    gxError("CDatabaseConnWrap:onConnected has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_onConnected'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_getDbHostID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_getDbHostID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getDbHostID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDatabaseConnWrap:getDbHostID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_getDbHostID'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_start(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDatabaseConnWrap:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_start'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_removeUser(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_removeUser'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CDatabaseConnWrap:removeUser");
        if(!ok)
            return 0;
        cobj->removeUser(arg0);
        return 0;
    }

    gxError("CDatabaseConnWrap:removeUser has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_removeUser'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_toString(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CDatabaseConnWrap:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_toString'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_setDbHostID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_setDbHostID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CDatabaseConnWrap:setDbHostID");
        if(!ok)
            return 0;
        cobj->setDbHostID(arg0);
        return 0;
    }

    gxError("CDatabaseConnWrap:setDbHostID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_setDbHostID'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_setTag(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_setTag'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CDatabaseConnWrap:setTag");
        if(!ok)
            return 0;
        cobj->setTag(arg0);
        return 0;
    }

    gxError("CDatabaseConnWrap:setTag has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_setTag'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_getTag(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_getTag'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getTag();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDatabaseConnWrap:getTag has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_getTag'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_onClose(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_onClose'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onClose();
        return 0;
    }

    gxError("CDatabaseConnWrap:onClose has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_onClose'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_isActive(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_isActive'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isActive();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDatabaseConnWrap:isActive has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_isActive'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_handleClearAllUser(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnWrap_handleClearAllUser'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->handleClearAllUser();
        return 0;
    }

    gxError("CDatabaseConnWrap:handleClearAllUser has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnWrap_handleClearAllUser'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnWrap_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnWrap* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CDatabaseConnMgr* arg0;

        ok &= luaval_to_object<GXMISC::CDatabaseConnMgr>(tolua_S, 2, "CDatabaseConnMgr", &arg0, "CDatabaseConnWrap:CDatabaseConnWrap");
        if(!ok)
            return 0;
        cobj = new GXMISC::CDatabaseConnWrap(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CDatabaseConnWrap");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CDatabaseConnWrap:CDatabaseConnWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CDatabaseConnWrap_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDatabaseConnWrap)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDatabaseConnWrap",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CDatabaseConnWrap* self = (GXMISC::CDatabaseConnWrap*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CDatabaseConnWrap(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDatabaseConnWrap");
    tolua_cclass(tolua_S,"CDatabaseConnWrap","CDatabaseConnWrap","CSimpleThreadLoopWrap",lua_corelib_CDatabaseConnWrap_finalize);

    tolua_beginmodule(tolua_S,"CDatabaseConnWrap");
        tolua_function(tolua_S,"new",lua_corelib_CDatabaseConnWrap_constructor);
        tolua_function(tolua_S,"findUser",lua_corelib_CDatabaseConnWrap_findUser);
        tolua_function(tolua_S,"setDbUrlInfo",lua_corelib_CDatabaseConnWrap_setDbUrlInfo);
        tolua_function(tolua_S,"setStartParam",lua_corelib_CDatabaseConnWrap_setStartParam);
        tolua_function(tolua_S,"getDbConn",lua_corelib_CDatabaseConnWrap_getDbConn);
        tolua_function(tolua_S,"isStop",lua_corelib_CDatabaseConnWrap_isStop);
        tolua_function(tolua_S,"addUser",lua_corelib_CDatabaseConnWrap_addUser);
        tolua_function(tolua_S,"pushTask",lua_corelib_CDatabaseConnWrap_pushTask);
        tolua_function(tolua_S,"setDbHostParam",lua_corelib_CDatabaseConnWrap_setDbHostParam);
        tolua_function(tolua_S,"getDbConnMgr",lua_corelib_CDatabaseConnWrap_getDbConnMgr);
        tolua_function(tolua_S,"onConnected",lua_corelib_CDatabaseConnWrap_onConnected);
        tolua_function(tolua_S,"getDbHostID",lua_corelib_CDatabaseConnWrap_getDbHostID);
        tolua_function(tolua_S,"start",lua_corelib_CDatabaseConnWrap_start);
        tolua_function(tolua_S,"removeUser",lua_corelib_CDatabaseConnWrap_removeUser);
        tolua_function(tolua_S,"toString",lua_corelib_CDatabaseConnWrap_toString);
        tolua_function(tolua_S,"setDbHostID",lua_corelib_CDatabaseConnWrap_setDbHostID);
        tolua_function(tolua_S,"setTag",lua_corelib_CDatabaseConnWrap_setTag);
        tolua_function(tolua_S,"getTag",lua_corelib_CDatabaseConnWrap_getTag);
        tolua_function(tolua_S,"onClose",lua_corelib_CDatabaseConnWrap_onClose);
        tolua_function(tolua_S,"isActive",lua_corelib_CDatabaseConnWrap_isActive);
        tolua_function(tolua_S,"handleClearAllUser",lua_corelib_CDatabaseConnWrap_handleClearAllUser);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CDatabaseConnWrap).name();
    g_luaType[typeName] = "CDatabaseConnWrap";
    g_typeCast["CDatabaseConnWrap"] = "CDatabaseConnWrap";
    return 1;
}

int lua_corelib_IScriptObject_getScriptHandleClassName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IScriptObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IScriptObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IScriptObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IScriptObject_getScriptHandleClassName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getScriptHandleClassName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("IScriptObject:getScriptHandleClassName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IScriptObject_getScriptHandleClassName'.",&tolua_err);
	return 0;
}
int lua_corelib_IScriptObject_getScriptObject(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IScriptObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IScriptObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IScriptObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IScriptObject_getScriptObject'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        lua_tinker::s_object ret = cobj->getScriptObject();
        lua_tinker::push(tolua_S,ret);
        return 1;
    }

    gxError("IScriptObject:getScriptObject has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IScriptObject_getScriptObject'.",&tolua_err);
	return 0;
}
int lua_corelib_IScriptObject_sCall(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IScriptObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IScriptObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IScriptObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IScriptObject_sCall'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "IScriptObject:sCall"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        std::string ret = cobj->sCall(arg0);
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("IScriptObject:sCall has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IScriptObject_sCall'.",&tolua_err);
	return 0;
}
int lua_corelib_IScriptObject_setScriptHandleClassName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IScriptObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IScriptObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IScriptObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IScriptObject_setScriptHandleClassName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "IScriptObject:setScriptHandleClassName");
        if(!ok)
            return 0;
        cobj->setScriptHandleClassName(arg0);
        return 0;
    }

    gxError("IScriptObject:setScriptHandleClassName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IScriptObject_setScriptHandleClassName'.",&tolua_err);
	return 0;
}
int lua_corelib_IScriptObject_isExistMember(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IScriptObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IScriptObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IScriptObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IScriptObject_isExistMember'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "IScriptObject:isExistMember"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        bool ret = cobj->isExistMember(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IScriptObject:isExistMember has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IScriptObject_isExistMember'.",&tolua_err);
	return 0;
}
int lua_corelib_IScriptObject_vCall(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IScriptObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IScriptObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IScriptObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IScriptObject_vCall'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "IScriptObject:vCall"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        cobj->vCall(arg0);
        return 0;
    }

    gxError("IScriptObject:vCall has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IScriptObject_vCall'.",&tolua_err);
	return 0;
}
int lua_corelib_IScriptObject_bCall(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IScriptObject* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IScriptObject",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IScriptObject*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IScriptObject_bCall'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "IScriptObject:bCall"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        bool ret = cobj->bCall(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IScriptObject:bCall has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IScriptObject_bCall'.",&tolua_err);
	return 0;
}
static int lua_corelib_IScriptObject_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IScriptObject)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IScriptObject",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IScriptObject* self = (GXMISC::IScriptObject*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IScriptObject(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IScriptObject");
    tolua_cclass(tolua_S,"IScriptObject","IScriptObject","IFreeable",nullptr);

    tolua_beginmodule(tolua_S,"IScriptObject");
        tolua_function(tolua_S,"getScriptHandleClassName",lua_corelib_IScriptObject_getScriptHandleClassName);
        tolua_function(tolua_S,"getScriptObject",lua_corelib_IScriptObject_getScriptObject);
        tolua_function(tolua_S,"sCall",lua_corelib_IScriptObject_sCall);
        tolua_function(tolua_S,"setScriptHandleClassName",lua_corelib_IScriptObject_setScriptHandleClassName);
        tolua_function(tolua_S,"isExistMember",lua_corelib_IScriptObject_isExistMember);
        tolua_function(tolua_S,"vCall",lua_corelib_IScriptObject_vCall);
        tolua_function(tolua_S,"bCall",lua_corelib_IScriptObject_bCall);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IScriptObject).name();
    g_luaType[typeName] = "IScriptObject";
    g_typeCast["IScriptObject"] = "IScriptObject";
    return 1;
}

int lua_corelib_IHandler_reset(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IHandler_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }

    gxError("IHandler:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IHandler_reset'.",&tolua_err);
	return 0;
}
int lua_corelib_IHandler_onDelete(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IHandler_onDelete'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onDelete();
        return 0;
    }

    gxError("IHandler:onDelete has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IHandler_onDelete'.",&tolua_err);
	return 0;
}
int lua_corelib_IHandler_setParam(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IHandler_setParam'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const GXMISC::IAllocatable* arg0;
        unsigned long long arg1;

        ok &= luaval_to_object<const GXMISC::IAllocatable>(tolua_S, 2, "IAllocatable", &arg0, "IHandler:setParam");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "IHandler:setParam");
        if(!ok)
            return 0;
        cobj->setParam(arg0, arg1);
        return 0;
    }

    gxError("IHandler:setParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IHandler_setParam'.",&tolua_err);
	return 0;
}
int lua_corelib_IHandler_handle(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IHandler_handle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char* arg0;
        unsigned int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "IHandler:handle"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "IHandler:handle");
        if(!ok)
            return 0;
        int ret = (int)cobj->handle(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("IHandler:handle has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IHandler_handle'.",&tolua_err);
	return 0;
}
int lua_corelib_IHandler_setStarted(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IHandler_setStarted'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setStarted();
        return 0;
    }

    gxError("IHandler:setStarted has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IHandler_setStarted'.",&tolua_err);
	return 0;
}
int lua_corelib_IHandler_isValid(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IHandler_isValid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isValid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IHandler:isValid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IHandler_isValid'.",&tolua_err);
	return 0;
}
int lua_corelib_IHandler_getName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IHandler_getName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->getName();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("IHandler:getName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IHandler_getName'.",&tolua_err);
	return 0;
}
int lua_corelib_IHandler_onReconnect(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IHandler_onReconnect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onReconnect();
        return 0;
    }

    gxError("IHandler:onReconnect has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IHandler_onReconnect'.",&tolua_err);
	return 0;
}
int lua_corelib_IHandler_isStarted(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IHandler_isStarted'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isStarted();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IHandler:isStarted has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IHandler_isStarted'.",&tolua_err);
	return 0;
}
int lua_corelib_IHandler_getUniqueIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IHandler_getUniqueIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getUniqueIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("IHandler:getUniqueIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IHandler_getUniqueIndex'.",&tolua_err);
	return 0;
}
int lua_corelib_IHandler_breath(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IHandler_breath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "IHandler:breath");
        if(!ok)
            return 0;
        cobj->breath(arg0);
        return 0;
    }

    gxError("IHandler:breath has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IHandler_breath'.",&tolua_err);
	return 0;
}
int lua_corelib_IHandler_start(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IHandler_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("IHandler:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IHandler_start'.",&tolua_err);
	return 0;
}
int lua_corelib_IHandler_close(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::IHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::IHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_IHandler_close'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->close();
        return 0;
    }

    gxError("IHandler:close has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_IHandler_close'.",&tolua_err);
	return 0;
}
static int lua_corelib_IHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IHandler* self = (GXMISC::IHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IHandler");
    tolua_cclass(tolua_S,"IHandler","IHandler","IScriptObject",nullptr);

    tolua_beginmodule(tolua_S,"IHandler");
        tolua_function(tolua_S,"reset",lua_corelib_IHandler_reset);
        tolua_function(tolua_S,"onDelete",lua_corelib_IHandler_onDelete);
        tolua_function(tolua_S,"setParam",lua_corelib_IHandler_setParam);
        tolua_function(tolua_S,"handle",lua_corelib_IHandler_handle);
        tolua_function(tolua_S,"setStarted",lua_corelib_IHandler_setStarted);
        tolua_function(tolua_S,"isValid",lua_corelib_IHandler_isValid);
        tolua_function(tolua_S,"getName",lua_corelib_IHandler_getName);
        tolua_function(tolua_S,"onReconnect",lua_corelib_IHandler_onReconnect);
        tolua_function(tolua_S,"isStarted",lua_corelib_IHandler_isStarted);
        tolua_function(tolua_S,"getUniqueIndex",lua_corelib_IHandler_getUniqueIndex);
        tolua_function(tolua_S,"breath",lua_corelib_IHandler_breath);
        tolua_function(tolua_S,"start",lua_corelib_IHandler_start);
        tolua_function(tolua_S,"close",lua_corelib_IHandler_close);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IHandler).name();
    g_luaType[typeName] = "IHandler";
    g_typeCast["IHandler"] = "IHandler";
    return 1;
}

int lua_corelib_CDatabaseHandler_handle(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseHandler_handle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char* arg0;
        unsigned int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CDatabaseHandler:handle"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CDatabaseHandler:handle");
        if(!ok)
            return 0;
        int ret = (int)cobj->handle(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDatabaseHandler:handle has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseHandler_handle'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseHandler_freeDatabaseTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseHandler_freeDatabaseTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CDbWrapTask* arg0;

        ok &= luaval_to_object<GXMISC::CDbWrapTask>(tolua_S, 2, "CDbWrapTask", &arg0, "CDatabaseHandler:freeDatabaseTask");
        if(!ok)
            return 0;
        cobj->freeDatabaseTask(arg0);
        return 0;
    }

    gxError("CDatabaseHandler:freeDatabaseTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseHandler_freeDatabaseTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseHandler_getDbWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseHandler_getDbWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CDatabaseConnWrap* ret = cobj->getDbWrap();
        object_to_luaval<GXMISC::CDatabaseConnWrap>(tolua_S, "CDatabaseConnWrap",(GXMISC::CDatabaseConnWrap*)ret);
        return 1;
    }

    gxError("CDatabaseHandler:getDbWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseHandler_getDbWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseHandler_isValid(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseHandler_isValid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isValid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDatabaseHandler:isValid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseHandler_isValid'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseHandler_pushTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseHandler_pushTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CDbWrapTask* arg0;

        ok &= luaval_to_object<GXMISC::CDbWrapTask>(tolua_S, 2, "CDbWrapTask", &arg0, "CDatabaseHandler:pushTask");
        if(!ok)
            return 0;
        cobj->pushTask(arg0);
        return 0;
    }

    gxError("CDatabaseHandler:pushTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseHandler_pushTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseHandler_getTag(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseHandler_getTag'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->getTag();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDatabaseHandler:getTag has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseHandler_getTag'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseHandler_kick(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseHandler_kick'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->kick();
        return 0;
    }

    gxError("CDatabaseHandler:kick has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseHandler_kick'.",&tolua_err);
	return 0;
}
static int lua_corelib_CDatabaseHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDatabaseHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDatabaseHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CDatabaseHandler* self = (GXMISC::CDatabaseHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CDatabaseHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDatabaseHandler");
    tolua_cclass(tolua_S,"CDatabaseHandler","CDatabaseHandler","IHandler",nullptr);

    tolua_beginmodule(tolua_S,"CDatabaseHandler");
        tolua_function(tolua_S,"handle",lua_corelib_CDatabaseHandler_handle);
        tolua_function(tolua_S,"freeDatabaseTask",lua_corelib_CDatabaseHandler_freeDatabaseTask);
        tolua_function(tolua_S,"getDbWrap",lua_corelib_CDatabaseHandler_getDbWrap);
        tolua_function(tolua_S,"isValid",lua_corelib_CDatabaseHandler_isValid);
        tolua_function(tolua_S,"pushTask",lua_corelib_CDatabaseHandler_pushTask);
        tolua_function(tolua_S,"getTag",lua_corelib_CDatabaseHandler_getTag);
        tolua_function(tolua_S,"kick",lua_corelib_CDatabaseHandler_kick);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CDatabaseHandler).name();
    g_luaType[typeName] = "CDatabaseHandler";
    g_typeCast["CDatabaseHandler"] = "CDatabaseHandler";
    return 1;
}

int lua_corelib_CDbHostParam_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDbHostParam* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CDbHostParam();
        tolua_pushusertype(tolua_S,(void*)cobj,"CDbHostParam");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CDbHostParam:CDbHostParam has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CDbHostParam_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDbHostParam)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDbHostParam",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CDbHostParam* self = (GXMISC::CDbHostParam*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CDbHostParam(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDbHostParam");
    tolua_cclass(tolua_S,"CDbHostParam","CDbHostParam","",lua_corelib_CDbHostParam_finalize);

    tolua_beginmodule(tolua_S,"CDbHostParam");
        tolua_function(tolua_S,"new",lua_corelib_CDbHostParam_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CDbHostParam).name();
    g_luaType[typeName] = "CDbHostParam";
    g_typeCast["CDbHostParam"] = "CDbHostParam";
    return 1;
}

int lua_corelib_CDatabaseConfig_setCleanupParm(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConfig_setCleanupParm'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CDatabaseConfig:setCleanupParm");
        if(!ok)
            return 0;
        cobj->setCleanupParm(arg0);
        return 0;
    }

    gxError("CDatabaseConfig:setCleanupParm has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConfig_setCleanupParm'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConfig_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConfig* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CDatabaseConfig:CDatabaseConfig");
        if(!ok)
            return 0;
        cobj = new GXMISC::CDatabaseConfig(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CDatabaseConfig");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CDatabaseConfig:CDatabaseConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CDatabaseConfig_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDatabaseConfig)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDatabaseConfig",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CDatabaseConfig* self = (GXMISC::CDatabaseConfig*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CDatabaseConfig(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDatabaseConfig");
    tolua_cclass(tolua_S,"CDatabaseConfig","CDatabaseConfig","IModuleConfig",lua_corelib_CDatabaseConfig_finalize);

    tolua_beginmodule(tolua_S,"CDatabaseConfig");
        tolua_function(tolua_S,"new",lua_corelib_CDatabaseConfig_constructor);
        tolua_function(tolua_S,"setCleanupParm",lua_corelib_CDatabaseConfig_setCleanupParm);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CDatabaseConfig).name();
    g_luaType[typeName] = "CDatabaseConfig";
    g_typeCast["CDatabaseConfig"] = "CDatabaseConfig";
    return 1;
}

int lua_corelib_CDatabaseConnMgr_pushTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnMgr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnMgr",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnMgr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnMgr_pushTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::CDbWrapTask* arg0;
        unsigned long long arg1;

        ok &= luaval_to_object<GXMISC::CDbWrapTask>(tolua_S, 2, "CDbWrapTask", &arg0, "CDatabaseConnMgr:pushTask");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CDatabaseConnMgr:pushTask");
        if(!ok)
            return 0;
        cobj->pushTask(arg0, arg1);
        return 0;
    }

    gxError("CDatabaseConnMgr:pushTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnMgr_pushTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnMgr_getUser(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnMgr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnMgr",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnMgr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnMgr_getUser'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CDatabaseConnMgr:getUser");
        if(!ok)
            return 0;
        GXMISC::CDatabaseHandler* ret = cobj->getUser(arg0);
        object_to_luaval<GXMISC::CDatabaseHandler>(tolua_S, "CDatabaseHandler",(GXMISC::CDatabaseHandler*)ret);
        return 1;
    }

    gxError("CDatabaseConnMgr:getUser has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnMgr_getUser'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnMgr_removeUser(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnMgr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnMgr",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnMgr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnMgr_removeUser'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CDatabaseConnMgr:removeUser");
        if(!ok)
            return 0;
        cobj->removeUser(arg0);
        return 0;
    }

    gxError("CDatabaseConnMgr:removeUser has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnMgr_removeUser'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnMgr_getConfig(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnMgr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnMgr",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnMgr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnMgr_getConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CDatabaseConfig* ret = cobj->getConfig();
        object_to_luaval<GXMISC::CDatabaseConfig>(tolua_S, "CDatabaseConfig",(GXMISC::CDatabaseConfig*)ret);
        return 1;
    }

    gxError("CDatabaseConnMgr:getConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnMgr_getConfig'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnMgr_size(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnMgr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDatabaseConnMgr",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDatabaseConnMgr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDatabaseConnMgr_size'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->size();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDatabaseConnMgr:size has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDatabaseConnMgr_size'.",&tolua_err);
	return 0;
}
int lua_corelib_CDatabaseConnMgr_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDatabaseConnMgr* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CDatabaseConnMgr();
        tolua_pushusertype(tolua_S,(void*)cobj,"CDatabaseConnMgr");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CDatabaseConnMgr:CDatabaseConnMgr");
        if(!ok)
            return 0;
        cobj = new GXMISC::CDatabaseConnMgr(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CDatabaseConnMgr");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CDatabaseConnMgr:CDatabaseConnMgr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CDatabaseConnMgr_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDatabaseConnMgr)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDatabaseConnMgr",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CDatabaseConnMgr* self = (GXMISC::CDatabaseConnMgr*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CDatabaseConnMgr(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDatabaseConnMgr");
    tolua_cclass(tolua_S,"CDatabaseConnMgr","CDatabaseConnMgr","CModuleBase",lua_corelib_CDatabaseConnMgr_finalize);

    tolua_beginmodule(tolua_S,"CDatabaseConnMgr");
        tolua_function(tolua_S,"new",lua_corelib_CDatabaseConnMgr_constructor);
        tolua_function(tolua_S,"pushTask",lua_corelib_CDatabaseConnMgr_pushTask);
        tolua_function(tolua_S,"getUser",lua_corelib_CDatabaseConnMgr_getUser);
        tolua_function(tolua_S,"removeUser",lua_corelib_CDatabaseConnMgr_removeUser);
        tolua_function(tolua_S,"getConfig",lua_corelib_CDatabaseConnMgr_getConfig);
        tolua_function(tolua_S,"size",lua_corelib_CDatabaseConnMgr_size);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CDatabaseConnMgr).name();
    g_luaType[typeName] = "CDatabaseConnMgr";
    g_typeCast["CDatabaseConnMgr"] = "CDatabaseConnMgr";
    return 1;
}

int lua_corelib_CGameTime_setGameTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGameTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGameTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGameTime_setGameTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameTime:setGameTime");
        if(!ok)
            return 0;
        cobj->setGameTime(arg0);
        return 0;
    }

    gxError("CGameTime:setGameTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGameTime_setGameTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CGameTime_toString(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGameTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGameTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGameTime_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CGameTime:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGameTime_toString'.",&tolua_err);
	return 0;
}
int lua_corelib_CGameTime_getGameTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGameTime* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameTime",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGameTime*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGameTime_getGameTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getGameTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameTime:getGameTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGameTime_getGameTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CGameTime_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGameTime* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameTime:CGameTime");

            if (!ok) { break; }
            cobj = new GXMISC::CGameTime(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CGameTime");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CGameTime();
            tolua_pushusertype(tolua_S,(void*)cobj,"CGameTime");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CGameTime:CGameTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CGameTime_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGameTime)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGameTime",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CGameTime* self = (GXMISC::CGameTime*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CGameTime(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGameTime");
    tolua_cclass(tolua_S,"CGameTime","CGameTime","",lua_corelib_CGameTime_finalize);

    tolua_beginmodule(tolua_S,"CGameTime");
        tolua_function(tolua_S,"new",lua_corelib_CGameTime_constructor);
        tolua_function(tolua_S,"setGameTime",lua_corelib_CGameTime_setGameTime);
        tolua_function(tolua_S,"toString",lua_corelib_CGameTime_toString);
        tolua_function(tolua_S,"getGameTime",lua_corelib_CGameTime_getGameTime);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CGameTime).name();
    g_luaType[typeName] = "CGameTime";
    g_typeCast["CGameTime"] = "CGameTime";
    return 1;
}

int lua_corelib_CMemInStream_reset(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInStream_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }

    gxError("CMemInStream:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInStream_reset'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInStream_getFreeSize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInStream_getFreeSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFreeSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemInStream:getFreeSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInStream_getFreeSize'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInStream_maxSize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInStream_maxSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->maxSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemInStream:maxSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInStream_maxSize'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInStream_curData(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInStream_curData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->curData();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CMemInStream:curData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInStream_curData'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInStream_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInStream_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CMemInStream:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInStream_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInStream_data(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInStream_data'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->data();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CMemInStream:data has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInStream_data'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInStream_size(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInStream_size'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->size();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemInStream:size has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInStream_size'.",&tolua_err);
	return 0;
}
static int lua_corelib_CMemInStream_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMemInStream)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMemInStream",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CMemInStream* self = (GXMISC::CMemInStream*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CMemInStream(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMemInStream");
    tolua_cclass(tolua_S,"CMemInStream","CMemInStream","IUnStream",nullptr);

    tolua_beginmodule(tolua_S,"CMemInStream");
        tolua_function(tolua_S,"reset",lua_corelib_CMemInStream_reset);
        tolua_function(tolua_S,"getFreeSize",lua_corelib_CMemInStream_getFreeSize);
        tolua_function(tolua_S,"maxSize",lua_corelib_CMemInStream_maxSize);
        tolua_function(tolua_S,"curData",lua_corelib_CMemInStream_curData);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CMemInStream_cleanUp);
        tolua_function(tolua_S,"data",lua_corelib_CMemInStream_data);
        tolua_function(tolua_S,"size",lua_corelib_CMemInStream_size);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CMemInStream).name();
    g_luaType[typeName] = "CMemInStream";
    g_typeCast["CMemInStream"] = "CMemInStream";
    return 1;
}

int lua_corelib_CMemOutStream_reset(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutStream_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }

    gxError("CMemOutStream:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutStream_reset'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutStream_getFreeSize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutStream_getFreeSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getFreeSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutStream:getFreeSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutStream_getFreeSize'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutStream_maxSize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutStream_maxSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->maxSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutStream:maxSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutStream_maxSize'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutStream_curData(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutStream_curData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        char* ret = cobj->curData();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CMemOutStream:curData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutStream_curData'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutStream_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutStream_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CMemOutStream:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutStream_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutStream_data(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutStream_data'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        char* ret = cobj->data();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CMemOutStream:data has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutStream_data'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutStream_size(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutStream_size'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->size();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutStream:size has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutStream_size'.",&tolua_err);
	return 0;
}
static int lua_corelib_CMemOutStream_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMemOutStream)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMemOutStream",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CMemOutStream* self = (GXMISC::CMemOutStream*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CMemOutStream(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMemOutStream");
    tolua_cclass(tolua_S,"CMemOutStream","CMemOutStream","IStream",nullptr);

    tolua_beginmodule(tolua_S,"CMemOutStream");
        tolua_function(tolua_S,"reset",lua_corelib_CMemOutStream_reset);
        tolua_function(tolua_S,"getFreeSize",lua_corelib_CMemOutStream_getFreeSize);
        tolua_function(tolua_S,"maxSize",lua_corelib_CMemOutStream_maxSize);
        tolua_function(tolua_S,"curData",lua_corelib_CMemOutStream_curData);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CMemOutStream_cleanUp);
        tolua_function(tolua_S,"data",lua_corelib_CMemOutStream_data);
        tolua_function(tolua_S,"size",lua_corelib_CMemOutStream_size);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CMemOutStream).name();
    g_luaType[typeName] = "CMemOutStream";
    g_typeCast["CMemOutStream"] = "CMemOutStream";
    return 1;
}

int lua_corelib_CMemOutputStream_writeInt8(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeInt8'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        char arg0;

        ok &= luaval_to_sint8(tolua_S, 2,(sint8*)&arg0, "CMemOutputStream:writeInt8");
        if(!ok)
            return 0;
        char ret = cobj->writeInt8(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeInt8 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeInt8'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeUInt64ByPos(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeUInt64ByPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        uint64 arg0;
        int arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMemOutputStream:writeUInt64ByPos");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMemOutputStream:writeUInt64ByPos");
        if(!ok)
            return 0;
        char ret = cobj->writeUInt64ByPos(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeUInt64ByPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeUInt64ByPos'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeUInt64(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeUInt64'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        uint64 arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CMemOutputStream:writeUInt64");
        if(!ok)
            return 0;
        char ret = cobj->writeUInt64(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeUInt64 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeUInt64'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeString(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CScriptString arg0;

        ok &= luaval_to_script_string(tolua_S, 2,&arg0, "CMemOutputStream:writeString");
        if(!ok)
            return 0;
        short ret = cobj->writeString(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeString has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeString'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeUInt16ByPos(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeUInt16ByPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned short arg0;
        int arg1;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMemOutputStream:writeUInt16ByPos");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMemOutputStream:writeUInt16ByPos");
        if(!ok)
            return 0;
        char ret = cobj->writeUInt16ByPos(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeUInt16ByPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeUInt16ByPos'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeUInt16(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeUInt16'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CMemOutputStream:writeUInt16");
        if(!ok)
            return 0;
        char ret = cobj->writeUInt16(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeUInt16 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeUInt16'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeInt64(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeInt64'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        sint64 arg0;

        ok &= luaval_to_sint64(tolua_S, 2,(sint64*)&arg0, "CMemOutputStream:writeInt64");
        if(!ok)
            return 0;
        char ret = cobj->writeInt64(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeInt64 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeInt64'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeUInt8(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeUInt8'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned char arg0;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CMemOutputStream:writeUInt8");
        if(!ok)
            return 0;
        char ret = cobj->writeUInt8(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeUInt8 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeUInt8'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeInt32(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeInt32'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMemOutputStream:writeInt32");
        if(!ok)
            return 0;
        char ret = cobj->writeInt32(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeInt32 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeInt32'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_getCurrentPos(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_getCurrentPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getCurrentPos();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:getCurrentPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_getCurrentPos'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeUInt8ByPos(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeUInt8ByPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned char arg0;
        int arg1;

        ok &= luaval_to_uint8(tolua_S, 2,(uint8*)&arg0, "CMemOutputStream:writeUInt8ByPos");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMemOutputStream:writeUInt8ByPos");
        if(!ok)
            return 0;
        char ret = cobj->writeUInt8ByPos(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeUInt8ByPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeUInt8ByPos'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeUInt32ByPos(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeUInt32ByPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        int arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CMemOutputStream:writeUInt32ByPos");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CMemOutputStream:writeUInt32ByPos");
        if(!ok)
            return 0;
        char ret = cobj->writeUInt32ByPos(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeUInt32ByPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeUInt32ByPos'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeBufferByPos(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeBufferByPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const char* arg0;
        unsigned int arg1;
        unsigned int arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CMemOutputStream:writeBufferByPos"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CMemOutputStream:writeBufferByPos");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CMemOutputStream:writeBufferByPos");
        if(!ok)
            return 0;
        bool ret = cobj->writeBufferByPos(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeBufferByPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeBufferByPos'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeSString(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeSString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        CScriptString arg0;

        ok &= luaval_to_script_string(tolua_S, 2,&arg0, "CMemOutputStream:writeSString");
        if(!ok)
            return 0;
        short ret = cobj->writeSString(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeSString has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeSString'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeUInt32(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeUInt32'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CMemOutputStream:writeUInt32");
        if(!ok)
            return 0;
        char ret = cobj->writeUInt32(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeUInt32 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeUInt32'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_writeInt16(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemOutputStream_writeInt16'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        short arg0;

        ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CMemOutputStream:writeInt16");
        if(!ok)
            return 0;
        char ret = cobj->writeInt16(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemOutputStream:writeInt16 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemOutputStream_writeInt16'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemOutputStream_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemOutputStream* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CMemOutputStream:CMemOutputStream");

            if (!ok) { break; }
            cobj = new GXMISC::CMemOutputStream(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CMemOutputStream");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CMemOutputStream();
            tolua_pushusertype(tolua_S,(void*)cobj,"CMemOutputStream");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CMemOutputStream:CMemOutputStream has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CMemOutputStream_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMemOutputStream)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMemOutputStream",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CMemOutputStream* self = (GXMISC::CMemOutputStream*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CMemOutputStream(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMemOutputStream");
    tolua_cclass(tolua_S,"CMemOutputStream","CMemOutputStream","CMemOutStream",lua_corelib_CMemOutputStream_finalize);

    tolua_beginmodule(tolua_S,"CMemOutputStream");
        tolua_function(tolua_S,"new",lua_corelib_CMemOutputStream_constructor);
        tolua_function(tolua_S,"writeInt8",lua_corelib_CMemOutputStream_writeInt8);
        tolua_function(tolua_S,"writeUInt64ByPos",lua_corelib_CMemOutputStream_writeUInt64ByPos);
        tolua_function(tolua_S,"writeUInt64",lua_corelib_CMemOutputStream_writeUInt64);
        tolua_function(tolua_S,"writeString",lua_corelib_CMemOutputStream_writeString);
        tolua_function(tolua_S,"writeUInt16ByPos",lua_corelib_CMemOutputStream_writeUInt16ByPos);
        tolua_function(tolua_S,"writeUInt16",lua_corelib_CMemOutputStream_writeUInt16);
        tolua_function(tolua_S,"writeInt64",lua_corelib_CMemOutputStream_writeInt64);
        tolua_function(tolua_S,"writeUInt8",lua_corelib_CMemOutputStream_writeUInt8);
        tolua_function(tolua_S,"writeInt32",lua_corelib_CMemOutputStream_writeInt32);
        tolua_function(tolua_S,"getCurrentPos",lua_corelib_CMemOutputStream_getCurrentPos);
        tolua_function(tolua_S,"writeUInt8ByPos",lua_corelib_CMemOutputStream_writeUInt8ByPos);
        tolua_function(tolua_S,"writeUInt32ByPos",lua_corelib_CMemOutputStream_writeUInt32ByPos);
        tolua_function(tolua_S,"writeBufferByPos",lua_corelib_CMemOutputStream_writeBufferByPos);
        tolua_function(tolua_S,"writeSString",lua_corelib_CMemOutputStream_writeSString);
        tolua_function(tolua_S,"writeUInt32",lua_corelib_CMemOutputStream_writeUInt32);
        tolua_function(tolua_S,"writeInt16",lua_corelib_CMemOutputStream_writeInt16);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CMemOutputStream).name();
    g_luaType[typeName] = "CMemOutputStream";
    g_typeCast["CMemOutputStream"] = "CMemOutputStream";
    return 1;
}

int lua_corelib_CMemInputStream_readUInt64(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_readUInt64'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        uint64 ret = cobj->readUInt64();
        lua_tinker::push(tolua_S,ret);
        return 1;
    }

    gxError("CMemInputStream:readUInt64 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_readUInt64'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_readInt32(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_readInt32'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->readInt32();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemInputStream:readInt32 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_readInt32'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_peakUInt16(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_peakUInt16'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMemInputStream:peakUInt16");
        if(!ok)
            return 0;
        unsigned short ret = cobj->peakUInt16(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemInputStream:peakUInt16 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_peakUInt16'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_readSString(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_readSString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CScriptString ret = cobj->readSString();
        script_string_to_luaval(tolua_S,ret);
        return 1;
    }

    gxError("CMemInputStream:readSString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_readSString'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_peakUInt64(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_peakUInt64'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMemInputStream:peakUInt64");
        if(!ok)
            return 0;
        uint64 ret = cobj->peakUInt64(arg0);
        lua_tinker::push(tolua_S,ret);
        return 1;
    }

    gxError("CMemInputStream:peakUInt64 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_peakUInt64'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_peakUInt8(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_peakUInt8'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMemInputStream:peakUInt8");
        if(!ok)
            return 0;
        unsigned char ret = cobj->peakUInt8(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemInputStream:peakUInt8 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_peakUInt8'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_readInt16(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_readInt16'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        short ret = cobj->readInt16();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemInputStream:readInt16 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_readInt16'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_readInt64(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_readInt64'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        sint64 ret = cobj->readInt64();
        lua_tinker::push(tolua_S,ret);
        return 1;
    }

    gxError("CMemInputStream:readInt64 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_readInt64'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_readUInt8(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_readUInt8'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned char ret = cobj->readUInt8();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemInputStream:readUInt8 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_readUInt8'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_readString(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_readString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        CScriptString ret = cobj->readString();
        script_string_to_luaval(tolua_S,ret);
        return 1;
    }

    gxError("CMemInputStream:readString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_readString'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_readUInt32(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_readUInt32'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->readUInt32();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemInputStream:readUInt32 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_readUInt32'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_peakBuffer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_peakBuffer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        char* arg0;
        unsigned int arg1;
        unsigned int arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CMemInputStream:peakBuffer"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CMemInputStream:peakBuffer");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CMemInputStream:peakBuffer");
        if(!ok)
            return 0;
        bool ret = cobj->peakBuffer(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMemInputStream:peakBuffer has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_peakBuffer'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_readUInt16(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_readUInt16'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->readUInt16();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemInputStream:readUInt16 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_readUInt16'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_readInt8(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_readInt8'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        char ret = cobj->readInt8();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemInputStream:readInt8 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_readInt8'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_peakUInt32(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMemInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMemInputStream_peakUInt32'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CMemInputStream:peakUInt32");
        if(!ok)
            return 0;
        unsigned int ret = cobj->peakUInt32(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CMemInputStream:peakUInt32 has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMemInputStream_peakUInt32'.",&tolua_err);
	return 0;
}
int lua_corelib_CMemInputStream_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMemInputStream* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CMemInputStream:CMemInputStream");

            if (!ok) { break; }
            cobj = new GXMISC::CMemInputStream(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CMemInputStream");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CMemInputStream();
            tolua_pushusertype(tolua_S,(void*)cobj,"CMemInputStream");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CMemInputStream:CMemInputStream has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CMemInputStream_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMemInputStream)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMemInputStream",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CMemInputStream* self = (GXMISC::CMemInputStream*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CMemInputStream(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMemInputStream");
    tolua_cclass(tolua_S,"CMemInputStream","CMemInputStream","CMemInStream",lua_corelib_CMemInputStream_finalize);

    tolua_beginmodule(tolua_S,"CMemInputStream");
        tolua_function(tolua_S,"new",lua_corelib_CMemInputStream_constructor);
        tolua_function(tolua_S,"readUInt64",lua_corelib_CMemInputStream_readUInt64);
        tolua_function(tolua_S,"readInt32",lua_corelib_CMemInputStream_readInt32);
        tolua_function(tolua_S,"peakUInt16",lua_corelib_CMemInputStream_peakUInt16);
        tolua_function(tolua_S,"readSString",lua_corelib_CMemInputStream_readSString);
        tolua_function(tolua_S,"peakUInt64",lua_corelib_CMemInputStream_peakUInt64);
        tolua_function(tolua_S,"peakUInt8",lua_corelib_CMemInputStream_peakUInt8);
        tolua_function(tolua_S,"readInt16",lua_corelib_CMemInputStream_readInt16);
        tolua_function(tolua_S,"readInt64",lua_corelib_CMemInputStream_readInt64);
        tolua_function(tolua_S,"readUInt8",lua_corelib_CMemInputStream_readUInt8);
        tolua_function(tolua_S,"readString",lua_corelib_CMemInputStream_readString);
        tolua_function(tolua_S,"readUInt32",lua_corelib_CMemInputStream_readUInt32);
        tolua_function(tolua_S,"peakBuffer",lua_corelib_CMemInputStream_peakBuffer);
        tolua_function(tolua_S,"readUInt16",lua_corelib_CMemInputStream_readUInt16);
        tolua_function(tolua_S,"readInt8",lua_corelib_CMemInputStream_readInt8);
        tolua_function(tolua_S,"peakUInt32",lua_corelib_CMemInputStream_peakUInt32);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CMemInputStream).name();
    g_luaType[typeName] = "CMemInputStream";
    g_typeCast["CMemInputStream"] = "CMemInputStream";
    return 1;
}

static int lua_corelib_dbColProxy_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (dbColProxy)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"dbColProxy",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::dbColProxy* self = (GXMISC::dbColProxy*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_dbColProxy(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"dbColProxy");
    tolua_cclass(tolua_S,"dbColProxy","dbColProxy","",nullptr);

    tolua_beginmodule(tolua_S,"dbColProxy");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::dbColProxy).name();
    g_luaType[typeName] = "dbColProxy";
    g_typeCast["dbColProxy"] = "dbColProxy";
    return 1;
}

static int lua_corelib_TDBStructBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (TDBStructBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"TDBStructBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::TDBStructBase* self = (GXMISC::TDBStructBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_TDBStructBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"TDBStructBase");
    tolua_cclass(tolua_S,"TDBStructBase","TDBStructBase","",nullptr);

    tolua_beginmodule(tolua_S,"TDBStructBase");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::TDBStructBase).name();
    g_luaType[typeName] = "TDBStructBase";
    g_typeCast["TDBStructBase"] = "TDBStructBase";
    return 1;
}

int lua_corelib_CIni_findIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIni_findIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:findIndex"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        int ret = cobj->findIndex(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CIni:findIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_findIndex'.",&tolua_err);
	return 0;
}
int lua_corelib_CIni_getData(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIni_getData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        char* ret = cobj->getData();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CIni:getData has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_getData'.",&tolua_err);
	return 0;
}
int lua_corelib_CIni_readInt(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_corelib_CIni_readInt'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:readInt"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CIni:readInt");

            if (!ok) { break; }
            int ret = cobj->readInt(arg0, arg1);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:readInt"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            const char* arg1;
            CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CIni:readInt"); arg1 = (char*)arg1_tmp.buffer;

            if (!ok) { break; }
            int ret = cobj->readInt(arg0, arg1);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CIni:readInt has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_readInt'.",&tolua_err);
    return 0;
}
int lua_corelib_CIni_readText(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_corelib_CIni_readText'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 4) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:readText"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CIni:readText");

            if (!ok) { break; }
            char* arg2;
            CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "CIni:readText"); arg2 = (char*)arg2_tmp.buffer;

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CIni:readText");

            if (!ok) { break; }
            char* ret = cobj->readText(arg0, arg1, arg2, arg3);
            tolua_pushstring(tolua_S,(const char*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:readText"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            const char* arg1;
            CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CIni:readText"); arg1 = (char*)arg1_tmp.buffer;

            if (!ok) { break; }
            char* arg2;
            CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "CIni:readText"); arg2 = (char*)arg2_tmp.buffer;

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CIni:readText");

            if (!ok) { break; }
            char* ret = cobj->readText(arg0, arg1, arg2, arg3);
            tolua_pushstring(tolua_S,(const char*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CIni:readText has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_readText'.",&tolua_err);
    return 0;
}
int lua_corelib_CIni_getContinueDataNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIni_getContinueDataNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:getContinueDataNum"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        int ret = cobj->getContinueDataNum(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CIni:getContinueDataNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_getContinueDataNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CIni_readCaption(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIni_readCaption'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        const char* arg0;
        int arg1;
        char* arg2;
        int arg3;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:readCaption"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CIni:readCaption");

        CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "CIni:readCaption"); arg2 = (char*)arg2_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CIni:readCaption");
        if(!ok)
            return 0;
        char* ret = cobj->readCaption(arg0, arg1, arg2, arg3);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CIni:readCaption has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_readCaption'.",&tolua_err);
	return 0;
}
int lua_corelib_CIni_returnLineNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIni_returnLineNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:returnLineNum"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        int ret = cobj->returnLineNum(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CIni:returnLineNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_returnLineNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CIni_write(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_corelib_CIni_write'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:write"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            const char* arg1;
            CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CIni:write"); arg1 = (char*)arg1_tmp.buffer;

            if (!ok) { break; }
            char* arg2;
            CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "CIni:write"); arg2 = (char*)arg2_tmp.buffer;

            if (!ok) { break; }
            bool ret = cobj->write(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:write"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            const char* arg1;
            CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CIni:write"); arg1 = (char*)arg1_tmp.buffer;

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CIni:write");

            if (!ok) { break; }
            bool ret = cobj->write(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CIni:write has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_write'.",&tolua_err);
    return 0;
}
int lua_corelib_CIni_getLines(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_corelib_CIni_getLines'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            int ret = cobj->getLines();
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CIni:getLines");

            if (!ok) { break; }
            int ret = cobj->getLines(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CIni:getLines has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_getLines'.",&tolua_err);
    return 0;
}
int lua_corelib_CIni_readTextIfExist(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_corelib_CIni_readTextIfExist'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:readTextIfExist"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            const char* arg1;
            CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CIni:readTextIfExist"); arg1 = (char*)arg1_tmp.buffer;

            if (!ok) { break; }
            std::string arg2;
            ok &= luaval_to_std_string(tolua_S, 4,&arg2, "CIni:readTextIfExist");

            if (!ok) { break; }
            bool ret = cobj->readTextIfExist(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:readTextIfExist"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            const char* arg1;
            CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CIni:readTextIfExist"); arg1 = (char*)arg1_tmp.buffer;

            if (!ok) { break; }
            char* arg2;
            CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "CIni:readTextIfExist"); arg2 = (char*)arg2_tmp.buffer;

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CIni:readTextIfExist");

            if (!ok) { break; }
            bool ret = cobj->readTextIfExist(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CIni:readTextIfExist has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_readTextIfExist'.",&tolua_err);
    return 0;
}
int lua_corelib_CIni_close(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIni_close'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->close();
        return 0;
    }

    gxError("CIni:close has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_close'.",&tolua_err);
	return 0;
}
int lua_corelib_CIni_findOneLine(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIni_findOneLine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CIni:findOneLine");
        if(!ok)
            return 0;
        int ret = cobj->findOneLine(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CIni:findOneLine has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_findOneLine'.",&tolua_err);
	return 0;
}
int lua_corelib_CIni_save(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIni_save'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->save();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 1) 
    {
        char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:save"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        bool ret = cobj->save(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CIni:save has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_save'.",&tolua_err);
	return 0;
}
int lua_corelib_CIni_open(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_corelib_CIni_open'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:open"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CIni:open");

            if (!ok) { break; }
            bool ret = cobj->open(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:open"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            bool ret = cobj->open(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CIni:open has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_open'.",&tolua_err);
    return 0;
}
int lua_corelib_CIni_readOneLine(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIni_readOneLine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CIni:readOneLine");
        if(!ok)
            return 0;
        char* ret = cobj->readOneLine(arg0);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CIni:readOneLine has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_readOneLine'.",&tolua_err);
	return 0;
}
int lua_corelib_CIni_readIntIfExist(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CIni*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CIni_readIntIfExist'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const char* arg0;
        const char* arg1;
        int arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:readIntIfExist"); arg0 = (char*)arg0_tmp.buffer;

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CIni:readIntIfExist"); arg1 = (char*)arg1_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CIni:readIntIfExist");
        if(!ok)
            return 0;
        bool ret = cobj->readIntIfExist(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CIni:readIntIfExist has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CIni_readIntIfExist'.",&tolua_err);
	return 0;
}
int lua_corelib_CIni_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CIni* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:CIni"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            cobj = new GXMISC::CIni(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CIni");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CIni();
            tolua_pushusertype(tolua_S,(void*)cobj,"CIni");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CIni:CIni"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CIni:CIni");

            if (!ok) { break; }
            cobj = new GXMISC::CIni(arg0, arg1);
            tolua_pushusertype(tolua_S,(void*)cobj,"CIni");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CIni:CIni has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

}

static int lua_corelib_CIni_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CIni)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CIni",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CIni* self = (GXMISC::CIni*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CIni(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CIni");
    tolua_cclass(tolua_S,"CIni","CIni","",lua_corelib_CIni_finalize);

    tolua_beginmodule(tolua_S,"CIni");
        tolua_function(tolua_S,"new",lua_corelib_CIni_constructor);
        tolua_function(tolua_S,"findIndex",lua_corelib_CIni_findIndex);
        tolua_function(tolua_S,"getData",lua_corelib_CIni_getData);
        tolua_function(tolua_S,"readInt",lua_corelib_CIni_readInt);
        tolua_function(tolua_S,"readText",lua_corelib_CIni_readText);
        tolua_function(tolua_S,"getContinueDataNum",lua_corelib_CIni_getContinueDataNum);
        tolua_function(tolua_S,"readCaption",lua_corelib_CIni_readCaption);
        tolua_function(tolua_S,"returnLineNum",lua_corelib_CIni_returnLineNum);
        tolua_function(tolua_S,"write",lua_corelib_CIni_write);
        tolua_function(tolua_S,"getLines",lua_corelib_CIni_getLines);
        tolua_function(tolua_S,"readTextIfExist",lua_corelib_CIni_readTextIfExist);
        tolua_function(tolua_S,"close",lua_corelib_CIni_close);
        tolua_function(tolua_S,"findOneLine",lua_corelib_CIni_findOneLine);
        tolua_function(tolua_S,"save",lua_corelib_CIni_save);
        tolua_function(tolua_S,"open",lua_corelib_CIni_open);
        tolua_function(tolua_S,"readOneLine",lua_corelib_CIni_readOneLine);
        tolua_function(tolua_S,"readIntIfExist",lua_corelib_CIni_readIntIfExist);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CIni).name();
    g_luaType[typeName] = "CIni";
    g_typeCast["CIni"] = "CIni";
    return 1;
}

static int lua_corelib_IniItem_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (IniItem)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"IniItem",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::IniItem* self = (GXMISC::IniItem*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_IniItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"IniItem");
    tolua_cclass(tolua_S,"IniItem","IniItem","",nullptr);

    tolua_beginmodule(tolua_S,"IniItem");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::IniItem).name();
    g_luaType[typeName] = "IniItem";
    g_typeCast["IniItem"] = "IniItem";
    return 1;
}

static int lua_corelib_CIniSection_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CIniSection)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CIniSection",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CIniSection* self = (GXMISC::CIniSection*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CIniSection(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CIniSection");
    tolua_cclass(tolua_S,"CIniSection","CIniSection","",nullptr);

    tolua_beginmodule(tolua_S,"CIniSection");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CIniSection).name();
    g_luaType[typeName] = "CIniSection";
    g_typeCast["CIniSection"] = "CIniSection";
    return 1;
}

int lua_corelib_CLibConfig_getStatInterval(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLibConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLibConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLibConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLibConfig_getStatInterval'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getStatInterval();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLibConfig:getStatInterval has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLibConfig_getStatInterval'.",&tolua_err);
	return 0;
}
int lua_corelib_CLibConfig_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLibConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLibConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLibConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLibConfig_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->init();
        return 0;
    }

    gxError("CLibConfig:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLibConfig_init'.",&tolua_err);
	return 0;
}
int lua_corelib_CLibConfig_setConfig(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLibConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLibConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLibConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLibConfig_setConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::ELibConfig arg0;
        unsigned int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLibConfig:setConfig");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CLibConfig:setConfig");
        if(!ok)
            return 0;
        cobj->setConfig(arg0, arg1);
        return 0;
    }

    gxError("CLibConfig:setConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLibConfig_setConfig'.",&tolua_err);
	return 0;
}
int lua_corelib_CLibConfig_getStatDb(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLibConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLibConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLibConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLibConfig_getStatDb'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getStatDb();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLibConfig:getStatDb has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLibConfig_getStatDb'.",&tolua_err);
	return 0;
}
int lua_corelib_CLibConfig_getConfig(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLibConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLibConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLibConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLibConfig_getConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::ELibConfig arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLibConfig:getConfig");
        if(!ok)
            return 0;
        unsigned int ret = cobj->getConfig(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CLibConfig:getConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLibConfig_getConfig'.",&tolua_err);
	return 0;
}
int lua_corelib_CLibConfig_isConfig(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CLibConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CLibConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CLibConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CLibConfig_isConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::ELibConfig arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CLibConfig:isConfig");
        if(!ok)
            return 0;
        bool ret = cobj->isConfig(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CLibConfig:isConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CLibConfig_isConfig'.",&tolua_err);
	return 0;
}
static int lua_corelib_CLibConfig_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CLibConfig)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CLibConfig",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CLibConfig* self = (GXMISC::CLibConfig*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CLibConfig(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CLibConfig");
    tolua_cclass(tolua_S,"CLibConfig","CLibConfig","",nullptr);

    tolua_beginmodule(tolua_S,"CLibConfig");
        tolua_function(tolua_S,"getStatInterval",lua_corelib_CLibConfig_getStatInterval);
        tolua_function(tolua_S,"init",lua_corelib_CLibConfig_init);
        tolua_function(tolua_S,"setConfig",lua_corelib_CLibConfig_setConfig);
        tolua_function(tolua_S,"getStatDb",lua_corelib_CLibConfig_getStatDb);
        tolua_function(tolua_S,"getConfig",lua_corelib_CLibConfig_getConfig);
        tolua_function(tolua_S,"isConfig",lua_corelib_CLibConfig_isConfig);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CLibConfig).name();
    g_luaType[typeName] = "CLibConfig";
    g_typeCast["CLibConfig"] = "CLibConfig";
    return 1;
}

static int lua_corelib_SSocketLoopEventArg_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (SSocketLoopEventArg)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"SSocketLoopEventArg",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::SSocketLoopEventArg* self = (GXMISC::SSocketLoopEventArg*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_SSocketLoopEventArg(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"SSocketLoopEventArg");
    tolua_cclass(tolua_S,"SSocketLoopEventArg","SSocketLoopEventArg","",nullptr);

    tolua_beginmodule(tolua_S,"SSocketLoopEventArg");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::SSocketLoopEventArg).name();
    g_luaType[typeName] = "SSocketLoopEventArg";
    g_typeCast["SSocketLoopEventArg"] = "SSocketLoopEventArg";
    return 1;
}

static int lua_corelib_SMainLoopEventArg_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (SMainLoopEventArg)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"SMainLoopEventArg",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::SMainLoopEventArg* self = (GXMISC::SMainLoopEventArg*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_SMainLoopEventArg(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"SMainLoopEventArg");
    tolua_cclass(tolua_S,"SMainLoopEventArg","SMainLoopEventArg","",nullptr);

    tolua_beginmodule(tolua_S,"SMainLoopEventArg");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::SMainLoopEventArg).name();
    g_luaType[typeName] = "SMainLoopEventArg";
    g_typeCast["SMainLoopEventArg"] = "SMainLoopEventArg";
    return 1;
}

int lua_corelib_CSocketInputStream_peakUint(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_peakUint'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->peakUint();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketInputStream:peakUint has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_peakUint'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_peakUint16(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_peakUint16'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->peakUint16();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketInputStream:peakUint16 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_peakUint16'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_getBuffer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_getBuffer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        char* ret = cobj->getBuffer();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CSocketInputStream:getBuffer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_getBuffer'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_capacity(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_capacity'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->capacity();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketInputStream:capacity has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_capacity'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_getTailPos(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_getTailPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getTailPos();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketInputStream:getTailPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_getTailPos'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_peek(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_peek'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocketInputStream:peek"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketInputStream:peek");
        if(!ok)
            return 0;
        bool ret = cobj->peek(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketInputStream:peek has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_peek'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_read(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_read'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocketInputStream:read"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketInputStream:read");
        if(!ok)
            return 0;
        int ret = cobj->read(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketInputStream:read has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_read'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_skip(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_skip'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocketInputStream:skip");
        if(!ok)
            return 0;
        bool ret = cobj->skip(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketInputStream:skip has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_skip'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_peakByte(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_peakByte'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        char ret = cobj->peakByte();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketInputStream:peakByte has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_peakByte'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_initsize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_initsize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CSocket* arg0;

        ok &= luaval_to_object<GXMISC::CSocket>(tolua_S, 2, "CSocket", &arg0, "CSocketInputStream:initsize");
        if(!ok)
            return 0;
        cobj->initsize(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        GXMISC::CSocket* arg0;
        int arg1;

        ok &= luaval_to_object<GXMISC::CSocket>(tolua_S, 2, "CSocket", &arg0, "CSocketInputStream:initsize");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketInputStream:initsize");
        if(!ok)
            return 0;
        cobj->initsize(arg0, arg1);
        return 0;
    }
    if (argc == 3) 
    {
        GXMISC::CSocket* arg0;
        int arg1;
        int arg2;

        ok &= luaval_to_object<GXMISC::CSocket>(tolua_S, 2, "CSocket", &arg0, "CSocketInputStream:initsize");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketInputStream:initsize");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CSocketInputStream:initsize");
        if(!ok)
            return 0;
        cobj->initsize(arg0, arg1, arg2);
        return 0;
    }

    gxError("CSocketInputStream:initsize has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_initsize'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_length(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_length'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->length();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketInputStream:length has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_length'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_peakInt(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_peakInt'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->peakInt();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketInputStream:peakInt has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_peakInt'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_isEmpty(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_isEmpty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isEmpty();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketInputStream:isEmpty has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_isEmpty'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_getBuffLen(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_getBuffLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getBuffLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketInputStream:getBuffLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_getBuffLen'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_getHeadPos(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_getHeadPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getHeadPos();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketInputStream:getHeadPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_getHeadPos'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_peakInt16(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_peakInt16'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        short ret = cobj->peakInt16();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketInputStream:peakInt16 has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_peakInt16'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CSocketInputStream:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_size(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_size'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->size();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketInputStream:size has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_size'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_resize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_resize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocketInputStream:resize");
        if(!ok)
            return 0;
        bool ret = cobj->resize(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketInputStream:resize has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_resize'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_fill(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketInputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketInputStream_fill'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->fill();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketInputStream:fill has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketInputStream_fill'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketInputStream_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketInputStream* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CSocketInputStream();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSocketInputStream");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSocketInputStream:CSocketInputStream has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CSocketInputStream_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSocketInputStream)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSocketInputStream",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSocketInputStream* self = (GXMISC::CSocketInputStream*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSocketInputStream(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSocketInputStream");
    tolua_cclass(tolua_S,"CSocketInputStream","CSocketInputStream","",lua_corelib_CSocketInputStream_finalize);

    tolua_beginmodule(tolua_S,"CSocketInputStream");
        tolua_function(tolua_S,"new",lua_corelib_CSocketInputStream_constructor);
        tolua_function(tolua_S,"peakUint",lua_corelib_CSocketInputStream_peakUint);
        tolua_function(tolua_S,"peakUint16",lua_corelib_CSocketInputStream_peakUint16);
        tolua_function(tolua_S,"getBuffer",lua_corelib_CSocketInputStream_getBuffer);
        tolua_function(tolua_S,"capacity",lua_corelib_CSocketInputStream_capacity);
        tolua_function(tolua_S,"getTailPos",lua_corelib_CSocketInputStream_getTailPos);
        tolua_function(tolua_S,"peek",lua_corelib_CSocketInputStream_peek);
        tolua_function(tolua_S,"read",lua_corelib_CSocketInputStream_read);
        tolua_function(tolua_S,"skip",lua_corelib_CSocketInputStream_skip);
        tolua_function(tolua_S,"peakByte",lua_corelib_CSocketInputStream_peakByte);
        tolua_function(tolua_S,"initsize",lua_corelib_CSocketInputStream_initsize);
        tolua_function(tolua_S,"length",lua_corelib_CSocketInputStream_length);
        tolua_function(tolua_S,"peakInt",lua_corelib_CSocketInputStream_peakInt);
        tolua_function(tolua_S,"isEmpty",lua_corelib_CSocketInputStream_isEmpty);
        tolua_function(tolua_S,"getBuffLen",lua_corelib_CSocketInputStream_getBuffLen);
        tolua_function(tolua_S,"getHeadPos",lua_corelib_CSocketInputStream_getHeadPos);
        tolua_function(tolua_S,"peakInt16",lua_corelib_CSocketInputStream_peakInt16);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CSocketInputStream_cleanUp);
        tolua_function(tolua_S,"size",lua_corelib_CSocketInputStream_size);
        tolua_function(tolua_S,"resize",lua_corelib_CSocketInputStream_resize);
        tolua_function(tolua_S,"fill",lua_corelib_CSocketInputStream_fill);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSocketInputStream).name();
    g_luaType[typeName] = "CSocketInputStream";
    g_typeCast["CSocketInputStream"] = "CSocketInputStream";
    return 1;
}

int lua_corelib_CSocketOutputStream_capacity(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_capacity'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->capacity();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketOutputStream:capacity has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_capacity'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_getTailPos(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_getTailPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getTailPos();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketOutputStream:getTailPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_getTailPos'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_write(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_write'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocketOutputStream:write"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketOutputStream:write");
        if(!ok)
            return 0;
        int ret = cobj->write(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketOutputStream:write has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_write'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_initsize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_initsize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CSocket* arg0;

        ok &= luaval_to_object<GXMISC::CSocket>(tolua_S, 2, "CSocket", &arg0, "CSocketOutputStream:initsize");
        if(!ok)
            return 0;
        cobj->initsize(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        GXMISC::CSocket* arg0;
        int arg1;

        ok &= luaval_to_object<GXMISC::CSocket>(tolua_S, 2, "CSocket", &arg0, "CSocketOutputStream:initsize");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketOutputStream:initsize");
        if(!ok)
            return 0;
        cobj->initsize(arg0, arg1);
        return 0;
    }
    if (argc == 3) 
    {
        GXMISC::CSocket* arg0;
        int arg1;
        int arg2;

        ok &= luaval_to_object<GXMISC::CSocket>(tolua_S, 2, "CSocket", &arg0, "CSocketOutputStream:initsize");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketOutputStream:initsize");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CSocketOutputStream:initsize");
        if(!ok)
            return 0;
        cobj->initsize(arg0, arg1, arg2);
        return 0;
    }

    gxError("CSocketOutputStream:initsize has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_initsize'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_length(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_length'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->length();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketOutputStream:length has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_length'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CSocketOutputStream:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_isEmpty(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_isEmpty'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isEmpty();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketOutputStream:isEmpty has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_isEmpty'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_getBuffLen(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_getBuffLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getBuffLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketOutputStream:getBuffLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_getBuffLen'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_getHeadPos(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_getHeadPos'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getHeadPos();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketOutputStream:getHeadPos has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_getHeadPos'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_flush(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_flush'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->flush();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketOutputStream:flush has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_flush'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_getBuffer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_getBuffer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        char* ret = cobj->getBuffer();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CSocketOutputStream:getBuffer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_getBuffer'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_getTail(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_getTail'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        char* ret = cobj->getTail();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CSocketOutputStream:getTail has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_getTail'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_resize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_resize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocketOutputStream:resize");
        if(!ok)
            return 0;
        bool ret = cobj->resize(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketOutputStream:resize has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_resize'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_size(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketOutputStream*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketOutputStream_size'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->size();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketOutputStream:size has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketOutputStream_size'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketOutputStream_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketOutputStream* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CSocketOutputStream();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSocketOutputStream");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSocketOutputStream:CSocketOutputStream has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CSocketOutputStream_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSocketOutputStream)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSocketOutputStream",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSocketOutputStream* self = (GXMISC::CSocketOutputStream*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSocketOutputStream(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSocketOutputStream");
    tolua_cclass(tolua_S,"CSocketOutputStream","CSocketOutputStream","",lua_corelib_CSocketOutputStream_finalize);

    tolua_beginmodule(tolua_S,"CSocketOutputStream");
        tolua_function(tolua_S,"new",lua_corelib_CSocketOutputStream_constructor);
        tolua_function(tolua_S,"capacity",lua_corelib_CSocketOutputStream_capacity);
        tolua_function(tolua_S,"getTailPos",lua_corelib_CSocketOutputStream_getTailPos);
        tolua_function(tolua_S,"write",lua_corelib_CSocketOutputStream_write);
        tolua_function(tolua_S,"initsize",lua_corelib_CSocketOutputStream_initsize);
        tolua_function(tolua_S,"length",lua_corelib_CSocketOutputStream_length);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CSocketOutputStream_cleanUp);
        tolua_function(tolua_S,"isEmpty",lua_corelib_CSocketOutputStream_isEmpty);
        tolua_function(tolua_S,"getBuffLen",lua_corelib_CSocketOutputStream_getBuffLen);
        tolua_function(tolua_S,"getHeadPos",lua_corelib_CSocketOutputStream_getHeadPos);
        tolua_function(tolua_S,"flush",lua_corelib_CSocketOutputStream_flush);
        tolua_function(tolua_S,"getBuffer",lua_corelib_CSocketOutputStream_getBuffer);
        tolua_function(tolua_S,"getTail",lua_corelib_CSocketOutputStream_getTail);
        tolua_function(tolua_S,"resize",lua_corelib_CSocketOutputStream_resize);
        tolua_function(tolua_S,"size",lua_corelib_CSocketOutputStream_size);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSocketOutputStream).name();
    g_luaType[typeName] = "CSocketOutputStream";
    g_typeCast["CSocketOutputStream"] = "CSocketOutputStream";
    return 1;
}

int lua_corelib_CPackHandleAry_getPack(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CPackHandleAry* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CPackHandleAry",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CPackHandleAry*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CPackHandleAry_getPack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CPackHandleAry:getPack");
        if(!ok)
            return 0;
        const char* ret = cobj->getPack(arg0);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CPackHandleAry:getPack has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CPackHandleAry_getPack'.",&tolua_err);
	return 0;
}
int lua_corelib_CPackHandleAry_push(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CPackHandleAry* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CPackHandleAry",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CPackHandleAry*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CPackHandleAry_push'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CPackHandleAry:push"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CPackHandleAry:push");
        if(!ok)
            return 0;
        cobj->push(arg0, arg1);
        return 0;
    }

    gxError("CPackHandleAry:push has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CPackHandleAry_push'.",&tolua_err);
	return 0;
}
int lua_corelib_CPackHandleAry_getPackNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CPackHandleAry* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CPackHandleAry",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CPackHandleAry*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CPackHandleAry_getPackNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPackNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CPackHandleAry:getPackNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CPackHandleAry_getPackNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CPackHandleAry_getPackLen(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CPackHandleAry* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CPackHandleAry",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CPackHandleAry*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_corelib_CPackHandleAry_getPackLen'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CPackHandleAry:getPackLen");

            if (!ok) { break; }
            int ret = cobj->getPackLen(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CPackHandleAry:getPackLen");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CPackHandleAry:getPackLen");

            if (!ok) { break; }
            int ret = cobj->getPackLen(arg0, arg1);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CPackHandleAry:getPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CPackHandleAry_getPackLen'.",&tolua_err);
    return 0;
}
int lua_corelib_CPackHandleAry_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CPackHandleAry* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CPackHandleAry();
        tolua_pushusertype(tolua_S,(void*)cobj,"CPackHandleAry");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CPackHandleAry:CPackHandleAry has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CPackHandleAry_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CPackHandleAry)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CPackHandleAry",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CPackHandleAry* self = (GXMISC::CPackHandleAry*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CPackHandleAry(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CPackHandleAry");
    tolua_cclass(tolua_S,"CPackHandleAry","CPackHandleAry","",lua_corelib_CPackHandleAry_finalize);

    tolua_beginmodule(tolua_S,"CPackHandleAry");
        tolua_function(tolua_S,"new",lua_corelib_CPackHandleAry_constructor);
        tolua_function(tolua_S,"getPack",lua_corelib_CPackHandleAry_getPack);
        tolua_function(tolua_S,"push",lua_corelib_CPackHandleAry_push);
        tolua_function(tolua_S,"getPackNum",lua_corelib_CPackHandleAry_getPackNum);
        tolua_function(tolua_S,"getPackLen",lua_corelib_CPackHandleAry_getPackLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CPackHandleAry).name();
    g_luaType[typeName] = "CPackHandleAry";
    g_typeCast["CPackHandleAry"] = "CPackHandleAry";
    return 1;
}

int lua_corelib_ISocketPacketHandler_needHandle(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_needHandle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::ISocketPacketHandler::EPackOpt arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "ISocketPacketHandler:needHandle");
        if(!ok)
            return 0;
        bool ret = cobj->needHandle(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("ISocketPacketHandler:needHandle has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_needHandle'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_isVarPacket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_isVarPacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "ISocketPacketHandler:isVarPacket"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "ISocketPacketHandler:isVarPacket");
        if(!ok)
            return 0;
        bool ret = cobj->isVarPacket(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("ISocketPacketHandler:isVarPacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_isVarPacket'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_sendPack(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_sendPack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        unsigned int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "ISocketPacketHandler:sendPack"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "ISocketPacketHandler:sendPack");
        if(!ok)
            return 0;
        cobj->sendPack(arg0, arg1);
        return 0;
    }

    gxError("ISocketPacketHandler:sendPack has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_sendPack'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_onSendPack(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_onSendPack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const char* arg0;
        int arg1;
        bool arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "ISocketPacketHandler:onSendPack"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "ISocketPacketHandler:onSendPack");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "ISocketPacketHandler:onSendPack");
        if(!ok)
            return 0;
        cobj->onSendPack(arg0, arg1, arg2);
        return 0;
    }

    gxError("ISocketPacketHandler:onSendPack has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_onSendPack'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_onBeforeFlushToSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_onBeforeFlushToSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        const char* arg0;
        int arg1;
        char* arg2;
        int arg3;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "ISocketPacketHandler:onBeforeFlushToSocket"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "ISocketPacketHandler:onBeforeFlushToSocket");

        CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "ISocketPacketHandler:onBeforeFlushToSocket"); arg2 = (char*)arg2_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "ISocketPacketHandler:onBeforeFlushToSocket");
        if(!ok)
            return 0;
        int ret = cobj->onBeforeFlushToSocket(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("ISocketPacketHandler:onBeforeFlushToSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_onBeforeFlushToSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_setSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_setSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CSocket* arg0;

        ok &= luaval_to_object<GXMISC::CSocket>(tolua_S, 2, "CSocket", &arg0, "ISocketPacketHandler:setSocket");
        if(!ok)
            return 0;
        cobj->setSocket(arg0);
        return 0;
    }

    gxError("ISocketPacketHandler:setSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_setSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_getUnpacketNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_getUnpacketNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getUnpacketNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("ISocketPacketHandler:getUnpacketNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_getUnpacketNum'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_onHandleVarUnpacket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_onHandleVarUnpacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        char* arg0;
        const char* arg1;
        int arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "ISocketPacketHandler:onHandleVarUnpacket"); arg0 = (char*)arg0_tmp.buffer;

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "ISocketPacketHandler:onHandleVarUnpacket"); arg1 = (char*)arg1_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "ISocketPacketHandler:onHandleVarUnpacket");
        if(!ok)
            return 0;
        cobj->onHandleVarUnpacket(arg0, arg1, arg2);
        return 0;
    }

    gxError("ISocketPacketHandler:onHandleVarUnpacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_onHandleVarUnpacket'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_onAfterReadFromSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_onAfterReadFromSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        const char* arg0;
        int arg1;
        char* arg2;
        int arg3;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "ISocketPacketHandler:onAfterReadFromSocket"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "ISocketPacketHandler:onAfterReadFromSocket");

        CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "ISocketPacketHandler:onAfterReadFromSocket"); arg2 = (char*)arg2_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "ISocketPacketHandler:onAfterReadFromSocket");
        if(!ok)
            return 0;
        int ret = cobj->onAfterReadFromSocket(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("ISocketPacketHandler:onAfterReadFromSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_onAfterReadFromSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_setUnpacketNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_setUnpacketNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "ISocketPacketHandler:setUnpacketNum");
        if(!ok)
            return 0;
        cobj->setUnpacketNum(arg0);
        return 0;
    }

    gxError("ISocketPacketHandler:setUnpacketNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_setUnpacketNum'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_getMaxVarPackLen(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_getMaxVarPackLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "ISocketPacketHandler:getMaxVarPackLen"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        int ret = cobj->getMaxVarPackLen(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("ISocketPacketHandler:getMaxVarPackLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_getMaxVarPackLen'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_canUnpacket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_canUnpacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->canUnpacket();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("ISocketPacketHandler:canUnpacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_canUnpacket'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_getPackHeaderLen(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_getPackHeaderLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPackHeaderLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("ISocketPacketHandler:getPackHeaderLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_getPackHeaderLen'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_getSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_getSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CSocket* ret = cobj->getSocket();
        object_to_luaval<GXMISC::CSocket>(tolua_S, "CSocket",(GXMISC::CSocket*)ret);
        return 1;
    }

    gxError("ISocketPacketHandler:getSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_getSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_onPackAfterFromSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_onPackAfterFromSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        const char* arg0;
        int arg1;
        char* arg2;
        int arg3;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "ISocketPacketHandler:onPackAfterFromSocket"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "ISocketPacketHandler:onPackAfterFromSocket");

        CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "ISocketPacketHandler:onPackAfterFromSocket"); arg2 = (char*)arg2_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "ISocketPacketHandler:onPackAfterFromSocket");
        if(!ok)
            return 0;
        int ret = cobj->onPackAfterFromSocket(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("ISocketPacketHandler:onPackAfterFromSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_onPackAfterFromSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_canReadPack(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_canReadPack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "ISocketPacketHandler:canReadPack"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "ISocketPacketHandler:canReadPack");
        if(!ok)
            return 0;
        int ret = cobj->canReadPack(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("ISocketPacketHandler:canReadPack has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_canReadPack'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_onPackBeforeFlushToSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_onPackBeforeFlushToSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        const char* arg0;
        int arg1;
        char* arg2;
        int arg3;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "ISocketPacketHandler:onPackBeforeFlushToSocket"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "ISocketPacketHandler:onPackBeforeFlushToSocket");

        CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "ISocketPacketHandler:onPackBeforeFlushToSocket"); arg2 = (char*)arg2_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "ISocketPacketHandler:onPackBeforeFlushToSocket");
        if(!ok)
            return 0;
        int ret = cobj->onPackBeforeFlushToSocket(arg0, arg1, arg2, arg3);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("ISocketPacketHandler:onPackBeforeFlushToSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 4);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_onPackBeforeFlushToSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_unpacket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_unpacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        GXMISC::CNetSocketLoopTask* arg0;
        char* arg1;
        int arg2;
        char* arg3;
        int arg4;

        ok &= luaval_to_object<GXMISC::CNetSocketLoopTask>(tolua_S, 2, "CNetSocketLoopTask", &arg0, "ISocketPacketHandler:unpacket");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "ISocketPacketHandler:unpacket"); arg1 = (char*)arg1_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "ISocketPacketHandler:unpacket");

        CScriptString arg3_tmp; ok &= luaval_to_script_string(tolua_S, 5, &arg3_tmp, "ISocketPacketHandler:unpacket"); arg3 = (char*)arg3_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "ISocketPacketHandler:unpacket");
        if(!ok)
            return 0;
        bool ret = cobj->unpacket(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("ISocketPacketHandler:unpacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_unpacket'.",&tolua_err);
	return 0;
}
int lua_corelib_ISocketPacketHandler_onRecvPack(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ISocketPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ISocketPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ISocketPacketHandler_onRecvPack'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const char* arg0;
        int arg1;
        bool arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "ISocketPacketHandler:onRecvPack"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "ISocketPacketHandler:onRecvPack");

        ok &= luaval_to_boolean(tolua_S, 4,(bool*)&arg2, "ISocketPacketHandler:onRecvPack");
        if(!ok)
            return 0;
        cobj->onRecvPack(arg0, arg1, arg2);
        return 0;
    }

    gxError("ISocketPacketHandler:onRecvPack has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ISocketPacketHandler_onRecvPack'.",&tolua_err);
	return 0;
}
static int lua_corelib_ISocketPacketHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ISocketPacketHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ISocketPacketHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::ISocketPacketHandler* self = (GXMISC::ISocketPacketHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_ISocketPacketHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ISocketPacketHandler");
    tolua_cclass(tolua_S,"ISocketPacketHandler","ISocketPacketHandler","IFreeable",nullptr);

    tolua_beginmodule(tolua_S,"ISocketPacketHandler");
        tolua_function(tolua_S,"needHandle",lua_corelib_ISocketPacketHandler_needHandle);
        tolua_function(tolua_S,"isVarPacket",lua_corelib_ISocketPacketHandler_isVarPacket);
        tolua_function(tolua_S,"sendPack",lua_corelib_ISocketPacketHandler_sendPack);
        tolua_function(tolua_S,"onSendPack",lua_corelib_ISocketPacketHandler_onSendPack);
        tolua_function(tolua_S,"onBeforeFlushToSocket",lua_corelib_ISocketPacketHandler_onBeforeFlushToSocket);
        tolua_function(tolua_S,"setSocket",lua_corelib_ISocketPacketHandler_setSocket);
        tolua_function(tolua_S,"getUnpacketNum",lua_corelib_ISocketPacketHandler_getUnpacketNum);
        tolua_function(tolua_S,"onHandleVarUnpacket",lua_corelib_ISocketPacketHandler_onHandleVarUnpacket);
        tolua_function(tolua_S,"onAfterReadFromSocket",lua_corelib_ISocketPacketHandler_onAfterReadFromSocket);
        tolua_function(tolua_S,"setUnpacketNum",lua_corelib_ISocketPacketHandler_setUnpacketNum);
        tolua_function(tolua_S,"getMaxVarPackLen",lua_corelib_ISocketPacketHandler_getMaxVarPackLen);
        tolua_function(tolua_S,"canUnpacket",lua_corelib_ISocketPacketHandler_canUnpacket);
        tolua_function(tolua_S,"getPackHeaderLen",lua_corelib_ISocketPacketHandler_getPackHeaderLen);
        tolua_function(tolua_S,"getSocket",lua_corelib_ISocketPacketHandler_getSocket);
        tolua_function(tolua_S,"onPackAfterFromSocket",lua_corelib_ISocketPacketHandler_onPackAfterFromSocket);
        tolua_function(tolua_S,"canReadPack",lua_corelib_ISocketPacketHandler_canReadPack);
        tolua_function(tolua_S,"onPackBeforeFlushToSocket",lua_corelib_ISocketPacketHandler_onPackBeforeFlushToSocket);
        tolua_function(tolua_S,"unpacket",lua_corelib_ISocketPacketHandler_unpacket);
        tolua_function(tolua_S,"onRecvPack",lua_corelib_ISocketPacketHandler_onRecvPack);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::ISocketPacketHandler).name();
    g_luaType[typeName] = "ISocketPacketHandler";
    g_typeCast["ISocketPacketHandler"] = "ISocketPacketHandler";
    return 1;
}

int lua_corelib_CEmptyPacketHandler_unpacket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CEmptyPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CEmptyPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CEmptyPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CEmptyPacketHandler_unpacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        GXMISC::CNetSocketLoopTask* arg0;
        char* arg1;
        int arg2;
        char* arg3;
        int arg4;

        ok &= luaval_to_object<GXMISC::CNetSocketLoopTask>(tolua_S, 2, "CNetSocketLoopTask", &arg0, "CEmptyPacketHandler:unpacket");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CEmptyPacketHandler:unpacket"); arg1 = (char*)arg1_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CEmptyPacketHandler:unpacket");

        CScriptString arg3_tmp; ok &= luaval_to_script_string(tolua_S, 5, &arg3_tmp, "CEmptyPacketHandler:unpacket"); arg3 = (char*)arg3_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CEmptyPacketHandler:unpacket");
        if(!ok)
            return 0;
        bool ret = cobj->unpacket(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CEmptyPacketHandler:unpacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CEmptyPacketHandler_unpacket'.",&tolua_err);
	return 0;
}
int lua_corelib_CEmptyPacketHandler_canUnpacket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CEmptyPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CEmptyPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CEmptyPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CEmptyPacketHandler_canUnpacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->canUnpacket();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CEmptyPacketHandler:canUnpacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CEmptyPacketHandler_canUnpacket'.",&tolua_err);
	return 0;
}
int lua_corelib_CEmptyPacketHandler_getPackHeaderLen(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CEmptyPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CEmptyPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CEmptyPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CEmptyPacketHandler_getPackHeaderLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPackHeaderLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CEmptyPacketHandler:getPackHeaderLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CEmptyPacketHandler_getPackHeaderLen'.",&tolua_err);
	return 0;
}
int lua_corelib_CEmptyPacketHandler_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CEmptyPacketHandler* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CEmptyPacketHandler();
        tolua_pushusertype(tolua_S,(void*)cobj,"CEmptyPacketHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CEmptyPacketHandler:CEmptyPacketHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CEmptyPacketHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CEmptyPacketHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CEmptyPacketHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CEmptyPacketHandler* self = (GXMISC::CEmptyPacketHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CEmptyPacketHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CEmptyPacketHandler");
    tolua_cclass(tolua_S,"CEmptyPacketHandler","CEmptyPacketHandler","ISocketPacketHandler",lua_corelib_CEmptyPacketHandler_finalize);

    tolua_beginmodule(tolua_S,"CEmptyPacketHandler");
        tolua_function(tolua_S,"new",lua_corelib_CEmptyPacketHandler_constructor);
        tolua_function(tolua_S,"unpacket",lua_corelib_CEmptyPacketHandler_unpacket);
        tolua_function(tolua_S,"canUnpacket",lua_corelib_CEmptyPacketHandler_canUnpacket);
        tolua_function(tolua_S,"getPackHeaderLen",lua_corelib_CEmptyPacketHandler_getPackHeaderLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CEmptyPacketHandler).name();
    g_luaType[typeName] = "CEmptyPacketHandler";
    g_typeCast["CEmptyPacketHandler"] = "CEmptyPacketHandler";
    return 1;
}

int lua_corelib_CDefaultPacketHandler_unpacket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDefaultPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDefaultPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDefaultPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDefaultPacketHandler_unpacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        GXMISC::CNetSocketLoopTask* arg0;
        char* arg1;
        int arg2;
        char* arg3;
        int arg4;

        ok &= luaval_to_object<GXMISC::CNetSocketLoopTask>(tolua_S, 2, "CNetSocketLoopTask", &arg0, "CDefaultPacketHandler:unpacket");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CDefaultPacketHandler:unpacket"); arg1 = (char*)arg1_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CDefaultPacketHandler:unpacket");

        CScriptString arg3_tmp; ok &= luaval_to_script_string(tolua_S, 5, &arg3_tmp, "CDefaultPacketHandler:unpacket"); arg3 = (char*)arg3_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CDefaultPacketHandler:unpacket");
        if(!ok)
            return 0;
        bool ret = cobj->unpacket(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CDefaultPacketHandler:unpacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDefaultPacketHandler_unpacket'.",&tolua_err);
	return 0;
}
int lua_corelib_CDefaultPacketHandler_canUnpacket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDefaultPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDefaultPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDefaultPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDefaultPacketHandler_canUnpacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->canUnpacket();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDefaultPacketHandler:canUnpacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDefaultPacketHandler_canUnpacket'.",&tolua_err);
	return 0;
}
int lua_corelib_CDefaultPacketHandler_getPackHeaderLen(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDefaultPacketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CDefaultPacketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CDefaultPacketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CDefaultPacketHandler_getPackHeaderLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPackHeaderLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CDefaultPacketHandler:getPackHeaderLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CDefaultPacketHandler_getPackHeaderLen'.",&tolua_err);
	return 0;
}
int lua_corelib_CDefaultPacketHandler_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CDefaultPacketHandler* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CDefaultPacketHandler();
        tolua_pushusertype(tolua_S,(void*)cobj,"CDefaultPacketHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CDefaultPacketHandler:CDefaultPacketHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CDefaultPacketHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CDefaultPacketHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CDefaultPacketHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CDefaultPacketHandler* self = (GXMISC::CDefaultPacketHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CDefaultPacketHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CDefaultPacketHandler");
    tolua_cclass(tolua_S,"CDefaultPacketHandler","CDefaultPacketHandler","ISocketPacketHandler",lua_corelib_CDefaultPacketHandler_finalize);

    tolua_beginmodule(tolua_S,"CDefaultPacketHandler");
        tolua_function(tolua_S,"new",lua_corelib_CDefaultPacketHandler_constructor);
        tolua_function(tolua_S,"unpacket",lua_corelib_CDefaultPacketHandler_unpacket);
        tolua_function(tolua_S,"canUnpacket",lua_corelib_CDefaultPacketHandler_canUnpacket);
        tolua_function(tolua_S,"getPackHeaderLen",lua_corelib_CDefaultPacketHandler_getPackHeaderLen);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CDefaultPacketHandler).name();
    g_luaType[typeName] = "CDefaultPacketHandler";
    g_typeCast["CDefaultPacketHandler"] = "CDefaultPacketHandler";
    return 1;
}

int lua_corelib_CSocket_setWaitCloseSecs(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_setWaitCloseSecs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CSocket:setWaitCloseSecs");
        if(!ok)
            return 0;
        cobj->setWaitCloseSecs(arg0);
        return 0;
    }

    gxError("CSocket:setWaitCloseSecs has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_setWaitCloseSecs'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getSocket();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:getSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_setSocketEventLoop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_setSocketEventLoop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CSocketEventLoop* arg0;

        ok &= luaval_to_object<GXMISC::CSocketEventLoop>(tolua_S, 2, "CSocketEventLoop", &arg0, "CSocket:setSocketEventLoop");
        if(!ok)
            return 0;
        cobj->setSocketEventLoop(arg0);
        return 0;
    }

    gxError("CSocket:setSocketEventLoop has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_setSocketEventLoop'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getOutputStream(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getOutputStream'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CSocketOutputStream* ret = cobj->getOutputStream();
        object_to_luaval<GXMISC::CSocketOutputStream>(tolua_S, "CSocketOutputStream",(GXMISC::CSocketOutputStream*)ret);
        return 1;
    }

    gxError("CSocket:getOutputStream has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getOutputStream'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getUniqueIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getUniqueIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getUniqueIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CSocket:getUniqueIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getUniqueIndex'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getReceiveBufferSize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getReceiveBufferSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getReceiveBufferSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:getReceiveBufferSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getReceiveBufferSize'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getUnpacketNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getUnpacketNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getUnpacketNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:getUnpacketNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getUnpacketNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CSocketEventLoop* arg0;

        ok &= luaval_to_object<GXMISC::CSocketEventLoop>(tolua_S, 2, "CSocketEventLoop", &arg0, "CSocket:cleanUp");
        if(!ok)
            return 0;
        cobj->cleanUp(arg0);
        return 0;
    }

    gxError("CSocket:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getInputLen(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getInputLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getInputLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:getInputLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getInputLen'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getPacketHandler(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getPacketHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::ISocketPacketHandler* ret = cobj->getPacketHandler();
        object_to_luaval<GXMISC::ISocketPacketHandler>(tolua_S, "ISocketPacketHandler",(GXMISC::ISocketPacketHandler*)ret);
        return 1;
    }

    gxError("CSocket:getPacketHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getPacketHandler'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_close(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_close'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->close();
        return 0;
    }

    gxError("CSocket:close has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_close'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_setLinger(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_setLinger'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocket:setLinger");
        if(!ok)
            return 0;
        bool ret = cobj->setLinger(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:setLinger has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_setLinger'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_isNonBlocking(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_isNonBlocking'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNonBlocking();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:isNonBlocking has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_isNonBlocking'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getThreadID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getThreadID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getThreadID();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CSocket:getThreadID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getThreadID'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_create(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_create'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->create();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:create has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_create'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_setPacketHandler(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_setPacketHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::ISocketPacketHandler* arg0;

        ok &= luaval_to_object<GXMISC::ISocketPacketHandler>(tolua_S, 2, "ISocketPacketHandler", &arg0, "CSocket:setPacketHandler");
        if(!ok)
            return 0;
        cobj->setPacketHandler(arg0);
        return 0;
    }

    gxError("CSocket:setPacketHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_setPacketHandler'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_setReceiveBufferSize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_setReceiveBufferSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocket:setReceiveBufferSize");
        if(!ok)
            return 0;
        bool ret = cobj->setReceiveBufferSize(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:setReceiveBufferSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_setReceiveBufferSize'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_setReuseAddr(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_setReuseAddr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->setReuseAddr();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CSocket:setReuseAddr");
        if(!ok)
            return 0;
        bool ret = cobj->setReuseAddr(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:setReuseAddr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_setReuseAddr'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_write(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_write'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocket:write"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocket:write");
        if(!ok)
            return 0;
        int ret = cobj->write(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:write has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_write'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_setUniqueIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_setUniqueIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSocket:setUniqueIndex");
        if(!ok)
            return 0;
        cobj->setUniqueIndex(arg0);
        return 0;
    }

    gxError("CSocket:setUniqueIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_setUniqueIndex'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_isReuseAddr(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_isReuseAddr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isReuseAddr();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:isReuseAddr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_isReuseAddr'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_toString(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const char* ret = cobj->toString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }

    gxError("CSocket:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_toString'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_onRead(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_onRead'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onRead();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:onRead has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_onRead'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getSendBufferSize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getSendBufferSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getSendBufferSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:getSendBufferSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getSendBufferSize'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_isSockError(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_isSockError'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isSockError();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:isSockError has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_isSockError'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getOutputLen(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getOutputLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getOutputLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:getOutputLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getOutputLen'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getPort(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:getPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getPort'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getLinger(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getLinger'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getLinger();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:getLinger has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getLinger'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_available(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_available'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->available();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:available has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_available'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_isNeedWrite(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_isNeedWrite'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNeedWrite();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:isNeedWrite has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_isNeedWrite'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_read(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_read'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocket:read"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocket:read");
        if(!ok)
            return 0;
        int ret = cobj->read(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:read has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_read'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_isValid(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_isValid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isValid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:isValid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_isValid'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_setSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_setSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocket:setSocket");
        if(!ok)
            return 0;
        cobj->setSocket(arg0);
        return 0;
    }

    gxError("CSocket:setSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_setSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_setActive(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_setActive'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CSocket:setActive");
        if(!ok)
            return 0;
        cobj->setActive(arg0);
        return 0;
    }

    gxError("CSocket:setActive has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_setActive'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getSockError(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getSockError'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getSockError();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:getSockError has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getSockError'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_setSendBufferSize(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_setSendBufferSize'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocket:setSendBufferSize");
        if(!ok)
            return 0;
        bool ret = cobj->setSendBufferSize(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:setSendBufferSize has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_setSendBufferSize'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_needDel(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_needDel'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->needDel();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:needDel has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_needDel'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_onWrite(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_onWrite'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onWrite();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:onWrite has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_onWrite'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getRemotePort(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getRemotePort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getRemotePort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:getRemotePort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getRemotePort'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getWaitCloseSecs(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getWaitCloseSecs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getWaitCloseSecs();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocket:getWaitCloseSecs has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getWaitCloseSecs'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getInputStream(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getInputStream'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CSocketInputStream* ret = cobj->getInputStream();
        object_to_luaval<GXMISC::CSocketInputStream>(tolua_S, "CSocketInputStream",(GXMISC::CSocketInputStream*)ret);
        return 1;
    }

    gxError("CSocket:getInputStream has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getInputStream'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_reset(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }

    gxError("CSocket:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_reset'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_setNonBlocking(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_setNonBlocking'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->setNonBlocking();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CSocket:setNonBlocking");
        if(!ok)
            return 0;
        bool ret = cobj->setNonBlocking(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:setNonBlocking has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_setNonBlocking'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_getSocketEventLoop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_getSocketEventLoop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CSocketEventLoop* ret = cobj->getSocketEventLoop();
        object_to_luaval<GXMISC::CSocketEventLoop>(tolua_S, "CSocketEventLoop",(GXMISC::CSocketEventLoop*)ret);
        return 1;
    }

    gxError("CSocket:getSocketEventLoop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_getSocketEventLoop'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_isActive(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_isActive'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isActive();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:isActive has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_isActive'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_canUnpacket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_canUnpacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canUnpacket();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:canUnpacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_canUnpacket'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_unpacket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocket*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocket_unpacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        GXMISC::CNetSocketLoopTask* arg0;
        char* arg1;
        int arg2;
        char* arg3;
        int arg4;

        ok &= luaval_to_object<GXMISC::CNetSocketLoopTask>(tolua_S, 2, "CNetSocketLoopTask", &arg0, "CSocket:unpacket");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CSocket:unpacket"); arg1 = (char*)arg1_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CSocket:unpacket");

        CScriptString arg3_tmp; ok &= luaval_to_script_string(tolua_S, 5, &arg3_tmp, "CSocket:unpacket"); arg3 = (char*)arg3_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CSocket:unpacket");
        if(!ok)
            return 0;
        bool ret = cobj->unpacket(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocket:unpacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocket_unpacket'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocket_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocket* cobj = nullptr;
    bool ok  = true;
   
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocket:CSocket"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocket:CSocket");

            if (!ok) { break; }
            cobj = new GXMISC::CSocket(arg0, arg1);
            tolua_pushusertype(tolua_S,(void*)cobj,"CSocket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocket:CSocket"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocket:CSocket");

            if (!ok) { break; }
            GXMISC::CSocketEventLoop* arg2;
            ok &= luaval_to_object<GXMISC::CSocketEventLoop>(tolua_S, 4, "CSocketEventLoop", &arg2, "CSocket:CSocket");

            if (!ok) { break; }
            cobj = new GXMISC::CSocket(arg0, arg1, arg2);
            tolua_pushusertype(tolua_S,(void*)cobj,"CSocket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocket:CSocket"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocket:CSocket");

            if (!ok) { break; }
            GXMISC::CSocketEventLoop* arg2;
            ok &= luaval_to_object<GXMISC::CSocketEventLoop>(tolua_S, 4, "CSocketEventLoop", &arg2, "CSocket:CSocket");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CSocket:CSocket");

            if (!ok) { break; }
            cobj = new GXMISC::CSocket(arg0, arg1, arg2, arg3);
            tolua_pushusertype(tolua_S,(void*)cobj,"CSocket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocket:CSocket"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocket:CSocket");

            if (!ok) { break; }
            GXMISC::CSocketEventLoop* arg2;
            ok &= luaval_to_object<GXMISC::CSocketEventLoop>(tolua_S, 4, "CSocketEventLoop", &arg2, "CSocket:CSocket");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CSocket:CSocket");

            if (!ok) { break; }
            int arg4;
            ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CSocket:CSocket");

            if (!ok) { break; }
            cobj = new GXMISC::CSocket(arg0, arg1, arg2, arg3, arg4);
            tolua_pushusertype(tolua_S,(void*)cobj,"CSocket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 6) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocket:CSocket"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocket:CSocket");

            if (!ok) { break; }
            GXMISC::CSocketEventLoop* arg2;
            ok &= luaval_to_object<GXMISC::CSocketEventLoop>(tolua_S, 4, "CSocketEventLoop", &arg2, "CSocket:CSocket");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CSocket:CSocket");

            if (!ok) { break; }
            int arg4;
            ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CSocket:CSocket");

            if (!ok) { break; }
            int arg5;
            ok &= luaval_to_sint32(tolua_S, 7,(sint32*)&arg5, "CSocket:CSocket");

            if (!ok) { break; }
            cobj = new GXMISC::CSocket(arg0, arg1, arg2, arg3, arg4, arg5);
            tolua_pushusertype(tolua_S,(void*)cobj,"CSocket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 7) {
            const char* arg0;
            CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocket:CSocket"); arg0 = (char*)arg0_tmp.buffer;

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocket:CSocket");

            if (!ok) { break; }
            GXMISC::CSocketEventLoop* arg2;
            ok &= luaval_to_object<GXMISC::CSocketEventLoop>(tolua_S, 4, "CSocketEventLoop", &arg2, "CSocket:CSocket");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CSocket:CSocket");

            if (!ok) { break; }
            int arg4;
            ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CSocket:CSocket");

            if (!ok) { break; }
            int arg5;
            ok &= luaval_to_sint32(tolua_S, 7,(sint32*)&arg5, "CSocket:CSocket");

            if (!ok) { break; }
            int arg6;
            ok &= luaval_to_sint32(tolua_S, 8,(sint32*)&arg6, "CSocket:CSocket");

            if (!ok) { break; }
            cobj = new GXMISC::CSocket(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            tolua_pushusertype(tolua_S,(void*)cobj,"CSocket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj = new GXMISC::CSocket();
            tolua_pushusertype(tolua_S,(void*)cobj,"CSocket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            GXMISC::CSocketEventLoop* arg0;
            ok &= luaval_to_object<GXMISC::CSocketEventLoop>(tolua_S, 2, "CSocketEventLoop", &arg0, "CSocket:CSocket");

            if (!ok) { break; }
            cobj = new GXMISC::CSocket(arg0);
            tolua_pushusertype(tolua_S,(void*)cobj,"CSocket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            GXMISC::CSocketEventLoop* arg0;
            ok &= luaval_to_object<GXMISC::CSocketEventLoop>(tolua_S, 2, "CSocketEventLoop", &arg0, "CSocket:CSocket");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocket:CSocket");

            if (!ok) { break; }
            cobj = new GXMISC::CSocket(arg0, arg1);
            tolua_pushusertype(tolua_S,(void*)cobj,"CSocket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            GXMISC::CSocketEventLoop* arg0;
            ok &= luaval_to_object<GXMISC::CSocketEventLoop>(tolua_S, 2, "CSocketEventLoop", &arg0, "CSocket:CSocket");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocket:CSocket");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CSocket:CSocket");

            if (!ok) { break; }
            cobj = new GXMISC::CSocket(arg0, arg1, arg2);
            tolua_pushusertype(tolua_S,(void*)cobj,"CSocket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            GXMISC::CSocketEventLoop* arg0;
            ok &= luaval_to_object<GXMISC::CSocketEventLoop>(tolua_S, 2, "CSocketEventLoop", &arg0, "CSocket:CSocket");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocket:CSocket");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CSocket:CSocket");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CSocket:CSocket");

            if (!ok) { break; }
            cobj = new GXMISC::CSocket(arg0, arg1, arg2, arg3);
            tolua_pushusertype(tolua_S,(void*)cobj,"CSocket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            GXMISC::CSocketEventLoop* arg0;
            ok &= luaval_to_object<GXMISC::CSocketEventLoop>(tolua_S, 2, "CSocketEventLoop", &arg0, "CSocket:CSocket");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocket:CSocket");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CSocket:CSocket");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CSocket:CSocket");

            if (!ok) { break; }
            int arg4;
            ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CSocket:CSocket");

            if (!ok) { break; }
            cobj = new GXMISC::CSocket(arg0, arg1, arg2, arg3, arg4);
            tolua_pushusertype(tolua_S,(void*)cobj,"CSocket");
            tolua_register_gc(tolua_S,lua_gettop(tolua_S));
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CSocket:CSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CSocket_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSocket)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSocket",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSocket* self = (GXMISC::CSocket*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSocket(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSocket");
    tolua_cclass(tolua_S,"CSocket","CSocket","",lua_corelib_CSocket_finalize);

    tolua_beginmodule(tolua_S,"CSocket");
        tolua_function(tolua_S,"new",lua_corelib_CSocket_constructor);
        tolua_function(tolua_S,"setWaitCloseSecs",lua_corelib_CSocket_setWaitCloseSecs);
        tolua_function(tolua_S,"getSocket",lua_corelib_CSocket_getSocket);
        tolua_function(tolua_S,"setSocketEventLoop",lua_corelib_CSocket_setSocketEventLoop);
        tolua_function(tolua_S,"getOutputStream",lua_corelib_CSocket_getOutputStream);
        tolua_function(tolua_S,"getUniqueIndex",lua_corelib_CSocket_getUniqueIndex);
        tolua_function(tolua_S,"getReceiveBufferSize",lua_corelib_CSocket_getReceiveBufferSize);
        tolua_function(tolua_S,"getUnpacketNum",lua_corelib_CSocket_getUnpacketNum);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CSocket_cleanUp);
        tolua_function(tolua_S,"getInputLen",lua_corelib_CSocket_getInputLen);
        tolua_function(tolua_S,"getPacketHandler",lua_corelib_CSocket_getPacketHandler);
        tolua_function(tolua_S,"close",lua_corelib_CSocket_close);
        tolua_function(tolua_S,"setLinger",lua_corelib_CSocket_setLinger);
        tolua_function(tolua_S,"isNonBlocking",lua_corelib_CSocket_isNonBlocking);
        tolua_function(tolua_S,"getThreadID",lua_corelib_CSocket_getThreadID);
        tolua_function(tolua_S,"create",lua_corelib_CSocket_create);
        tolua_function(tolua_S,"setPacketHandler",lua_corelib_CSocket_setPacketHandler);
        tolua_function(tolua_S,"setReceiveBufferSize",lua_corelib_CSocket_setReceiveBufferSize);
        tolua_function(tolua_S,"setReuseAddr",lua_corelib_CSocket_setReuseAddr);
        tolua_function(tolua_S,"write",lua_corelib_CSocket_write);
        tolua_function(tolua_S,"setUniqueIndex",lua_corelib_CSocket_setUniqueIndex);
        tolua_function(tolua_S,"isReuseAddr",lua_corelib_CSocket_isReuseAddr);
        tolua_function(tolua_S,"toString",lua_corelib_CSocket_toString);
        tolua_function(tolua_S,"onRead",lua_corelib_CSocket_onRead);
        tolua_function(tolua_S,"getSendBufferSize",lua_corelib_CSocket_getSendBufferSize);
        tolua_function(tolua_S,"isSockError",lua_corelib_CSocket_isSockError);
        tolua_function(tolua_S,"getOutputLen",lua_corelib_CSocket_getOutputLen);
        tolua_function(tolua_S,"getPort",lua_corelib_CSocket_getPort);
        tolua_function(tolua_S,"getLinger",lua_corelib_CSocket_getLinger);
        tolua_function(tolua_S,"available",lua_corelib_CSocket_available);
        tolua_function(tolua_S,"isNeedWrite",lua_corelib_CSocket_isNeedWrite);
        tolua_function(tolua_S,"read",lua_corelib_CSocket_read);
        tolua_function(tolua_S,"isValid",lua_corelib_CSocket_isValid);
        tolua_function(tolua_S,"setSocket",lua_corelib_CSocket_setSocket);
        tolua_function(tolua_S,"setActive",lua_corelib_CSocket_setActive);
        tolua_function(tolua_S,"getSockError",lua_corelib_CSocket_getSockError);
        tolua_function(tolua_S,"setSendBufferSize",lua_corelib_CSocket_setSendBufferSize);
        tolua_function(tolua_S,"needDel",lua_corelib_CSocket_needDel);
        tolua_function(tolua_S,"onWrite",lua_corelib_CSocket_onWrite);
        tolua_function(tolua_S,"getRemotePort",lua_corelib_CSocket_getRemotePort);
        tolua_function(tolua_S,"getWaitCloseSecs",lua_corelib_CSocket_getWaitCloseSecs);
        tolua_function(tolua_S,"getInputStream",lua_corelib_CSocket_getInputStream);
        tolua_function(tolua_S,"reset",lua_corelib_CSocket_reset);
        tolua_function(tolua_S,"setNonBlocking",lua_corelib_CSocket_setNonBlocking);
        tolua_function(tolua_S,"getSocketEventLoop",lua_corelib_CSocket_getSocketEventLoop);
        tolua_function(tolua_S,"isActive",lua_corelib_CSocket_isActive);
        tolua_function(tolua_S,"canUnpacket",lua_corelib_CSocket_canUnpacket);
        tolua_function(tolua_S,"unpacket",lua_corelib_CSocket_unpacket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSocket).name();
    g_luaType[typeName] = "CSocket";
    g_typeCast["CSocket"] = "CSocket";
    return 1;
}

int lua_corelib_CNetSocketLoopTask_getNetLoopWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSocketLoopTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetSocketLoopTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetSocketLoopTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetSocketLoopTask_getNetLoopWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CNetLoopWrap* ret = cobj->getNetLoopWrap();
        object_to_luaval<GXMISC::CNetLoopWrap>(tolua_S, "CNetLoopWrap",(GXMISC::CNetLoopWrap*)ret);
        return 1;
    }

    gxError("CNetSocketLoopTask:getNetLoopWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetSocketLoopTask_getNetLoopWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetSocketLoopTask_setSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSocketLoopTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetSocketLoopTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetSocketLoopTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetSocketLoopTask_setSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CNetSocketLoopTask:setSocketIndex");
        if(!ok)
            return 0;
        cobj->setSocketIndex(arg0);
        return 0;
    }

    gxError("CNetSocketLoopTask:setSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetSocketLoopTask_setSocketIndex'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetSocketLoopTask_getSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSocketLoopTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetSocketLoopTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetSocketLoopTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetSocketLoopTask_getSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getSocketIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CNetSocketLoopTask:getSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetSocketLoopTask_getSocketIndex'.",&tolua_err);
	return 0;
}
static int lua_corelib_CNetSocketLoopTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNetSocketLoopTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNetSocketLoopTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CNetSocketLoopTask* self = (GXMISC::CNetSocketLoopTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CNetSocketLoopTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNetSocketLoopTask");
    tolua_cclass(tolua_S,"CNetSocketLoopTask","CNetSocketLoopTask","CThreadToLoopTask",nullptr);

    tolua_beginmodule(tolua_S,"CNetSocketLoopTask");
        tolua_function(tolua_S,"getNetLoopWrap",lua_corelib_CNetSocketLoopTask_getNetLoopWrap);
        tolua_function(tolua_S,"setSocketIndex",lua_corelib_CNetSocketLoopTask_setSocketIndex);
        tolua_function(tolua_S,"getSocketIndex",lua_corelib_CNetSocketLoopTask_getSocketIndex);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CNetSocketLoopTask).name();
    g_luaType[typeName] = "CNetSocketLoopTask";
    g_typeCast["CNetSocketLoopTask"] = "CNetSocketLoopTask";
    return 1;
}

int lua_corelib_CNetSocketLoopWrapTask_setSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSocketLoopWrapTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetSocketLoopWrapTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetSocketLoopWrapTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetSocketLoopWrapTask_setSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CNetSocketLoopWrapTask:setSocketIndex");
        if(!ok)
            return 0;
        cobj->setSocketIndex(arg0);
        return 0;
    }

    gxError("CNetSocketLoopWrapTask:setSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetSocketLoopWrapTask_setSocketIndex'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetSocketLoopWrapTask_getSocketLoop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSocketLoopWrapTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetSocketLoopWrapTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetSocketLoopWrapTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetSocketLoopWrapTask_getSocketLoop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CSocketEventLoop* ret = cobj->getSocketLoop();
        object_to_luaval<GXMISC::CSocketEventLoop>(tolua_S, "CSocketEventLoop",(GXMISC::CSocketEventLoop*)ret);
        return 1;
    }

    gxError("CNetSocketLoopWrapTask:getSocketLoop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetSocketLoopWrapTask_getSocketLoop'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetSocketLoopWrapTask_getSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSocketLoopWrapTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetSocketLoopWrapTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetSocketLoopWrapTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetSocketLoopWrapTask_getSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getSocketIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CNetSocketLoopWrapTask:getSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetSocketLoopWrapTask_getSocketIndex'.",&tolua_err);
	return 0;
}
static int lua_corelib_CNetSocketLoopWrapTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNetSocketLoopWrapTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNetSocketLoopWrapTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CNetSocketLoopWrapTask* self = (GXMISC::CNetSocketLoopWrapTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CNetSocketLoopWrapTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNetSocketLoopWrapTask");
    tolua_cclass(tolua_S,"CNetSocketLoopWrapTask","CNetSocketLoopWrapTask","CLoopToThreadTask",nullptr);

    tolua_beginmodule(tolua_S,"CNetSocketLoopWrapTask");
        tolua_function(tolua_S,"setSocketIndex",lua_corelib_CNetSocketLoopWrapTask_setSocketIndex);
        tolua_function(tolua_S,"getSocketLoop",lua_corelib_CNetSocketLoopWrapTask_getSocketLoop);
        tolua_function(tolua_S,"getSocketIndex",lua_corelib_CNetSocketLoopWrapTask_getSocketIndex);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CNetSocketLoopWrapTask).name();
    g_luaType[typeName] = "CNetSocketLoopWrapTask";
    g_typeCast["CNetSocketLoopWrapTask"] = "CNetSocketLoopWrapTask";
    return 1;
}

int lua_corelib_CNetSendPacketTask_getName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSendPacketTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetSendPacketTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetSendPacketTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetSendPacketTask_getName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CNetSendPacketTask:getName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetSendPacketTask_getName'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetSendPacketTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSendPacketTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetSendPacketTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetSendPacketTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetSendPacketTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CNetSendPacketTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetSendPacketTask_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetSendPacketTask_type(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSendPacketTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetSendPacketTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetSendPacketTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetSendPacketTask_type'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->type();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CNetSendPacketTask:type has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetSendPacketTask_type'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetSendPacketTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSendPacketTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CNetSendPacketTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CNetSendPacketTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CNetSendPacketTask:CNetSendPacketTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CNetSendPacketTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNetSendPacketTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNetSendPacketTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CNetSendPacketTask* self = (GXMISC::CNetSendPacketTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CNetSendPacketTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNetSendPacketTask");
    tolua_cclass(tolua_S,"CNetSendPacketTask","CNetSendPacketTask","CNetSocketLoopWrapTask",lua_corelib_CNetSendPacketTask_finalize);

    tolua_beginmodule(tolua_S,"CNetSendPacketTask");
        tolua_function(tolua_S,"new",lua_corelib_CNetSendPacketTask_constructor);
        tolua_function(tolua_S,"getName",lua_corelib_CNetSendPacketTask_getName);
        tolua_function(tolua_S,"doRun",lua_corelib_CNetSendPacketTask_doRun);
        tolua_function(tolua_S,"type",lua_corelib_CNetSendPacketTask_type);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CNetSendPacketTask).name();
    g_luaType[typeName] = "CNetSendPacketTask";
    g_typeCast["CNetSendPacketTask"] = "CNetSendPacketTask";
    return 1;
}

int lua_corelib_CNetRecvPacketTask_getName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetRecvPacketTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetRecvPacketTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetRecvPacketTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetRecvPacketTask_getName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CNetRecvPacketTask:getName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetRecvPacketTask_getName'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetRecvPacketTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetRecvPacketTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetRecvPacketTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetRecvPacketTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetRecvPacketTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CNetRecvPacketTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetRecvPacketTask_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetRecvPacketTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetRecvPacketTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CNetRecvPacketTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CNetRecvPacketTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CNetRecvPacketTask:CNetRecvPacketTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CNetRecvPacketTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNetRecvPacketTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNetRecvPacketTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CNetRecvPacketTask* self = (GXMISC::CNetRecvPacketTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CNetRecvPacketTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNetRecvPacketTask");
    tolua_cclass(tolua_S,"CNetRecvPacketTask","CNetRecvPacketTask","CNetSocketLoopTask",lua_corelib_CNetRecvPacketTask_finalize);

    tolua_beginmodule(tolua_S,"CNetRecvPacketTask");
        tolua_function(tolua_S,"new",lua_corelib_CNetRecvPacketTask_constructor);
        tolua_function(tolua_S,"getName",lua_corelib_CNetRecvPacketTask_getName);
        tolua_function(tolua_S,"doRun",lua_corelib_CNetRecvPacketTask_doRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CNetRecvPacketTask).name();
    g_luaType[typeName] = "CNetRecvPacketTask";
    g_typeCast["CNetRecvPacketTask"] = "CNetRecvPacketTask";
    return 1;
}

int lua_corelib_CNetWrapBroadCastTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetWrapBroadCastTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetWrapBroadCastTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetWrapBroadCastTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetWrapBroadCastTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CNetWrapBroadCastTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetWrapBroadCastTask_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetWrapBroadCastTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetWrapBroadCastTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CNetWrapBroadCastTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CNetWrapBroadCastTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CNetWrapBroadCastTask:CNetWrapBroadCastTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CNetWrapBroadCastTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNetWrapBroadCastTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNetWrapBroadCastTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CNetWrapBroadCastTask* self = (GXMISC::CNetWrapBroadCastTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CNetWrapBroadCastTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNetWrapBroadCastTask");
    tolua_cclass(tolua_S,"CNetWrapBroadCastTask","CNetWrapBroadCastTask","CNetSocketLoopWrapTask",lua_corelib_CNetWrapBroadCastTask_finalize);

    tolua_beginmodule(tolua_S,"CNetWrapBroadCastTask");
        tolua_function(tolua_S,"new",lua_corelib_CNetWrapBroadCastTask_constructor);
        tolua_function(tolua_S,"doRun",lua_corelib_CNetWrapBroadCastTask_doRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CNetWrapBroadCastTask).name();
    g_luaType[typeName] = "CNetWrapBroadCastTask";
    g_typeCast["CNetWrapBroadCastTask"] = "CNetWrapBroadCastTask";
    return 1;
}

int lua_corelib_CBroadcastPacketTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CBroadcastPacketTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CBroadcastPacketTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CBroadcastPacketTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CBroadcastPacketTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CBroadcastPacketTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CBroadcastPacketTask_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CBroadcastPacketTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CBroadcastPacketTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CBroadcastPacketTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CBroadcastPacketTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CBroadcastPacketTask:CBroadcastPacketTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CBroadcastPacketTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CBroadcastPacketTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CBroadcastPacketTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CBroadcastPacketTask* self = (GXMISC::CBroadcastPacketTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CBroadcastPacketTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CBroadcastPacketTask");
    tolua_cclass(tolua_S,"CBroadcastPacketTask","CBroadcastPacketTask","CNetSocketLoopWrapTask",lua_corelib_CBroadcastPacketTask_finalize);

    tolua_beginmodule(tolua_S,"CBroadcastPacketTask");
        tolua_function(tolua_S,"new",lua_corelib_CBroadcastPacketTask_constructor);
        tolua_function(tolua_S,"doRun",lua_corelib_CBroadcastPacketTask_doRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CBroadcastPacketTask).name();
    g_luaType[typeName] = "CBroadcastPacketTask";
    g_typeCast["CBroadcastPacketTask"] = "CBroadcastPacketTask";
    return 1;
}

int lua_corelib_CNetSocketClose_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSocketClose* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetSocketClose",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetSocketClose*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetSocketClose_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CNetSocketClose:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetSocketClose_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetSocketClose_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSocketClose* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CNetSocketClose();
        tolua_pushusertype(tolua_S,(void*)cobj,"CNetSocketClose");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CNetSocketClose:CNetSocketClose has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CNetSocketClose_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNetSocketClose)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNetSocketClose",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CNetSocketClose* self = (GXMISC::CNetSocketClose*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CNetSocketClose(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNetSocketClose");
    tolua_cclass(tolua_S,"CNetSocketClose","CNetSocketClose","CNetSocketLoopTask",lua_corelib_CNetSocketClose_finalize);

    tolua_beginmodule(tolua_S,"CNetSocketClose");
        tolua_function(tolua_S,"new",lua_corelib_CNetSocketClose_constructor);
        tolua_function(tolua_S,"doRun",lua_corelib_CNetSocketClose_doRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CNetSocketClose).name();
    g_luaType[typeName] = "CNetSocketClose";
    g_typeCast["CNetSocketClose"] = "CNetSocketClose";
    return 1;
}

int lua_corelib_CNetSocketDelTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSocketDelTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetSocketDelTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetSocketDelTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetSocketDelTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CNetSocketDelTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetSocketDelTask_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetSocketDelTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSocketDelTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CNetSocketDelTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CNetSocketDelTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CNetSocketDelTask:CNetSocketDelTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CNetSocketDelTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNetSocketDelTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNetSocketDelTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CNetSocketDelTask* self = (GXMISC::CNetSocketDelTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CNetSocketDelTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNetSocketDelTask");
    tolua_cclass(tolua_S,"CNetSocketDelTask","CNetSocketDelTask","CNetSocketLoopWrapTask",lua_corelib_CNetSocketDelTask_finalize);

    tolua_beginmodule(tolua_S,"CNetSocketDelTask");
        tolua_function(tolua_S,"new",lua_corelib_CNetSocketDelTask_constructor);
        tolua_function(tolua_S,"doRun",lua_corelib_CNetSocketDelTask_doRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CNetSocketDelTask).name();
    g_luaType[typeName] = "CNetSocketDelTask";
    g_typeCast["CNetSocketDelTask"] = "CNetSocketDelTask";
    return 1;
}

int lua_corelib_CNetSocketAddRet_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSocketAddRet* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetSocketAddRet",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetSocketAddRet*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetSocketAddRet_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CNetSocketAddRet:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetSocketAddRet_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetSocketAddRet_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetSocketAddRet* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CNetSocketAddRet();
        tolua_pushusertype(tolua_S,(void*)cobj,"CNetSocketAddRet");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CNetSocketAddRet:CNetSocketAddRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CNetSocketAddRet_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNetSocketAddRet)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNetSocketAddRet",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CNetSocketAddRet* self = (GXMISC::CNetSocketAddRet*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CNetSocketAddRet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNetSocketAddRet");
    tolua_cclass(tolua_S,"CNetSocketAddRet","CNetSocketAddRet","CNetSocketLoopTask",lua_corelib_CNetSocketAddRet_finalize);

    tolua_beginmodule(tolua_S,"CNetSocketAddRet");
        tolua_function(tolua_S,"new",lua_corelib_CNetSocketAddRet_constructor);
        tolua_function(tolua_S,"doRun",lua_corelib_CNetSocketAddRet_doRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CNetSocketAddRet).name();
    g_luaType[typeName] = "CNetSocketAddRet";
    g_typeCast["CNetSocketAddRet"] = "CNetSocketAddRet";
    return 1;
}

int lua_corelib_CSocketEventLoop_stopMsgHandle(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketEventLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketEventLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketEventLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketEventLoop_stopMsgHandle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->stopMsgHandle();
        return 0;
    }

    gxError("CSocketEventLoop:stopMsgHandle has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketEventLoop_stopMsgHandle'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketEventLoop_setMsgPerFrame(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketEventLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketEventLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketEventLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketEventLoop_setMsgPerFrame'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CSocketEventLoop:setMsgPerFrame");
        if(!ok)
            return 0;
        cobj->setMsgPerFrame(arg0);
        return 0;
    }

    gxError("CSocketEventLoop:setMsgPerFrame has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketEventLoop_setMsgPerFrame'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketEventLoop_pushTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketEventLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketEventLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketEventLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketEventLoop_pushTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::CNetSocketLoopTask* arg0;
        unsigned long long arg1;

        ok &= luaval_to_object<GXMISC::CNetSocketLoopTask>(tolua_S, 2, "CNetSocketLoopTask", &arg0, "CSocketEventLoop:pushTask");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CSocketEventLoop:pushTask");
        if(!ok)
            return 0;
        cobj->pushTask(arg0, arg1);
        return 0;
    }

    gxError("CSocketEventLoop:pushTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketEventLoop_pushTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketEventLoop_setBroadCastQ(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketEventLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketEventLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketEventLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketEventLoop_setBroadCastQ'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::CSyncActiveQueue* arg0;
        GXMISC::CSyncActiveQueue* arg1;

        ok &= luaval_to_object<GXMISC::CSyncActiveQueue>(tolua_S, 2, "CSyncActiveQueue", &arg0, "CSocketEventLoop:setBroadCastQ");

        ok &= luaval_to_object<GXMISC::CSyncActiveQueue>(tolua_S, 3, "CSyncActiveQueue", &arg1, "CSocketEventLoop:setBroadCastQ");
        if(!ok)
            return 0;
        cobj->setBroadCastQ(arg0, arg1);
        return 0;
    }

    gxError("CSocketEventLoop:setBroadCastQ has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketEventLoop_setBroadCastQ'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketEventLoop_handleDelSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketEventLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketEventLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketEventLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketEventLoop_handleDelSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned long long arg0;
        int arg1;
        int arg2;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSocketEventLoop:handleDelSocket");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketEventLoop:handleDelSocket");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CSocketEventLoop:handleDelSocket");
        if(!ok)
            return 0;
        cobj->handleDelSocket(arg0, arg1, arg2);
        return 0;
    }

    gxError("CSocketEventLoop:handleDelSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketEventLoop_handleDelSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketEventLoop_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketEventLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketEventLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketEventLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketEventLoop_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketEventLoop:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketEventLoop_init'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketEventLoop_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketEventLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketEventLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketEventLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketEventLoop_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CSocketEventLoop:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketEventLoop_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketEventLoop_isStopMsgHandle(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketEventLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketEventLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketEventLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketEventLoop_isStopMsgHandle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isStopMsgHandle();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketEventLoop:isStopMsgHandle has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketEventLoop_isStopMsgHandle'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketEventLoop_handleWriteMsg(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketEventLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketEventLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketEventLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketEventLoop_handleWriteMsg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned long long arg0;
        char* arg1;
        unsigned int arg2;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSocketEventLoop:handleWriteMsg");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CSocketEventLoop:handleWriteMsg"); arg1 = (char*)arg1_tmp.buffer;

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CSocketEventLoop:handleWriteMsg");
        if(!ok)
            return 0;
        cobj->handleWriteMsg(arg0, arg1, arg2);
        return 0;
    }

    gxError("CSocketEventLoop:handleWriteMsg has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketEventLoop_handleWriteMsg'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketEventLoop_getBroadcastQWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketEventLoop* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketEventLoop",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketEventLoop*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketEventLoop_getBroadcastQWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CSyncActiveQueueWrap* ret = cobj->getBroadcastQWrap();
        object_to_luaval<GXMISC::CSyncActiveQueueWrap>(tolua_S, "CSyncActiveQueueWrap",(GXMISC::CSyncActiveQueueWrap*)ret);
        return 1;
    }

    gxError("CSocketEventLoop:getBroadcastQWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketEventLoop_getBroadcastQWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketEventLoop_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketEventLoop* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CSocketEventLoop();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSocketEventLoop");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSocketEventLoop:CSocketEventLoop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CSocketEventLoop_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSocketEventLoop)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSocketEventLoop",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSocketEventLoop* self = (GXMISC::CSocketEventLoop*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSocketEventLoop(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSocketEventLoop");
    tolua_cclass(tolua_S,"CSocketEventLoop","CSocketEventLoop","CModuleThreadLoop",lua_corelib_CSocketEventLoop_finalize);

    tolua_beginmodule(tolua_S,"CSocketEventLoop");
        tolua_function(tolua_S,"new",lua_corelib_CSocketEventLoop_constructor);
        tolua_function(tolua_S,"stopMsgHandle",lua_corelib_CSocketEventLoop_stopMsgHandle);
        tolua_function(tolua_S,"setMsgPerFrame",lua_corelib_CSocketEventLoop_setMsgPerFrame);
        tolua_function(tolua_S,"pushTask",lua_corelib_CSocketEventLoop_pushTask);
        tolua_function(tolua_S,"setBroadCastQ",lua_corelib_CSocketEventLoop_setBroadCastQ);
        tolua_function(tolua_S,"handleDelSocket",lua_corelib_CSocketEventLoop_handleDelSocket);
        tolua_function(tolua_S,"init",lua_corelib_CSocketEventLoop_init);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CSocketEventLoop_cleanUp);
        tolua_function(tolua_S,"isStopMsgHandle",lua_corelib_CSocketEventLoop_isStopMsgHandle);
        tolua_function(tolua_S,"handleWriteMsg",lua_corelib_CSocketEventLoop_handleWriteMsg);
        tolua_function(tolua_S,"getBroadcastQWrap",lua_corelib_CSocketEventLoop_getBroadcastQWrap);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSocketEventLoop).name();
    g_luaType[typeName] = "CSocketEventLoop";
    g_typeCast["CSocketEventLoop"] = "CSocketEventLoop";
    return 1;
}

int lua_corelib_CNetLoopWrap_writeMsg(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_writeMsg'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const char* arg0;
        int arg1;
        unsigned long long arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CNetLoopWrap:writeMsg"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CNetLoopWrap:writeMsg");

        ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CNetLoopWrap:writeMsg");
        if(!ok)
            return 0;
        cobj->writeMsg(arg0, arg1, arg2);
        return 0;
    }
    if (argc == 4) 
    {
        const char* arg0;
        int arg1;
        unsigned long long arg2;
        const char* arg3;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CNetLoopWrap:writeMsg"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CNetLoopWrap:writeMsg");

        ok &= luaval_to_uint64(tolua_S, 4, (uint64*)&arg2, "CNetLoopWrap:writeMsg");

        CScriptString arg3_tmp; ok &= luaval_to_script_string(tolua_S, 5, &arg3_tmp, "CNetLoopWrap:writeMsg"); arg3 = (char*)arg3_tmp.buffer;
        if(!ok)
            return 0;
        cobj->writeMsg(arg0, arg1, arg2, arg3);
        return 0;
    }

    gxError("CNetLoopWrap:writeMsg has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_writeMsg'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_handlePacket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_handlePacket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        unsigned long long arg0;
        char* arg1;
        int arg2;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CNetLoopWrap:handlePacket");

        CScriptString arg1_tmp; ok &= luaval_to_script_string(tolua_S, 3, &arg1_tmp, "CNetLoopWrap:handlePacket"); arg1 = (char*)arg1_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CNetLoopWrap:handlePacket");
        if(!ok)
            return 0;
        cobj->handlePacket(arg0, arg1, arg2);
        return 0;
    }

    gxError("CNetLoopWrap:handlePacket has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_handlePacket'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_getNetConfig(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_getNetConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const GXMISC::CNetModuleConfig* ret = cobj->getNetConfig();
        object_to_luaval<GXMISC::CNetModuleConfig>(tolua_S, "CNetModuleConfig",(GXMISC::CNetModuleConfig*)ret);
        return 1;
    }

    gxError("CNetLoopWrap:getNetConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_getNetConfig'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_getSocketEventLoop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_getSocketEventLoop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CSocketEventLoop* ret = cobj->getSocketEventLoop();
        object_to_luaval<GXMISC::CSocketEventLoop>(tolua_S, "CSocketEventLoop",(GXMISC::CSocketEventLoop*)ret);
        return 1;
    }

    gxError("CNetLoopWrap:getSocketEventLoop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_getSocketEventLoop'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_delSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_delSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CNetLoopWrap:delSocket");
        if(!ok)
            return 0;
        cobj->delSocket(arg0);
        return 0;
    }

    gxError("CNetLoopWrap:delSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_delSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_addSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_addSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::CSocket* arg0;
        GXMISC::CSocketHandler* arg1;

        ok &= luaval_to_object<GXMISC::CSocket>(tolua_S, 2, "CSocket", &arg0, "CNetLoopWrap:addSocket");

        ok &= luaval_to_object<GXMISC::CSocketHandler>(tolua_S, 3, "CSocketHandler", &arg1, "CNetLoopWrap:addSocket");
        if(!ok)
            return 0;
        cobj->addSocket(arg0, arg1);
        return 0;
    }

    gxError("CNetLoopWrap:addSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_addSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_pushTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_pushTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::CNetSocketLoopWrapTask* arg0;
        unsigned long long arg1;

        ok &= luaval_to_object<GXMISC::CNetSocketLoopWrapTask>(tolua_S, 2, "CNetSocketLoopWrapTask", &arg0, "CNetLoopWrap:pushTask");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CNetLoopWrap:pushTask");
        if(!ok)
            return 0;
        cobj->pushTask(arg0, arg1);
        return 0;
    }

    gxError("CNetLoopWrap:pushTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_pushTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_getSocketHandlerAll(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_getSocketHandlerAll'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CNetLoopWrap:getSocketHandlerAll");
        if(!ok)
            return 0;
        GXMISC::CSocketHandler* ret = cobj->getSocketHandlerAll(arg0);
        object_to_luaval<GXMISC::CSocketHandler>(tolua_S, "CSocketHandler",(GXMISC::CSocketHandler*)ret);
        return 1;
    }

    gxError("CNetLoopWrap:getSocketHandlerAll has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_getSocketHandlerAll'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_getUserNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_getUserNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getUserNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CNetLoopWrap:getUserNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_getUserNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_getNetLoopWrapMgr(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_getNetLoopWrapMgr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CNetModule* ret = cobj->getNetLoopWrapMgr();
        object_to_luaval<GXMISC::CNetModule>(tolua_S, "CNetModule",(GXMISC::CNetModule*)ret);
        return 1;
    }

    gxError("CNetLoopWrap:getNetLoopWrapMgr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_getNetLoopWrapMgr'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_handleCloseSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_handleCloseSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CNetLoopWrap:handleCloseSocket");
        if(!ok)
            return 0;
        cobj->handleCloseSocket(arg0);
        return 0;
    }

    gxError("CNetLoopWrap:handleCloseSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_handleCloseSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_getSocketHandler(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_getSocketHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CNetLoopWrap:getSocketHandler");
        if(!ok)
            return 0;
        GXMISC::CSocketHandler* ret = cobj->getSocketHandler(arg0);
        object_to_luaval<GXMISC::CSocketHandler>(tolua_S, "CSocketHandler",(GXMISC::CSocketHandler*)ret);
        return 1;
    }

    gxError("CNetLoopWrap:getSocketHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_getSocketHandler'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_initBroadcastQ(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_initBroadcastQ'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::CSyncActiveQueue* arg0;
        GXMISC::CSyncActiveQueue* arg1;

        ok &= luaval_to_object<GXMISC::CSyncActiveQueue>(tolua_S, 2, "CSyncActiveQueue", &arg0, "CNetLoopWrap:initBroadcastQ");

        ok &= luaval_to_object<GXMISC::CSyncActiveQueue>(tolua_S, 3, "CSyncActiveQueue", &arg1, "CNetLoopWrap:initBroadcastQ");
        if(!ok)
            return 0;
        cobj->initBroadcastQ(arg0, arg1);
        return 0;
    }

    gxError("CNetLoopWrap:initBroadcastQ has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_initBroadcastQ'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_handleAddSocketRet(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_handleAddSocketRet'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CNetLoopWrap:handleAddSocketRet");
        if(!ok)
            return 0;
        cobj->handleAddSocketRet(arg0);
        return 0;
    }

    gxError("CNetLoopWrap:handleAddSocketRet has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_handleAddSocketRet'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_closeSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetLoopWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetLoopWrap_closeSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned long long arg0;
        int arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CNetLoopWrap:closeSocket");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CNetLoopWrap:closeSocket");
        if(!ok)
            return 0;
        cobj->closeSocket(arg0, arg1);
        return 0;
    }

    gxError("CNetLoopWrap:closeSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetLoopWrap_closeSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetLoopWrap_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetLoopWrap* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::CNetModule* arg0;
        int arg1;

        ok &= luaval_to_object<GXMISC::CNetModule>(tolua_S, 2, "CNetModule", &arg0, "CNetLoopWrap:CNetLoopWrap");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CNetLoopWrap:CNetLoopWrap");
        if(!ok)
            return 0;
        cobj = new GXMISC::CNetLoopWrap(arg0, arg1);
        tolua_pushusertype(tolua_S,(void*)cobj,"CNetLoopWrap");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CNetLoopWrap:CNetLoopWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

}

static int lua_corelib_CNetLoopWrap_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNetLoopWrap)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNetLoopWrap",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CNetLoopWrap* self = (GXMISC::CNetLoopWrap*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CNetLoopWrap(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNetLoopWrap");
    tolua_cclass(tolua_S,"CNetLoopWrap","CNetLoopWrap","CSimpleThreadLoopWrap",lua_corelib_CNetLoopWrap_finalize);

    tolua_beginmodule(tolua_S,"CNetLoopWrap");
        tolua_function(tolua_S,"new",lua_corelib_CNetLoopWrap_constructor);
        tolua_function(tolua_S,"writeMsg",lua_corelib_CNetLoopWrap_writeMsg);
        tolua_function(tolua_S,"handlePacket",lua_corelib_CNetLoopWrap_handlePacket);
        tolua_function(tolua_S,"getNetConfig",lua_corelib_CNetLoopWrap_getNetConfig);
        tolua_function(tolua_S,"getSocketEventLoop",lua_corelib_CNetLoopWrap_getSocketEventLoop);
        tolua_function(tolua_S,"delSocket",lua_corelib_CNetLoopWrap_delSocket);
        tolua_function(tolua_S,"addSocket",lua_corelib_CNetLoopWrap_addSocket);
        tolua_function(tolua_S,"pushTask",lua_corelib_CNetLoopWrap_pushTask);
        tolua_function(tolua_S,"getSocketHandlerAll",lua_corelib_CNetLoopWrap_getSocketHandlerAll);
        tolua_function(tolua_S,"getUserNum",lua_corelib_CNetLoopWrap_getUserNum);
        tolua_function(tolua_S,"getNetLoopWrapMgr",lua_corelib_CNetLoopWrap_getNetLoopWrapMgr);
        tolua_function(tolua_S,"handleCloseSocket",lua_corelib_CNetLoopWrap_handleCloseSocket);
        tolua_function(tolua_S,"getSocketHandler",lua_corelib_CNetLoopWrap_getSocketHandler);
        tolua_function(tolua_S,"initBroadcastQ",lua_corelib_CNetLoopWrap_initBroadcastQ);
        tolua_function(tolua_S,"handleAddSocketRet",lua_corelib_CNetLoopWrap_handleAddSocketRet);
        tolua_function(tolua_S,"closeSocket",lua_corelib_CNetLoopWrap_closeSocket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CNetLoopWrap).name();
    g_luaType[typeName] = "CNetLoopWrap";
    g_typeCast["CNetLoopWrap"] = "CNetLoopWrap";
    return 1;
}

int lua_corelib_CSocketHandler_getString(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_getString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CSocketHandler:getString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_getString'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CSocketHandler:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_flush(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_flush'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->flush();
        return 0;
    }

    gxError("CSocketHandler:flush has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_flush'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_setRemoteAddr(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_setRemoteAddr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        std::string arg0;
        int arg1;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CSocketHandler:setRemoteAddr");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketHandler:setRemoteAddr");
        if(!ok)
            return 0;
        cobj->setRemoteAddr(arg0, arg1);
        return 0;
    }

    gxError("CSocketHandler:setRemoteAddr has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_setRemoteAddr'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_getLocalPort(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_getLocalPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getLocalPort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketHandler:getLocalPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_getLocalPort'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_getNetLoopWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_getNetLoopWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CNetLoopWrap* ret = cobj->getNetLoopWrap();
        object_to_luaval<GXMISC::CNetLoopWrap>(tolua_S, "CNetLoopWrap",(GXMISC::CNetLoopWrap*)ret);
        return 1;
    }

    gxError("CSocketHandler:getNetLoopWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_getNetLoopWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_setAddr(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_setAddr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        std::string arg0;
        int arg1;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CSocketHandler:setAddr");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketHandler:setAddr");
        if(!ok)
            return 0;
        cobj->setAddr(arg0, arg1);
        return 0;
    }

    gxError("CSocketHandler:setAddr has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_setAddr'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_getBufferStream(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_getBufferStream'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CMemOutputStream* ret = cobj->getBufferStream();
        object_to_luaval<GXMISC::CMemOutputStream>(tolua_S, "CMemOutputStream",(GXMISC::CMemOutputStream*)ret);
        return 1;
    }

    gxError("CSocketHandler:getBufferStream has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_getBufferStream'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_send(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_send'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocketHandler:send"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketHandler:send");
        if(!ok)
            return 0;
        cobj->send(arg0, arg1);
        return 0;
    }
    if (argc == 3) 
    {
        const char* arg0;
        int arg1;
        const char* arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocketHandler:send"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketHandler:send");

        CScriptString arg2_tmp; ok &= luaval_to_script_string(tolua_S, 4, &arg2_tmp, "CSocketHandler:send"); arg2 = (char*)arg2_tmp.buffer;
        if(!ok)
            return 0;
        cobj->send(arg0, arg1, arg2);
        return 0;
    }

    gxError("CSocketHandler:send has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_send'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_breath(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_breath'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocketHandler:breath");
        if(!ok)
            return 0;
        cobj->breath(arg0);
        return 0;
    }

    gxError("CSocketHandler:breath has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_breath'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        GXMISC::CNetLoopWrap* arg0;
        unsigned long long arg1;

        ok &= luaval_to_object<GXMISC::CNetLoopWrap>(tolua_S, 2, "CNetLoopWrap", &arg0, "CSocketHandler:init");

        ok &= luaval_to_uint64(tolua_S, 3, (uint64*)&arg1, "CSocketHandler:init");
        if(!ok)
            return 0;
        cobj->init(arg0, arg1);
        return 0;
    }

    gxError("CSocketHandler:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_init'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_kick(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_kick'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->kick();
        return 0;
    }
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocketHandler:kick");
        if(!ok)
            return 0;
        cobj->kick(arg0);
        return 0;
    }

    gxError("CSocketHandler:kick has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_kick'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_onFlushData(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_onFlushData'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocketHandler:onFlushData"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketHandler:onFlushData");
        if(!ok)
            return 0;
        bool ret = cobj->onFlushData(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketHandler:onFlushData has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_onFlushData'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_isScriptHandler(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_isScriptHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isScriptHandler();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketHandler:isScriptHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_isScriptHandler'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_getRemoteIp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_getRemoteIp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getRemoteIp();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CSocketHandler:getRemoteIp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_getRemoteIp'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_getOtherHandler(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_getOtherHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CSocketHandler:getOtherHandler");
        if(!ok)
            return 0;
        GXMISC::CSocketHandler* ret = cobj->getOtherHandler(arg0);
        object_to_luaval<GXMISC::CSocketHandler>(tolua_S, "CSocketHandler",(GXMISC::CSocketHandler*)ret);
        return 1;
    }

    gxError("CSocketHandler:getOtherHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_getOtherHandler'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_isValid(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_isValid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isValid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketHandler:isValid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_isValid'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_getSocketIndex(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_getSocketIndex'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned long long ret = cobj->getSocketIndex();
        lua_tinker::push(tolua_S,(uint64)ret);
        return 1;
    }

    gxError("CSocketHandler:getSocketIndex has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_getSocketIndex'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_getLocalIp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_getLocalIp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getLocalIp();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CSocketHandler:getLocalIp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_getLocalIp'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_getWaitSecs(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_getWaitSecs'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getWaitSecs();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketHandler:getWaitSecs has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_getWaitSecs'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_getRemotePort(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_getRemotePort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getRemotePort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketHandler:getRemotePort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_getRemotePort'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_reset(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_reset'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->reset();
        return 0;
    }

    gxError("CSocketHandler:reset has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_reset'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketHandler_onDelete(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketHandler_onDelete'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onDelete();
        return 0;
    }

    gxError("CSocketHandler:onDelete has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketHandler_onDelete'.",&tolua_err);
	return 0;
}
static int lua_corelib_CSocketHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSocketHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSocketHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSocketHandler* self = (GXMISC::CSocketHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSocketHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSocketHandler");
    tolua_cclass(tolua_S,"CSocketHandler","CSocketHandler","IHandler",nullptr);

    tolua_beginmodule(tolua_S,"CSocketHandler");
        tolua_function(tolua_S,"getString",lua_corelib_CSocketHandler_getString);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CSocketHandler_cleanUp);
        tolua_function(tolua_S,"flush",lua_corelib_CSocketHandler_flush);
        tolua_function(tolua_S,"setRemoteAddr",lua_corelib_CSocketHandler_setRemoteAddr);
        tolua_function(tolua_S,"getLocalPort",lua_corelib_CSocketHandler_getLocalPort);
        tolua_function(tolua_S,"getNetLoopWrap",lua_corelib_CSocketHandler_getNetLoopWrap);
        tolua_function(tolua_S,"setAddr",lua_corelib_CSocketHandler_setAddr);
        tolua_function(tolua_S,"getBufferStream",lua_corelib_CSocketHandler_getBufferStream);
        tolua_function(tolua_S,"send",lua_corelib_CSocketHandler_send);
        tolua_function(tolua_S,"breath",lua_corelib_CSocketHandler_breath);
        tolua_function(tolua_S,"init",lua_corelib_CSocketHandler_init);
        tolua_function(tolua_S,"kick",lua_corelib_CSocketHandler_kick);
        tolua_function(tolua_S,"onFlushData",lua_corelib_CSocketHandler_onFlushData);
        tolua_function(tolua_S,"isScriptHandler",lua_corelib_CSocketHandler_isScriptHandler);
        tolua_function(tolua_S,"getRemoteIp",lua_corelib_CSocketHandler_getRemoteIp);
        tolua_function(tolua_S,"getOtherHandler",lua_corelib_CSocketHandler_getOtherHandler);
        tolua_function(tolua_S,"isValid",lua_corelib_CSocketHandler_isValid);
        tolua_function(tolua_S,"getSocketIndex",lua_corelib_CSocketHandler_getSocketIndex);
        tolua_function(tolua_S,"getLocalIp",lua_corelib_CSocketHandler_getLocalIp);
        tolua_function(tolua_S,"getWaitSecs",lua_corelib_CSocketHandler_getWaitSecs);
        tolua_function(tolua_S,"getRemotePort",lua_corelib_CSocketHandler_getRemotePort);
        tolua_function(tolua_S,"reset",lua_corelib_CSocketHandler_reset);
        tolua_function(tolua_S,"onDelete",lua_corelib_CSocketHandler_onDelete);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSocketHandler).name();
    g_luaType[typeName] = "CSocketHandler";
    g_typeCast["CSocketHandler"] = "CSocketHandler";
    return 1;
}

int lua_corelib_CScriptSocketHandler_isScriptHandler(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CScriptSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScriptSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CScriptSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CScriptSocketHandler_isScriptHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isScriptHandler();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CScriptSocketHandler:isScriptHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CScriptSocketHandler_isScriptHandler'.",&tolua_err);
	return 0;
}
int lua_corelib_CScriptSocketHandler_initScriptObject(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CScriptSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScriptSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CScriptSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CScriptSocketHandler_initScriptObject'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CLuaVM* arg0;

        ok &= luaval_to_object<GXMISC::CLuaVM>(tolua_S, 2, "CLuaVM", &arg0, "CScriptSocketHandler:initScriptObject");
        if(!ok)
            return 0;
        bool ret = cobj->initScriptObject(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CScriptSocketHandler:initScriptObject has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CScriptSocketHandler_initScriptObject'.",&tolua_err);
	return 0;
}
int lua_corelib_CScriptSocketHandler_handle(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CScriptSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScriptSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CScriptSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CScriptSocketHandler_handle'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        char* arg0;
        unsigned int arg1;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CScriptSocketHandler:handle"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CScriptSocketHandler:handle");
        if(!ok)
            return 0;
        int ret = (int)cobj->handle(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CScriptSocketHandler:handle has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CScriptSocketHandler_handle'.",&tolua_err);
	return 0;
}
int lua_corelib_CScriptSocketHandler_start(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CScriptSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScriptSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CScriptSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CScriptSocketHandler_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CScriptSocketHandler:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CScriptSocketHandler_start'.",&tolua_err);
	return 0;
}
int lua_corelib_CScriptSocketHandler_close(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CScriptSocketHandler* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CScriptSocketHandler",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CScriptSocketHandler*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CScriptSocketHandler_close'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->close();
        return 0;
    }

    gxError("CScriptSocketHandler:close has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CScriptSocketHandler_close'.",&tolua_err);
	return 0;
}
int lua_corelib_CScriptSocketHandler_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CScriptSocketHandler* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CScriptSocketHandler();
        tolua_pushusertype(tolua_S,(void*)cobj,"CScriptSocketHandler");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CScriptSocketHandler:CScriptSocketHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CScriptSocketHandler_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CScriptSocketHandler)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CScriptSocketHandler",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CScriptSocketHandler* self = (GXMISC::CScriptSocketHandler*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CScriptSocketHandler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CScriptSocketHandler");
    tolua_cclass(tolua_S,"CScriptSocketHandler","CScriptSocketHandler","CSocketHandler",lua_corelib_CScriptSocketHandler_finalize);

    tolua_beginmodule(tolua_S,"CScriptSocketHandler");
        tolua_function(tolua_S,"new",lua_corelib_CScriptSocketHandler_constructor);
        tolua_function(tolua_S,"isScriptHandler",lua_corelib_CScriptSocketHandler_isScriptHandler);
        tolua_function(tolua_S,"initScriptObject",lua_corelib_CScriptSocketHandler_initScriptObject);
        tolua_function(tolua_S,"handle",lua_corelib_CScriptSocketHandler_handle);
        tolua_function(tolua_S,"start",lua_corelib_CScriptSocketHandler_start);
        tolua_function(tolua_S,"close",lua_corelib_CScriptSocketHandler_close);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CScriptSocketHandler).name();
    g_luaType[typeName] = "CScriptSocketHandler";
    g_typeCast["CScriptSocketHandler"] = "CScriptSocketHandler";
    return 1;
}

int lua_corelib_CSocketConnector_reconnect(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketConnector* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketConnector*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketConnector_reconnect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const char* arg0;
        unsigned short arg1;
        unsigned int arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocketConnector:reconnect"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CSocketConnector:reconnect");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CSocketConnector:reconnect");
        if(!ok)
            return 0;
        bool ret = cobj->reconnect(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketConnector:reconnect has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketConnector_reconnect'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketConnector_updateLastConnectTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketConnector* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketConnector*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketConnector_updateLastConnectTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->updateLastConnectTime();
        return 0;
    }

    gxError("CSocketConnector:updateLastConnectTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketConnector_updateLastConnectTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketConnector_getReconnectDiff(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketConnector* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketConnector*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketConnector_getReconnectDiff'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getReconnectDiff();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketConnector:getReconnectDiff has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketConnector_getReconnectDiff'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketConnector_setServerIP(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketConnector* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketConnector*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketConnector_setServerIP'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CSocketConnector:setServerIP");
        if(!ok)
            return 0;
        cobj->setServerIP(arg0);
        return 0;
    }

    gxError("CSocketConnector:setServerIP has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketConnector_setServerIP'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketConnector_getConnectDiff(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketConnector* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketConnector*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketConnector_getConnectDiff'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getConnectDiff();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketConnector:getConnectDiff has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketConnector_getConnectDiff'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketConnector_setServerPort(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketConnector* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketConnector*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketConnector_setServerPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_uint16(tolua_S, 2, (uint16*)&arg0, "CSocketConnector:setServerPort");
        if(!ok)
            return 0;
        cobj->setServerPort(arg0);
        return 0;
    }

    gxError("CSocketConnector:setServerPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketConnector_setServerPort'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketConnector_toString(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketConnector* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketConnector*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketConnector_toString'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->toString();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CSocketConnector:toString has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketConnector_toString'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketConnector_connect(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketConnector* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketConnector*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketConnector_connect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const char* arg0;
        unsigned short arg1;
        unsigned int arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "CSocketConnector:connect"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "CSocketConnector:connect");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "CSocketConnector:connect");
        if(!ok)
            return 0;
        bool ret = cobj->connect(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketConnector:connect has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketConnector_connect'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketConnector_setReconnectDiff(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketConnector* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketConnector*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketConnector_setReconnectDiff'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocketConnector:setReconnectDiff");
        if(!ok)
            return 0;
        cobj->setReconnectDiff(arg0);
        return 0;
    }

    gxError("CSocketConnector:setReconnectDiff has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketConnector_setReconnectDiff'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketConnector_setConnectDiff(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketConnector* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketConnector*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketConnector_setConnectDiff'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocketConnector:setConnectDiff");
        if(!ok)
            return 0;
        cobj->setConnectDiff(arg0);
        return 0;
    }

    gxError("CSocketConnector:setConnectDiff has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketConnector_setConnectDiff'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketConnector_getServerIP(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketConnector* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketConnector*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketConnector_getServerIP'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getServerIP();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CSocketConnector:getServerIP has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketConnector_getServerIP'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketConnector_canReconnect(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketConnector* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketConnector*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketConnector_canReconnect'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->canReconnect();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketConnector:canReconnect has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketConnector_canReconnect'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketConnector_getServerPort(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketConnector* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketConnector*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketConnector_getServerPort'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned short ret = cobj->getServerPort();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketConnector:getServerPort has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketConnector_getServerPort'.",&tolua_err);
	return 0;
}
static int lua_corelib_CSocketConnector_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSocketConnector)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSocketConnector",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSocketConnector* self = (GXMISC::CSocketConnector*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSocketConnector(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSocketConnector");
    tolua_cclass(tolua_S,"CSocketConnector","CSocketConnector","CSocket",nullptr);

    tolua_beginmodule(tolua_S,"CSocketConnector");
        tolua_function(tolua_S,"reconnect",lua_corelib_CSocketConnector_reconnect);
        tolua_function(tolua_S,"updateLastConnectTime",lua_corelib_CSocketConnector_updateLastConnectTime);
        tolua_function(tolua_S,"getReconnectDiff",lua_corelib_CSocketConnector_getReconnectDiff);
        tolua_function(tolua_S,"setServerIP",lua_corelib_CSocketConnector_setServerIP);
        tolua_function(tolua_S,"getConnectDiff",lua_corelib_CSocketConnector_getConnectDiff);
        tolua_function(tolua_S,"setServerPort",lua_corelib_CSocketConnector_setServerPort);
        tolua_function(tolua_S,"toString",lua_corelib_CSocketConnector_toString);
        tolua_function(tolua_S,"connect",lua_corelib_CSocketConnector_connect);
        tolua_function(tolua_S,"setReconnectDiff",lua_corelib_CSocketConnector_setReconnectDiff);
        tolua_function(tolua_S,"setConnectDiff",lua_corelib_CSocketConnector_setConnectDiff);
        tolua_function(tolua_S,"getServerIP",lua_corelib_CSocketConnector_getServerIP);
        tolua_function(tolua_S,"canReconnect",lua_corelib_CSocketConnector_canReconnect);
        tolua_function(tolua_S,"getServerPort",lua_corelib_CSocketConnector_getServerPort);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSocketConnector).name();
    g_luaType[typeName] = "CSocketConnector";
    g_typeCast["CSocketConnector"] = "CSocketConnector";
    return 1;
}

int lua_corelib_CSocketListener_getBacklog(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketListener* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketListener",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketListener*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketListener_getBacklog'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getBacklog();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CSocketListener:getBacklog has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketListener_getBacklog'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketListener_accept(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketListener* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketListener",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketListener*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketListener_accept'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CSocket* ret = cobj->accept();
        object_to_luaval<GXMISC::CSocket>(tolua_S, "CSocket",(GXMISC::CSocket*)ret);
        return 1;
    }

    gxError("CSocketListener:accept has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketListener_accept'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketListener_start(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketListener* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketListener",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketListener*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketListener_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketListener:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketListener_start'.",&tolua_err);
	return 0;
}
static int lua_corelib_CSocketListener_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSocketListener)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSocketListener",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSocketListener* self = (GXMISC::CSocketListener*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSocketListener(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSocketListener");
    tolua_cclass(tolua_S,"CSocketListener","CSocketListener","CSocket",nullptr);

    tolua_beginmodule(tolua_S,"CSocketListener");
        tolua_function(tolua_S,"getBacklog",lua_corelib_CSocketListener_getBacklog);
        tolua_function(tolua_S,"accept",lua_corelib_CSocketListener_accept);
        tolua_function(tolua_S,"start",lua_corelib_CSocketListener_start);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSocketListener).name();
    g_luaType[typeName] = "CSocketListener";
    g_typeCast["CSocketListener"] = "CSocketListener";
    return 1;
}

int lua_corelib_CSocketBroadCast_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketBroadCast* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketBroadCast",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketBroadCast*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketBroadCast_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CSocketBroadCast:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketBroadCast_init'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketBroadCast_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketBroadCast* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketBroadCast",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketBroadCast*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketBroadCast_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CSocketBroadCast:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketBroadCast_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketBroadCast_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketBroadCast* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CSocketBroadCast();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSocketBroadCast");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSocketBroadCast:CSocketBroadCast has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CSocketBroadCast_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSocketBroadCast)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSocketBroadCast",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSocketBroadCast* self = (GXMISC::CSocketBroadCast*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSocketBroadCast(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSocketBroadCast");
    tolua_cclass(tolua_S,"CSocketBroadCast","CSocketBroadCast","CModuleThreadLoop",lua_corelib_CSocketBroadCast_finalize);

    tolua_beginmodule(tolua_S,"CSocketBroadCast");
        tolua_function(tolua_S,"new",lua_corelib_CSocketBroadCast_constructor);
        tolua_function(tolua_S,"init",lua_corelib_CSocketBroadCast_init);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CSocketBroadCast_cleanUp);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSocketBroadCast).name();
    g_luaType[typeName] = "CSocketBroadCast";
    g_typeCast["CSocketBroadCast"] = "CSocketBroadCast";
    return 1;
}

int lua_corelib_CNetBroadcastWrap_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetBroadcastWrap* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CNetBroadcastModule* arg0;

        ok &= luaval_to_object<GXMISC::CNetBroadcastModule>(tolua_S, 2, "CNetBroadcastModule", &arg0, "CNetBroadcastWrap:CNetBroadcastWrap");
        if(!ok)
            return 0;
        cobj = new GXMISC::CNetBroadcastWrap(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CNetBroadcastWrap");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CNetBroadcastWrap:CNetBroadcastWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CNetBroadcastWrap_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNetBroadcastWrap)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNetBroadcastWrap",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CNetBroadcastWrap* self = (GXMISC::CNetBroadcastWrap*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CNetBroadcastWrap(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNetBroadcastWrap");
    tolua_cclass(tolua_S,"CNetBroadcastWrap","CNetBroadcastWrap","CSimpleThreadLoopWrap",lua_corelib_CNetBroadcastWrap_finalize);

    tolua_beginmodule(tolua_S,"CNetBroadcastWrap");
        tolua_function(tolua_S,"new",lua_corelib_CNetBroadcastWrap_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CNetBroadcastWrap).name();
    g_luaType[typeName] = "CNetBroadcastWrap";
    g_typeCast["CNetBroadcastWrap"] = "CNetBroadcastWrap";
    return 1;
}

int lua_corelib_CNetBroadcastModule_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetBroadcastModule* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CNetBroadcastModule();
        tolua_pushusertype(tolua_S,(void*)cobj,"CNetBroadcastModule");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CNetBroadcastModule:CNetBroadcastModule");
        if(!ok)
            return 0;
        cobj = new GXMISC::CNetBroadcastModule(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CNetBroadcastModule");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CNetBroadcastModule:CNetBroadcastModule has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CNetBroadcastModule_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNetBroadcastModule)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNetBroadcastModule",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CNetBroadcastModule* self = (GXMISC::CNetBroadcastModule*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CNetBroadcastModule(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNetBroadcastModule");
    tolua_cclass(tolua_S,"CNetBroadcastModule","CNetBroadcastModule","CModuleBase",lua_corelib_CNetBroadcastModule_finalize);

    tolua_beginmodule(tolua_S,"CNetBroadcastModule");
        tolua_function(tolua_S,"new",lua_corelib_CNetBroadcastModule_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CNetBroadcastModule).name();
    g_luaType[typeName] = "CNetBroadcastModule";
    g_typeCast["CNetBroadcastModule"] = "CNetBroadcastModule";
    return 1;
}

int lua_corelib_CServerTaskPool_newScriptRetTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskPool* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerTaskPool",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerTaskPool*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerTaskPool_newScriptRetTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CServerTaskPool:newScriptRetTask");
        if(!ok)
            return 0;
        GXMISC::CServerScriptRetTask* ret = cobj->newScriptRetTask(arg0);
        object_to_luaval<GXMISC::CServerScriptRetTask>(tolua_S, "CServerScriptRetTask",(GXMISC::CServerScriptRetTask*)ret);
        return 1;
    }

    gxError("CServerTaskPool:newScriptRetTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerTaskPool_newScriptRetTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerTaskPool_getScriptEngine(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskPool* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerTaskPool",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerTaskPool*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerTaskPool_getScriptEngine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CLuaVM* ret = cobj->getScriptEngine();
        object_to_luaval<GXMISC::CLuaVM>(tolua_S, "CLuaVM",(GXMISC::CLuaVM*)ret);
        return 1;
    }

    gxError("CServerTaskPool:getScriptEngine has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerTaskPool_getScriptEngine'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerTaskPool_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskPool* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerTaskPool",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerTaskPool*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerTaskPool_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CServerTaskPool:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerTaskPool_init'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerTaskPool_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskPool* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerTaskPool",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerTaskPool*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerTaskPool_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CServerTaskPool:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerTaskPool_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerTaskPool_initBeforeRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskPool* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerTaskPool",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerTaskPool*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerTaskPool_initBeforeRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->initBeforeRun();
        return 0;
    }

    gxError("CServerTaskPool:initBeforeRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerTaskPool_initBeforeRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerTaskPool_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskPool* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CServerTaskPool();
        tolua_pushusertype(tolua_S,(void*)cobj,"CServerTaskPool");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CServerTaskPool:CServerTaskPool has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CServerTaskPool_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CServerTaskPool)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CServerTaskPool",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CServerTaskPool* self = (GXMISC::CServerTaskPool*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CServerTaskPool(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CServerTaskPool");
    tolua_cclass(tolua_S,"CServerTaskPool","CServerTaskPool","CModuleThreadLoop",lua_corelib_CServerTaskPool_finalize);

    tolua_beginmodule(tolua_S,"CServerTaskPool");
        tolua_function(tolua_S,"new",lua_corelib_CServerTaskPool_constructor);
        tolua_function(tolua_S,"newScriptRetTask",lua_corelib_CServerTaskPool_newScriptRetTask);
        tolua_function(tolua_S,"getScriptEngine",lua_corelib_CServerTaskPool_getScriptEngine);
        tolua_function(tolua_S,"init",lua_corelib_CServerTaskPool_init);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CServerTaskPool_cleanUp);
        tolua_function(tolua_S,"initBeforeRun",lua_corelib_CServerTaskPool_initBeforeRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CServerTaskPool).name();
    g_luaType[typeName] = "CServerTaskPool";
    g_typeCast["CServerTaskPool"] = "CServerTaskPool";
    return 1;
}

int lua_corelib_CServerPoolTask_getTaskPoolWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerPoolTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerPoolTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerPoolTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerPoolTask_getTaskPoolWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CServerTaskPoolWrap* ret = cobj->getTaskPoolWrap();
        object_to_luaval<GXMISC::CServerTaskPoolWrap>(tolua_S, "CServerTaskPoolWrap",(GXMISC::CServerTaskPoolWrap*)ret);
        return 1;
    }

    gxError("CServerPoolTask:getTaskPoolWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerPoolTask_getTaskPoolWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerPoolTask_setDebugInfo(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerPoolTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerPoolTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerPoolTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerPoolTask_setDebugInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CServerPoolTask:setDebugInfo");
        if(!ok)
            return 0;
        cobj->setDebugInfo(arg0);
        return 0;
    }

    gxError("CServerPoolTask:setDebugInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerPoolTask_setDebugInfo'.",&tolua_err);
	return 0;
}
static int lua_corelib_CServerPoolTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CServerPoolTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CServerPoolTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CServerPoolTask* self = (GXMISC::CServerPoolTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CServerPoolTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CServerPoolTask");
    tolua_cclass(tolua_S,"CServerPoolTask","CServerPoolTask","CThreadToLoopTask",nullptr);

    tolua_beginmodule(tolua_S,"CServerPoolTask");
        tolua_function(tolua_S,"getTaskPoolWrap",lua_corelib_CServerPoolTask_getTaskPoolWrap);
        tolua_function(tolua_S,"setDebugInfo",lua_corelib_CServerPoolTask_setDebugInfo);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CServerPoolTask).name();
    g_luaType[typeName] = "CServerPoolTask";
    g_typeCast["CServerPoolTask"] = "CServerPoolTask";
    return 1;
}

int lua_corelib_CServerPoolWrapTask_getServerTaskPool(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerPoolWrapTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerPoolWrapTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerPoolWrapTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerPoolWrapTask_getServerTaskPool'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CServerTaskPool* ret = cobj->getServerTaskPool();
        object_to_luaval<GXMISC::CServerTaskPool>(tolua_S, "CServerTaskPool",(GXMISC::CServerTaskPool*)ret);
        return 1;
    }

    gxError("CServerPoolWrapTask:getServerTaskPool has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerPoolWrapTask_getServerTaskPool'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerPoolWrapTask_setDebugInfo(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerPoolWrapTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerPoolWrapTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerPoolWrapTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerPoolWrapTask_setDebugInfo'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CServerPoolWrapTask:setDebugInfo");
        if(!ok)
            return 0;
        cobj->setDebugInfo(arg0);
        return 0;
    }

    gxError("CServerPoolWrapTask:setDebugInfo has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerPoolWrapTask_setDebugInfo'.",&tolua_err);
	return 0;
}
static int lua_corelib_CServerPoolWrapTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CServerPoolWrapTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CServerPoolWrapTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CServerPoolWrapTask* self = (GXMISC::CServerPoolWrapTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CServerPoolWrapTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CServerPoolWrapTask");
    tolua_cclass(tolua_S,"CServerPoolWrapTask","CServerPoolWrapTask","CLoopToThreadTask",nullptr);

    tolua_beginmodule(tolua_S,"CServerPoolWrapTask");
        tolua_function(tolua_S,"getServerTaskPool",lua_corelib_CServerPoolWrapTask_getServerTaskPool);
        tolua_function(tolua_S,"setDebugInfo",lua_corelib_CServerPoolWrapTask_setDebugInfo);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CServerPoolWrapTask).name();
    g_luaType[typeName] = "CServerPoolWrapTask";
    g_typeCast["CServerPoolWrapTask"] = "CServerPoolWrapTask";
    return 1;
}

int lua_corelib_CSocketReconnectTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketReconnectTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketReconnectTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketReconnectTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketReconnectTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CSocketReconnectTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketReconnectTask_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketReconnectTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketReconnectTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CSocketReconnectTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSocketReconnectTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSocketReconnectTask:CSocketReconnectTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CSocketReconnectTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSocketReconnectTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSocketReconnectTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSocketReconnectTask* self = (GXMISC::CSocketReconnectTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSocketReconnectTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSocketReconnectTask");
    tolua_cclass(tolua_S,"CSocketReconnectTask","CSocketReconnectTask","CServerPoolWrapTask",lua_corelib_CSocketReconnectTask_finalize);

    tolua_beginmodule(tolua_S,"CSocketReconnectTask");
        tolua_function(tolua_S,"new",lua_corelib_CSocketReconnectTask_constructor);
        tolua_function(tolua_S,"doRun",lua_corelib_CSocketReconnectTask_doRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSocketReconnectTask).name();
    g_luaType[typeName] = "CSocketReconnectTask";
    g_typeCast["CSocketReconnectTask"] = "CSocketReconnectTask";
    return 1;
}

int lua_corelib_CSocketReconnectRetTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketReconnectRetTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketReconnectRetTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketReconnectRetTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketReconnectRetTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CSocketReconnectRetTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketReconnectRetTask_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CSocketReconnectRetTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketReconnectRetTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CSocketReconnectRetTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CSocketReconnectRetTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CSocketReconnectRetTask:CSocketReconnectRetTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CSocketReconnectRetTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSocketReconnectRetTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSocketReconnectRetTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSocketReconnectRetTask* self = (GXMISC::CSocketReconnectRetTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSocketReconnectRetTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSocketReconnectRetTask");
    tolua_cclass(tolua_S,"CSocketReconnectRetTask","CSocketReconnectRetTask","CServerPoolTask",lua_corelib_CSocketReconnectRetTask_finalize);

    tolua_beginmodule(tolua_S,"CSocketReconnectRetTask");
        tolua_function(tolua_S,"new",lua_corelib_CSocketReconnectRetTask_constructor);
        tolua_function(tolua_S,"doRun",lua_corelib_CSocketReconnectRetTask_doRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSocketReconnectRetTask).name();
    g_luaType[typeName] = "CSocketReconnectRetTask";
    g_typeCast["CSocketReconnectRetTask"] = "CSocketReconnectRetTask";
    return 1;
}

int lua_corelib_CServerScriptRetTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerScriptRetTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerScriptRetTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerScriptRetTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerScriptRetTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CServerScriptRetTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerScriptRetTask_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerScriptRetTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerScriptRetTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CServerScriptRetTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CServerScriptRetTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CServerScriptRetTask:CServerScriptRetTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CServerScriptRetTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CServerScriptRetTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CServerScriptRetTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CServerScriptRetTask* self = (GXMISC::CServerScriptRetTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CServerScriptRetTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CServerScriptRetTask");
    tolua_cclass(tolua_S,"CServerScriptRetTask","CServerScriptRetTask","CServerPoolTask",lua_corelib_CServerScriptRetTask_finalize);

    tolua_beginmodule(tolua_S,"CServerScriptRetTask");
        tolua_function(tolua_S,"new",lua_corelib_CServerScriptRetTask_constructor);
        tolua_function(tolua_S,"doRun",lua_corelib_CServerScriptRetTask_doRun);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CServerScriptRetTask).name();
    g_luaType[typeName] = "CServerScriptRetTask";
    g_typeCast["CServerScriptRetTask"] = "CServerScriptRetTask";
    return 1;
}

int lua_corelib_CServerScriptTask_doRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerScriptTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerScriptTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerScriptTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerScriptTask_doRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->doRun();
        return 0;
    }

    gxError("CServerScriptTask:doRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerScriptTask_doRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerScriptTask_newScriptRetTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerScriptTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerScriptTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerScriptTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerScriptTask_newScriptRetTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CServerScriptTask:newScriptRetTask");
        if(!ok)
            return 0;
        GXMISC::CServerScriptRetTask* ret = cobj->newScriptRetTask(arg0);
        object_to_luaval<GXMISC::CServerScriptRetTask>(tolua_S, "CServerScriptRetTask",(GXMISC::CServerScriptRetTask*)ret);
        return 1;
    }

    gxError("CServerScriptTask:newScriptRetTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerScriptTask_newScriptRetTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerScriptTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerScriptTask* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CServerScriptTask();
        tolua_pushusertype(tolua_S,(void*)cobj,"CServerScriptTask");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CServerScriptTask:CServerScriptTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CServerScriptTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CServerScriptTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CServerScriptTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CServerScriptTask* self = (GXMISC::CServerScriptTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CServerScriptTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CServerScriptTask");
    tolua_cclass(tolua_S,"CServerScriptTask","CServerScriptTask","CServerPoolWrapTask",lua_corelib_CServerScriptTask_finalize);

    tolua_beginmodule(tolua_S,"CServerScriptTask");
        tolua_function(tolua_S,"new",lua_corelib_CServerScriptTask_constructor);
        tolua_function(tolua_S,"doRun",lua_corelib_CServerScriptTask_doRun);
        tolua_function(tolua_S,"newScriptRetTask",lua_corelib_CServerScriptTask_newScriptRetTask);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CServerScriptTask).name();
    g_luaType[typeName] = "CServerScriptTask";
    g_typeCast["CServerScriptTask"] = "CServerScriptTask";
    return 1;
}

int lua_corelib_CServerTaskPoolWrap_newScriptTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskPoolWrap* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerTaskPoolWrap",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerTaskPoolWrap*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerTaskPoolWrap_newScriptTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CServerScriptTask* ret = cobj->newScriptTask();
        object_to_luaval<GXMISC::CServerScriptTask>(tolua_S, "CServerScriptTask",(GXMISC::CServerScriptTask*)ret);
        return 1;
    }

    gxError("CServerTaskPoolWrap:newScriptTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerTaskPoolWrap_newScriptTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerTaskPoolWrap_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskPoolWrap* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CServerTaskPoolMgr* arg0;

        ok &= luaval_to_object<GXMISC::CServerTaskPoolMgr>(tolua_S, 2, "CServerTaskPoolMgr", &arg0, "CServerTaskPoolWrap:CServerTaskPoolWrap");
        if(!ok)
            return 0;
        cobj = new GXMISC::CServerTaskPoolWrap(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CServerTaskPoolWrap");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CServerTaskPoolWrap:CServerTaskPoolWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CServerTaskPoolWrap_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CServerTaskPoolWrap)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CServerTaskPoolWrap",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CServerTaskPoolWrap* self = (GXMISC::CServerTaskPoolWrap*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CServerTaskPoolWrap(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CServerTaskPoolWrap");
    tolua_cclass(tolua_S,"CServerTaskPoolWrap","CServerTaskPoolWrap","CSimpleThreadLoopWrap",lua_corelib_CServerTaskPoolWrap_finalize);

    tolua_beginmodule(tolua_S,"CServerTaskPoolWrap");
        tolua_function(tolua_S,"new",lua_corelib_CServerTaskPoolWrap_constructor);
        tolua_function(tolua_S,"newScriptTask",lua_corelib_CServerTaskPoolWrap_newScriptTask);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CServerTaskPoolWrap).name();
    g_luaType[typeName] = "CServerTaskPoolWrap";
    g_typeCast["CServerTaskPoolWrap"] = "CServerTaskPoolWrap";
    return 1;
}

int lua_corelib_CServerTaskConfig_getScriptFileName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerTaskConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerTaskConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerTaskConfig_getScriptFileName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        const std::string ret = cobj->getScriptFileName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("CServerTaskConfig:getScriptFileName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerTaskConfig_getScriptFileName'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerTaskConfig_getPoolNum(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerTaskConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerTaskConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerTaskConfig_getPoolNum'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPoolNum();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CServerTaskConfig:getPoolNum has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerTaskConfig_getPoolNum'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerTaskConfig_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskConfig* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CServerTaskConfig:CServerTaskConfig");
        if(!ok)
            return 0;
        cobj = new GXMISC::CServerTaskConfig(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CServerTaskConfig");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CServerTaskConfig:CServerTaskConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CServerTaskConfig_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CServerTaskConfig)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CServerTaskConfig",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CServerTaskConfig* self = (GXMISC::CServerTaskConfig*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CServerTaskConfig(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CServerTaskConfig");
    tolua_cclass(tolua_S,"CServerTaskConfig","CServerTaskConfig","IModuleConfig",lua_corelib_CServerTaskConfig_finalize);

    tolua_beginmodule(tolua_S,"CServerTaskConfig");
        tolua_function(tolua_S,"new",lua_corelib_CServerTaskConfig_constructor);
        tolua_function(tolua_S,"getScriptFileName",lua_corelib_CServerTaskConfig_getScriptFileName);
        tolua_function(tolua_S,"getPoolNum",lua_corelib_CServerTaskConfig_getPoolNum);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CServerTaskConfig).name();
    g_luaType[typeName] = "CServerTaskConfig";
    g_typeCast["CServerTaskConfig"] = "CServerTaskConfig";
    return 1;
}

int lua_corelib_CServerTaskPoolMgr_newScriptTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskPoolMgr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerTaskPoolMgr",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerTaskPoolMgr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerTaskPoolMgr_newScriptTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CServerTaskPoolMgr:newScriptTask");
        if(!ok)
            return 0;
        GXMISC::CServerScriptTask* ret = cobj->newScriptTask(arg0);
        object_to_luaval<GXMISC::CServerScriptTask>(tolua_S, "CServerScriptTask",(GXMISC::CServerScriptTask*)ret);
        return 1;
    }

    gxError("CServerTaskPoolMgr:newScriptTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerTaskPoolMgr_newScriptTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerTaskPoolMgr_getLeastPoolWrap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskPoolMgr* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServerTaskPoolMgr",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServerTaskPoolMgr*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServerTaskPoolMgr_getLeastPoolWrap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CServerTaskPoolWrap* ret = cobj->getLeastPoolWrap();
        object_to_luaval<GXMISC::CServerTaskPoolWrap>(tolua_S, "CServerTaskPoolWrap",(GXMISC::CServerTaskPoolWrap*)ret);
        return 1;
    }

    gxError("CServerTaskPoolMgr:getLeastPoolWrap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServerTaskPoolMgr_getLeastPoolWrap'.",&tolua_err);
	return 0;
}
int lua_corelib_CServerTaskPoolMgr_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServerTaskPoolMgr* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CServerTaskPoolMgr();
        tolua_pushusertype(tolua_S,(void*)cobj,"CServerTaskPoolMgr");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CServerTaskPoolMgr:CServerTaskPoolMgr");
        if(!ok)
            return 0;
        cobj = new GXMISC::CServerTaskPoolMgr(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CServerTaskPoolMgr");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CServerTaskPoolMgr:CServerTaskPoolMgr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CServerTaskPoolMgr_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CServerTaskPoolMgr)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CServerTaskPoolMgr",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CServerTaskPoolMgr* self = (GXMISC::CServerTaskPoolMgr*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CServerTaskPoolMgr(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CServerTaskPoolMgr");
    tolua_cclass(tolua_S,"CServerTaskPoolMgr","CServerTaskPoolMgr","CModuleBase",lua_corelib_CServerTaskPoolMgr_finalize);

    tolua_beginmodule(tolua_S,"CServerTaskPoolMgr");
        tolua_function(tolua_S,"new",lua_corelib_CServerTaskPoolMgr_constructor);
        tolua_function(tolua_S,"newScriptTask",lua_corelib_CServerTaskPoolMgr_newScriptTask);
        tolua_function(tolua_S,"getLeastPoolWrap",lua_corelib_CServerTaskPoolMgr_getLeastPoolWrap);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CServerTaskPoolMgr).name();
    g_luaType[typeName] = "CServerTaskPoolMgr";
    g_typeCast["CServerTaskPoolMgr"] = "CServerTaskPoolMgr";
    return 1;
}

int lua_corelib_CNetModuleConfig_getPackTempReadBuffLen(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetModuleConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetModuleConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetModuleConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetModuleConfig_getPackTempReadBuffLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPackTempReadBuffLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CNetModuleConfig:getPackTempReadBuffLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetModuleConfig_getPackTempReadBuffLen'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetModuleConfig_getPackBuffLen(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetModuleConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetModuleConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetModuleConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetModuleConfig_getPackBuffLen'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPackBuffLen();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CNetModuleConfig:getPackBuffLen has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetModuleConfig_getPackBuffLen'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetModuleConfig_getPacketNumPerFrame(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetModuleConfig* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetModuleConfig",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetModuleConfig*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetModuleConfig_getPacketNumPerFrame'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getPacketNumPerFrame();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CNetModuleConfig:getPacketNumPerFrame has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetModuleConfig_getPacketNumPerFrame'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetModuleConfig_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetModuleConfig* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CNetModuleConfig:CNetModuleConfig");
        if(!ok)
            return 0;
        cobj = new GXMISC::CNetModuleConfig(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CNetModuleConfig");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CNetModuleConfig:CNetModuleConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CNetModuleConfig_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNetModuleConfig)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNetModuleConfig",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CNetModuleConfig* self = (GXMISC::CNetModuleConfig*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CNetModuleConfig(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNetModuleConfig");
    tolua_cclass(tolua_S,"CNetModuleConfig","CNetModuleConfig","IModuleConfig",lua_corelib_CNetModuleConfig_finalize);

    tolua_beginmodule(tolua_S,"CNetModuleConfig");
        tolua_function(tolua_S,"new",lua_corelib_CNetModuleConfig_constructor);
        tolua_function(tolua_S,"getPackTempReadBuffLen",lua_corelib_CNetModuleConfig_getPackTempReadBuffLen);
        tolua_function(tolua_S,"getPackBuffLen",lua_corelib_CNetModuleConfig_getPackBuffLen);
        tolua_function(tolua_S,"getPacketNumPerFrame",lua_corelib_CNetModuleConfig_getPacketNumPerFrame);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CNetModuleConfig).name();
    g_luaType[typeName] = "CNetModuleConfig";
    g_typeCast["CNetModuleConfig"] = "CNetModuleConfig";
    return 1;
}

int lua_corelib_CNetModule_addListener(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetModule_addListener'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CSocketListener* arg0;

        ok &= luaval_to_object<GXMISC::CSocketListener>(tolua_S, 2, "CSocketListener", &arg0, "CNetModule:addListener");
        if(!ok)
            return 0;
        bool ret = cobj->addListener(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CNetModule:addListener has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetModule_addListener'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetModule_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetModule_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CNetModule:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetModule_init'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetModule_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetModule_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CNetModule:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetModule_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetModule_getLeastNetLoop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetModule_getLeastNetLoop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CNetLoopWrap* ret = cobj->getLeastNetLoop();
        object_to_luaval<GXMISC::CNetLoopWrap>(tolua_S, "CNetLoopWrap",(GXMISC::CNetLoopWrap*)ret);
        return 1;
    }

    gxError("CNetModule:getLeastNetLoop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetModule_getLeastNetLoop'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetModule_addConnector(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetModule_addConnector'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CSocketConnector* arg0;

        ok &= luaval_to_object<GXMISC::CSocketConnector>(tolua_S, 2, "CSocketConnector", &arg0, "CNetModule:addConnector");
        if(!ok)
            return 0;
        bool ret = cobj->addConnector(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CNetModule:addConnector has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetModule_addConnector'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetModule_getConfig(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetModule_getConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CNetModuleConfig* ret = cobj->getConfig();
        object_to_luaval<GXMISC::CNetModuleConfig>(tolua_S, "CNetModuleConfig",(GXMISC::CNetModuleConfig*)ret);
        return 1;
    }

    gxError("CNetModule:getConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetModule_getConfig'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetModule_getSocketHandler(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetModule_getSocketHandler'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CNetModule:getSocketHandler");
        if(!ok)
            return 0;
        GXMISC::CSocketHandler* ret = cobj->getSocketHandler(arg0);
        object_to_luaval<GXMISC::CSocketHandler>(tolua_S, "CSocketHandler",(GXMISC::CSocketHandler*)ret);
        return 1;
    }

    gxError("CNetModule:getSocketHandler has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetModule_getSocketHandler'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetModule_closeSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetModule* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CNetModule",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CNetModule*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CNetModule_closeSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned long long arg0;
        int arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "CNetModule:closeSocket");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CNetModule:closeSocket");
        if(!ok)
            return 0;
        cobj->closeSocket(arg0, arg1);
        return 0;
    }

    gxError("CNetModule:closeSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CNetModule_closeSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_CNetModule_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CNetModule* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CNetModule();
        tolua_pushusertype(tolua_S,(void*)cobj,"CNetModule");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CNetModule:CNetModule");
        if(!ok)
            return 0;
        cobj = new GXMISC::CNetModule(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CNetModule");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CNetModule:CNetModule has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CNetModule_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CNetModule)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CNetModule",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CNetModule* self = (GXMISC::CNetModule*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CNetModule(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CNetModule");
    tolua_cclass(tolua_S,"CNetModule","CNetModule","CModuleBase",lua_corelib_CNetModule_finalize);

    tolua_beginmodule(tolua_S,"CNetModule");
        tolua_function(tolua_S,"new",lua_corelib_CNetModule_constructor);
        tolua_function(tolua_S,"addListener",lua_corelib_CNetModule_addListener);
        tolua_function(tolua_S,"init",lua_corelib_CNetModule_init);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CNetModule_cleanUp);
        tolua_function(tolua_S,"getLeastNetLoop",lua_corelib_CNetModule_getLeastNetLoop);
        tolua_function(tolua_S,"addConnector",lua_corelib_CNetModule_addConnector);
        tolua_function(tolua_S,"getConfig",lua_corelib_CNetModule_getConfig);
        tolua_function(tolua_S,"getSocketHandler",lua_corelib_CNetModule_getSocketHandler);
        tolua_function(tolua_S,"closeSocket",lua_corelib_CNetModule_closeSocket);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CNetModule).name();
    g_luaType[typeName] = "CNetModule";
    g_typeCast["CNetModule"] = "CNetModule";
    return 1;
}

int lua_corelib_CSocketServerListener_accept(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CSocketServerListener* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CSocketServerListener",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CSocketServerListener*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CSocketServerListener_accept'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CSocket* ret = cobj->accept();
        object_to_luaval<GXMISC::CSocket>(tolua_S, "CSocket",(GXMISC::CSocket*)ret);
        return 1;
    }
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocketServerListener:accept");
        if(!ok)
            return 0;
        GXMISC::CSocket* ret = cobj->accept(arg0);
        object_to_luaval<GXMISC::CSocket>(tolua_S, "CSocket",(GXMISC::CSocket*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        int arg1;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocketServerListener:accept");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketServerListener:accept");
        if(!ok)
            return 0;
        GXMISC::CSocket* ret = cobj->accept(arg0, arg1);
        object_to_luaval<GXMISC::CSocket>(tolua_S, "CSocket",(GXMISC::CSocket*)ret);
        return 1;
    }
    if (argc == 3) 
    {
        int arg0;
        int arg1;
        int arg2;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocketServerListener:accept");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketServerListener:accept");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CSocketServerListener:accept");
        if(!ok)
            return 0;
        GXMISC::CSocket* ret = cobj->accept(arg0, arg1, arg2);
        object_to_luaval<GXMISC::CSocket>(tolua_S, "CSocket",(GXMISC::CSocket*)ret);
        return 1;
    }
    if (argc == 4) 
    {
        int arg0;
        int arg1;
        int arg2;
        int arg3;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CSocketServerListener:accept");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CSocketServerListener:accept");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CSocketServerListener:accept");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CSocketServerListener:accept");
        if(!ok)
            return 0;
        GXMISC::CSocket* ret = cobj->accept(arg0, arg1, arg2, arg3);
        object_to_luaval<GXMISC::CSocket>(tolua_S, "CSocket",(GXMISC::CSocket*)ret);
        return 1;
    }

    gxError("CSocketServerListener:accept has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CSocketServerListener_accept'.",&tolua_err);
	return 0;
}
static int lua_corelib_CSocketServerListener_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSocketServerListener)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSocketServerListener",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSocketServerListener* self = (GXMISC::CSocketServerListener*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSocketServerListener(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSocketServerListener");
    tolua_cclass(tolua_S,"CSocketServerListener","CSocketServerListener","CSocketListener",nullptr);

    tolua_beginmodule(tolua_S,"CSocketServerListener");
        tolua_function(tolua_S,"accept",lua_corelib_CSocketServerListener_accept);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSocketServerListener).name();
    g_luaType[typeName] = "CSocketServerListener";
    g_typeCast["CSocketServerListener"] = "CSocketServerListener";
    return 1;
}

int lua_corelib_CServiceTask_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServiceTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServiceTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServiceTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServiceTask_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CServiceTask:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServiceTask_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CServiceTask_setExcuteNumPerFrame(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServiceTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServiceTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServiceTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServiceTask_setExcuteNumPerFrame'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setExcuteNumPerFrame();
        return 0;
    }
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CServiceTask:setExcuteNumPerFrame");
        if(!ok)
            return 0;
        cobj->setExcuteNumPerFrame(arg0);
        return 0;
    }

    gxError("CServiceTask:setExcuteNumPerFrame has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServiceTask_setExcuteNumPerFrame'.",&tolua_err);
	return 0;
}
int lua_corelib_CServiceTask_getType(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServiceTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServiceTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServiceTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServiceTask_getType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CServiceTask:getType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServiceTask_getType'.",&tolua_err);
	return 0;
}
int lua_corelib_CServiceTask_getExcuteNumPerFrame(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServiceTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServiceTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServiceTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServiceTask_getExcuteNumPerFrame'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getExcuteNumPerFrame();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CServiceTask:getExcuteNumPerFrame has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServiceTask_getExcuteNumPerFrame'.",&tolua_err);
	return 0;
}
int lua_corelib_CServiceTask_isUnlimited(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServiceTask* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServiceTask",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServiceTask*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServiceTask_isUnlimited'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isUnlimited();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CServiceTask:isUnlimited has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServiceTask_isUnlimited'.",&tolua_err);
	return 0;
}
static int lua_corelib_CServiceTask_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CServiceTask)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CServiceTask",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CServiceTask* self = (GXMISC::CServiceTask*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CServiceTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CServiceTask");
    tolua_cclass(tolua_S,"CServiceTask","CServiceTask","IRunnable",nullptr);

    tolua_beginmodule(tolua_S,"CServiceTask");
        tolua_function(tolua_S,"cleanUp",lua_corelib_CServiceTask_cleanUp);
        tolua_function(tolua_S,"setExcuteNumPerFrame",lua_corelib_CServiceTask_setExcuteNumPerFrame);
        tolua_function(tolua_S,"getType",lua_corelib_CServiceTask_getType);
        tolua_function(tolua_S,"getExcuteNumPerFrame",lua_corelib_CServiceTask_getExcuteNumPerFrame);
        tolua_function(tolua_S,"isUnlimited",lua_corelib_CServiceTask_isUnlimited);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CServiceTask).name();
    g_luaType[typeName] = "CServiceTask";
    g_typeCast["CServiceTask"] = "CServiceTask";
    return 1;
}

int lua_corelib_CServiceTaskQue_pushTask(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServiceTaskQue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServiceTaskQue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServiceTaskQue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServiceTaskQue_pushTask'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CServiceTask* arg0;

        ok &= luaval_to_object<GXMISC::CServiceTask>(tolua_S, 2, "CServiceTask", &arg0, "CServiceTaskQue:pushTask");
        if(!ok)
            return 0;
        bool ret = cobj->pushTask(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CServiceTaskQue:pushTask has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServiceTaskQue_pushTask'.",&tolua_err);
	return 0;
}
int lua_corelib_CServiceTaskQue_update(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServiceTaskQue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServiceTaskQue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServiceTaskQue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServiceTaskQue_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CServiceTaskQue:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CServiceTaskQue:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServiceTaskQue_update'.",&tolua_err);
	return 0;
}
int lua_corelib_CServiceTaskQue_setExecuteNumPerFrame(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServiceTaskQue* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CServiceTaskQue",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CServiceTaskQue*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CServiceTaskQue_setExecuteNumPerFrame'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CServiceTaskQue:setExecuteNumPerFrame");
        if(!ok)
            return 0;
        cobj->setExecuteNumPerFrame(arg0);
        return 0;
    }

    gxError("CServiceTaskQue:setExecuteNumPerFrame has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CServiceTaskQue_setExecuteNumPerFrame'.",&tolua_err);
	return 0;
}
int lua_corelib_CServiceTaskQue_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CServiceTaskQue* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CServiceTaskQue();
        tolua_pushusertype(tolua_S,(void*)cobj,"CServiceTaskQue");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CServiceTaskQue:CServiceTaskQue has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CServiceTaskQue_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CServiceTaskQue)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CServiceTaskQue",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CServiceTaskQue* self = (GXMISC::CServiceTaskQue*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CServiceTaskQue(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CServiceTaskQue");
    tolua_cclass(tolua_S,"CServiceTaskQue","CServiceTaskQue","IAllocatable",lua_corelib_CServiceTaskQue_finalize);

    tolua_beginmodule(tolua_S,"CServiceTaskQue");
        tolua_function(tolua_S,"new",lua_corelib_CServiceTaskQue_constructor);
        tolua_function(tolua_S,"pushTask",lua_corelib_CServiceTaskQue_pushTask);
        tolua_function(tolua_S,"update",lua_corelib_CServiceTaskQue_update);
        tolua_function(tolua_S,"setExecuteNumPerFrame",lua_corelib_CServiceTaskQue_setExecuteNumPerFrame);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CServiceTaskQue).name();
    g_luaType[typeName] = "CServiceTaskQue";
    g_typeCast["CServiceTaskQue"] = "CServiceTaskQue";
    return 1;
}

int lua_corelib_CGxServiceConfig_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGxServiceConfig* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CGxServiceConfig();
        tolua_pushusertype(tolua_S,(void*)cobj,"CGxServiceConfig");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CGxServiceConfig:CGxServiceConfig");
        if(!ok)
            return 0;
        cobj = new GXMISC::CGxServiceConfig(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CGxServiceConfig");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CGxServiceConfig:CGxServiceConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CGxServiceConfig_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGxServiceConfig)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGxServiceConfig",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CGxServiceConfig* self = (GXMISC::CGxServiceConfig*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CGxServiceConfig(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGxServiceConfig");
    tolua_cclass(tolua_S,"CGxServiceConfig","CGxServiceConfig","IModuleConfig",lua_corelib_CGxServiceConfig_finalize);

    tolua_beginmodule(tolua_S,"CGxServiceConfig");
        tolua_function(tolua_S,"new",lua_corelib_CGxServiceConfig_constructor);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CGxServiceConfig).name();
    g_luaType[typeName] = "CGxServiceConfig";
    g_typeCast["CGxServiceConfig"] = "CGxServiceConfig";
    return 1;
}

static int lua_corelib_CSerivceScriptObject_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSerivceScriptObject)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSerivceScriptObject",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSerivceScriptObject* self = (GXMISC::CSerivceScriptObject*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSerivceScriptObject(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSerivceScriptObject");
    tolua_cclass(tolua_S,"CSerivceScriptObject","CSerivceScriptObject","IScriptObject",nullptr);

    tolua_beginmodule(tolua_S,"CSerivceScriptObject");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSerivceScriptObject).name();
    g_luaType[typeName] = "CSerivceScriptObject";
    g_typeCast["CSerivceScriptObject"] = "CSerivceScriptObject";
    return 1;
}

int lua_corelib_GxService_load(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_load'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "GxService:load");
        if(!ok)
            return 0;
        bool ret = cobj->load(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("GxService:load has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_load'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_getNetMgr(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_getNetMgr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CNetModule* ret = cobj->getNetMgr();
        object_to_luaval<GXMISC::CNetModule>(tolua_S, "CNetModule",(GXMISC::CNetModule*)ret);
        return 1;
    }

    gxError("GxService:getNetMgr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_getNetMgr'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_addLoad(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_addLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "GxService:addLoad");
        if(!ok)
            return 0;
        bool ret = cobj->addLoad(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("GxService:addLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_addLoad'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_doScriptEvent(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_doScriptEvent'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "GxService:doScriptEvent"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        cobj->doScriptEvent(arg0);
        return 0;
    }

    gxError("GxService:doScriptEvent has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_doScriptEvent'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_getNetBroadcast(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_getNetBroadcast'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CNetBroadcastModule* ret = cobj->getNetBroadcast();
        object_to_luaval<GXMISC::CNetBroadcastModule>(tolua_S, "CNetBroadcastModule",(GXMISC::CNetBroadcastModule*)ret);
        return 1;
    }

    gxError("GxService:getNetBroadcast has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_getNetBroadcast'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_getDbMgr(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_getDbMgr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CDatabaseConnMgr* ret = cobj->getDbMgr();
        object_to_luaval<GXMISC::CDatabaseConnMgr>(tolua_S, "CDatabaseConnMgr",(GXMISC::CDatabaseConnMgr*)ret);
        return 1;
    }

    gxError("GxService:getDbMgr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_getDbMgr'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("GxService:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_addConnector(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_addConnector'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CSocketConnector* arg0;

        ok &= luaval_to_object<GXMISC::CSocketConnector>(tolua_S, 2, "CSocketConnector", &arg0, "GxService:addConnector");
        if(!ok)
            return 0;
        bool ret = cobj->addConnector(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("GxService:addConnector has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_addConnector'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_openClientListener(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_openClientListener'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const char* arg0;
        unsigned short arg1;
        int arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "GxService:openClientListener"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "GxService:openClientListener");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "GxService:openClientListener");
        if(!ok)
            return 0;
        bool ret = cobj->openClientListener(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("GxService:openClientListener has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_openClientListener'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_getServerTaskMgr(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_getServerTaskMgr'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CServerTaskPoolMgr* ret = cobj->getServerTaskMgr();
        object_to_luaval<GXMISC::CServerTaskPoolMgr>(tolua_S, "CServerTaskPoolMgr",(GXMISC::CServerTaskPoolMgr*)ret);
        return 1;
    }

    gxError("GxService:getServerTaskMgr has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_getServerTaskMgr'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_setScriptEngine(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_setScriptEngine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CLuaVM* arg0;

        ok &= luaval_to_object<GXMISC::CLuaVM>(tolua_S, 2, "CLuaVM", &arg0, "GxService:setScriptEngine");
        if(!ok)
            return 0;
        cobj->setScriptEngine(arg0);
        return 0;
    }

    gxError("GxService:setScriptEngine has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_setScriptEngine'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_setOption(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_setOption'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        unsigned int arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "GxService:setOption");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "GxService:setOption");
        if(!ok)
            return 0;
        cobj->setOption(arg0, arg1);
        return 0;
    }

    gxError("GxService:setOption has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_setOption'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_openServerListener(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_openServerListener'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        const char* arg0;
        unsigned short arg1;
        int arg2;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "GxService:openServerListener"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "GxService:openServerListener");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "GxService:openServerListener");
        if(!ok)
            return 0;
        bool ret = cobj->openServerListener(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("GxService:openServerListener has wrong number of arguments: {0}, was expecting {1} \n", argc, 3);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_openServerListener'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_openClientConnector(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_openClientConnector'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        const char* arg0;
        unsigned short arg1;
        unsigned int arg2;
        int arg3;
        bool arg4;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "GxService:openClientConnector"); arg0 = (char*)arg0_tmp.buffer;

        ok &= luaval_to_uint16(tolua_S, 3, (uint16*)&arg1, "GxService:openClientConnector");

        ok &= luaval_to_uint32(tolua_S, 4,(uint32*)&arg2, "GxService:openClientConnector");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "GxService:openClientConnector");

        ok &= luaval_to_boolean(tolua_S, 6,(bool*)&arg4, "GxService:openClientConnector");
        if(!ok)
            return 0;
        bool ret = cobj->openClientConnector(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("GxService:openClientConnector has wrong number of arguments: {0}, was expecting {1} \n", argc, 5);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_openClientConnector'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_start(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_start'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->start();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("GxService:start has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_start'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_init(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_init'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("GxService:init has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_init'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_test(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_test'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->test();
        return 0;
    }

    gxError("GxService:test has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_test'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_closeSocket(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_closeSocket'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned long long arg0;
        int arg1;

        ok &= luaval_to_uint64(tolua_S, 2, (uint64*)&arg0, "GxService:closeSocket");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "GxService:closeSocket");
        if(!ok)
            return 0;
        cobj->closeSocket(arg0, arg1);
        return 0;
    }

    gxError("GxService:closeSocket has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_closeSocket'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_setMainScriptName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_setMainScriptName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "GxService:setMainScriptName");
        if(!ok)
            return 0;
        cobj->setMainScriptName(arg0);
        return 0;
    }

    gxError("GxService:setMainScriptName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_setMainScriptName'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_getScriptObject(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_getScriptObject'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CSerivceScriptObject* ret = cobj->getScriptObject();
        object_to_luaval<GXMISC::CSerivceScriptObject>(tolua_S, "CSerivceScriptObject",(GXMISC::CSerivceScriptObject*)ret);
        return 1;
    }

    gxError("GxService:getScriptObject has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_getScriptObject'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_addReconnector(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_addReconnector'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CSocketConnector* arg0;

        ok &= luaval_to_object<GXMISC::CSocketConnector>(tolua_S, 2, "CSocketConnector", &arg0, "GxService:addReconnector");
        if(!ok)
            return 0;
        bool ret = cobj->addReconnector(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("GxService:addReconnector has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_addReconnector'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_getModuleName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_getModuleName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getModuleName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("GxService:getModuleName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_getModuleName'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_getServiceName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_getServiceName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        std::string ret = cobj->getServiceName();
        tolua_pushcppstring(tolua_S,ret);
        return 1;
    }

    gxError("GxService:getServiceName has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_getServiceName'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_setNewServiceFunctionName(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_setNewServiceFunctionName'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "GxService:setNewServiceFunctionName");
        if(!ok)
            return 0;
        cobj->setNewServiceFunctionName(arg0);
        return 0;
    }

    gxError("GxService:setNewServiceFunctionName has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_setNewServiceFunctionName'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_addLogger(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_addLogger'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::IDisplayer* arg0;

        ok &= luaval_to_object<GXMISC::IDisplayer>(tolua_S, 2, "IDisplayer", &arg0, "GxService:addLogger");
        if(!ok)
            return 0;
        cobj->addLogger(arg0);
        return 0;
    }

    gxError("GxService:addLogger has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_addLogger'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_doServerEvent(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_doServerEvent'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        CScriptString arg0_tmp; ok &= luaval_to_script_string(tolua_S, 2, &arg0_tmp, "GxService:doServerEvent"); arg0 = (char*)arg0_tmp.buffer;
        if(!ok)
            return 0;
        cobj->doServerEvent(arg0);
        return 0;
    }

    gxError("GxService:doServerEvent has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_doServerEvent'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_setSystemEnvironment(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_setSystemEnvironment'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->setSystemEnvironment();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("GxService:setSystemEnvironment has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_setSystemEnvironment'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_getTaskQue(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_getTaskQue'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CServiceTaskQue* ret = cobj->getTaskQue();
        object_to_luaval<GXMISC::CServiceTaskQue>(tolua_S, "CServiceTaskQue",(GXMISC::CServiceTaskQue*)ret);
        return 1;
    }

    gxError("GxService:getTaskQue has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_getTaskQue'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_getScriptEngine(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_getScriptEngine'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CLuaVM* ret = cobj->getScriptEngine();
        object_to_luaval<GXMISC::CLuaVM>(tolua_S, "CLuaVM",(GXMISC::CLuaVM*)ret);
        return 1;
    }

    gxError("GxService:getScriptEngine has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_getScriptEngine'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_getServiceConfig(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_getServiceConfig'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CGxServiceConfig* ret = cobj->getServiceConfig();
        object_to_luaval<GXMISC::CGxServiceConfig>(tolua_S, "CGxServiceConfig",(GXMISC::CGxServiceConfig*)ret);
        return 1;
    }

    gxError("GxService:getServiceConfig has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_getServiceConfig'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_getConfigMap(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_getConfigMap'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        GXMISC::CConfigMap* ret = cobj->getConfigMap();
        object_to_luaval<GXMISC::CConfigMap>(tolua_S, "CConfigMap",(GXMISC::CConfigMap*)ret);
        return 1;
    }

    gxError("GxService:getConfigMap has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_getConfigMap'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_addTimer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_addTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CIntervalTimer* arg0;

        ok &= luaval_to_object<GXMISC::CIntervalTimer>(tolua_S, 2, "CIntervalTimer", &arg0, "GxService:addTimer");
        if(!ok)
            return 0;
        cobj->addTimer(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        GXMISC::CIntervalTimer* arg0;
        bool arg1;

        ok &= luaval_to_object<GXMISC::CIntervalTimer>(tolua_S, 2, "CIntervalTimer", &arg0, "GxService:addTimer");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "GxService:addTimer");
        if(!ok)
            return 0;
        cobj->addTimer(arg0, arg1);
        return 0;
    }

    gxError("GxService:addTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_addTimer'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_setStopSigno(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::GxService*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_GxService_setStopSigno'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->setStopSigno();
        return 0;
    }
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "GxService:setStopSigno");
        if(!ok)
            return 0;
        cobj->setStopSigno(arg0);
        return 0;
    }

    gxError("GxService:setStopSigno has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_GxService_setStopSigno'.",&tolua_err);
	return 0;
}
int lua_corelib_GxService_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::GxService* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CGxServiceConfig* arg0;

        ok &= luaval_to_object<GXMISC::CGxServiceConfig>(tolua_S, 2, "CGxServiceConfig", &arg0, "GxService:GxService");
        if(!ok)
            return 0;
        cobj = new GXMISC::GxService(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"GxService");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 2) 
    {
        GXMISC::CGxServiceConfig* arg0;
        std::string arg1;

        ok &= luaval_to_object<GXMISC::CGxServiceConfig>(tolua_S, 2, "CGxServiceConfig", &arg0, "GxService:GxService");

        ok &= luaval_to_std_string(tolua_S, 3,&arg1, "GxService:GxService");
        if(!ok)
            return 0;
        cobj = new GXMISC::GxService(arg0, arg1);
        tolua_pushusertype(tolua_S,(void*)cobj,"GxService");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("GxService:GxService has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_GxService_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (GxService)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"GxService",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::GxService* self = (GXMISC::GxService*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_GxService(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"GxService");
    tolua_cclass(tolua_S,"GxService","GxService","IServiceModule",lua_corelib_GxService_finalize);

    tolua_beginmodule(tolua_S,"GxService");
        tolua_function(tolua_S,"new",lua_corelib_GxService_constructor);
        tolua_function(tolua_S,"load",lua_corelib_GxService_load);
        tolua_function(tolua_S,"getNetMgr",lua_corelib_GxService_getNetMgr);
        tolua_function(tolua_S,"addLoad",lua_corelib_GxService_addLoad);
        tolua_function(tolua_S,"doScriptEvent",lua_corelib_GxService_doScriptEvent);
        tolua_function(tolua_S,"getNetBroadcast",lua_corelib_GxService_getNetBroadcast);
        tolua_function(tolua_S,"getDbMgr",lua_corelib_GxService_getDbMgr);
        tolua_function(tolua_S,"cleanUp",lua_corelib_GxService_cleanUp);
        tolua_function(tolua_S,"addConnector",lua_corelib_GxService_addConnector);
        tolua_function(tolua_S,"openClientListener",lua_corelib_GxService_openClientListener);
        tolua_function(tolua_S,"getServerTaskMgr",lua_corelib_GxService_getServerTaskMgr);
        tolua_function(tolua_S,"setScriptEngine",lua_corelib_GxService_setScriptEngine);
        tolua_function(tolua_S,"setOption",lua_corelib_GxService_setOption);
        tolua_function(tolua_S,"openServerListener",lua_corelib_GxService_openServerListener);
        tolua_function(tolua_S,"openClientConnector",lua_corelib_GxService_openClientConnector);
        tolua_function(tolua_S,"start",lua_corelib_GxService_start);
        tolua_function(tolua_S,"init",lua_corelib_GxService_init);
        tolua_function(tolua_S,"test",lua_corelib_GxService_test);
        tolua_function(tolua_S,"closeSocket",lua_corelib_GxService_closeSocket);
        tolua_function(tolua_S,"setMainScriptName",lua_corelib_GxService_setMainScriptName);
        tolua_function(tolua_S,"getScriptObject",lua_corelib_GxService_getScriptObject);
        tolua_function(tolua_S,"addReconnector",lua_corelib_GxService_addReconnector);
        tolua_function(tolua_S,"getModuleName",lua_corelib_GxService_getModuleName);
        tolua_function(tolua_S,"getServiceName",lua_corelib_GxService_getServiceName);
        tolua_function(tolua_S,"setNewServiceFunctionName",lua_corelib_GxService_setNewServiceFunctionName);
        tolua_function(tolua_S,"addLogger",lua_corelib_GxService_addLogger);
        tolua_function(tolua_S,"doServerEvent",lua_corelib_GxService_doServerEvent);
        tolua_function(tolua_S,"setSystemEnvironment",lua_corelib_GxService_setSystemEnvironment);
        tolua_function(tolua_S,"getTaskQue",lua_corelib_GxService_getTaskQue);
        tolua_function(tolua_S,"getScriptEngine",lua_corelib_GxService_getScriptEngine);
        tolua_function(tolua_S,"getServiceConfig",lua_corelib_GxService_getServiceConfig);
        tolua_function(tolua_S,"getConfigMap",lua_corelib_GxService_getConfigMap);
        tolua_function(tolua_S,"addTimer",lua_corelib_GxService_addTimer);
        tolua_function(tolua_S,"setStopSigno",lua_corelib_GxService_setStopSigno);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::GxService).name();
    g_luaType[typeName] = "GxService";
    g_typeCast["GxService"] = "GxService";
    return 1;
}

int lua_corelib_CMiniServer_onAfterLoad(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMiniServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMiniServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMiniServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMiniServer_onAfterLoad'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onAfterLoad();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMiniServer:onAfterLoad has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMiniServer_onAfterLoad'.",&tolua_err);
	return 0;
}
int lua_corelib_CMiniServer_onSystemEnvironment(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMiniServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMiniServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMiniServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMiniServer_onSystemEnvironment'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onSystemEnvironment();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMiniServer:onSystemEnvironment has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMiniServer_onSystemEnvironment'.",&tolua_err);
	return 0;
}
int lua_corelib_CMiniServer_onAfterInit(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMiniServer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMiniServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMiniServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CMiniServer_onAfterInit'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->onAfterInit();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CMiniServer:onAfterInit has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMiniServer_onAfterInit'.",&tolua_err);
	return 0;
}
int lua_corelib_CMiniServer_test(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMiniServer* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CMiniServer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CMiniServer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_corelib_CMiniServer_test'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            cobj->test();
            return 0;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string arg0;
            ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMiniServer:test");

            if (!ok) { break; }
            sint64 ret = cobj->test(arg0);
            lua_tinker::push(tolua_S,ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CMiniServer:test");

            if (!ok) { break; }
            cobj->test(arg0);
            return 0;
        }
    }while(0);
    ok  = true;
    gxError("CMiniServer:test has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMiniServer_test'.",&tolua_err);
    return 0;
}
int lua_corelib_CMiniServer_Test(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMiniServer",0,&tolua_err)) goto tolua_lerror;

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 1)
        {
            short arg0;
            ok &= luaval_to_sint16(tolua_S, 2,(sint16*)&arg0, "CMiniServer:Test");
            if (!ok) { break; }
            unsigned int ret = GXMISC::CMiniServer::Test(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 0)
        {
            unsigned int ret = GXMISC::CMiniServer::Test();
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    } while (0);
    ok  = true;

    gxError("CMiniServer:Test has wrong number of arguments: {0}, was expecting {1}",argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMiniServer_Test'.",&tolua_err);
    return 0;
}
int lua_corelib_CMiniServer_TT(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"CMiniServer",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
            return 0;
        GXMISC::CMiniServer::TT();
        return 0;
    }
    gxError("CMiniServer:TT has wrong number of arguments: {0}, was expecting {1}\n ", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CMiniServer_TT'.", &tolua_err);
    return 0;
}
int lua_corelib_CMiniServer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CMiniServer* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CMiniServer();
        tolua_pushusertype(tolua_S,(void*)cobj,"CMiniServer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CMiniServer:CMiniServer");
        if(!ok)
            return 0;
        cobj = new GXMISC::CMiniServer(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CMiniServer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CMiniServer:CMiniServer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CMiniServer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CMiniServer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CMiniServer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CMiniServer* self = (GXMISC::CMiniServer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CMiniServer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CMiniServer");
    tolua_cclass(tolua_S,"CMiniServer","CMiniServer","GxService",lua_corelib_CMiniServer_finalize);

    tolua_beginmodule(tolua_S,"CMiniServer");
        tolua_function(tolua_S,"new",lua_corelib_CMiniServer_constructor);
        tolua_function(tolua_S,"onAfterLoad",lua_corelib_CMiniServer_onAfterLoad);
        tolua_function(tolua_S,"onSystemEnvironment",lua_corelib_CMiniServer_onSystemEnvironment);
        tolua_function(tolua_S,"onAfterInit",lua_corelib_CMiniServer_onAfterInit);
        tolua_function(tolua_S,"test",lua_corelib_CMiniServer_test);
        tolua_function(tolua_S,"Test", lua_corelib_CMiniServer_Test);
        tolua_function(tolua_S,"TT", lua_corelib_CMiniServer_TT);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CMiniServer).name();
    g_luaType[typeName] = "CMiniServer";
    g_typeCast["CMiniServer"] = "CMiniServer";
    return 1;
}

int lua_corelib_ManCore_errorLog(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"ManCore",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string arg0;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "ManCore:errorLog");
        if(!ok)
            return 0;
        ManCore::errorLog(arg0);
        return 0;
    }
    gxError("ManCore:errorLog has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ManCore_errorLog'.", &tolua_err);
    return 0;
}
int lua_corelib_ManCore_infoLog(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"ManCore",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string arg0;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "ManCore:infoLog");
        if(!ok)
            return 0;
        ManCore::infoLog(arg0);
        return 0;
    }
    gxError("ManCore:infoLog has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ManCore_infoLog'.", &tolua_err);
    return 0;
}
int lua_corelib_ManCore_warnLog(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"ManCore",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string arg0;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "ManCore:warnLog");
        if(!ok)
            return 0;
        ManCore::warnLog(arg0);
        return 0;
    }
    gxError("ManCore:warnLog has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ManCore_warnLog'.", &tolua_err);
    return 0;
}
int lua_corelib_ManCore_debugLog(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

    tolua_Error tolua_err;
    if (!tolua_isusertable(tolua_S,1,"ManCore",0,&tolua_err)){
		goto tolua_lerror;
	}

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string arg0;
        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "ManCore:debugLog");
        if(!ok)
            return 0;
        ManCore::debugLog(arg0);
        return 0;
    }
    gxError("ManCore:debugLog has wrong number of arguments: {0}, was expecting {1}\n ", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ManCore_debugLog'.", &tolua_err);
    return 0;
}
static int lua_corelib_ManCore_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ManCore)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ManCore",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        ManCore* self = (ManCore*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_ManCore(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ManCore");
    tolua_cclass(tolua_S,"ManCore","ManCore","",nullptr);

    tolua_beginmodule(tolua_S,"ManCore");
        tolua_function(tolua_S,"errorLog", lua_corelib_ManCore_errorLog);
        tolua_function(tolua_S,"infoLog", lua_corelib_ManCore_infoLog);
        tolua_function(tolua_S,"warnLog", lua_corelib_ManCore_warnLog);
        tolua_function(tolua_S,"debugLog", lua_corelib_ManCore_debugLog);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(ManCore).name();
    g_luaType[typeName] = "ManCore";
    g_typeCast["ManCore"] = "ManCore";
    return 1;
}

static int lua_corelib_CSocketServerConnector_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CSocketServerConnector)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CSocketServerConnector",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CSocketServerConnector* self = (GXMISC::CSocketServerConnector*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CSocketServerConnector(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CSocketServerConnector");
    tolua_cclass(tolua_S,"CSocketServerConnector","CSocketServerConnector","CSocketConnector",nullptr);

    tolua_beginmodule(tolua_S,"CSocketServerConnector");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CSocketServerConnector).name();
    g_luaType[typeName] = "CSocketServerConnector";
    g_typeCast["CSocketServerConnector"] = "CSocketServerConnector";
    return 1;
}

static int lua_corelib_CUnsensitiveSStringLessPred_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CUnsensitiveSStringLessPred)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CUnsensitiveSStringLessPred",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        CUnsensitiveSStringLessPred* self = (CUnsensitiveSStringLessPred*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CUnsensitiveSStringLessPred(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CUnsensitiveSStringLessPred");
    tolua_cclass(tolua_S,"CUnsensitiveSStringLessPred","CUnsensitiveSStringLessPred","std::less<GXMISC::CSString>",nullptr);

    tolua_beginmodule(tolua_S,"CUnsensitiveSStringLessPred");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(CUnsensitiveSStringLessPred).name();
    g_luaType[typeName] = "CUnsensitiveSStringLessPred";
    g_typeCast["CUnsensitiveSStringLessPred"] = "CUnsensitiveSStringLessPred";
    return 1;
}

static int lua_corelib_CUnsensitiveStrLessPred_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CUnsensitiveStrLessPred)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CUnsensitiveStrLessPred",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CUnsensitiveStrLessPred* self = (GXMISC::CUnsensitiveStrLessPred*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CUnsensitiveStrLessPred(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CUnsensitiveStrLessPred");
    tolua_cclass(tolua_S,"CUnsensitiveStrLessPred","CUnsensitiveStrLessPred","",nullptr);

    tolua_beginmodule(tolua_S,"CUnsensitiveStrLessPred");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CUnsensitiveStrLessPred).name();
    g_luaType[typeName] = "CUnsensitiveStrLessPred";
    g_typeCast["CUnsensitiveStrLessPred"] = "CUnsensitiveStrLessPred";
    return 1;
}

static int lua_corelib_FiledVar_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (FiledVar)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"FiledVar",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::FiledVar* self = (GXMISC::FiledVar*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_FiledVar(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"FiledVar");
    tolua_cclass(tolua_S,"FiledVar","FiledVar","",nullptr);

    tolua_beginmodule(tolua_S,"FiledVar");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::FiledVar).name();
    g_luaType[typeName] = "FiledVar";
    g_typeCast["FiledVar"] = "FiledVar";
    return 1;
}

int lua_corelib_ITimer_invalidFunc(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ITimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ITimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ITimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ITimer_invalidFunc'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->invalidFunc();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("ITimer:invalidFunc has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ITimer_invalidFunc'.",&tolua_err);
	return 0;
}
int lua_corelib_ITimer_beginTriggerFunc(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ITimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ITimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ITimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ITimer_beginTriggerFunc'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->beginTriggerFunc();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("ITimer:beginTriggerFunc has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ITimer_beginTriggerFunc'.",&tolua_err);
	return 0;
}
int lua_corelib_ITimer_endTriggerFunc(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::ITimer* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"ITimer",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::ITimer*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_ITimer_endTriggerFunc'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->endTriggerFunc();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("ITimer:endTriggerFunc has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_ITimer_endTriggerFunc'.",&tolua_err);
	return 0;
}
static int lua_corelib_ITimer_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (ITimer)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"ITimer",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::ITimer* self = (GXMISC::ITimer*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_ITimer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ITimer");
    tolua_cclass(tolua_S,"ITimer","ITimer","",nullptr);

    tolua_beginmodule(tolua_S,"ITimer");
        tolua_function(tolua_S,"invalidFunc",lua_corelib_ITimer_invalidFunc);
        tolua_function(tolua_S,"beginTriggerFunc",lua_corelib_ITimer_beginTriggerFunc);
        tolua_function(tolua_S,"endTriggerFunc",lua_corelib_ITimer_endTriggerFunc);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::ITimer).name();
    g_luaType[typeName] = "ITimer";
    g_typeCast["ITimer"] = "ITimer";
    return 1;
}

int lua_corelib_CTimerBase_getLastStartTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_getLastStartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastStartTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerBase:getLastStartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_getLastStartTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_registeInvalidFunc(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_registeInvalidFunc'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CTimerBase:registeInvalidFunc");
        if(!ok)
            return 0;
        cobj->registeInvalidFunc(arg0);
        return 0;
    }

    gxError("CTimerBase:registeInvalidFunc has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_registeInvalidFunc'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_isStop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_isStop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isStop();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerBase:isStop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_isStop'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_getEndTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_getEndTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getEndTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerBase:getEndTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_getEndTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_cleanUp(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_cleanUp'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->cleanUp();
        return 0;
    }

    gxError("CTimerBase:cleanUp has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_cleanUp'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_setEndTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_setEndTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerBase:setEndTime");
        if(!ok)
            return 0;
        cobj->setEndTime(arg0);
        return 0;
    }

    gxError("CTimerBase:setEndTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_setEndTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_setTimerType(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_setTimerType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::ETimerType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTimerBase:setTimerType");
        if(!ok)
            return 0;
        cobj->setTimerType(arg0);
        return 0;
    }

    gxError("CTimerBase:setTimerType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_setTimerType'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_isInInterval(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_isInInterval'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isInInterval();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerBase:isInInterval has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_isInInterval'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_getStartTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_getStartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getStartTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerBase:getStartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_getStartTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_getCallTimes(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_getCallTimes'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = cobj->getCallTimes();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerBase:getCallTimes has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_getCallTimes'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_pause(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_pause'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->pause();
        return 0;
    }

    gxError("CTimerBase:pause has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_pause'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_isRun(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_isRun'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isRun();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerBase:isRun has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_isRun'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_resume(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_resume'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->resume();
        return 0;
    }

    gxError("CTimerBase:resume has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_resume'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_getTimerID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_getTimerID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getTimerID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerBase:getTimerID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_getTimerID'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_registeEndFunc(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_registeEndFunc'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CTimerBase:registeEndFunc");
        if(!ok)
            return 0;
        cobj->registeEndFunc(arg0);
        return 0;
    }

    gxError("CTimerBase:registeEndFunc has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_registeEndFunc'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_setStatus(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_setStatus'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CTimerBase::ETimerStatus arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTimerBase:setStatus");
        if(!ok)
            return 0;
        cobj->setStatus(arg0);
        return 0;
    }

    gxError("CTimerBase:setStatus has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_setStatus'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_initInterval(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_initInterval'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 7) 
    {
        int arg0;
        int arg1;
        int arg2;
        int arg3;
        int arg4;
        int arg5;
        int arg6;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTimerBase:initInterval");

        ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CTimerBase:initInterval");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CTimerBase:initInterval");

        ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CTimerBase:initInterval");

        ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CTimerBase:initInterval");

        ok &= luaval_to_sint32(tolua_S, 7,(sint32*)&arg5, "CTimerBase:initInterval");

        ok &= luaval_to_sint32(tolua_S, 8,(sint32*)&arg6, "CTimerBase:initInterval");
        if(!ok)
            return 0;
        cobj->initInterval(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
        return 0;
    }

    gxError("CTimerBase:initInterval has wrong number of arguments: {0}, was expecting {1} \n", argc, 7);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_initInterval'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_registeAll(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_registeAll'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->registeAll();
        return 0;
    }

    gxError("CTimerBase:registeAll has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_registeAll'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_registeBeginFunc(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_registeBeginFunc'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CTimerBase:registeBeginFunc");
        if(!ok)
            return 0;
        cobj->registeBeginFunc(arg0);
        return 0;
    }

    gxError("CTimerBase:registeBeginFunc has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_registeBeginFunc'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_isNeedSave(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_isNeedSave'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNeedSave();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerBase:isNeedSave has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_isNeedSave'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_onInvalid(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_onInvalid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onInvalid();
        return 0;
    }

    gxError("CTimerBase:onInvalid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_onInvalid'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_run(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_run'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->run();
        return 0;
    }

    gxError("CTimerBase:run has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_run'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_setTimerID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_setTimerID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerBase:setTimerID");
        if(!ok)
            return 0;
        cobj->setTimerID(arg0);
        return 0;
    }

    gxError("CTimerBase:setTimerID has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_setTimerID'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_getNextStartSeconds(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_getNextStartSeconds'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getNextStartSeconds();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerBase:getNextStartSeconds has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_getNextStartSeconds'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_initTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_initTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->initTime();
        return 0;
    }
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerBase:initTime");
        if(!ok)
            return 0;
        cobj->initTime(arg0);
        return 0;
    }
    if (argc == 2) 
    {
        unsigned int arg0;
        unsigned int arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerBase:initTime");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CTimerBase:initTime");
        if(!ok)
            return 0;
        cobj->initTime(arg0, arg1);
        return 0;
    }
    if (argc == 3) 
    {
        unsigned int arg0;
        unsigned int arg1;
        int arg2;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerBase:initTime");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CTimerBase:initTime");

        ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CTimerBase:initTime");
        if(!ok)
            return 0;
        cobj->initTime(arg0, arg1, arg2);
        return 0;
    }

    gxError("CTimerBase:initTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_initTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_stop(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_stop'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->stop();
        return 0;
    }

    gxError("CTimerBase:stop has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_stop'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_update(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTimerBase:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CTimerBase:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_update'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_getCreateTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_getCreateTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getCreateTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerBase:getCreateTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_getCreateTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_isPause(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_isPause'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isPause();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerBase:isPause has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_isPause'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_getLastActiveTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_getLastActiveTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastActiveTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerBase:getLastActiveTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_getLastActiveTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_needStart(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_needStart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->needStart();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerBase:needStart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_needStart'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_getStatus(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_getStatus'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getStatus();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerBase:getStatus has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_getStatus'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_isInvalid(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_isInvalid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isInvalid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerBase:isInvalid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_isInvalid'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_getTimerType(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_getTimerType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getTimerType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerBase:getTimerType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_getTimerType'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_isInTimer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_isInTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isInTimer();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerBase:isInTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_isInTimer'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_setStartTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_setStartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerBase:setStartTime");
        if(!ok)
            return 0;
        cobj->setStartTime(arg0);
        return 0;
    }

    gxError("CTimerBase:setStartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_setStartTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_setCallTimes(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_setCallTimes'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTimerBase:setCallTimes");
        if(!ok)
            return 0;
        cobj->setCallTimes(arg0);
        return 0;
    }

    gxError("CTimerBase:setCallTimes has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_setCallTimes'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_setLastActiveTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_setLastActiveTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerBase:setLastActiveTime");
        if(!ok)
            return 0;
        cobj->setLastActiveTime(arg0);
        return 0;
    }

    gxError("CTimerBase:setLastActiveTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_setLastActiveTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_setCreateTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_setCreateTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerBase:setCreateTime");
        if(!ok)
            return 0;
        cobj->setCreateTime(arg0);
        return 0;
    }

    gxError("CTimerBase:setCreateTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_setCreateTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_callScriptFunc(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerBase_callScriptFunc'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string arg0;

        ok &= luaval_to_std_string(tolua_S, 2,&arg0, "CTimerBase:callScriptFunc");
        if(!ok)
            return 0;
        cobj->callScriptFunc(arg0);
        return 0;
    }

    gxError("CTimerBase:callScriptFunc has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerBase_callScriptFunc'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerBase:CTimerBase");
        if(!ok)
            return 0;
        cobj = new GXMISC::CTimerBase(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CTimerBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CTimerBase:CTimerBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CTimerBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTimerBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTimerBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CTimerBase* self = (GXMISC::CTimerBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CTimerBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTimerBase");
    tolua_cclass(tolua_S,"CTimerBase","CTimerBase","ITimer",lua_corelib_CTimerBase_finalize);

    tolua_beginmodule(tolua_S,"CTimerBase");
        tolua_function(tolua_S,"new",lua_corelib_CTimerBase_constructor);
        tolua_function(tolua_S,"getLastStartTime",lua_corelib_CTimerBase_getLastStartTime);
        tolua_function(tolua_S,"registeInvalidFunc",lua_corelib_CTimerBase_registeInvalidFunc);
        tolua_function(tolua_S,"isStop",lua_corelib_CTimerBase_isStop);
        tolua_function(tolua_S,"getEndTime",lua_corelib_CTimerBase_getEndTime);
        tolua_function(tolua_S,"cleanUp",lua_corelib_CTimerBase_cleanUp);
        tolua_function(tolua_S,"setEndTime",lua_corelib_CTimerBase_setEndTime);
        tolua_function(tolua_S,"setTimerType",lua_corelib_CTimerBase_setTimerType);
        tolua_function(tolua_S,"isInInterval",lua_corelib_CTimerBase_isInInterval);
        tolua_function(tolua_S,"getStartTime",lua_corelib_CTimerBase_getStartTime);
        tolua_function(tolua_S,"getCallTimes",lua_corelib_CTimerBase_getCallTimes);
        tolua_function(tolua_S,"pause",lua_corelib_CTimerBase_pause);
        tolua_function(tolua_S,"isRun",lua_corelib_CTimerBase_isRun);
        tolua_function(tolua_S,"resume",lua_corelib_CTimerBase_resume);
        tolua_function(tolua_S,"getTimerID",lua_corelib_CTimerBase_getTimerID);
        tolua_function(tolua_S,"registeEndFunc",lua_corelib_CTimerBase_registeEndFunc);
        tolua_function(tolua_S,"setStatus",lua_corelib_CTimerBase_setStatus);
        tolua_function(tolua_S,"initInterval",lua_corelib_CTimerBase_initInterval);
        tolua_function(tolua_S,"registeAll",lua_corelib_CTimerBase_registeAll);
        tolua_function(tolua_S,"registeBeginFunc",lua_corelib_CTimerBase_registeBeginFunc);
        tolua_function(tolua_S,"isNeedSave",lua_corelib_CTimerBase_isNeedSave);
        tolua_function(tolua_S,"onInvalid",lua_corelib_CTimerBase_onInvalid);
        tolua_function(tolua_S,"run",lua_corelib_CTimerBase_run);
        tolua_function(tolua_S,"setTimerID",lua_corelib_CTimerBase_setTimerID);
        tolua_function(tolua_S,"getNextStartSeconds",lua_corelib_CTimerBase_getNextStartSeconds);
        tolua_function(tolua_S,"initTime",lua_corelib_CTimerBase_initTime);
        tolua_function(tolua_S,"stop",lua_corelib_CTimerBase_stop);
        tolua_function(tolua_S,"update",lua_corelib_CTimerBase_update);
        tolua_function(tolua_S,"getCreateTime",lua_corelib_CTimerBase_getCreateTime);
        tolua_function(tolua_S,"isPause",lua_corelib_CTimerBase_isPause);
        tolua_function(tolua_S,"getLastActiveTime",lua_corelib_CTimerBase_getLastActiveTime);
        tolua_function(tolua_S,"needStart",lua_corelib_CTimerBase_needStart);
        tolua_function(tolua_S,"getStatus",lua_corelib_CTimerBase_getStatus);
        tolua_function(tolua_S,"isInvalid",lua_corelib_CTimerBase_isInvalid);
        tolua_function(tolua_S,"getTimerType",lua_corelib_CTimerBase_getTimerType);
        tolua_function(tolua_S,"isInTimer",lua_corelib_CTimerBase_isInTimer);
        tolua_function(tolua_S,"setStartTime",lua_corelib_CTimerBase_setStartTime);
        tolua_function(tolua_S,"setCallTimes",lua_corelib_CTimerBase_setCallTimes);
        tolua_function(tolua_S,"setLastActiveTime",lua_corelib_CTimerBase_setLastActiveTime);
        tolua_function(tolua_S,"setCreateTime",lua_corelib_CTimerBase_setCreateTime);
        tolua_function(tolua_S,"callScriptFunc",lua_corelib_CTimerBase_callScriptFunc);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CTimerBase).name();
    g_luaType[typeName] = "CTimerBase";
    g_typeCast["CTimerBase"] = "CTimerBase";
    return 1;
}

int lua_corelib_CTimerAT_setTimeType(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerAT* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerAT",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerAT*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerAT_setTimeType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::EATimeType arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTimerAT:setTimeType");
        if(!ok)
            return 0;
        cobj->setTimeType(arg0);
        return 0;
    }

    gxError("CTimerAT:setTimeType has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerAT_setTimeType'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerAT_update(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerAT* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerAT",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerAT*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerAT_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTimerAT:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CTimerAT:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerAT_update'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerAT_defaultInInterval(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerAT* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerAT",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerAT*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerAT_defaultInInterval'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->defaultInInterval();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerAT:defaultInInterval has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerAT_defaultInInterval'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerAT_getTimeType(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerAT* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerAT",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerAT*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerAT_getTimeType'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        int ret = (int)cobj->getTimeType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerAT:getTimeType has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerAT_getTimeType'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerAT_isInInterval(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerAT* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerAT",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerAT*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerAT_isInInterval'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isInInterval();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerAT:isInInterval has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerAT_isInInterval'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerAT_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerAT* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerAT:CTimerAT");
        if(!ok)
            return 0;
        cobj = new GXMISC::CTimerAT(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CTimerAT");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CTimerAT:CTimerAT has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CTimerAT_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTimerAT)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTimerAT",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CTimerAT* self = (GXMISC::CTimerAT*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CTimerAT(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTimerAT");
    tolua_cclass(tolua_S,"CTimerAT","CTimerAT","CTimerBase",lua_corelib_CTimerAT_finalize);

    tolua_beginmodule(tolua_S,"CTimerAT");
        tolua_function(tolua_S,"new",lua_corelib_CTimerAT_constructor);
        tolua_function(tolua_S,"setTimeType",lua_corelib_CTimerAT_setTimeType);
        tolua_function(tolua_S,"update",lua_corelib_CTimerAT_update);
        tolua_function(tolua_S,"defaultInInterval",lua_corelib_CTimerAT_defaultInInterval);
        tolua_function(tolua_S,"getTimeType",lua_corelib_CTimerAT_getTimeType);
        tolua_function(tolua_S,"isInInterval",lua_corelib_CTimerAT_isInInterval);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CTimerAT).name();
    g_luaType[typeName] = "CTimerAT";
    g_typeCast["CTimerAT"] = "CTimerAT";
    return 1;
}

int lua_corelib_CTimerATD_getLastStartTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerATD* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerATD",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerATD*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerATD_getLastStartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastStartTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerATD:getLastStartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerATD_getLastStartTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerATD_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerATD* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerATD:CTimerATD");
        if(!ok)
            return 0;
        cobj = new GXMISC::CTimerATD(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CTimerATD");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CTimerATD:CTimerATD has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CTimerATD_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTimerATD)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTimerATD",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CTimerATD* self = (GXMISC::CTimerATD*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CTimerATD(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTimerATD");
    tolua_cclass(tolua_S,"CTimerATD","CTimerATD","CTimerAT",lua_corelib_CTimerATD_finalize);

    tolua_beginmodule(tolua_S,"CTimerATD");
        tolua_function(tolua_S,"new",lua_corelib_CTimerATD_constructor);
        tolua_function(tolua_S,"getLastStartTime",lua_corelib_CTimerATD_getLastStartTime);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CTimerATD).name();
    g_luaType[typeName] = "CTimerATD";
    g_typeCast["CTimerATD"] = "CTimerATD";
    return 1;
}

int lua_corelib_CTimerATW_needStart(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerATW* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerATW",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerATW*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerATW_needStart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->needStart();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerATW:needStart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerATW_needStart'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerATW_getLastStartTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerATW* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerATW",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerATW*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerATW_getLastStartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastStartTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerATW:getLastStartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerATW_getLastStartTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerATW_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerATW* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerATW:CTimerATW");
        if(!ok)
            return 0;
        cobj = new GXMISC::CTimerATW(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CTimerATW");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CTimerATW:CTimerATW has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CTimerATW_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTimerATW)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTimerATW",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CTimerATW* self = (GXMISC::CTimerATW*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CTimerATW(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTimerATW");
    tolua_cclass(tolua_S,"CTimerATW","CTimerATW","CTimerAT",lua_corelib_CTimerATW_finalize);

    tolua_beginmodule(tolua_S,"CTimerATW");
        tolua_function(tolua_S,"new",lua_corelib_CTimerATW_constructor);
        tolua_function(tolua_S,"needStart",lua_corelib_CTimerATW_needStart);
        tolua_function(tolua_S,"getLastStartTime",lua_corelib_CTimerATW_getLastStartTime);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CTimerATW).name();
    g_luaType[typeName] = "CTimerATW";
    g_typeCast["CTimerATW"] = "CTimerATW";
    return 1;
}

int lua_corelib_CTimerATM_needStart(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerATM* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerATM",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerATM*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerATM_needStart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->needStart();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerATM:needStart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerATM_needStart'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerATM_getLastStartTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerATM* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerATM",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerATM*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerATM_getLastStartTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastStartTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerATM:getLastStartTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerATM_getLastStartTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerATM_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerATM* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerATM:CTimerATM");
        if(!ok)
            return 0;
        cobj = new GXMISC::CTimerATM(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CTimerATM");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CTimerATM:CTimerATM has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CTimerATM_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTimerATM)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTimerATM",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CTimerATM* self = (GXMISC::CTimerATM*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CTimerATM(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTimerATM");
    tolua_cclass(tolua_S,"CTimerATM","CTimerATM","CTimerAT",lua_corelib_CTimerATM_finalize);

    tolua_beginmodule(tolua_S,"CTimerATM");
        tolua_function(tolua_S,"new",lua_corelib_CTimerATM_constructor);
        tolua_function(tolua_S,"needStart",lua_corelib_CTimerATM_needStart);
        tolua_function(tolua_S,"getLastStartTime",lua_corelib_CTimerATM_getLastStartTime);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CTimerATM).name();
    g_luaType[typeName] = "CTimerATM";
    g_typeCast["CTimerATM"] = "CTimerATM";
    return 1;
}

int lua_corelib_CTimerIT_needStart(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerIT* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerIT",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerIT*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerIT_needStart'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->needStart();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerIT:needStart has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerIT_needStart'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerIT_isInInterval(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerIT* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerIT",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerIT*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerIT_isInInterval'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isInInterval();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerIT:isInInterval has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerIT_isInInterval'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerIT_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerIT* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerIT:CTimerIT");
        if(!ok)
            return 0;
        cobj = new GXMISC::CTimerIT(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"CTimerIT");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CTimerIT:CTimerIT has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

}

static int lua_corelib_CTimerIT_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTimerIT)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTimerIT",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CTimerIT* self = (GXMISC::CTimerIT*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CTimerIT(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTimerIT");
    tolua_cclass(tolua_S,"CTimerIT","CTimerIT","CTimerBase",lua_corelib_CTimerIT_finalize);

    tolua_beginmodule(tolua_S,"CTimerIT");
        tolua_function(tolua_S,"new",lua_corelib_CTimerIT_constructor);
        tolua_function(tolua_S,"needStart",lua_corelib_CTimerIT_needStart);
        tolua_function(tolua_S,"isInInterval",lua_corelib_CTimerIT_isInInterval);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CTimerIT).name();
    g_luaType[typeName] = "CTimerIT";
    g_typeCast["CTimerIT"] = "CTimerIT";
    return 1;
}

int lua_corelib_CTimerManager_registeATD(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerManager* cobj = nullptr;
    bool ok  = true;
   
	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobject' in function 'lua_corelib_CTimerManager_registeATD'", nullptr);
        return 0;
    }
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 4) {
            int arg0;
            ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTimerManager:registeATD");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_sint32(tolua_S, 3,(sint32*)&arg1, "CTimerManager:registeATD");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CTimerManager:registeATD");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CTimerManager:registeATD");

            if (!ok) { break; }
            GXMISC::CTimerBase* ret = cobj->registeATD(arg0, arg1, arg2, arg3);
            object_to_luaval<GXMISC::CTimerBase>(tolua_S, "CTimerBase",(GXMISC::CTimerBase*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 6) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerManager:registeATD");

            if (!ok) { break; }
            unsigned int arg1;
            ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CTimerManager:registeATD");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_sint32(tolua_S, 4,(sint32*)&arg2, "CTimerManager:registeATD");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_sint32(tolua_S, 5,(sint32*)&arg3, "CTimerManager:registeATD");

            if (!ok) { break; }
            int arg4;
            ok &= luaval_to_sint32(tolua_S, 6,(sint32*)&arg4, "CTimerManager:registeATD");

            if (!ok) { break; }
            int arg5;
            ok &= luaval_to_sint32(tolua_S, 7,(sint32*)&arg5, "CTimerManager:registeATD");

            if (!ok) { break; }
            GXMISC::CTimerBase* ret = cobj->registeATD(arg0, arg1, arg2, arg3, arg4, arg5);
            object_to_luaval<GXMISC::CTimerBase>(tolua_S, "CTimerBase",(GXMISC::CTimerBase*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    gxError("CTimerManager:registeATD has wrong number of arguments: {0}, was expecting {1} \n", argc, 6);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerManager_registeATD'.",&tolua_err);
    return 0;
}
int lua_corelib_CTimerManager_saveTimer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerManager_saveTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->saveTimer();
        return 0;
    }

    gxError("CTimerManager:saveTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerManager_saveTimer'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerManager_removeTimer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerManager_removeTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerManager:removeTimer");
        if(!ok)
            return 0;
        cobj->removeTimer(arg0);
        return 0;
    }

    gxError("CTimerManager:removeTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerManager_removeTimer'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerManager_update(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerManager_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_sint32(tolua_S, 2,(sint32*)&arg0, "CTimerManager:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CTimerManager:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerManager_update'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerManager_isTimerExist(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerManager_isTimerExist'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerManager:isTimerExist");
        if(!ok)
            return 0;
        bool ret = cobj->isTimerExist(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CTimerManager:isTimerExist has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerManager_isTimerExist'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerManager_registeIT(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerManager_registeIT'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        unsigned int arg1;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerManager:registeIT");

        ok &= luaval_to_uint32(tolua_S, 3,(uint32*)&arg1, "CTimerManager:registeIT");
        if(!ok)
            return 0;
        GXMISC::CTimerBase* ret = cobj->registeIT(arg0, arg1);
        object_to_luaval<GXMISC::CTimerBase>(tolua_S, "CTimerBase",(GXMISC::CTimerBase*)ret);
        return 1;
    }

    gxError("CTimerManager:registeIT has wrong number of arguments: {0}, was expecting {1} \n", argc, 2);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerManager_registeIT'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerManager_loadTimer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerManager_loadTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->loadTimer();
        return 0;
    }

    gxError("CTimerManager:loadTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerManager_loadTimer'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerManager_getTimer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerManager_getTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CTimerManager:getTimer");
        if(!ok)
            return 0;
        GXMISC::CTimerBase* ret = cobj->getTimer(arg0);
        object_to_luaval<GXMISC::CTimerBase>(tolua_S, "CTimerBase",(GXMISC::CTimerBase*)ret);
        return 1;
    }

    gxError("CTimerManager:getTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerManager_getTimer'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerManager_genTimerID(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerManager_genTimerID'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->genTimerID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerManager:genTimerID has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerManager_genTimerID'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerManager_registe(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerManager* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CTimerManager",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CTimerManager*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CTimerManager_registe'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        GXMISC::CTimerBase* arg0;

        ok &= luaval_to_object<GXMISC::CTimerBase>(tolua_S, 2, "CTimerBase", &arg0, "CTimerManager:registe");
        if(!ok)
            return 0;
        unsigned int ret = cobj->registe(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 2) 
    {
        GXMISC::CTimerBase* arg0;
        bool arg1;

        ok &= luaval_to_object<GXMISC::CTimerBase>(tolua_S, 2, "CTimerBase", &arg0, "CTimerManager:registe");

        ok &= luaval_to_boolean(tolua_S, 3,(bool*)&arg1, "CTimerManager:registe");
        if(!ok)
            return 0;
        unsigned int ret = cobj->registe(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CTimerManager:registe has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CTimerManager_registe'.",&tolua_err);
	return 0;
}
int lua_corelib_CTimerManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CTimerManager* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CTimerManager();
        tolua_pushusertype(tolua_S,(void*)cobj,"CTimerManager");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CTimerManager:CTimerManager has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CTimerManager_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CTimerManager)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CTimerManager",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CTimerManager* self = (GXMISC::CTimerManager*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CTimerManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CTimerManager");
    tolua_cclass(tolua_S,"CTimerManager","CTimerManager","",lua_corelib_CTimerManager_finalize);

    tolua_beginmodule(tolua_S,"CTimerManager");
        tolua_function(tolua_S,"new",lua_corelib_CTimerManager_constructor);
        tolua_function(tolua_S,"registeATD",lua_corelib_CTimerManager_registeATD);
        tolua_function(tolua_S,"saveTimer",lua_corelib_CTimerManager_saveTimer);
        tolua_function(tolua_S,"removeTimer",lua_corelib_CTimerManager_removeTimer);
        tolua_function(tolua_S,"update",lua_corelib_CTimerManager_update);
        tolua_function(tolua_S,"isTimerExist",lua_corelib_CTimerManager_isTimerExist);
        tolua_function(tolua_S,"registeIT",lua_corelib_CTimerManager_registeIT);
        tolua_function(tolua_S,"loadTimer",lua_corelib_CTimerManager_loadTimer);
        tolua_function(tolua_S,"getTimer",lua_corelib_CTimerManager_getTimer);
        tolua_function(tolua_S,"genTimerID",lua_corelib_CTimerManager_genTimerID);
        tolua_function(tolua_S,"registe",lua_corelib_CTimerManager_registe);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CTimerManager).name();
    g_luaType[typeName] = "CTimerManager";
    g_typeCast["CTimerManager"] = "CTimerManager";
    return 1;
}

int lua_corelib_CGameTimerInterface_isNeedBegin(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGameTimerInterface* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameTimerInterface",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGameTimerInterface*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGameTimerInterface_isNeedBegin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isNeedBegin();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameTimerInterface:isNeedBegin has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGameTimerInterface_isNeedBegin'.",&tolua_err);
	return 0;
}
int lua_corelib_CGameTimerInterface_getIsNeedBegin(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGameTimerInterface* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameTimerInterface",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGameTimerInterface*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGameTimerInterface_getIsNeedBegin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->getIsNeedBegin();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameTimerInterface:getIsNeedBegin has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGameTimerInterface_getIsNeedBegin'.",&tolua_err);
	return 0;
}
int lua_corelib_CGameTimerInterface_setIsNeedBegin(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGameTimerInterface* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameTimerInterface",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGameTimerInterface*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGameTimerInterface_setIsNeedBegin'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,(bool*)&arg0, "CGameTimerInterface:setIsNeedBegin");
        if(!ok)
            return 0;
        cobj->setIsNeedBegin(arg0);
        return 0;
    }

    gxError("CGameTimerInterface:setIsNeedBegin has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGameTimerInterface_setIsNeedBegin'.",&tolua_err);
	return 0;
}
int lua_corelib_CGameTimerInterface_setLastActiveTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGameTimerInterface* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameTimerInterface",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGameTimerInterface*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGameTimerInterface_setLastActiveTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameTimerInterface:setLastActiveTime");
        if(!ok)
            return 0;
        cobj->setLastActiveTime(arg0);
        return 0;
    }

    gxError("CGameTimerInterface:setLastActiveTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGameTimerInterface_setLastActiveTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CGameTimerInterface_getLastActiveTime(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGameTimerInterface* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameTimerInterface",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGameTimerInterface*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGameTimerInterface_getLastActiveTime'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        unsigned int ret = cobj->getLastActiveTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }

    gxError("CGameTimerInterface:getLastActiveTime has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGameTimerInterface_getLastActiveTime'.",&tolua_err);
	return 0;
}
int lua_corelib_CGameTimerInterface_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGameTimerInterface* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CGameTimerInterface();
        tolua_pushusertype(tolua_S,(void*)cobj,"CGameTimerInterface");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CGameTimerInterface:CGameTimerInterface has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CGameTimerInterface_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGameTimerInterface)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGameTimerInterface",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CGameTimerInterface* self = (GXMISC::CGameTimerInterface*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CGameTimerInterface(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGameTimerInterface");
    tolua_cclass(tolua_S,"CGameTimerInterface","CGameTimerInterface","",lua_corelib_CGameTimerInterface_finalize);

    tolua_beginmodule(tolua_S,"CGameTimerInterface");
        tolua_function(tolua_S,"new",lua_corelib_CGameTimerInterface_constructor);
        tolua_function(tolua_S,"isNeedBegin",lua_corelib_CGameTimerInterface_isNeedBegin);
        tolua_function(tolua_S,"getIsNeedBegin",lua_corelib_CGameTimerInterface_getIsNeedBegin);
        tolua_function(tolua_S,"setIsNeedBegin",lua_corelib_CGameTimerInterface_setIsNeedBegin);
        tolua_function(tolua_S,"setLastActiveTime",lua_corelib_CGameTimerInterface_setLastActiveTime);
        tolua_function(tolua_S,"getLastActiveTime",lua_corelib_CGameTimerInterface_getLastActiveTime);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CGameTimerInterface).name();
    g_luaType[typeName] = "CGameTimerInterface";
    g_typeCast["CGameTimerInterface"] = "CGameTimerInterface";
    return 1;
}

int lua_corelib_CGameTimerBase_isInvalid(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGameTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGameTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGameTimerBase_isInvalid'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        bool ret = cobj->isInvalid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGameTimerBase:isInvalid has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGameTimerBase_isInvalid'.",&tolua_err);
	return 0;
}
int lua_corelib_CGameTimerBase_update(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGameTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGameTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGameTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGameTimerBase_update'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGameTimerBase:update");
        if(!ok)
            return 0;
        cobj->update(arg0);
        return 0;
    }

    gxError("CGameTimerBase:update has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGameTimerBase_update'.",&tolua_err);
	return 0;
}
static int lua_corelib_CGameTimerBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGameTimerBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGameTimerBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CGameTimerBase* self = (GXMISC::CGameTimerBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CGameTimerBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGameTimerBase");
    tolua_cclass(tolua_S,"CGameTimerBase","CGameTimerBase","",nullptr);

    tolua_beginmodule(tolua_S,"CGameTimerBase");
        tolua_function(tolua_S,"isInvalid",lua_corelib_CGameTimerBase_isInvalid);
        tolua_function(tolua_S,"update",lua_corelib_CGameTimerBase_update);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CGameTimerBase).name();
    g_luaType[typeName] = "CGameTimerBase";
    g_typeCast["CGameTimerBase"] = "CGameTimerBase";
    return 1;
}

int lua_corelib_CGamePassTimerBase_updateTimer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGamePassTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGamePassTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGamePassTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGamePassTimerBase_updateTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGamePassTimerBase:updateTimer");
        if(!ok)
            return 0;
        cobj->updateTimer(arg0);
        return 0;
    }

    gxError("CGamePassTimerBase:updateTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGamePassTimerBase_updateTimer'.",&tolua_err);
	return 0;
}
int lua_corelib_CGamePassTimerBase_onPassWeekday(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGamePassTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGamePassTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGamePassTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGamePassTimerBase_onPassWeekday'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onPassWeekday();
        return 0;
    }

    gxError("CGamePassTimerBase:onPassWeekday has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGamePassTimerBase_onPassWeekday'.",&tolua_err);
	return 0;
}
int lua_corelib_CGamePassTimerBase_onPassDay(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGamePassTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGamePassTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGamePassTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGamePassTimerBase_onPassDay'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onPassDay();
        return 0;
    }

    gxError("CGamePassTimerBase:onPassDay has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGamePassTimerBase_onPassDay'.",&tolua_err);
	return 0;
}
int lua_corelib_CGamePassTimerBase_onPassMonth(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGamePassTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGamePassTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGamePassTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGamePassTimerBase_onPassMonth'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onPassMonth();
        return 0;
    }

    gxError("CGamePassTimerBase:onPassMonth has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGamePassTimerBase_onPassMonth'.",&tolua_err);
	return 0;
}
int lua_corelib_CGamePassTimerBase_initTimer(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGamePassTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGamePassTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGamePassTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGamePassTimerBase_initTimer'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,(uint32*)&arg0, "CGamePassTimerBase:initTimer");
        if(!ok)
            return 0;
        bool ret = cobj->initTimer(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }

    gxError("CGamePassTimerBase:initTimer has wrong number of arguments: {0}, was expecting {1} \n", argc, 1);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGamePassTimerBase_initTimer'.",&tolua_err);
	return 0;
}
int lua_corelib_CGamePassTimerBase_onPassHour(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGamePassTimerBase* cobj = nullptr;
    bool ok  = true;

	tolua_Error tolua_err;
    if (!tolua_isusertype(tolua_S,1,"CGamePassTimerBase",0,&tolua_err)) goto tolua_lerror;
    cobj = (GXMISC::CGamePassTimerBase*)tolua_tousertype(tolua_S,1,0);
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_corelib_CGamePassTimerBase_onPassHour'", nullptr);
        return 0;
    }

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj->onPassHour();
        return 0;
    }

    gxError("CGamePassTimerBase:onPassHour has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_corelib_CGamePassTimerBase_onPassHour'.",&tolua_err);
	return 0;
}
int lua_corelib_CGamePassTimerBase_constructor(lua_State* tolua_S)
{
    int argc = 0;
    GXMISC::CGamePassTimerBase* cobj = nullptr;
    bool ok  = true;


    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
            return 0;
        cobj = new GXMISC::CGamePassTimerBase();
        tolua_pushusertype(tolua_S,(void*)cobj,"CGamePassTimerBase");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;

    }

    gxError("CGamePassTimerBase:CGamePassTimerBase has wrong number of arguments: {0}, was expecting {1} \n", argc, 0);
    return 0;

}

static int lua_corelib_CGamePassTimerBase_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CGamePassTimerBase)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CGamePassTimerBase",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CGamePassTimerBase* self = (GXMISC::CGamePassTimerBase*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CGamePassTimerBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CGamePassTimerBase");
    tolua_cclass(tolua_S,"CGamePassTimerBase","CGamePassTimerBase","",lua_corelib_CGamePassTimerBase_finalize);

    tolua_beginmodule(tolua_S,"CGamePassTimerBase");
        tolua_function(tolua_S,"new",lua_corelib_CGamePassTimerBase_constructor);
        tolua_function(tolua_S,"updateTimer",lua_corelib_CGamePassTimerBase_updateTimer);
        tolua_function(tolua_S,"onPassWeekday",lua_corelib_CGamePassTimerBase_onPassWeekday);
        tolua_function(tolua_S,"onPassDay",lua_corelib_CGamePassTimerBase_onPassDay);
        tolua_function(tolua_S,"onPassMonth",lua_corelib_CGamePassTimerBase_onPassMonth);
        tolua_function(tolua_S,"initTimer",lua_corelib_CGamePassTimerBase_initTimer);
        tolua_function(tolua_S,"onPassHour",lua_corelib_CGamePassTimerBase_onPassHour);
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CGamePassTimerBase).name();
    g_luaType[typeName] = "CGamePassTimerBase";
    g_typeCast["CGamePassTimerBase"] = "CGamePassTimerBase";
    return 1;
}

static int lua_corelib_CUCStringHashMapTraits_finalize(lua_State* tolua_S)
{
    gxDebug("luabindings: finalizing LUA object (CUCStringHashMapTraits)");

    tolua_Error tolua_err;
    if (
    !tolua_isusertype(tolua_S,1,"CUCStringHashMapTraits",0,&tolua_err) ||
    !tolua_isnoobj(tolua_S,2,&tolua_err)
    ){
        goto tolua_lerror;
	}
    else
    {
        GXMISC::CUCStringHashMapTraits* self = (GXMISC::CUCStringHashMapTraits*)  tolua_tousertype(tolua_S,1,0);
        if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", nullptr);
        delete self;
    }
    return 0;

tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
    return 0;
}

int lua_register_corelib_CUCStringHashMapTraits(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"CUCStringHashMapTraits");
    tolua_cclass(tolua_S,"CUCStringHashMapTraits","CUCStringHashMapTraits","",nullptr);

    tolua_beginmodule(tolua_S,"CUCStringHashMapTraits");
    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GXMISC::CUCStringHashMapTraits).name();
    g_luaType[typeName] = "CUCStringHashMapTraits";
    g_typeCast["CUCStringHashMapTraits"] = "CUCStringHashMapTraits";
    return 1;
}
int register_all_corelib(lua_State* tolua_S)
{
	tolua_open(tolua_S);
	
	tolua_module(tolua_S,nullptr,0);
	tolua_beginmodule(tolua_S,nullptr);

	lua_register_corelib_IStopHandler(tolua_S);
	lua_register_corelib_IRunnable(tolua_S);
	lua_register_corelib_ISyncable(tolua_S);
	lua_register_corelib_CTask(tolua_S);
	lua_register_corelib_CLoopToThreadTask(tolua_S);
	lua_register_corelib_CServerPoolWrapTask(tolua_S);
	lua_register_corelib_CThreadToLoopTask(tolua_S);
	lua_register_corelib_CDbConnTask(tolua_S);
	lua_register_corelib_CDbTaskClose(tolua_S);
	lua_register_corelib_IFreeable(tolua_S);
	lua_register_corelib_IScriptObject(tolua_S);
	lua_register_corelib_IModuleConfig(tolua_S);
	lua_register_corelib_CDatabaseConfig(tolua_S);
	lua_register_corelib_CSocket(tolua_S);
	lua_register_corelib_CSocketConnector(tolua_S);
	lua_register_corelib_CSocketServerConnector(tolua_S);
	lua_register_corelib_ITimer(tolua_S);
	lua_register_corelib_CModuleThreadLoop(tolua_S);
	lua_register_corelib_CLogger(tolua_S);
	lua_register_corelib_CModuleThreadLoopWrap(tolua_S);
	lua_register_corelib_CSafeLog(tolua_S);
	lua_register_corelib_CDebugControl(tolua_S);
	lua_register_corelib_CSyncActiveQueueWrap(tolua_S);
	lua_register_corelib_IDisplayer(tolua_S);
	lua_register_corelib_CFileDisplayer(tolua_S);
	lua_register_corelib_CServiceTask(tolua_S);
	lua_register_corelib_IModuleManager(tolua_S);
	lua_register_corelib_CModuleBase(tolua_S);
	lua_register_corelib_CDatabaseConnMgr(tolua_S);
	lua_register_corelib_CLibConfig(tolua_S);
	lua_register_corelib_CNetBroadcastModule(tolua_S);
	lua_register_corelib_IHandler(tolua_S);
	lua_register_corelib_CDatabaseHandler(tolua_S);
	lua_register_corelib_CServerTaskPoolMgr(tolua_S);
	lua_register_corelib_CTimeVal(tolua_S);
	lua_register_corelib_CBit16(tolua_S);
	lua_register_corelib_CNetSocketLoopWrapTask(tolua_S);
	lua_register_corelib_ISocketPacketHandler(tolua_S);
	lua_register_corelib_CEmptyPacketHandler(tolua_S);
	lua_register_corelib_IStream(tolua_S);
	lua_register_corelib_CMemOutStream(tolua_S);
	lua_register_corelib_CMemOutputStream(tolua_S);
	lua_register_corelib_CSocketEventLoop(tolua_S);
	lua_register_corelib_IAllocatable(tolua_S);
	lua_register_corelib_CSyncActiveQueue(tolua_S);
	lua_register_corelib_CSimpleThreadLoopWrap(tolua_S);
	lua_register_corelib_CNetLoopWrap(tolua_S);
	lua_register_corelib_CGameTime(tolua_S);
	lua_register_corelib_CServerPoolTask(tolua_S);
	lua_register_corelib_CSocketListener(tolua_S);
	lua_register_corelib_CSafeFileDispalyer(tolua_S);
	lua_register_corelib_CSocketBroadCast(tolua_S);
	lua_register_corelib_CFairMutex(tolua_S);
	lua_register_corelib_CSerivceScriptObject(tolua_S);
	lua_register_corelib_CUnfairMutex(tolua_S);
	lua_register_corelib_IUnStream(tolua_S);
	lua_register_corelib_IStreamableAll(tolua_S);
	lua_register_corelib_CDbWrapTask(tolua_S);
	lua_register_corelib_CNetWrapBroadCastTask(tolua_S);
	lua_register_corelib_CNetModule(tolua_S);
	lua_register_corelib_IServiceModule(tolua_S);
	lua_register_corelib_GxService(tolua_S);
	lua_register_corelib_CMiniServer(tolua_S);
	lua_register_corelib_CTimerManager(tolua_S);
	lua_register_corelib_CTimerBase(tolua_S);
	lua_register_corelib_CTimerAT(tolua_S);
	lua_register_corelib_CTimerATW(tolua_S);
	lua_register_corelib_CBit32(tolua_S);
	lua_register_corelib_CMemInStream(tolua_S);
	lua_register_corelib_CTimerATM(tolua_S);
	lua_register_corelib_IUnStreamable(tolua_S);
	lua_register_corelib_CServerScriptTask(tolua_S);
	lua_register_corelib_CPackHandleAry(tolua_S);
	lua_register_corelib_CIni(tolua_S);
	lua_register_corelib_CNetSocketLoopTask(tolua_S);
	lua_register_corelib_CNetSocketAddRet(tolua_S);
	lua_register_corelib_dbColProxy(tolua_S);
	lua_register_corelib_CNetSendPacketTask(tolua_S);
	lua_register_corelib_ILockable(tolua_S);
	lua_register_corelib_CEmptyLock(tolua_S);
	lua_register_corelib_CGameTimerBase(tolua_S);
	lua_register_corelib_CFastLock(tolua_S);
	lua_register_corelib_SMainLoopEventArg(tolua_S);
	lua_register_corelib_CCPUTimeStat(tolua_S);
	lua_register_corelib_CGxContext(tolua_S);
	lua_register_corelib_CUCStringHashMapTraits(tolua_S);
	lua_register_corelib_CNetRecvPacketTask(tolua_S);
	lua_register_corelib_CNetSocketDelTask(tolua_S);
	lua_register_corelib_SSocketLoopEventArg(tolua_S);
	lua_register_corelib_CStdDisplayer(tolua_S);
	lua_register_corelib_CSafeStdDisplayer(tolua_S);
	lua_register_corelib_CNetBroadcastWrap(tolua_S);
	lua_register_corelib_CFixNullBase(tolua_S);
	lua_register_corelib_CConfigMap(tolua_S);
	lua_register_corelib_CTimerATD(tolua_S);
	lua_register_corelib_CDatabaseConn(tolua_S);
	lua_register_corelib_IniItem(tolua_S);
	lua_register_corelib_CIntervalTimer(tolua_S);
	lua_register_corelib_CSimpleAllocator(tolua_S);
	lua_register_corelib_TDBStructBase(tolua_S);
	lua_register_corelib_CSocketOutputStream(tolua_S);
	lua_register_corelib_CNetModuleConfig(tolua_S);
	lua_register_corelib_FiledVar(tolua_S);
	lua_register_corelib_CGameTimerInterface(tolua_S);
	lua_register_corelib_CDefaultPacketHandler(tolua_S);
	lua_register_corelib_INoncopyable(tolua_S);
	lua_register_corelib_CTimerIT(tolua_S);
	lua_register_corelib_CMemInputStream(tolua_S);
	lua_register_corelib_CSocketInputStream(tolua_S);
	lua_register_corelib_CSocketHandler(tolua_S);
	lua_register_corelib_CScriptSocketHandler(tolua_S);
	lua_register_corelib_CServerTaskPoolWrap(tolua_S);
	lua_register_corelib_CBroadcastPacketTask(tolua_S);
	lua_register_corelib_IDumpHandler(tolua_S);
	lua_register_corelib_CNetSocketClose(tolua_S);
	lua_register_corelib_CServerTaskConfig(tolua_S);
	lua_register_corelib_CFixLenBase(tolua_S);
	lua_register_corelib_CDateTime(tolua_S);
	lua_register_corelib_CSocketReconnectTask(tolua_S);
	lua_register_corelib_CIniSection(tolua_S);
	lua_register_corelib_CUnsensitiveSStringLessPred(tolua_S);
	lua_register_corelib_CManualIntervalTimer(tolua_S);
	lua_register_corelib_CGamePassTimerBase(tolua_S);
	lua_register_corelib_CBit64(tolua_S);
	lua_register_corelib_CTime(tolua_S);
	lua_register_corelib_CGxServiceConfig(tolua_S);
	lua_register_corelib_CTimespan(tolua_S);
	lua_register_corelib_CBit8(tolua_S);
	lua_register_corelib_IStreamable(tolua_S);
	lua_register_corelib_CDbTaskConnected(tolua_S);
	lua_register_corelib_CUnsensitiveStrLessPred(tolua_S);
	lua_register_corelib_CDbHostParam(tolua_S);
	lua_register_corelib_CServerScriptRetTask(tolua_S);
	lua_register_corelib_CServerTaskPool(tolua_S);
	lua_register_corelib_CServiceTaskQue(tolua_S);
	lua_register_corelib_ManCore(tolua_S);
	lua_register_corelib_CDatabaseConnWrap(tolua_S);
	lua_register_corelib_CSocketServerListener(tolua_S);
	lua_register_corelib_ISimpleNoncopyable(tolua_S);
	lua_register_corelib_CIntervalTimerMgr(tolua_S);
	lua_register_corelib_CSocketReconnectRetTask(tolua_S);
	lua_register_corelib_CTimeManager(tolua_S);

	tolua_endmodule(tolua_S);
	return 1;
}

